webpackJsonp([1,5,6],{

/***/ 699:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(316);\nvar common_1 = __webpack_require__(336);\nvar forms_1 = __webpack_require__(700);\nvar shared_module_1 = __webpack_require__(701);\nvar dashboard_component_1 = __webpack_require__(718);\nvar boards_component_1 = __webpack_require__(721);\nvar account_component_1 = __webpack_require__(725);\nvar dashboard_nav_component_1 = __webpack_require__(728);\nvar dashboard_routes_1 = __webpack_require__(731);\nvar angular2_flash_messages_1 = __webpack_require__(682);\nvar material_1 = __webpack_require__(732);\n// import {MaterializeDirective} from \"angular2-materialize\";\nvar DashboardModule = (function () {\n    function DashboardModule() {\n    }\n    DashboardModule = __decorate([\n        core_1.NgModule({\n            imports: [common_1.CommonModule, forms_1.FormsModule, shared_module_1.SharedModule, dashboard_routes_1.default, angular2_flash_messages_1.FlashMessagesModule, material_1.MaterialModule.forRoot()],\n            declarations: [dashboard_component_1.DashboardComponent, boards_component_1.BoardsComponent, account_component_1.AccountComponent, dashboard_nav_component_1.DashboardNavComponent,\n            ],\n            providers: []\n        }), \n        __metadata('design:paramtypes', [])\n    ], DashboardModule);\n    return DashboardModule;\n}());\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DashboardModule;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Rhc2hib2FyZC9kYXNoYm9hcmQubW9kdWxlLnRzPzA5MjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSBcIkBhbmd1bGFyL2NvbW1vblwiO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfWZyb20gXCJAYW5ndWxhci9mb3Jtc1wiOyBcbmltcG9ydCB7IFNoYXJlZE1vZHVsZSB9IGZyb20gJy4uL3NoYXJlZC9zaGFyZWQubW9kdWxlJztcbmltcG9ydCB7IERhc2hib2FyZENvbXBvbmVudCB9IGZyb20gXCIuL2Rhc2hib2FyZC5jb21wb25lbnRcIjtcbmltcG9ydCB7IEJvYXJkc0NvbXBvbmVudCB9IGZyb20gXCIuL2JvYXJkcy9ib2FyZHMuY29tcG9uZW50XCI7XG5pbXBvcnQgeyBBY2NvdW50Q29tcG9uZW50IH0gZnJvbSBcIi4vYWNjb3VudC9hY2NvdW50LmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgRGFzaGJvYXJkTmF2Q29tcG9uZW50IH0gZnJvbSBcIi4vZGFzaGJvYXJkLW5hdi9kYXNoYm9hcmQtbmF2LmNvbXBvbmVudFwiO1xuXG5pbXBvcnQgcm91dGVzIGZyb20gXCIuL2Rhc2hib2FyZC5yb3V0ZXNcIjtcbmltcG9ydCB7IEZsYXNoTWVzc2FnZXNNb2R1bGUgfSBmcm9tICdhbmd1bGFyMi1mbGFzaC1tZXNzYWdlcyc7XG5pbXBvcnQgeyBNYXRlcmlhbE1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcbi8vIGltcG9ydCB7TWF0ZXJpYWxpemVEaXJlY3RpdmV9IGZyb20gXCJhbmd1bGFyMi1tYXRlcmlhbGl6ZVwiO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czpbQ29tbW9uTW9kdWxlLCBGb3Jtc01vZHVsZSwgU2hhcmVkTW9kdWxlLCByb3V0ZXMsIEZsYXNoTWVzc2FnZXNNb2R1bGUsIE1hdGVyaWFsTW9kdWxlLmZvclJvb3QoKV0sXG4gICAgZGVjbGFyYXRpb25zOiBbRGFzaGJvYXJkQ29tcG9uZW50LCBCb2FyZHNDb21wb25lbnQsIEFjY291bnRDb21wb25lbnQsIERhc2hib2FyZE5hdkNvbXBvbmVudCwgXG4gICAgLy8gTWF0ZXJpYWxpemVEaXJlY3RpdmVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYXNoYm9hcmRNb2R1bGV7fVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9kYXNoYm9hcmQvZGFzaGJvYXJkLm1vZHVsZS50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBQUE7QUFBQTtBQVBBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 700:
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * @license Angular v2.1.2\n * (c) 2010-2016 Google, Inc. https://angular.io/\n * License: MIT\n */\n(function (global, factory) {\n     true ? factory(exports, __webpack_require__(316), __webpack_require__(640), __webpack_require__(317), __webpack_require__(318), __webpack_require__(387)) :\n    typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/operator/toPromise', 'rxjs/Subject', 'rxjs/Observable', 'rxjs/observable/fromPromise'], factory) :\n    (factory((global.ng = global.ng || {}, global.ng.forms = global.ng.forms || {}),global.ng.core,global.Rx.Observable.prototype,global.Rx,global.Rx,global.Rx.Observable));\n}(this, function (exports,_angular_core,rxjs_operator_toPromise,rxjs_Subject,rxjs_Observable,rxjs_observable_fromPromise) { 'use strict';\n\n    function isPresent(obj) {\n        return obj != null;\n    }\n    function isBlank(obj) {\n        return obj == null;\n    }\n    // JS has NaN !== NaN\n    function looseIdentical(a, b) {\n        return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);\n    }\n    function isJsObject(o) {\n        return o !== null && (typeof o === 'function' || typeof o === 'object');\n    }\n    function isPrimitive(obj) {\n        return !isJsObject(obj);\n    }\n\n    /**\n     * Base class for control directives.\n     *\n     * Only used internally in the forms module.\n     *\n     * @stable\n     */\n    var AbstractControlDirective = (function () {\n        function AbstractControlDirective() {\n        }\n        Object.defineProperty(AbstractControlDirective.prototype, \"control\", {\n            get: function () { throw new Error('unimplemented'); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"value\", {\n            get: function () { return isPresent(this.control) ? this.control.value : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"valid\", {\n            get: function () { return isPresent(this.control) ? this.control.valid : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"invalid\", {\n            get: function () { return isPresent(this.control) ? this.control.invalid : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"pending\", {\n            get: function () { return isPresent(this.control) ? this.control.pending : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"errors\", {\n            get: function () {\n                return isPresent(this.control) ? this.control.errors : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"pristine\", {\n            get: function () { return isPresent(this.control) ? this.control.pristine : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"dirty\", {\n            get: function () { return isPresent(this.control) ? this.control.dirty : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"touched\", {\n            get: function () { return isPresent(this.control) ? this.control.touched : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"untouched\", {\n            get: function () { return isPresent(this.control) ? this.control.untouched : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"disabled\", {\n            get: function () { return isPresent(this.control) ? this.control.disabled : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"enabled\", {\n            get: function () { return isPresent(this.control) ? this.control.enabled : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"statusChanges\", {\n            get: function () {\n                return isPresent(this.control) ? this.control.statusChanges : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"valueChanges\", {\n            get: function () {\n                return isPresent(this.control) ? this.control.valueChanges : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlDirective.prototype, \"path\", {\n            get: function () { return null; },\n            enumerable: true,\n            configurable: true\n        });\n        AbstractControlDirective.prototype.reset = function (value) {\n            if (value === void 0) { value = undefined; }\n            if (isPresent(this.control))\n                this.control.reset(value);\n        };\n        return AbstractControlDirective;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$1 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * A directive that contains multiple {@link NgControl}s.\n     *\n     * Only used by the forms module.\n     *\n     * @stable\n     */\n    var ControlContainer = (function (_super) {\n        __extends$1(ControlContainer, _super);\n        function ControlContainer() {\n            _super.apply(this, arguments);\n        }\n        Object.defineProperty(ControlContainer.prototype, \"formDirective\", {\n            /**\n             * Get the form to which this container belongs.\n             */\n            get: function () { return null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ControlContainer.prototype, \"path\", {\n            /**\n             * Get the path to this container.\n             */\n            get: function () { return null; },\n            enumerable: true,\n            configurable: true\n        });\n        return ControlContainer;\n    }(AbstractControlDirective));\n\n    // Safari doesn't implement MapIterator.next(), which is used is Traceur's polyfill of Array.from\n    // TODO(mlaval): remove the work around once we have a working polyfill of Array.from\n    var _arrayFromMap = (function () {\n        try {\n            if ((new Map()).values().next) {\n                return function createArrayFromMap(m, getValues) {\n                    return getValues ? Array.from(m.values()) : Array.from(m.keys());\n                };\n            }\n        }\n        catch (e) {\n        }\n        return function createArrayFromMapWithForeach(m, getValues) {\n            var res = new Array(m.size), i = 0;\n            m.forEach(function (v, k) {\n                res[i] = getValues ? v : k;\n                i++;\n            });\n            return res;\n        };\n    })();\n    var MapWrapper = (function () {\n        function MapWrapper() {\n        }\n        MapWrapper.createFromStringMap = function (stringMap) {\n            var result = new Map();\n            for (var prop in stringMap) {\n                result.set(prop, stringMap[prop]);\n            }\n            return result;\n        };\n        MapWrapper.keys = function (m) { return _arrayFromMap(m, false); };\n        MapWrapper.values = function (m) { return _arrayFromMap(m, true); };\n        return MapWrapper;\n    }());\n    /**\n     * Wraps Javascript Objects\n     */\n    var StringMapWrapper = (function () {\n        function StringMapWrapper() {\n        }\n        StringMapWrapper.merge = function (m1, m2) {\n            var m = {};\n            for (var _i = 0, _a = Object.keys(m1); _i < _a.length; _i++) {\n                var k = _a[_i];\n                m[k] = m1[k];\n            }\n            for (var _b = 0, _c = Object.keys(m2); _b < _c.length; _b++) {\n                var k = _c[_b];\n                m[k] = m2[k];\n            }\n            return m;\n        };\n        StringMapWrapper.equals = function (m1, m2) {\n            var k1 = Object.keys(m1);\n            var k2 = Object.keys(m2);\n            if (k1.length != k2.length) {\n                return false;\n            }\n            for (var i = 0; i < k1.length; i++) {\n                var key = k1[i];\n                if (m1[key] !== m2[key]) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        return StringMapWrapper;\n    }());\n    var ListWrapper = (function () {\n        function ListWrapper() {\n        }\n        ListWrapper.removeAll = function (list, items) {\n            for (var i = 0; i < items.length; ++i) {\n                var index = list.indexOf(items[i]);\n                list.splice(index, 1);\n            }\n        };\n        ListWrapper.remove = function (list, el) {\n            var index = list.indexOf(el);\n            if (index > -1) {\n                list.splice(index, 1);\n                return true;\n            }\n            return false;\n        };\n        ListWrapper.equals = function (a, b) {\n            if (a.length != b.length)\n                return false;\n            for (var i = 0; i < a.length; ++i) {\n                if (a[i] !== b[i])\n                    return false;\n            }\n            return true;\n        };\n        ListWrapper.maximum = function (list, predicate) {\n            if (list.length == 0) {\n                return null;\n            }\n            var solution = null;\n            var maxValue = -Infinity;\n            for (var index = 0; index < list.length; index++) {\n                var candidate = list[index];\n                if (candidate == null) {\n                    continue;\n                }\n                var candidateValue = predicate(candidate);\n                if (candidateValue > maxValue) {\n                    solution = candidate;\n                    maxValue = candidateValue;\n                }\n            }\n            return solution;\n        };\n        ListWrapper.flatten = function (list) {\n            var target = [];\n            _flattenArray(list, target);\n            return target;\n        };\n        return ListWrapper;\n    }());\n    function _flattenArray(source, target) {\n        if (isPresent(source)) {\n            for (var i = 0; i < source.length; i++) {\n                var item = source[i];\n                if (Array.isArray(item)) {\n                    _flattenArray(item, target);\n                }\n                else {\n                    target.push(item);\n                }\n            }\n        }\n        return target;\n    }\n\n    var isPromise = _angular_core.__core_private__.isPromise;\n\n    function isEmptyInputValue(value) {\n        return value == null || typeof value === 'string' && value.length === 0;\n    }\n    /**\n     * Providers for validators to be used for {@link FormControl}s in a form.\n     *\n     * Provide this using `multi: true` to add validators.\n     *\n     * ### Example\n     *\n     * {@example core/forms/ts/ng_validators/ng_validators.ts region='ng_validators'}\n     * @stable\n     */\n    var NG_VALIDATORS = new _angular_core.OpaqueToken('NgValidators');\n    /**\n     * Providers for asynchronous validators to be used for {@link FormControl}s\n     * in a form.\n     *\n     * Provide this using `multi: true` to add validators.\n     *\n     * See {@link NG_VALIDATORS} for more details.\n     *\n     * @stable\n     */\n    var NG_ASYNC_VALIDATORS = new _angular_core.OpaqueToken('NgAsyncValidators');\n    /**\n     * Provides a set of validators used by form controls.\n     *\n     * A validator is a function that processes a {@link FormControl} or collection of\n     * controls and returns a map of errors. A null map means that validation has passed.\n     *\n     * ### Example\n     *\n     * ```typescript\n     * var loginControl = new FormControl(\"\", Validators.required)\n     * ```\n     *\n     * @stable\n     */\n    var Validators = (function () {\n        function Validators() {\n        }\n        /**\n         * Validator that requires controls to have a non-empty value.\n         */\n        Validators.required = function (control) {\n            return isEmptyInputValue(control.value) ? { 'required': true } : null;\n        };\n        /**\n         * Validator that requires controls to have a value of a minimum length.\n         */\n        Validators.minLength = function (minLength) {\n            return function (control) {\n                if (isEmptyInputValue(control.value)) {\n                    return null; // don't validate empty values to allow optional controls\n                }\n                var length = typeof control.value === 'string' ? control.value.length : 0;\n                return length < minLength ?\n                    { 'minlength': { 'requiredLength': minLength, 'actualLength': length } } :\n                    null;\n            };\n        };\n        /**\n         * Validator that requires controls to have a value of a maximum length.\n         */\n        Validators.maxLength = function (maxLength) {\n            return function (control) {\n                var length = typeof control.value === 'string' ? control.value.length : 0;\n                return length > maxLength ?\n                    { 'maxlength': { 'requiredLength': maxLength, 'actualLength': length } } :\n                    null;\n            };\n        };\n        /**\n         * Validator that requires a control to match a regex to its value.\n         */\n        Validators.pattern = function (pattern) {\n            return function (control) {\n                if (isEmptyInputValue(control.value)) {\n                    return null; // don't validate empty values to allow optional controls\n                }\n                var regex = new RegExp(\"^\" + pattern + \"$\");\n                var value = control.value;\n                return regex.test(value) ?\n                    null :\n                    { 'pattern': { 'requiredPattern': \"^\" + pattern + \"$\", 'actualValue': value } };\n            };\n        };\n        /**\n         * No-op validator.\n         */\n        Validators.nullValidator = function (c) { return null; };\n        /**\n         * Compose multiple validators into a single function that returns the union\n         * of the individual error maps.\n         */\n        Validators.compose = function (validators) {\n            if (!validators)\n                return null;\n            var presentValidators = validators.filter(isPresent);\n            if (presentValidators.length == 0)\n                return null;\n            return function (control) {\n                return _mergeErrors(_executeValidators(control, presentValidators));\n            };\n        };\n        Validators.composeAsync = function (validators) {\n            if (!validators)\n                return null;\n            var presentValidators = validators.filter(isPresent);\n            if (presentValidators.length == 0)\n                return null;\n            return function (control) {\n                var promises = _executeAsyncValidators(control, presentValidators).map(_convertToPromise);\n                return Promise.all(promises).then(_mergeErrors);\n            };\n        };\n        return Validators;\n    }());\n    function _convertToPromise(obj) {\n        return isPromise(obj) ? obj : rxjs_operator_toPromise.toPromise.call(obj);\n    }\n    function _executeValidators(control, validators) {\n        return validators.map(function (v) { return v(control); });\n    }\n    function _executeAsyncValidators(control, validators) {\n        return validators.map(function (v) { return v(control); });\n    }\n    function _mergeErrors(arrayOfErrors) {\n        var res = arrayOfErrors.reduce(function (res, errors) {\n            return isPresent(errors) ? StringMapWrapper.merge(res, errors) : res;\n        }, {});\n        return Object.keys(res).length === 0 ? null : res;\n    }\n\n    /**\n     * Used to provide a {@link ControlValueAccessor} for form controls.\n     *\n     * See {@link DefaultValueAccessor} for how to implement one.\n     * @stable\n     */\n    var NG_VALUE_ACCESSOR = new _angular_core.OpaqueToken('NgValueAccessor');\n\n    var CHECKBOX_VALUE_ACCESSOR = {\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: _angular_core.forwardRef(function () { return CheckboxControlValueAccessor; }),\n        multi: true\n    };\n    /**\n     * The accessor for writing a value and listening to changes on a checkbox input element.\n     *\n     *  ### Example\n     *  ```\n     *  <input type=\"checkbox\" name=\"rememberLogin\" ngModel>\n     *  ```\n     *\n     *  @stable\n     */\n    var CheckboxControlValueAccessor = (function () {\n        function CheckboxControlValueAccessor(_renderer, _elementRef) {\n            this._renderer = _renderer;\n            this._elementRef = _elementRef;\n            this.onChange = function (_) { };\n            this.onTouched = function () { };\n        }\n        CheckboxControlValueAccessor.prototype.writeValue = function (value) {\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', value);\n        };\n        CheckboxControlValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };\n        CheckboxControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };\n        CheckboxControlValueAccessor.prototype.setDisabledState = function (isDisabled) {\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n        };\n        CheckboxControlValueAccessor.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: 'input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]',\n                        host: { '(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()' },\n                        providers: [CHECKBOX_VALUE_ACCESSOR]\n                    },] },\n        ];\n        /** @nocollapse */\n        CheckboxControlValueAccessor.ctorParameters = [\n            { type: _angular_core.Renderer, },\n            { type: _angular_core.ElementRef, },\n        ];\n        return CheckboxControlValueAccessor;\n    }());\n\n    var DEFAULT_VALUE_ACCESSOR = {\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: _angular_core.forwardRef(function () { return DefaultValueAccessor; }),\n        multi: true\n    };\n    /**\n     * The default accessor for writing a value and listening to changes that is used by the\n     * {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName} directives.\n     *\n     *  ### Example\n     *  ```\n     *  <input type=\"text\" name=\"searchQuery\" ngModel>\n     *  ```\n     *\n     *  @stable\n     */\n    var DefaultValueAccessor = (function () {\n        function DefaultValueAccessor(_renderer, _elementRef) {\n            this._renderer = _renderer;\n            this._elementRef = _elementRef;\n            this.onChange = function (_) { };\n            this.onTouched = function () { };\n        }\n        DefaultValueAccessor.prototype.writeValue = function (value) {\n            var normalizedValue = isBlank(value) ? '' : value;\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);\n        };\n        DefaultValueAccessor.prototype.registerOnChange = function (fn) { this.onChange = fn; };\n        DefaultValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };\n        DefaultValueAccessor.prototype.setDisabledState = function (isDisabled) {\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n        };\n        DefaultValueAccessor.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: 'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',\n                        // TODO: vsavkin replace the above selector with the one below it once\n                        // https://github.com/angular/angular/issues/3011 is implemented\n                        // selector: '[ngControl],[ngModel],[ngFormControl]',\n                        host: { '(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },\n                        providers: [DEFAULT_VALUE_ACCESSOR]\n                    },] },\n        ];\n        /** @nocollapse */\n        DefaultValueAccessor.ctorParameters = [\n            { type: _angular_core.Renderer, },\n            { type: _angular_core.ElementRef, },\n        ];\n        return DefaultValueAccessor;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    function normalizeValidator(validator) {\n        if (validator.validate !== undefined) {\n            return function (c) { return validator.validate(c); };\n        }\n        else {\n            return validator;\n        }\n    }\n    function normalizeAsyncValidator(validator) {\n        if (validator.validate !== undefined) {\n            return function (c) { return validator.validate(c); };\n        }\n        else {\n            return validator;\n        }\n    }\n\n    var NUMBER_VALUE_ACCESSOR = {\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: _angular_core.forwardRef(function () { return NumberValueAccessor; }),\n        multi: true\n    };\n    /**\n     * The accessor for writing a number value and listening to changes that is used by the\n     * {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName} directives.\n     *\n     *  ### Example\n     *  ```\n     *  <input type=\"number\" [(ngModel)]=\"age\">\n     *  ```\n     */\n    var NumberValueAccessor = (function () {\n        function NumberValueAccessor(_renderer, _elementRef) {\n            this._renderer = _renderer;\n            this._elementRef = _elementRef;\n            this.onChange = function (_) { };\n            this.onTouched = function () { };\n        }\n        NumberValueAccessor.prototype.writeValue = function (value) {\n            // The value needs to be normalized for IE9, otherwise it is set to 'null' when null\n            var normalizedValue = isBlank(value) ? '' : value;\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', normalizedValue);\n        };\n        NumberValueAccessor.prototype.registerOnChange = function (fn) {\n            this.onChange = function (value) { fn(value == '' ? null : parseFloat(value)); };\n        };\n        NumberValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };\n        NumberValueAccessor.prototype.setDisabledState = function (isDisabled) {\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n        };\n        NumberValueAccessor.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: 'input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]',\n                        host: {\n                            '(change)': 'onChange($event.target.value)',\n                            '(input)': 'onChange($event.target.value)',\n                            '(blur)': 'onTouched()'\n                        },\n                        providers: [NUMBER_VALUE_ACCESSOR]\n                    },] },\n        ];\n        /** @nocollapse */\n        NumberValueAccessor.ctorParameters = [\n            { type: _angular_core.Renderer, },\n            { type: _angular_core.ElementRef, },\n        ];\n        return NumberValueAccessor;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$2 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    function unimplemented() {\n        throw new Error('unimplemented');\n    }\n    /**\n     * A base class that all control directive extend.\n     * It binds a {@link FormControl} object to a DOM element.\n     *\n     * Used internally by Angular forms.\n     *\n     * @stable\n     */\n    var NgControl = (function (_super) {\n        __extends$2(NgControl, _super);\n        function NgControl() {\n            _super.apply(this, arguments);\n            /** @internal */\n            this._parent = null;\n            this.name = null;\n            this.valueAccessor = null;\n            /** @internal */\n            this._rawValidators = [];\n            /** @internal */\n            this._rawAsyncValidators = [];\n        }\n        Object.defineProperty(NgControl.prototype, \"validator\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgControl.prototype, \"asyncValidator\", {\n            get: function () { return unimplemented(); },\n            enumerable: true,\n            configurable: true\n        });\n        return NgControl;\n    }(AbstractControlDirective));\n\n    var RADIO_VALUE_ACCESSOR = {\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: _angular_core.forwardRef(function () { return RadioControlValueAccessor; }),\n        multi: true\n    };\n    /**\n     * Internal class used by Angular to uncheck radio buttons with the matching name.\n     */\n    var RadioControlRegistry = (function () {\n        function RadioControlRegistry() {\n            this._accessors = [];\n        }\n        RadioControlRegistry.prototype.add = function (control, accessor) {\n            this._accessors.push([control, accessor]);\n        };\n        RadioControlRegistry.prototype.remove = function (accessor) {\n            var indexToRemove = -1;\n            for (var i = 0; i < this._accessors.length; ++i) {\n                if (this._accessors[i][1] === accessor) {\n                    indexToRemove = i;\n                }\n            }\n            this._accessors.splice(indexToRemove, 1);\n        };\n        RadioControlRegistry.prototype.select = function (accessor) {\n            var _this = this;\n            this._accessors.forEach(function (c) {\n                if (_this._isSameGroup(c, accessor) && c[1] !== accessor) {\n                    c[1].fireUncheck(accessor.value);\n                }\n            });\n        };\n        RadioControlRegistry.prototype._isSameGroup = function (controlPair, accessor) {\n            if (!controlPair[0].control)\n                return false;\n            return controlPair[0]._parent === accessor._control._parent &&\n                controlPair[1].name === accessor.name;\n        };\n        RadioControlRegistry.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        RadioControlRegistry.ctorParameters = [];\n        return RadioControlRegistry;\n    }());\n    /**\n     * @whatItDoes  Writes radio control values and listens to radio control changes.\n     *\n     * Used by {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName}\n     * to keep the view synced with the {@link FormControl} model.\n     *\n     * @howToUse\n     *\n     * If you have imported the {@link FormsModule} or the {@link ReactiveFormsModule}, this\n     * value accessor will be active on any radio control that has a form directive. You do\n     * **not** need to add a special selector to activate it.\n     *\n     * ### How to use radio buttons with form directives\n     *\n     * To use radio buttons in a template-driven form, you'll want to ensure that radio buttons\n     * in the same group have the same `name` attribute.  Radio buttons with different `name`\n     * attributes do not affect each other.\n     *\n     * {@example forms/ts/radioButtons/radio_button_example.ts region='TemplateDriven'}\n     *\n     * When using radio buttons in a reactive form, radio buttons in the same group should have the\n     * same `formControlName`. You can also add a `name` attribute, but it's optional.\n     *\n     * {@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}\n     *\n     *  * **npm package**: `@angular/forms`\n     *\n     *  @stable\n     */\n    var RadioControlValueAccessor = (function () {\n        function RadioControlValueAccessor(_renderer, _elementRef, _registry, _injector) {\n            this._renderer = _renderer;\n            this._elementRef = _elementRef;\n            this._registry = _registry;\n            this._injector = _injector;\n            this.onChange = function () { };\n            this.onTouched = function () { };\n        }\n        RadioControlValueAccessor.prototype.ngOnInit = function () {\n            this._control = this._injector.get(NgControl);\n            this._checkName();\n            this._registry.add(this._control, this);\n        };\n        RadioControlValueAccessor.prototype.ngOnDestroy = function () { this._registry.remove(this); };\n        RadioControlValueAccessor.prototype.writeValue = function (value) {\n            this._state = value === this.value;\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'checked', this._state);\n        };\n        RadioControlValueAccessor.prototype.registerOnChange = function (fn) {\n            var _this = this;\n            this._fn = fn;\n            this.onChange = function () {\n                fn(_this.value);\n                _this._registry.select(_this);\n            };\n        };\n        RadioControlValueAccessor.prototype.fireUncheck = function (value) { this.writeValue(value); };\n        RadioControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };\n        RadioControlValueAccessor.prototype.setDisabledState = function (isDisabled) {\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n        };\n        RadioControlValueAccessor.prototype._checkName = function () {\n            if (this.name && this.formControlName && this.name !== this.formControlName) {\n                this._throwNameError();\n            }\n            if (!this.name && this.formControlName)\n                this.name = this.formControlName;\n        };\n        RadioControlValueAccessor.prototype._throwNameError = function () {\n            throw new Error(\"\\n      If you define both a name and a formControlName attribute on your radio button, their values\\n      must match. Ex: <input type=\\\"radio\\\" formControlName=\\\"food\\\" name=\\\"food\\\">\\n    \");\n        };\n        RadioControlValueAccessor.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: 'input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]',\n                        host: { '(change)': 'onChange()', '(blur)': 'onTouched()' },\n                        providers: [RADIO_VALUE_ACCESSOR]\n                    },] },\n        ];\n        /** @nocollapse */\n        RadioControlValueAccessor.ctorParameters = [\n            { type: _angular_core.Renderer, },\n            { type: _angular_core.ElementRef, },\n            { type: RadioControlRegistry, },\n            { type: _angular_core.Injector, },\n        ];\n        RadioControlValueAccessor.propDecorators = {\n            'name': [{ type: _angular_core.Input },],\n            'formControlName': [{ type: _angular_core.Input },],\n            'value': [{ type: _angular_core.Input },],\n        };\n        return RadioControlValueAccessor;\n    }());\n\n    var SELECT_VALUE_ACCESSOR = {\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: _angular_core.forwardRef(function () { return SelectControlValueAccessor; }),\n        multi: true\n    };\n    function _buildValueString(id, value) {\n        if (isBlank(id))\n            return \"\" + value;\n        if (!isPrimitive(value))\n            value = 'Object';\n        return (id + \": \" + value).slice(0, 50);\n    }\n    function _extractId(valueString) {\n        return valueString.split(':')[0];\n    }\n    /**\n     * @whatItDoes Writes values and listens to changes on a select element.\n     *\n     * Used by {@link NgModel}, {@link FormControlDirective}, and {@link FormControlName}\n     * to keep the view synced with the {@link FormControl} model.\n     *\n     * @howToUse\n     *\n     * If you have imported the {@link FormsModule} or the {@link ReactiveFormsModule}, this\n     * value accessor will be active on any select control that has a form directive. You do\n     * **not** need to add a special selector to activate it.\n     *\n     * ### How to use select controls with form directives\n     *\n     * To use a select in a template-driven form, simply add an `ngModel` and a `name`\n     * attribute to the main `<select>` tag.\n     *\n     * If your option values are simple strings, you can bind to the normal `value` property\n     * on the option.  If your option values happen to be objects (and you'd like to save the\n     * selection in your form as an object), use `ngValue` instead:\n     *\n     * {@example forms/ts/selectControl/select_control_example.ts region='Component'}\n     *\n     * In reactive forms, you'll also want to add your form directive (`formControlName` or\n     * `formControl`) on the main `<select>` tag. Like in the former example, you have the\n     * choice of binding to the  `value` or `ngValue` property on the select's options.\n     *\n     * {@example forms/ts/reactiveSelectControl/reactive_select_control_example.ts region='Component'}\n     *\n     * Note: We listen to the 'change' event because 'input' events aren't fired\n     * for selects in Firefox and IE:\n     * https://bugzilla.mozilla.org/show_bug.cgi?id=1024350\n     * https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/4660045/\n     *\n     * * **npm package**: `@angular/forms`\n     *\n     * @stable\n     */\n    var SelectControlValueAccessor = (function () {\n        function SelectControlValueAccessor(_renderer, _elementRef) {\n            this._renderer = _renderer;\n            this._elementRef = _elementRef;\n            /** @internal */\n            this._optionMap = new Map();\n            /** @internal */\n            this._idCounter = 0;\n            this.onChange = function (_) { };\n            this.onTouched = function () { };\n        }\n        SelectControlValueAccessor.prototype.writeValue = function (value) {\n            this.value = value;\n            var valueString = _buildValueString(this._getOptionId(value), value);\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'value', valueString);\n        };\n        SelectControlValueAccessor.prototype.registerOnChange = function (fn) {\n            var _this = this;\n            this.onChange = function (valueString) {\n                _this.value = valueString;\n                fn(_this._getOptionValue(valueString));\n            };\n        };\n        SelectControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };\n        SelectControlValueAccessor.prototype.setDisabledState = function (isDisabled) {\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n        };\n        /** @internal */\n        SelectControlValueAccessor.prototype._registerOption = function () { return (this._idCounter++).toString(); };\n        /** @internal */\n        SelectControlValueAccessor.prototype._getOptionId = function (value) {\n            for (var _i = 0, _a = MapWrapper.keys(this._optionMap); _i < _a.length; _i++) {\n                var id = _a[_i];\n                if (looseIdentical(this._optionMap.get(id), value))\n                    return id;\n            }\n            return null;\n        };\n        /** @internal */\n        SelectControlValueAccessor.prototype._getOptionValue = function (valueString) {\n            var value = this._optionMap.get(_extractId(valueString));\n            return isPresent(value) ? value : valueString;\n        };\n        SelectControlValueAccessor.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: 'select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]',\n                        host: { '(change)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },\n                        providers: [SELECT_VALUE_ACCESSOR]\n                    },] },\n        ];\n        /** @nocollapse */\n        SelectControlValueAccessor.ctorParameters = [\n            { type: _angular_core.Renderer, },\n            { type: _angular_core.ElementRef, },\n        ];\n        return SelectControlValueAccessor;\n    }());\n    /**\n     * @whatItDoes Marks `<option>` as dynamic, so Angular can be notified when options change.\n     *\n     * @howToUse\n     *\n     * See docs for {@link SelectControlValueAccessor} for usage examples.\n     *\n     * @stable\n     */\n    var NgSelectOption = (function () {\n        function NgSelectOption(_element, _renderer, _select) {\n            this._element = _element;\n            this._renderer = _renderer;\n            this._select = _select;\n            if (isPresent(this._select))\n                this.id = this._select._registerOption();\n        }\n        Object.defineProperty(NgSelectOption.prototype, \"ngValue\", {\n            set: function (value) {\n                if (this._select == null)\n                    return;\n                this._select._optionMap.set(this.id, value);\n                this._setElementValue(_buildValueString(this.id, value));\n                this._select.writeValue(this._select.value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgSelectOption.prototype, \"value\", {\n            set: function (value) {\n                this._setElementValue(value);\n                if (isPresent(this._select))\n                    this._select.writeValue(this._select.value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** @internal */\n        NgSelectOption.prototype._setElementValue = function (value) {\n            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);\n        };\n        NgSelectOption.prototype.ngOnDestroy = function () {\n            if (isPresent(this._select)) {\n                this._select._optionMap.delete(this.id);\n                this._select.writeValue(this._select.value);\n            }\n        };\n        NgSelectOption.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: 'option' },] },\n        ];\n        /** @nocollapse */\n        NgSelectOption.ctorParameters = [\n            { type: _angular_core.ElementRef, },\n            { type: _angular_core.Renderer, },\n            { type: SelectControlValueAccessor, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },\n        ];\n        NgSelectOption.propDecorators = {\n            'ngValue': [{ type: _angular_core.Input, args: ['ngValue',] },],\n            'value': [{ type: _angular_core.Input, args: ['value',] },],\n        };\n        return NgSelectOption;\n    }());\n\n    var SELECT_MULTIPLE_VALUE_ACCESSOR = {\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: _angular_core.forwardRef(function () { return SelectMultipleControlValueAccessor; }),\n        multi: true\n    };\n    function _buildValueString$1(id, value) {\n        if (isBlank(id))\n            return \"\" + value;\n        if (typeof value === 'string')\n            value = \"'\" + value + \"'\";\n        if (!isPrimitive(value))\n            value = 'Object';\n        return (id + \": \" + value).slice(0, 50);\n    }\n    function _extractId$1(valueString) {\n        return valueString.split(':')[0];\n    }\n    /**\n     * The accessor for writing a value and listening to changes on a select element.\n     *\n     * @stable\n     */\n    var SelectMultipleControlValueAccessor = (function () {\n        function SelectMultipleControlValueAccessor(_renderer, _elementRef) {\n            this._renderer = _renderer;\n            this._elementRef = _elementRef;\n            /** @internal */\n            this._optionMap = new Map();\n            /** @internal */\n            this._idCounter = 0;\n            this.onChange = function (_) { };\n            this.onTouched = function () { };\n        }\n        SelectMultipleControlValueAccessor.prototype.writeValue = function (value) {\n            var _this = this;\n            this.value = value;\n            if (value == null)\n                return;\n            var values = value;\n            // convert values to ids\n            var ids = values.map(function (v) { return _this._getOptionId(v); });\n            this._optionMap.forEach(function (opt, o) { opt._setSelected(ids.indexOf(o.toString()) > -1); });\n        };\n        SelectMultipleControlValueAccessor.prototype.registerOnChange = function (fn) {\n            var _this = this;\n            this.onChange = function (_) {\n                var selected = [];\n                if (_.hasOwnProperty('selectedOptions')) {\n                    var options = _.selectedOptions;\n                    for (var i = 0; i < options.length; i++) {\n                        var opt = options.item(i);\n                        var val = _this._getOptionValue(opt.value);\n                        selected.push(val);\n                    }\n                }\n                else {\n                    var options = _.options;\n                    for (var i = 0; i < options.length; i++) {\n                        var opt = options.item(i);\n                        if (opt.selected) {\n                            var val = _this._getOptionValue(opt.value);\n                            selected.push(val);\n                        }\n                    }\n                }\n                fn(selected);\n            };\n        };\n        SelectMultipleControlValueAccessor.prototype.registerOnTouched = function (fn) { this.onTouched = fn; };\n        SelectMultipleControlValueAccessor.prototype.setDisabledState = function (isDisabled) {\n            this._renderer.setElementProperty(this._elementRef.nativeElement, 'disabled', isDisabled);\n        };\n        /** @internal */\n        SelectMultipleControlValueAccessor.prototype._registerOption = function (value) {\n            var id = (this._idCounter++).toString();\n            this._optionMap.set(id, value);\n            return id;\n        };\n        /** @internal */\n        SelectMultipleControlValueAccessor.prototype._getOptionId = function (value) {\n            for (var _i = 0, _a = MapWrapper.keys(this._optionMap); _i < _a.length; _i++) {\n                var id = _a[_i];\n                if (looseIdentical(this._optionMap.get(id)._value, value))\n                    return id;\n            }\n            return null;\n        };\n        /** @internal */\n        SelectMultipleControlValueAccessor.prototype._getOptionValue = function (valueString) {\n            var opt = this._optionMap.get(_extractId$1(valueString));\n            return isPresent(opt) ? opt._value : valueString;\n        };\n        SelectMultipleControlValueAccessor.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: 'select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]',\n                        host: { '(change)': 'onChange($event.target)', '(blur)': 'onTouched()' },\n                        providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]\n                    },] },\n        ];\n        /** @nocollapse */\n        SelectMultipleControlValueAccessor.ctorParameters = [\n            { type: _angular_core.Renderer, },\n            { type: _angular_core.ElementRef, },\n        ];\n        return SelectMultipleControlValueAccessor;\n    }());\n    /**\n     * Marks `<option>` as dynamic, so Angular can be notified when options change.\n     *\n     * ### Example\n     *\n     * ```\n     * <select multiple name=\"city\" ngModel>\n     *   <option *ngFor=\"let c of cities\" [value]=\"c\"></option>\n     * </select>\n     * ```\n     */\n    var NgSelectMultipleOption = (function () {\n        function NgSelectMultipleOption(_element, _renderer, _select) {\n            this._element = _element;\n            this._renderer = _renderer;\n            this._select = _select;\n            if (isPresent(this._select)) {\n                this.id = this._select._registerOption(this);\n            }\n        }\n        Object.defineProperty(NgSelectMultipleOption.prototype, \"ngValue\", {\n            set: function (value) {\n                if (this._select == null)\n                    return;\n                this._value = value;\n                this._setElementValue(_buildValueString$1(this.id, value));\n                this._select.writeValue(this._select.value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgSelectMultipleOption.prototype, \"value\", {\n            set: function (value) {\n                if (isPresent(this._select)) {\n                    this._value = value;\n                    this._setElementValue(_buildValueString$1(this.id, value));\n                    this._select.writeValue(this._select.value);\n                }\n                else {\n                    this._setElementValue(value);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** @internal */\n        NgSelectMultipleOption.prototype._setElementValue = function (value) {\n            this._renderer.setElementProperty(this._element.nativeElement, 'value', value);\n        };\n        /** @internal */\n        NgSelectMultipleOption.prototype._setSelected = function (selected) {\n            this._renderer.setElementProperty(this._element.nativeElement, 'selected', selected);\n        };\n        NgSelectMultipleOption.prototype.ngOnDestroy = function () {\n            if (isPresent(this._select)) {\n                this._select._optionMap.delete(this.id);\n                this._select.writeValue(this._select.value);\n            }\n        };\n        NgSelectMultipleOption.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: 'option' },] },\n        ];\n        /** @nocollapse */\n        NgSelectMultipleOption.ctorParameters = [\n            { type: _angular_core.ElementRef, },\n            { type: _angular_core.Renderer, },\n            { type: SelectMultipleControlValueAccessor, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },\n        ];\n        NgSelectMultipleOption.propDecorators = {\n            'ngValue': [{ type: _angular_core.Input, args: ['ngValue',] },],\n            'value': [{ type: _angular_core.Input, args: ['value',] },],\n        };\n        return NgSelectMultipleOption;\n    }());\n\n    function controlPath(name, parent) {\n        return parent.path.concat([name]);\n    }\n    function setUpControl(control, dir) {\n        if (!control)\n            _throwError(dir, 'Cannot find control with');\n        if (!dir.valueAccessor)\n            _throwError(dir, 'No value accessor for form control with');\n        control.validator = Validators.compose([control.validator, dir.validator]);\n        control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);\n        dir.valueAccessor.writeValue(control.value);\n        // view -> model\n        dir.valueAccessor.registerOnChange(function (newValue) {\n            dir.viewToModelUpdate(newValue);\n            control.markAsDirty();\n            control.setValue(newValue, { emitModelToViewChange: false });\n        });\n        // touched\n        dir.valueAccessor.registerOnTouched(function () { return control.markAsTouched(); });\n        control.registerOnChange(function (newValue, emitModelEvent) {\n            // control -> view\n            dir.valueAccessor.writeValue(newValue);\n            // control -> ngModel\n            if (emitModelEvent)\n                dir.viewToModelUpdate(newValue);\n        });\n        if (dir.valueAccessor.setDisabledState) {\n            control.registerOnDisabledChange(function (isDisabled) { dir.valueAccessor.setDisabledState(isDisabled); });\n        }\n        // re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4\n        dir._rawValidators.forEach(function (validator) {\n            if (validator.registerOnValidatorChange)\n                validator.registerOnValidatorChange(function () { return control.updateValueAndValidity(); });\n        });\n        dir._rawAsyncValidators.forEach(function (validator) {\n            if (validator.registerOnValidatorChange)\n                validator.registerOnValidatorChange(function () { return control.updateValueAndValidity(); });\n        });\n    }\n    function cleanUpControl(control, dir) {\n        dir.valueAccessor.registerOnChange(function () { return _noControlError(dir); });\n        dir.valueAccessor.registerOnTouched(function () { return _noControlError(dir); });\n        dir._rawValidators.forEach(function (validator) { return validator.registerOnValidatorChange(null); });\n        dir._rawAsyncValidators.forEach(function (validator) { return validator.registerOnValidatorChange(null); });\n        if (control)\n            control._clearChangeFns();\n    }\n    function setUpFormContainer(control, dir) {\n        if (isBlank(control))\n            _throwError(dir, 'Cannot find control with');\n        control.validator = Validators.compose([control.validator, dir.validator]);\n        control.asyncValidator = Validators.composeAsync([control.asyncValidator, dir.asyncValidator]);\n    }\n    function _noControlError(dir) {\n        return _throwError(dir, 'There is no FormControl instance attached to form control element with');\n    }\n    function _throwError(dir, message) {\n        var messageEnd;\n        if (dir.path.length > 1) {\n            messageEnd = \"path: '\" + dir.path.join(' -> ') + \"'\";\n        }\n        else if (dir.path[0]) {\n            messageEnd = \"name: '\" + dir.path + \"'\";\n        }\n        else {\n            messageEnd = 'unspecified name attribute';\n        }\n        throw new Error(message + \" \" + messageEnd);\n    }\n    function composeValidators(validators) {\n        return isPresent(validators) ? Validators.compose(validators.map(normalizeValidator)) : null;\n    }\n    function composeAsyncValidators(validators) {\n        return isPresent(validators) ? Validators.composeAsync(validators.map(normalizeAsyncValidator)) :\n            null;\n    }\n    function isPropertyUpdated(changes, viewModel) {\n        if (!changes.hasOwnProperty('model'))\n            return false;\n        var change = changes['model'];\n        if (change.isFirstChange())\n            return true;\n        return !looseIdentical(viewModel, change.currentValue);\n    }\n    var BUILTIN_ACCESSORS = [\n        CheckboxControlValueAccessor,\n        NumberValueAccessor,\n        SelectControlValueAccessor,\n        SelectMultipleControlValueAccessor,\n        RadioControlValueAccessor,\n    ];\n    function isBuiltInAccessor(valueAccessor) {\n        return BUILTIN_ACCESSORS.some(function (a) { return valueAccessor.constructor === a; });\n    }\n    // TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented\n    function selectValueAccessor(dir, valueAccessors) {\n        if (!valueAccessors)\n            return null;\n        var defaultAccessor;\n        var builtinAccessor;\n        var customAccessor;\n        valueAccessors.forEach(function (v) {\n            if (v.constructor === DefaultValueAccessor) {\n                defaultAccessor = v;\n            }\n            else if (isBuiltInAccessor(v)) {\n                if (builtinAccessor)\n                    _throwError(dir, 'More than one built-in value accessor matches form control with');\n                builtinAccessor = v;\n            }\n            else {\n                if (customAccessor)\n                    _throwError(dir, 'More than one custom value accessor matches form control with');\n                customAccessor = v;\n            }\n        });\n        if (customAccessor)\n            return customAccessor;\n        if (builtinAccessor)\n            return builtinAccessor;\n        if (defaultAccessor)\n            return defaultAccessor;\n        _throwError(dir, 'No valid value accessor for form control with');\n        return null;\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * This is a base class for code shared between {@link NgModelGroup} and {@link FormGroupName}.\n     *\n     * @stable\n     */\n    var AbstractFormGroupDirective = (function (_super) {\n        __extends(AbstractFormGroupDirective, _super);\n        function AbstractFormGroupDirective() {\n            _super.apply(this, arguments);\n        }\n        AbstractFormGroupDirective.prototype.ngOnInit = function () {\n            this._checkParentType();\n            this.formDirective.addFormGroup(this);\n        };\n        AbstractFormGroupDirective.prototype.ngOnDestroy = function () {\n            if (this.formDirective) {\n                this.formDirective.removeFormGroup(this);\n            }\n        };\n        Object.defineProperty(AbstractFormGroupDirective.prototype, \"control\", {\n            /**\n             * Get the {@link FormGroup} backing this binding.\n             */\n            get: function () { return this.formDirective.getFormGroup(this); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractFormGroupDirective.prototype, \"path\", {\n            /**\n             * Get the path to this control group.\n             */\n            get: function () { return controlPath(this.name, this._parent); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractFormGroupDirective.prototype, \"formDirective\", {\n            /**\n             * Get the {@link Form} to which this group belongs.\n             */\n            get: function () { return this._parent ? this._parent.formDirective : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractFormGroupDirective.prototype, \"validator\", {\n            get: function () { return composeValidators(this._validators); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractFormGroupDirective.prototype, \"asyncValidator\", {\n            get: function () { return composeAsyncValidators(this._asyncValidators); },\n            enumerable: true,\n            configurable: true\n        });\n        /** @internal */\n        AbstractFormGroupDirective.prototype._checkParentType = function () { };\n        return AbstractFormGroupDirective;\n    }(ControlContainer));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$3 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var AbstractControlStatus = (function () {\n        function AbstractControlStatus(cd) {\n            this._cd = cd;\n        }\n        Object.defineProperty(AbstractControlStatus.prototype, \"ngClassUntouched\", {\n            get: function () {\n                return isPresent(this._cd.control) ? this._cd.control.untouched : false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlStatus.prototype, \"ngClassTouched\", {\n            get: function () {\n                return isPresent(this._cd.control) ? this._cd.control.touched : false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlStatus.prototype, \"ngClassPristine\", {\n            get: function () {\n                return isPresent(this._cd.control) ? this._cd.control.pristine : false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlStatus.prototype, \"ngClassDirty\", {\n            get: function () {\n                return isPresent(this._cd.control) ? this._cd.control.dirty : false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlStatus.prototype, \"ngClassValid\", {\n            get: function () {\n                return isPresent(this._cd.control) ? this._cd.control.valid : false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControlStatus.prototype, \"ngClassInvalid\", {\n            get: function () {\n                return isPresent(this._cd.control) ? this._cd.control.invalid : false;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return AbstractControlStatus;\n    }());\n    var ngControlStatusHost = {\n        '[class.ng-untouched]': 'ngClassUntouched',\n        '[class.ng-touched]': 'ngClassTouched',\n        '[class.ng-pristine]': 'ngClassPristine',\n        '[class.ng-dirty]': 'ngClassDirty',\n        '[class.ng-valid]': 'ngClassValid',\n        '[class.ng-invalid]': 'ngClassInvalid'\n    };\n    /**\n     * Directive automatically applied to Angular form controls that sets CSS classes\n     * based on control status (valid/invalid/dirty/etc).\n     *\n     * @stable\n     */\n    var NgControlStatus = (function (_super) {\n        __extends$3(NgControlStatus, _super);\n        function NgControlStatus(cd) {\n            _super.call(this, cd);\n        }\n        NgControlStatus.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[formControlName],[ngModel],[formControl]', host: ngControlStatusHost },] },\n        ];\n        /** @nocollapse */\n        NgControlStatus.ctorParameters = [\n            { type: NgControl, decorators: [{ type: _angular_core.Self },] },\n        ];\n        return NgControlStatus;\n    }(AbstractControlStatus));\n    /**\n     * Directive automatically applied to Angular form groups that sets CSS classes\n     * based on control status (valid/invalid/dirty/etc).\n     *\n     * @stable\n     */\n    var NgControlStatusGroup = (function (_super) {\n        __extends$3(NgControlStatusGroup, _super);\n        function NgControlStatusGroup(cd) {\n            _super.call(this, cd);\n        }\n        NgControlStatusGroup.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]',\n                        host: ngControlStatusHost\n                    },] },\n        ];\n        /** @nocollapse */\n        NgControlStatusGroup.ctorParameters = [\n            { type: ControlContainer, decorators: [{ type: _angular_core.Self },] },\n        ];\n        return NgControlStatusGroup;\n    }(AbstractControlStatus));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$5 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Use by directives and components to emit custom Events.\n     *\n     * ### Examples\n     *\n     * In the following example, `Zippy` alternatively emits `open` and `close` events when its\n     * title gets clicked:\n     *\n     * ```\n     * @Component({\n     *   selector: 'zippy',\n     *   template: `\n     *   <div class=\"zippy\">\n     *     <div (click)=\"toggle()\">Toggle</div>\n     *     <div [hidden]=\"!visible\">\n     *       <ng-content></ng-content>\n     *     </div>\n     *  </div>`})\n     * export class Zippy {\n     *   visible: boolean = true;\n     *   @Output() open: EventEmitter<any> = new EventEmitter();\n     *   @Output() close: EventEmitter<any> = new EventEmitter();\n     *\n     *   toggle() {\n     *     this.visible = !this.visible;\n     *     if (this.visible) {\n     *       this.open.emit(null);\n     *     } else {\n     *       this.close.emit(null);\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * The events payload can be accessed by the parameter `$event` on the components output event\n     * handler:\n     *\n     * ```\n     * <zippy (open)=\"onOpen($event)\" (close)=\"onClose($event)\"></zippy>\n     * ```\n     *\n     * Uses Rx.Observable but provides an adapter to make it work as specified here:\n     * https://github.com/jhusain/observable-spec\n     *\n     * Once a reference implementation of the spec is available, switch to it.\n     * @stable\n     */\n    var EventEmitter = (function (_super) {\n        __extends$5(EventEmitter, _super);\n        /**\n         * Creates an instance of [EventEmitter], which depending on [isAsync],\n         * delivers events synchronously or asynchronously.\n         */\n        function EventEmitter(isAsync) {\n            if (isAsync === void 0) { isAsync = false; }\n            _super.call(this);\n            this.__isAsync = isAsync;\n        }\n        EventEmitter.prototype.emit = function (value) { _super.prototype.next.call(this, value); };\n        EventEmitter.prototype.subscribe = function (generatorOrNext, error, complete) {\n            var schedulerFn;\n            var errorFn = function (err) { return null; };\n            var completeFn = function () { return null; };\n            if (generatorOrNext && typeof generatorOrNext === 'object') {\n                schedulerFn = this.__isAsync ? function (value) {\n                    setTimeout(function () { return generatorOrNext.next(value); });\n                } : function (value) { generatorOrNext.next(value); };\n                if (generatorOrNext.error) {\n                    errorFn = this.__isAsync ? function (err) { setTimeout(function () { return generatorOrNext.error(err); }); } :\n                        function (err) { generatorOrNext.error(err); };\n                }\n                if (generatorOrNext.complete) {\n                    completeFn = this.__isAsync ? function () { setTimeout(function () { return generatorOrNext.complete(); }); } :\n                        function () { generatorOrNext.complete(); };\n                }\n            }\n            else {\n                schedulerFn = this.__isAsync ? function (value) { setTimeout(function () { return generatorOrNext(value); }); } :\n                    function (value) { generatorOrNext(value); };\n                if (error) {\n                    errorFn =\n                        this.__isAsync ? function (err) { setTimeout(function () { return error(err); }); } : function (err) { error(err); };\n                }\n                if (complete) {\n                    completeFn =\n                        this.__isAsync ? function () { setTimeout(function () { return complete(); }); } : function () { complete(); };\n                }\n            }\n            return _super.prototype.subscribe.call(this, schedulerFn, errorFn, completeFn);\n        };\n        return EventEmitter;\n    }(rxjs_Subject.Subject));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$6 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    /**\n     * Indicates that a FormControl is valid, i.e. that no errors exist in the input value.\n     */\n    var VALID = 'VALID';\n    /**\n     * Indicates that a FormControl is invalid, i.e. that an error exists in the input value.\n     */\n    var INVALID = 'INVALID';\n    /**\n     * Indicates that a FormControl is pending, i.e. that async validation is occurring and\n     * errors are not yet available for the input value.\n     */\n    var PENDING = 'PENDING';\n    /**\n     * Indicates that a FormControl is disabled, i.e. that the control is exempt from ancestor\n     * calculations of validity or value.\n     */\n    var DISABLED = 'DISABLED';\n    function _find(control, path, delimiter) {\n        if (path == null)\n            return null;\n        if (!(path instanceof Array)) {\n            path = path.split(delimiter);\n        }\n        if (path instanceof Array && (path.length === 0))\n            return null;\n        return path.reduce(function (v, name) {\n            if (v instanceof FormGroup) {\n                return v.controls[name] || null;\n            }\n            if (v instanceof FormArray) {\n                return v.at(name) || null;\n            }\n            return null;\n        }, control);\n    }\n    function toObservable(r) {\n        return isPromise(r) ? rxjs_observable_fromPromise.fromPromise(r) : r;\n    }\n    function coerceToValidator(validator) {\n        return Array.isArray(validator) ? composeValidators(validator) : validator;\n    }\n    function coerceToAsyncValidator(asyncValidator) {\n        return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator;\n    }\n    /**\n     * @whatItDoes This is the base class for {@link FormControl}, {@link FormGroup}, and\n     * {@link FormArray}.\n     *\n     * It provides some of the shared behavior that all controls and groups of controls have, like\n     * running validators, calculating status, and resetting state. It also defines the properties\n     * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\n     * instantiated directly.\n     *\n     * @stable\n     */\n    var AbstractControl = (function () {\n        function AbstractControl(validator, asyncValidator) {\n            this.validator = validator;\n            this.asyncValidator = asyncValidator;\n            /** @internal */\n            this._onCollectionChange = function () { };\n            this._pristine = true;\n            this._touched = false;\n            /** @internal */\n            this._onDisabledChange = [];\n        }\n        Object.defineProperty(AbstractControl.prototype, \"value\", {\n            /**\n             * The value of the control.\n             */\n            get: function () { return this._value; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"status\", {\n            /**\n             * The validation status of the control. There are four possible\n             * validation statuses:\n             *\n             * * **VALID**:  control has passed all validation checks\n             * * **INVALID**: control has failed at least one validation check\n             * * **PENDING**: control is in the midst of conducting a validation check\n             * * **DISABLED**: control is exempt from validation checks\n             *\n             * These statuses are mutually exclusive, so a control cannot be\n             * both valid AND invalid or invalid AND disabled.\n             */\n            get: function () { return this._status; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"valid\", {\n            /**\n             * A control is `valid` when its `status === VALID`.\n             *\n             * In order to have this status, the control must have passed all its\n             * validation checks.\n             */\n            get: function () { return this._status === VALID; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"invalid\", {\n            /**\n             * A control is `invalid` when its `status === INVALID`.\n             *\n             * In order to have this status, the control must have failed\n             * at least one of its validation checks.\n             */\n            get: function () { return this._status === INVALID; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"pending\", {\n            /**\n             * A control is `pending` when its `status === PENDING`.\n             *\n             * In order to have this status, the control must be in the\n             * middle of conducting a validation check.\n             */\n            get: function () { return this._status == PENDING; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"disabled\", {\n            /**\n             * A control is `disabled` when its `status === DISABLED`.\n             *\n             * Disabled controls are exempt from validation checks and\n             * are not included in the aggregate value of their ancestor\n             * controls.\n             */\n            get: function () { return this._status === DISABLED; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"enabled\", {\n            /**\n             * A control is `enabled` as long as its `status !== DISABLED`.\n             *\n             * In other words, it has a status of `VALID`, `INVALID`, or\n             * `PENDING`.\n             */\n            get: function () { return this._status !== DISABLED; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"errors\", {\n            /**\n             * Returns any errors generated by failing validation. If there\n             * are no errors, it will return null.\n             */\n            get: function () { return this._errors; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"pristine\", {\n            /**\n             * A control is `pristine` if the user has not yet changed\n             * the value in the UI.\n             *\n             * Note that programmatic changes to a control's value will\n             * *not* mark it dirty.\n             */\n            get: function () { return this._pristine; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"dirty\", {\n            /**\n             * A control is `dirty` if the user has changed the value\n             * in the UI.\n             *\n             * Note that programmatic changes to a control's value will\n             * *not* mark it dirty.\n             */\n            get: function () { return !this.pristine; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"touched\", {\n            /**\n            * A control is marked `touched` once the user has triggered\n            * a `blur` event on it.\n            */\n            get: function () { return this._touched; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"untouched\", {\n            /**\n             * A control is `untouched` if the user has not yet triggered\n             * a `blur` event on it.\n             */\n            get: function () { return !this._touched; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"valueChanges\", {\n            /**\n             * Emits an event every time the value of the control changes, in\n             * the UI or programmatically.\n             */\n            get: function () { return this._valueChanges; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(AbstractControl.prototype, \"statusChanges\", {\n            /**\n             * Emits an event every time the validation status of the control\n             * is re-calculated.\n             */\n            get: function () { return this._statusChanges; },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * Sets the synchronous validators that are active on this control.  Calling\n         * this will overwrite any existing sync validators.\n         */\n        AbstractControl.prototype.setValidators = function (newValidator) {\n            this.validator = coerceToValidator(newValidator);\n        };\n        /**\n         * Sets the async validators that are active on this control. Calling this\n         * will overwrite any existing async validators.\n         */\n        AbstractControl.prototype.setAsyncValidators = function (newValidator) {\n            this.asyncValidator = coerceToAsyncValidator(newValidator);\n        };\n        /**\n         * Empties out the sync validator list.\n         */\n        AbstractControl.prototype.clearValidators = function () { this.validator = null; };\n        /**\n         * Empties out the async validator list.\n         */\n        AbstractControl.prototype.clearAsyncValidators = function () { this.asyncValidator = null; };\n        /**\n         * Marks the control as `touched`.\n         *\n         * This will also mark all direct ancestors as `touched` to maintain\n         * the model.\n         */\n        AbstractControl.prototype.markAsTouched = function (_a) {\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._touched = true;\n            if (this._parent && !onlySelf) {\n                this._parent.markAsTouched({ onlySelf: onlySelf });\n            }\n        };\n        /**\n         * Marks the control as `untouched`.\n         *\n         * If the control has any children, it will also mark all children as `untouched`\n         * to maintain the model, and re-calculate the `touched` status of all parent\n         * controls.\n         */\n        AbstractControl.prototype.markAsUntouched = function (_a) {\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._touched = false;\n            this._forEachChild(function (control) { control.markAsUntouched({ onlySelf: true }); });\n            if (this._parent && !onlySelf) {\n                this._parent._updateTouched({ onlySelf: onlySelf });\n            }\n        };\n        /**\n         * Marks the control as `dirty`.\n         *\n         * This will also mark all direct ancestors as `dirty` to maintain\n         * the model.\n         */\n        AbstractControl.prototype.markAsDirty = function (_a) {\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._pristine = false;\n            if (this._parent && !onlySelf) {\n                this._parent.markAsDirty({ onlySelf: onlySelf });\n            }\n        };\n        /**\n         * Marks the control as `pristine`.\n         *\n         * If the control has any children, it will also mark all children as `pristine`\n         * to maintain the model, and re-calculate the `pristine` status of all parent\n         * controls.\n         */\n        AbstractControl.prototype.markAsPristine = function (_a) {\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._pristine = true;\n            this._forEachChild(function (control) { control.markAsPristine({ onlySelf: true }); });\n            if (this._parent && !onlySelf) {\n                this._parent._updatePristine({ onlySelf: onlySelf });\n            }\n        };\n        /**\n         * Marks the control as `pending`.\n         */\n        AbstractControl.prototype.markAsPending = function (_a) {\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._status = PENDING;\n            if (this._parent && !onlySelf) {\n                this._parent.markAsPending({ onlySelf: onlySelf });\n            }\n        };\n        /**\n         * Disables the control. This means the control will be exempt from validation checks and\n         * excluded from the aggregate value of any parent. Its status is `DISABLED`.\n         *\n         * If the control has children, all children will be disabled to maintain the model.\n         */\n        AbstractControl.prototype.disable = function (_a) {\n            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;\n            this._status = DISABLED;\n            this._errors = null;\n            this._forEachChild(function (control) { control.disable({ onlySelf: true }); });\n            this._updateValue();\n            if (emitEvent !== false) {\n                this._valueChanges.emit(this._value);\n                this._statusChanges.emit(this._status);\n            }\n            this._updateAncestors(onlySelf);\n            this._onDisabledChange.forEach(function (changeFn) { return changeFn(true); });\n        };\n        /**\n         * Enables the control. This means the control will be included in validation checks and\n         * the aggregate value of its parent. Its status is re-calculated based on its value and\n         * its validators.\n         *\n         * If the control has children, all children will be enabled.\n         */\n        AbstractControl.prototype.enable = function (_a) {\n            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;\n            this._status = VALID;\n            this._forEachChild(function (control) { control.enable({ onlySelf: true }); });\n            this.updateValueAndValidity({ onlySelf: true, emitEvent: emitEvent });\n            this._updateAncestors(onlySelf);\n            this._onDisabledChange.forEach(function (changeFn) { return changeFn(false); });\n        };\n        AbstractControl.prototype._updateAncestors = function (onlySelf) {\n            if (this._parent && !onlySelf) {\n                this._parent.updateValueAndValidity();\n                this._parent._updatePristine();\n                this._parent._updateTouched();\n            }\n        };\n        AbstractControl.prototype.setParent = function (parent) { this._parent = parent; };\n        /**\n         * Re-calculates the value and validation status of the control.\n         *\n         * By default, it will also update the value and validity of its ancestors.\n         */\n        AbstractControl.prototype.updateValueAndValidity = function (_a) {\n            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent;\n            this._setInitialStatus();\n            this._updateValue();\n            if (this.enabled) {\n                this._errors = this._runValidator();\n                this._status = this._calculateStatus();\n                if (this._status === VALID || this._status === PENDING) {\n                    this._runAsyncValidator(emitEvent);\n                }\n            }\n            if (emitEvent !== false) {\n                this._valueChanges.emit(this._value);\n                this._statusChanges.emit(this._status);\n            }\n            if (this._parent && !onlySelf) {\n                this._parent.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });\n            }\n        };\n        /** @internal */\n        AbstractControl.prototype._updateTreeValidity = function (_a) {\n            var emitEvent = (_a === void 0 ? { emitEvent: true } : _a).emitEvent;\n            this._forEachChild(function (ctrl) { return ctrl._updateTreeValidity({ emitEvent: emitEvent }); });\n            this.updateValueAndValidity({ onlySelf: true, emitEvent: emitEvent });\n        };\n        AbstractControl.prototype._setInitialStatus = function () { this._status = this._allControlsDisabled() ? DISABLED : VALID; };\n        AbstractControl.prototype._runValidator = function () {\n            return this.validator ? this.validator(this) : null;\n        };\n        AbstractControl.prototype._runAsyncValidator = function (emitEvent) {\n            var _this = this;\n            if (this.asyncValidator) {\n                this._status = PENDING;\n                this._cancelExistingSubscription();\n                var obs = toObservable(this.asyncValidator(this));\n                this._asyncValidationSubscription =\n                    obs.subscribe({ next: function (res) { return _this.setErrors(res, { emitEvent: emitEvent }); } });\n            }\n        };\n        AbstractControl.prototype._cancelExistingSubscription = function () {\n            if (this._asyncValidationSubscription) {\n                this._asyncValidationSubscription.unsubscribe();\n            }\n        };\n        /**\n         * Sets errors on a form control.\n         *\n         * This is used when validations are run manually by the user, rather than automatically.\n         *\n         * Calling `setErrors` will also update the validity of the parent control.\n         *\n         * ### Example\n         *\n         * ```\n         * const login = new FormControl(\"someLogin\");\n         * login.setErrors({\n         *   \"notUnique\": true\n         * });\n         *\n         * expect(login.valid).toEqual(false);\n         * expect(login.errors).toEqual({\"notUnique\": true});\n         *\n         * login.setValue(\"someOtherLogin\");\n         *\n         * expect(login.valid).toEqual(true);\n         * ```\n         */\n        AbstractControl.prototype.setErrors = function (errors, _a) {\n            var emitEvent = (_a === void 0 ? {} : _a).emitEvent;\n            this._errors = errors;\n            this._updateControlsErrors(emitEvent !== false);\n        };\n        /**\n         * Retrieves a child control given the control's name or path.\n         *\n         * Paths can be passed in as an array or a string delimited by a dot.\n         *\n         * To get a control nested within a `person` sub-group:\n         *\n         * * `this.form.get('person.name');`\n         *\n         * -OR-\n         *\n         * * `this.form.get(['person', 'name']);`\n         */\n        AbstractControl.prototype.get = function (path) { return _find(this, path, '.'); };\n        /**\n         * Returns true if the control with the given path has the error specified. Otherwise\n         * returns null or undefined.\n         *\n         * If no path is given, it checks for the error on the present control.\n         */\n        AbstractControl.prototype.getError = function (errorCode, path) {\n            if (path === void 0) { path = null; }\n            var control = path ? this.get(path) : this;\n            return control && control._errors ? control._errors[errorCode] : null;\n        };\n        /**\n         * Returns true if the control with the given path has the error specified. Otherwise\n         * returns false.\n         *\n         * If no path is given, it checks for the error on the present control.\n         */\n        AbstractControl.prototype.hasError = function (errorCode, path) {\n            if (path === void 0) { path = null; }\n            return !!this.getError(errorCode, path);\n        };\n        Object.defineProperty(AbstractControl.prototype, \"root\", {\n            /**\n             * Retrieves the top-level ancestor of this control.\n             */\n            get: function () {\n                var x = this;\n                while (x._parent) {\n                    x = x._parent;\n                }\n                return x;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** @internal */\n        AbstractControl.prototype._updateControlsErrors = function (emitEvent) {\n            this._status = this._calculateStatus();\n            if (emitEvent) {\n                this._statusChanges.emit(this._status);\n            }\n            if (this._parent) {\n                this._parent._updateControlsErrors(emitEvent);\n            }\n        };\n        /** @internal */\n        AbstractControl.prototype._initObservables = function () {\n            this._valueChanges = new EventEmitter();\n            this._statusChanges = new EventEmitter();\n        };\n        AbstractControl.prototype._calculateStatus = function () {\n            if (this._allControlsDisabled())\n                return DISABLED;\n            if (this._errors)\n                return INVALID;\n            if (this._anyControlsHaveStatus(PENDING))\n                return PENDING;\n            if (this._anyControlsHaveStatus(INVALID))\n                return INVALID;\n            return VALID;\n        };\n        /** @internal */\n        AbstractControl.prototype._anyControlsHaveStatus = function (status) {\n            return this._anyControls(function (control) { return control.status === status; });\n        };\n        /** @internal */\n        AbstractControl.prototype._anyControlsDirty = function () {\n            return this._anyControls(function (control) { return control.dirty; });\n        };\n        /** @internal */\n        AbstractControl.prototype._anyControlsTouched = function () {\n            return this._anyControls(function (control) { return control.touched; });\n        };\n        /** @internal */\n        AbstractControl.prototype._updatePristine = function (_a) {\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._pristine = !this._anyControlsDirty();\n            if (this._parent && !onlySelf) {\n                this._parent._updatePristine({ onlySelf: onlySelf });\n            }\n        };\n        /** @internal */\n        AbstractControl.prototype._updateTouched = function (_a) {\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._touched = this._anyControlsTouched();\n            if (this._parent && !onlySelf) {\n                this._parent._updateTouched({ onlySelf: onlySelf });\n            }\n        };\n        /** @internal */\n        AbstractControl.prototype._isBoxedValue = function (formState) {\n            return typeof formState === 'object' && formState !== null &&\n                Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;\n        };\n        /** @internal */\n        AbstractControl.prototype._registerOnCollectionChange = function (fn) { this._onCollectionChange = fn; };\n        return AbstractControl;\n    }());\n    /**\n     * @whatItDoes Tracks the value and validation status of an individual form control.\n     *\n     * It is one of the three fundamental building blocks of Angular forms, along with\n     * {@link FormGroup} and {@link FormArray}.\n     *\n     * @howToUse\n     *\n     * When instantiating a {@link FormControl}, you can pass in an initial value as the\n     * first argument. Example:\n     *\n     * ```ts\n     * const ctrl = new FormControl('some value');\n     * console.log(ctrl.value);     // 'some value'\n     *```\n     *\n     * You can also initialize the control with a form state object on instantiation,\n     * which includes both the value and whether or not the control is disabled.\n     * You can't use the value key without the disabled key; both are required\n     * to use this way of initialization.\n     *\n     * ```ts\n     * const ctrl = new FormControl({value: 'n/a', disabled: true});\n     * console.log(ctrl.value);     // 'n/a'\n     * console.log(ctrl.status);   // 'DISABLED'\n     * ```\n     *\n     * To include a sync validator (or an array of sync validators) with the control,\n     * pass it in as the second argument. Async validators are also supported, but\n     * have to be passed in separately as the third arg.\n     *\n     * ```ts\n     * const ctrl = new FormControl('', Validators.required);\n     * console.log(ctrl.value);     // ''\n     * console.log(ctrl.status);   // 'INVALID'\n     * ```\n     *\n     * See its superclass, {@link AbstractControl}, for more properties and methods.\n     *\n     * * **npm package**: `@angular/forms`\n     *\n     * @stable\n     */\n    var FormControl = (function (_super) {\n        __extends$6(FormControl, _super);\n        function FormControl(formState, validator, asyncValidator) {\n            if (formState === void 0) { formState = null; }\n            if (validator === void 0) { validator = null; }\n            if (asyncValidator === void 0) { asyncValidator = null; }\n            _super.call(this, coerceToValidator(validator), coerceToAsyncValidator(asyncValidator));\n            /** @internal */\n            this._onChange = [];\n            this._applyFormState(formState);\n            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });\n            this._initObservables();\n        }\n        /**\n         * Set the value of the form control to `value`.\n         *\n         * If `onlySelf` is `true`, this change will only affect the validation of this `FormControl`\n         * and not its parent component. This defaults to false.\n         *\n         * If `emitEvent` is `true`, this\n         * change will cause a `valueChanges` event on the `FormControl` to be emitted. This defaults\n         * to true (as it falls through to `updateValueAndValidity`).\n         *\n         * If `emitModelToViewChange` is `true`, the view will be notified about the new value\n         * via an `onChange` event. This is the default behavior if `emitModelToViewChange` is not\n         * specified.\n         *\n         * If `emitViewToModelChange` is `true`, an ngModelChange event will be fired to update the\n         * model.  This is the default behavior if `emitViewToModelChange` is not specified.\n         */\n        FormControl.prototype.setValue = function (value, _a) {\n            var _this = this;\n            var _b = _a === void 0 ? {} : _a, onlySelf = _b.onlySelf, emitEvent = _b.emitEvent, emitModelToViewChange = _b.emitModelToViewChange, emitViewToModelChange = _b.emitViewToModelChange;\n            this._value = value;\n            if (this._onChange.length && emitModelToViewChange !== false) {\n                this._onChange.forEach(function (changeFn) { return changeFn(_this._value, emitViewToModelChange !== false); });\n            }\n            this.updateValueAndValidity({ onlySelf: onlySelf, emitEvent: emitEvent });\n        };\n        /**\n         * Patches the value of a control.\n         *\n         * This function is functionally the same as {@link FormControl.setValue} at this level.\n         * It exists for symmetry with {@link FormGroup.patchValue} on `FormGroups` and `FormArrays`,\n         * where it does behave differently.\n         */\n        FormControl.prototype.patchValue = function (value, options) {\n            if (options === void 0) { options = {}; }\n            this.setValue(value, options);\n        };\n        /**\n         * Resets the form control. This means by default:\n         *\n         * * it is marked as `pristine`\n         * * it is marked as `untouched`\n         * * value is set to null\n         *\n         * You can also reset to a specific form state by passing through a standalone\n         * value or a form state object that contains both a value and a disabled state\n         * (these are the only two properties that cannot be calculated).\n         *\n         * Ex:\n         *\n         * ```ts\n         * this.control.reset('Nancy');\n         *\n         * console.log(this.control.value);  // 'Nancy'\n         * ```\n         *\n         * OR\n         *\n         * ```\n         * this.control.reset({value: 'Nancy', disabled: true});\n         *\n         * console.log(this.control.value);  // 'Nancy'\n         * console.log(this.control.status);  // 'DISABLED'\n         * ```\n         */\n        FormControl.prototype.reset = function (formState, _a) {\n            if (formState === void 0) { formState = null; }\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._applyFormState(formState);\n            this.markAsPristine({ onlySelf: onlySelf });\n            this.markAsUntouched({ onlySelf: onlySelf });\n            this.setValue(this._value, { onlySelf: onlySelf });\n        };\n        /**\n         * @internal\n         */\n        FormControl.prototype._updateValue = function () { };\n        /**\n         * @internal\n         */\n        FormControl.prototype._anyControls = function (condition) { return false; };\n        /**\n         * @internal\n         */\n        FormControl.prototype._allControlsDisabled = function () { return this.disabled; };\n        /**\n         * Register a listener for change events.\n         */\n        FormControl.prototype.registerOnChange = function (fn) { this._onChange.push(fn); };\n        /**\n         * @internal\n         */\n        FormControl.prototype._clearChangeFns = function () {\n            this._onChange = [];\n            this._onDisabledChange = [];\n            this._onCollectionChange = function () { };\n        };\n        /**\n         * Register a listener for disabled events.\n         */\n        FormControl.prototype.registerOnDisabledChange = function (fn) {\n            this._onDisabledChange.push(fn);\n        };\n        /**\n         * @internal\n         */\n        FormControl.prototype._forEachChild = function (cb) { };\n        FormControl.prototype._applyFormState = function (formState) {\n            if (this._isBoxedValue(formState)) {\n                this._value = formState.value;\n                formState.disabled ? this.disable({ onlySelf: true, emitEvent: false }) :\n                    this.enable({ onlySelf: true, emitEvent: false });\n            }\n            else {\n                this._value = formState;\n            }\n        };\n        return FormControl;\n    }(AbstractControl));\n    /**\n     * @whatItDoes Tracks the value and validity state of a group of {@link FormControl}\n     * instances.\n     *\n     * A `FormGroup` aggregates the values of each child {@link FormControl} into one object,\n     * with each control name as the key.  It calculates its status by reducing the statuses\n     * of its children. For example, if one of the controls in a group is invalid, the entire\n     * group becomes invalid.\n     *\n     * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,\n     * along with {@link FormControl} and {@link FormArray}.\n     *\n     * @howToUse\n     *\n     * When instantiating a {@link FormGroup}, pass in a collection of child controls as the first\n     * argument. The key for each child will be the name under which it is registered.\n     *\n     * ### Example\n     *\n     * ```\n     * const form = new FormGroup({\n     *   first: new FormControl('Nancy', Validators.minLength(2)),\n     *   last: new FormControl('Drew'),\n     * });\n     *\n     * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}\n     * console.log(form.status);  // 'VALID'\n     * ```\n     *\n     * You can also include group-level validators as the second arg, or group-level async\n     * validators as the third arg. These come in handy when you want to perform validation\n     * that considers the value of more than one child control.\n     *\n     * ### Example\n     *\n     * ```\n     * const form = new FormGroup({\n     *   password: new FormControl('', Validators.minLength(2)),\n     *   passwordConfirm: new FormControl('', Validators.minLength(2)),\n     * }, passwordMatchValidator);\n     *\n     *\n     * function passwordMatchValidator(g: FormGroup) {\n     *    return g.get('password').value === g.get('passwordConfirm').value\n     *       ? null : {'mismatch': true};\n     * }\n     * ```\n     *\n     * * **npm package**: `@angular/forms`\n     *\n     * @stable\n     */\n    var FormGroup = (function (_super) {\n        __extends$6(FormGroup, _super);\n        function FormGroup(controls, validator, asyncValidator) {\n            if (validator === void 0) { validator = null; }\n            if (asyncValidator === void 0) { asyncValidator = null; }\n            _super.call(this, validator, asyncValidator);\n            this.controls = controls;\n            this._initObservables();\n            this._setUpControls();\n            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });\n        }\n        /**\n         * Registers a control with the group's list of controls.\n         *\n         * This method does not update value or validity of the control, so for\n         * most cases you'll want to use {@link FormGroup.addControl} instead.\n         */\n        FormGroup.prototype.registerControl = function (name, control) {\n            if (this.controls[name])\n                return this.controls[name];\n            this.controls[name] = control;\n            control.setParent(this);\n            control._registerOnCollectionChange(this._onCollectionChange);\n            return control;\n        };\n        /**\n         * Add a control to this group.\n         */\n        FormGroup.prototype.addControl = function (name, control) {\n            this.registerControl(name, control);\n            this.updateValueAndValidity();\n            this._onCollectionChange();\n        };\n        /**\n         * Remove a control from this group.\n         */\n        FormGroup.prototype.removeControl = function (name) {\n            if (this.controls[name])\n                this.controls[name]._registerOnCollectionChange(function () { });\n            delete (this.controls[name]);\n            this.updateValueAndValidity();\n            this._onCollectionChange();\n        };\n        /**\n         * Replace an existing control.\n         */\n        FormGroup.prototype.setControl = function (name, control) {\n            if (this.controls[name])\n                this.controls[name]._registerOnCollectionChange(function () { });\n            delete (this.controls[name]);\n            if (control)\n                this.registerControl(name, control);\n            this.updateValueAndValidity();\n            this._onCollectionChange();\n        };\n        /**\n         * Check whether there is an enabled control with the given name in the group.\n         *\n         * It will return false for disabled controls. If you'd like to check for\n         * existence in the group only, use {@link AbstractControl.get} instead.\n         */\n        FormGroup.prototype.contains = function (controlName) {\n            return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;\n        };\n        /**\n         *  Sets the value of the {@link FormGroup}. It accepts an object that matches\n         *  the structure of the group, with control names as keys.\n         *\n         * This method performs strict checks, so it will throw an error if you try\n         * to set the value of a control that doesn't exist or if you exclude the\n         * value of a control.\n         *\n         *  ### Example\n         *\n         *  ```\n         *  const form = new FormGroup({\n         *     first: new FormControl(),\n         *     last: new FormControl()\n         *  });\n         *  console.log(form.value);   // {first: null, last: null}\n         *\n         *  form.setValue({first: 'Nancy', last: 'Drew'});\n         *  console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n         *\n         *  ```\n         */\n        FormGroup.prototype.setValue = function (value, _a) {\n            var _this = this;\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._checkAllValuesPresent(value);\n            Object.keys(value).forEach(function (name) {\n                _this._throwIfControlMissing(name);\n                _this.controls[name].setValue(value[name], { onlySelf: true });\n            });\n            this.updateValueAndValidity({ onlySelf: onlySelf });\n        };\n        /**\n         *  Patches the value of the {@link FormGroup}. It accepts an object with control\n         *  names as keys, and will do its best to match the values to the correct controls\n         *  in the group.\n         *\n         *  It accepts both super-sets and sub-sets of the group without throwing an error.\n         *\n         *  ### Example\n         *\n         *  ```\n         *  const form = new FormGroup({\n         *     first: new FormControl(),\n         *     last: new FormControl()\n         *  });\n         *  console.log(form.value);   // {first: null, last: null}\n         *\n         *  form.patchValue({first: 'Nancy'});\n         *  console.log(form.value);   // {first: 'Nancy', last: null}\n         *\n         *  ```\n         */\n        FormGroup.prototype.patchValue = function (value, _a) {\n            var _this = this;\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            Object.keys(value).forEach(function (name) {\n                if (_this.controls[name]) {\n                    _this.controls[name].patchValue(value[name], { onlySelf: true });\n                }\n            });\n            this.updateValueAndValidity({ onlySelf: onlySelf });\n        };\n        /**\n         * Resets the {@link FormGroup}. This means by default:\n         *\n         * * The group and all descendants are marked `pristine`\n         * * The group and all descendants are marked `untouched`\n         * * The value of all descendants will be null or null maps\n         *\n         * You can also reset to a specific form state by passing in a map of states\n         * that matches the structure of your form, with control names as keys. The state\n         * can be a standalone value or a form state object with both a value and a disabled\n         * status.\n         *\n         * ### Example\n         *\n         * ```ts\n         * this.form.reset({first: 'name', last: 'last name'});\n         *\n         * console.log(this.form.value);  // {first: 'name', last: 'last name'}\n         * ```\n         *\n         * - OR -\n         *\n         * ```\n         * this.form.reset({\n         *   first: {value: 'name', disabled: true},\n         *   last: 'last'\n         * });\n         *\n         * console.log(this.form.value);  // {first: 'name', last: 'last name'}\n         * console.log(this.form.get('first').status);  // 'DISABLED'\n         * ```\n         */\n        FormGroup.prototype.reset = function (value, _a) {\n            if (value === void 0) { value = {}; }\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._forEachChild(function (control, name) {\n                control.reset(value[name], { onlySelf: true });\n            });\n            this.updateValueAndValidity({ onlySelf: onlySelf });\n            this._updatePristine({ onlySelf: onlySelf });\n            this._updateTouched({ onlySelf: onlySelf });\n        };\n        /**\n         * The aggregate value of the {@link FormGroup}, including any disabled controls.\n         *\n         * If you'd like to include all values regardless of disabled status, use this method.\n         * Otherwise, the `value` property is the best way to get the value of the group.\n         */\n        FormGroup.prototype.getRawValue = function () {\n            return this._reduceChildren({}, function (acc, control, name) {\n                acc[name] = control.value;\n                return acc;\n            });\n        };\n        /** @internal */\n        FormGroup.prototype._throwIfControlMissing = function (name) {\n            if (!Object.keys(this.controls).length) {\n                throw new Error(\"\\n        There are no form controls registered with this group yet.  If you're using ngModel,\\n        you may want to check next tick (e.g. use setTimeout).\\n      \");\n            }\n            if (!this.controls[name]) {\n                throw new Error(\"Cannot find form control with name: \" + name + \".\");\n            }\n        };\n        /** @internal */\n        FormGroup.prototype._forEachChild = function (cb) {\n            var _this = this;\n            Object.keys(this.controls).forEach(function (k) { return cb(_this.controls[k], k); });\n        };\n        /** @internal */\n        FormGroup.prototype._setUpControls = function () {\n            var _this = this;\n            this._forEachChild(function (control) {\n                control.setParent(_this);\n                control._registerOnCollectionChange(_this._onCollectionChange);\n            });\n        };\n        /** @internal */\n        FormGroup.prototype._updateValue = function () { this._value = this._reduceValue(); };\n        /** @internal */\n        FormGroup.prototype._anyControls = function (condition) {\n            var _this = this;\n            var res = false;\n            this._forEachChild(function (control, name) {\n                res = res || (_this.contains(name) && condition(control));\n            });\n            return res;\n        };\n        /** @internal */\n        FormGroup.prototype._reduceValue = function () {\n            var _this = this;\n            return this._reduceChildren({}, function (acc, control, name) {\n                if (control.enabled || _this.disabled) {\n                    acc[name] = control.value;\n                }\n                return acc;\n            });\n        };\n        /** @internal */\n        FormGroup.prototype._reduceChildren = function (initValue, fn) {\n            var res = initValue;\n            this._forEachChild(function (control, name) { res = fn(res, control, name); });\n            return res;\n        };\n        /** @internal */\n        FormGroup.prototype._allControlsDisabled = function () {\n            for (var _i = 0, _a = Object.keys(this.controls); _i < _a.length; _i++) {\n                var controlName = _a[_i];\n                if (this.controls[controlName].enabled) {\n                    return false;\n                }\n            }\n            return Object.keys(this.controls).length > 0 || this.disabled;\n        };\n        /** @internal */\n        FormGroup.prototype._checkAllValuesPresent = function (value) {\n            this._forEachChild(function (control, name) {\n                if (value[name] === undefined) {\n                    throw new Error(\"Must supply a value for form control with name: '\" + name + \"'.\");\n                }\n            });\n        };\n        return FormGroup;\n    }(AbstractControl));\n    /**\n     * @whatItDoes Tracks the value and validity state of an array of {@link FormControl}\n     * instances.\n     *\n     * A `FormArray` aggregates the values of each child {@link FormControl} into an array.\n     * It calculates its status by reducing the statuses of its children. For example, if one of\n     * the controls in a `FormArray` is invalid, the entire array becomes invalid.\n     *\n     * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,\n     * along with {@link FormControl} and {@link FormGroup}.\n     *\n     * @howToUse\n     *\n     * When instantiating a {@link FormArray}, pass in an array of child controls as the first\n     * argument.\n     *\n     * ### Example\n     *\n     * ```\n     * const arr = new FormArray([\n     *   new FormControl('Nancy', Validators.minLength(2)),\n     *   new FormControl('Drew'),\n     * ]);\n     *\n     * console.log(arr.value);   // ['Nancy', 'Drew']\n     * console.log(arr.status);  // 'VALID'\n     * ```\n     *\n     * You can also include array-level validators as the second arg, or array-level async\n     * validators as the third arg. These come in handy when you want to perform validation\n     * that considers the value of more than one child control.\n     *\n     * ### Adding or removing controls\n     *\n     * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods\n     * in `FormArray` itself. These methods ensure the controls are properly tracked in the\n     * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate\n     * the `FormArray` directly, as that will result in strange and unexpected behavior such\n     * as broken change detection.\n     *\n     * * **npm package**: `@angular/forms`\n     *\n     * @stable\n     */\n    var FormArray = (function (_super) {\n        __extends$6(FormArray, _super);\n        function FormArray(controls, validator, asyncValidator) {\n            if (validator === void 0) { validator = null; }\n            if (asyncValidator === void 0) { asyncValidator = null; }\n            _super.call(this, validator, asyncValidator);\n            this.controls = controls;\n            this._initObservables();\n            this._setUpControls();\n            this.updateValueAndValidity({ onlySelf: true, emitEvent: false });\n        }\n        /**\n         * Get the {@link AbstractControl} at the given `index` in the array.\n         */\n        FormArray.prototype.at = function (index) { return this.controls[index]; };\n        /**\n         * Insert a new {@link AbstractControl} at the end of the array.\n         */\n        FormArray.prototype.push = function (control) {\n            this.controls.push(control);\n            this._registerControl(control);\n            this.updateValueAndValidity();\n            this._onCollectionChange();\n        };\n        /**\n         * Insert a new {@link AbstractControl} at the given `index` in the array.\n         */\n        FormArray.prototype.insert = function (index, control) {\n            this.controls.splice(index, 0, control);\n            this._registerControl(control);\n            this.updateValueAndValidity();\n            this._onCollectionChange();\n        };\n        /**\n         * Remove the control at the given `index` in the array.\n         */\n        FormArray.prototype.removeAt = function (index) {\n            if (this.controls[index])\n                this.controls[index]._registerOnCollectionChange(function () { });\n            this.controls.splice(index, 1);\n            this.updateValueAndValidity();\n            this._onCollectionChange();\n        };\n        /**\n         * Replace an existing control.\n         */\n        FormArray.prototype.setControl = function (index, control) {\n            if (this.controls[index])\n                this.controls[index]._registerOnCollectionChange(function () { });\n            this.controls.splice(index, 1);\n            if (control) {\n                this.controls.splice(index, 0, control);\n                this._registerControl(control);\n            }\n            this.updateValueAndValidity();\n            this._onCollectionChange();\n        };\n        Object.defineProperty(FormArray.prototype, \"length\", {\n            /**\n             * Length of the control array.\n             */\n            get: function () { return this.controls.length; },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         *  Sets the value of the {@link FormArray}. It accepts an array that matches\n         *  the structure of the control.\n         *\n         * This method performs strict checks, so it will throw an error if you try\n         * to set the value of a control that doesn't exist or if you exclude the\n         * value of a control.\n         *\n         *  ### Example\n         *\n         *  ```\n         *  const arr = new FormArray([\n         *     new FormControl(),\n         *     new FormControl()\n         *  ]);\n         *  console.log(arr.value);   // [null, null]\n         *\n         *  arr.setValue(['Nancy', 'Drew']);\n         *  console.log(arr.value);   // ['Nancy', 'Drew']\n         *  ```\n         */\n        FormArray.prototype.setValue = function (value, _a) {\n            var _this = this;\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._checkAllValuesPresent(value);\n            value.forEach(function (newValue, index) {\n                _this._throwIfControlMissing(index);\n                _this.at(index).setValue(newValue, { onlySelf: true });\n            });\n            this.updateValueAndValidity({ onlySelf: onlySelf });\n        };\n        /**\n         *  Patches the value of the {@link FormArray}. It accepts an array that matches the\n         *  structure of the control, and will do its best to match the values to the correct\n         *  controls in the group.\n         *\n         *  It accepts both super-sets and sub-sets of the array without throwing an error.\n         *\n         *  ### Example\n         *\n         *  ```\n         *  const arr = new FormArray([\n         *     new FormControl(),\n         *     new FormControl()\n         *  ]);\n         *  console.log(arr.value);   // [null, null]\n         *\n         *  arr.patchValue(['Nancy']);\n         *  console.log(arr.value);   // ['Nancy', null]\n         *  ```\n         */\n        FormArray.prototype.patchValue = function (value, _a) {\n            var _this = this;\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            value.forEach(function (newValue, index) {\n                if (_this.at(index)) {\n                    _this.at(index).patchValue(newValue, { onlySelf: true });\n                }\n            });\n            this.updateValueAndValidity({ onlySelf: onlySelf });\n        };\n        /**\n         * Resets the {@link FormArray}. This means by default:\n         *\n         * * The array and all descendants are marked `pristine`\n         * * The array and all descendants are marked `untouched`\n         * * The value of all descendants will be null or null maps\n         *\n         * You can also reset to a specific form state by passing in an array of states\n         * that matches the structure of the control. The state can be a standalone value\n         * or a form state object with both a value and a disabled status.\n         *\n         * ### Example\n         *\n         * ```ts\n         * this.arr.reset(['name', 'last name']);\n         *\n         * console.log(this.arr.value);  // ['name', 'last name']\n         * ```\n         *\n         * - OR -\n         *\n         * ```\n         * this.arr.reset([\n         *   {value: 'name', disabled: true},\n         *   'last'\n         * ]);\n         *\n         * console.log(this.arr.value);  // ['name', 'last name']\n         * console.log(this.arr.get(0).status);  // 'DISABLED'\n         * ```\n         */\n        FormArray.prototype.reset = function (value, _a) {\n            if (value === void 0) { value = []; }\n            var onlySelf = (_a === void 0 ? {} : _a).onlySelf;\n            this._forEachChild(function (control, index) {\n                control.reset(value[index], { onlySelf: true });\n            });\n            this.updateValueAndValidity({ onlySelf: onlySelf });\n            this._updatePristine({ onlySelf: onlySelf });\n            this._updateTouched({ onlySelf: onlySelf });\n        };\n        /**\n         * The aggregate value of the array, including any disabled controls.\n         *\n         * If you'd like to include all values regardless of disabled status, use this method.\n         * Otherwise, the `value` property is the best way to get the value of the array.\n         */\n        FormArray.prototype.getRawValue = function () { return this.controls.map(function (control) { return control.value; }); };\n        /** @internal */\n        FormArray.prototype._throwIfControlMissing = function (index) {\n            if (!this.controls.length) {\n                throw new Error(\"\\n        There are no form controls registered with this array yet.  If you're using ngModel,\\n        you may want to check next tick (e.g. use setTimeout).\\n      \");\n            }\n            if (!this.at(index)) {\n                throw new Error(\"Cannot find form control at index \" + index);\n            }\n        };\n        /** @internal */\n        FormArray.prototype._forEachChild = function (cb) {\n            this.controls.forEach(function (control, index) { cb(control, index); });\n        };\n        /** @internal */\n        FormArray.prototype._updateValue = function () {\n            var _this = this;\n            this._value = this.controls.filter(function (control) { return control.enabled || _this.disabled; })\n                .map(function (control) { return control.value; });\n        };\n        /** @internal */\n        FormArray.prototype._anyControls = function (condition) {\n            return this.controls.some(function (control) { return control.enabled && condition(control); });\n        };\n        /** @internal */\n        FormArray.prototype._setUpControls = function () {\n            var _this = this;\n            this._forEachChild(function (control) { return _this._registerControl(control); });\n        };\n        /** @internal */\n        FormArray.prototype._checkAllValuesPresent = function (value) {\n            this._forEachChild(function (control, i) {\n                if (value[i] === undefined) {\n                    throw new Error(\"Must supply a value for form control at index: \" + i + \".\");\n                }\n            });\n        };\n        /** @internal */\n        FormArray.prototype._allControlsDisabled = function () {\n            for (var _i = 0, _a = this.controls; _i < _a.length; _i++) {\n                var control = _a[_i];\n                if (control.enabled)\n                    return false;\n            }\n            return this.controls.length > 0 || this.disabled;\n        };\n        FormArray.prototype._registerControl = function (control) {\n            control.setParent(this);\n            control._registerOnCollectionChange(this._onCollectionChange);\n        };\n        return FormArray;\n    }(AbstractControl));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$4 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var formDirectiveProvider = {\n        provide: ControlContainer,\n        useExisting: _angular_core.forwardRef(function () { return NgForm; })\n    };\n    var resolvedPromise = Promise.resolve(null);\n    /**\n     * @whatItDoes Creates a top-level {@link FormGroup} instance and binds it to a form\n     * to track aggregate form value and validation status.\n     *\n     * @howToUse\n     *\n     * As soon as you import the `FormsModule`, this directive becomes active by default on\n     * all `<form>` tags.  You don't need to add a special selector.\n     *\n     * You can export the directive into a local template variable using `ngForm` as the key\n     * (ex: `#myForm=\"ngForm\"`). This is optional, but useful.  Many properties from the underlying\n     * {@link FormGroup} instance are duplicated on the directive itself, so a reference to it\n     * will give you access to the aggregate value and validity status of the form, as well as\n     * user interaction properties like `dirty` and `touched`.\n     *\n     * To register child controls with the form, you'll want to use {@link NgModel} with a\n     * `name` attribute.  You can also use {@link NgModelGroup} if you'd like to create\n     * sub-groups within the form.\n     *\n     * You can listen to the directive's `ngSubmit` event to be notified when the user has\n     * triggered a form submission. The `ngSubmit` event will be emitted with the original form\n     * submission event.\n     *\n     * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}\n     *\n     * * **npm package**: `@angular/forms`\n     *\n     * * **NgModule**: `FormsModule`\n     *\n     *  @stable\n     */\n    var NgForm = (function (_super) {\n        __extends$4(NgForm, _super);\n        function NgForm(validators, asyncValidators) {\n            _super.call(this);\n            this._submitted = false;\n            this.ngSubmit = new EventEmitter();\n            this.form =\n                new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));\n        }\n        Object.defineProperty(NgForm.prototype, \"submitted\", {\n            get: function () { return this._submitted; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgForm.prototype, \"formDirective\", {\n            get: function () { return this; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgForm.prototype, \"control\", {\n            get: function () { return this.form; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgForm.prototype, \"path\", {\n            get: function () { return []; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgForm.prototype, \"controls\", {\n            get: function () { return this.form.controls; },\n            enumerable: true,\n            configurable: true\n        });\n        NgForm.prototype.addControl = function (dir) {\n            var _this = this;\n            resolvedPromise.then(function () {\n                var container = _this._findContainer(dir.path);\n                dir._control = container.registerControl(dir.name, dir.control);\n                setUpControl(dir.control, dir);\n                dir.control.updateValueAndValidity({ emitEvent: false });\n            });\n        };\n        NgForm.prototype.getControl = function (dir) { return this.form.get(dir.path); };\n        NgForm.prototype.removeControl = function (dir) {\n            var _this = this;\n            resolvedPromise.then(function () {\n                var container = _this._findContainer(dir.path);\n                if (isPresent(container)) {\n                    container.removeControl(dir.name);\n                }\n            });\n        };\n        NgForm.prototype.addFormGroup = function (dir) {\n            var _this = this;\n            resolvedPromise.then(function () {\n                var container = _this._findContainer(dir.path);\n                var group = new FormGroup({});\n                setUpFormContainer(group, dir);\n                container.registerControl(dir.name, group);\n                group.updateValueAndValidity({ emitEvent: false });\n            });\n        };\n        NgForm.prototype.removeFormGroup = function (dir) {\n            var _this = this;\n            resolvedPromise.then(function () {\n                var container = _this._findContainer(dir.path);\n                if (isPresent(container)) {\n                    container.removeControl(dir.name);\n                }\n            });\n        };\n        NgForm.prototype.getFormGroup = function (dir) { return this.form.get(dir.path); };\n        NgForm.prototype.updateModel = function (dir, value) {\n            var _this = this;\n            resolvedPromise.then(function () {\n                var ctrl = _this.form.get(dir.path);\n                ctrl.setValue(value);\n            });\n        };\n        NgForm.prototype.setValue = function (value) { this.control.setValue(value); };\n        NgForm.prototype.onSubmit = function ($event) {\n            this._submitted = true;\n            this.ngSubmit.emit($event);\n            return false;\n        };\n        NgForm.prototype.onReset = function () { this.resetForm(); };\n        NgForm.prototype.resetForm = function (value) {\n            if (value === void 0) { value = undefined; }\n            this.form.reset(value);\n            this._submitted = false;\n        };\n        /** @internal */\n        NgForm.prototype._findContainer = function (path) {\n            path.pop();\n            return path.length ? this.form.get(path) : this.form;\n        };\n        NgForm.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: 'form:not([ngNoForm]):not([formGroup]),ngForm,[ngForm]',\n                        providers: [formDirectiveProvider],\n                        host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },\n                        outputs: ['ngSubmit'],\n                        exportAs: 'ngForm'\n                    },] },\n        ];\n        /** @nocollapse */\n        NgForm.ctorParameters = [\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },\n        ];\n        return NgForm;\n    }(ControlContainer));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var Examples = {\n        formControlName: \"\\n    <div [formGroup]=\\\"myGroup\\\">\\n      <input formControlName=\\\"firstName\\\">\\n    </div>\\n\\n    In your class:\\n\\n    this.myGroup = new FormGroup({\\n       firstName: new FormControl()\\n    });\",\n        formGroupName: \"\\n    <div [formGroup]=\\\"myGroup\\\">\\n       <div formGroupName=\\\"person\\\">\\n          <input formControlName=\\\"firstName\\\">\\n       </div>\\n    </div>\\n\\n    In your class:\\n\\n    this.myGroup = new FormGroup({\\n       person: new FormGroup({ firstName: new FormControl() })\\n    });\",\n        formArrayName: \"\\n    <div [formGroup]=\\\"myGroup\\\">\\n      <div formArrayName=\\\"cities\\\">\\n        <div *ngFor=\\\"let city of cityArray.controls; let i=index\\\">\\n          <input [formControlName]=\\\"i\\\">\\n        </div>\\n      </div>\\n    </div>\\n\\n    In your class:\\n\\n    this.cityArray = new FormArray([new FormControl('SF')]);\\n    this.myGroup = new FormGroup({\\n      cities: this.cityArray\\n    });\",\n        ngModelGroup: \"\\n    <form>\\n       <div ngModelGroup=\\\"person\\\">\\n          <input [(ngModel)]=\\\"person.name\\\" name=\\\"firstName\\\">\\n       </div>\\n    </form>\",\n        ngModelWithFormGroup: \"\\n    <div [formGroup]=\\\"myGroup\\\">\\n       <input formControlName=\\\"firstName\\\">\\n       <input [(ngModel)]=\\\"showMoreControls\\\" [ngModelOptions]=\\\"{standalone: true}\\\">\\n    </div>\\n  \"\n    };\n\n    var TemplateDrivenErrors = (function () {\n        function TemplateDrivenErrors() {\n        }\n        TemplateDrivenErrors.modelParentException = function () {\n            throw new Error(\"\\n      ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\\n      formGroup's partner directive \\\"formControlName\\\" instead.  Example:\\n\\n      \" + Examples.formControlName + \"\\n\\n      Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:\\n\\n      Example:\\n\\n      \" + Examples.ngModelWithFormGroup);\n        };\n        TemplateDrivenErrors.formGroupNameException = function () {\n            throw new Error(\"\\n      ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\\n\\n      Option 1: Use formControlName instead of ngModel (reactive strategy):\\n\\n      \" + Examples.formGroupName + \"\\n\\n      Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\\n\\n      \" + Examples.ngModelGroup);\n        };\n        TemplateDrivenErrors.missingNameException = function () {\n            throw new Error(\"If ngModel is used within a form tag, either the name attribute must be set or the form\\n      control must be defined as 'standalone' in ngModelOptions.\\n\\n      Example 1: <input [(ngModel)]=\\\"person.firstName\\\" name=\\\"first\\\">\\n      Example 2: <input [(ngModel)]=\\\"person.firstName\\\" [ngModelOptions]=\\\"{standalone: true}\\\">\");\n        };\n        TemplateDrivenErrors.modelGroupParentException = function () {\n            throw new Error(\"\\n      ngModelGroup cannot be used with a parent formGroup directive.\\n\\n      Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\\n\\n      \" + Examples.formGroupName + \"\\n\\n      Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\\n\\n      \" + Examples.ngModelGroup);\n        };\n        return TemplateDrivenErrors;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$8 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var modelGroupProvider = {\n        provide: ControlContainer,\n        useExisting: _angular_core.forwardRef(function () { return NgModelGroup; })\n    };\n    /**\n     * @whatItDoes Creates and binds a {@link FormGroup} instance to a DOM element.\n     *\n     * @howToUse\n     *\n     * This directive can only be used as a child of {@link NgForm} (or in other words,\n     * within `<form>` tags).\n     *\n     * Use this directive if you'd like to create a sub-group within a form. This can\n     * come in handy if you want to validate a sub-group of your form separately from\n     * the rest of your form, or if some values in your domain model make more sense to\n     * consume together in a nested object.\n     *\n     * Pass in the name you'd like this sub-group to have and it will become the key\n     * for the sub-group in the form's full value. You can also export the directive into\n     * a local template variable using `ngModelGroup` (ex: `#myGroup=\"ngModelGroup\"`).\n     *\n     * {@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}\n     *\n     * * **npm package**: `@angular/forms`\n     *\n     * * **NgModule**: `FormsModule`\n     *\n     * @stable\n     */\n    var NgModelGroup = (function (_super) {\n        __extends$8(NgModelGroup, _super);\n        function NgModelGroup(parent, validators, asyncValidators) {\n            _super.call(this);\n            this._parent = parent;\n            this._validators = validators;\n            this._asyncValidators = asyncValidators;\n        }\n        /** @internal */\n        NgModelGroup.prototype._checkParentType = function () {\n            if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {\n                TemplateDrivenErrors.modelGroupParentException();\n            }\n        };\n        NgModelGroup.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[ngModelGroup]', providers: [modelGroupProvider], exportAs: 'ngModelGroup' },] },\n        ];\n        /** @nocollapse */\n        NgModelGroup.ctorParameters = [\n            { type: ControlContainer, decorators: [{ type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },\n        ];\n        NgModelGroup.propDecorators = {\n            'name': [{ type: _angular_core.Input, args: ['ngModelGroup',] },],\n        };\n        return NgModelGroup;\n    }(AbstractFormGroupDirective));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$7 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var formControlBinding = {\n        provide: NgControl,\n        useExisting: _angular_core.forwardRef(function () { return NgModel; })\n    };\n    var resolvedPromise$1 = Promise.resolve(null);\n    /**\n     * @whatItDoes Creates a {@link FormControl} instance from a domain model and binds it\n     * to a form control element.\n     *\n     * The {@link FormControl} instance will track the value, user interaction, and\n     * validation status of the control and keep the view synced with the model. If used\n     * within a parent form, the directive will also register itself with the form as a child\n     * control.\n     *\n     * @howToUse\n     *\n     * This directive can be used by itself or as part of a larger form. All you need is the\n     * `ngModel` selector to activate it.\n     *\n     * It accepts a domain model as an optional {@link @Input}. If you have a one-way binding\n     * to `ngModel` with `[]` syntax, changing the value of the domain model in the component\n     * class will set the value in the view. If you have a two-way binding with `[()]` syntax\n     * (also known as 'banana-box syntax'), the value in the UI will always be synced back to\n     * the domain model in your class as well.\n     *\n     * If you wish to inspect the properties of the associated {@link FormControl} (like\n     * validity state), you can also export the directive into a local template variable using\n     * `ngModel` as the key (ex: `#myVar=\"ngModel\"`). You can then access the control using the\n     * directive's `control` property, but most properties you'll need (like `valid` and `dirty`)\n     * will fall through to the control anyway, so you can access them directly. You can see a\n     * full list of properties directly available in {@link AbstractControlDirective}.\n     *\n     * The following is an example of a simple standalone control using `ngModel`:\n     *\n     * {@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}\n     *\n     * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute\n     * so that the control can be registered with the parent form under that name.\n     *\n     * It's worth noting that in the context of a parent form, you often can skip one-way or\n     * two-way binding because the parent form will sync the value for you. You can access\n     * its properties by exporting it into a local template variable using `ngForm` (ex:\n     * `#f=\"ngForm\"`). Then you can pass it where it needs to go on submit.\n     *\n     * If you do need to populate initial values into your form, using a one-way binding for\n     * `ngModel` tends to be sufficient as long as you use the exported form's value rather\n     * than the domain model's value on submit.\n     *\n     * Take a look at an example of using `ngModel` within a form:\n     *\n     * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}\n     *\n     * To see `ngModel` examples with different form control types, see:\n     *\n     * * Radio buttons: {@link RadioControlValueAccessor}\n     * * Selects: {@link SelectControlValueAccessor}\n     *\n     * **npm package**: `@angular/forms`\n     *\n     * **NgModule**: `FormsModule`\n     *\n     *  @stable\n     */\n    var NgModel = (function (_super) {\n        __extends$7(NgModel, _super);\n        function NgModel(parent, validators, asyncValidators, valueAccessors) {\n            _super.call(this);\n            /** @internal */\n            this._control = new FormControl();\n            /** @internal */\n            this._registered = false;\n            this.update = new EventEmitter();\n            this._parent = parent;\n            this._rawValidators = validators || [];\n            this._rawAsyncValidators = asyncValidators || [];\n            this.valueAccessor = selectValueAccessor(this, valueAccessors);\n        }\n        NgModel.prototype.ngOnChanges = function (changes) {\n            this._checkForErrors();\n            if (!this._registered)\n                this._setUpControl();\n            if ('isDisabled' in changes) {\n                this._updateDisabled(changes);\n            }\n            if (isPropertyUpdated(changes, this.viewModel)) {\n                this._updateValue(this.model);\n                this.viewModel = this.model;\n            }\n        };\n        NgModel.prototype.ngOnDestroy = function () { this.formDirective && this.formDirective.removeControl(this); };\n        Object.defineProperty(NgModel.prototype, \"control\", {\n            get: function () { return this._control; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgModel.prototype, \"path\", {\n            get: function () {\n                return this._parent ? controlPath(this.name, this._parent) : [this.name];\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgModel.prototype, \"formDirective\", {\n            get: function () { return this._parent ? this._parent.formDirective : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgModel.prototype, \"validator\", {\n            get: function () { return composeValidators(this._rawValidators); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(NgModel.prototype, \"asyncValidator\", {\n            get: function () {\n                return composeAsyncValidators(this._rawAsyncValidators);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        NgModel.prototype.viewToModelUpdate = function (newValue) {\n            this.viewModel = newValue;\n            this.update.emit(newValue);\n        };\n        NgModel.prototype._setUpControl = function () {\n            this._isStandalone() ? this._setUpStandalone() :\n                this.formDirective.addControl(this);\n            this._registered = true;\n        };\n        NgModel.prototype._isStandalone = function () {\n            return !this._parent || (this.options && this.options.standalone);\n        };\n        NgModel.prototype._setUpStandalone = function () {\n            setUpControl(this._control, this);\n            this._control.updateValueAndValidity({ emitEvent: false });\n        };\n        NgModel.prototype._checkForErrors = function () {\n            if (!this._isStandalone()) {\n                this._checkParentType();\n            }\n            this._checkName();\n        };\n        NgModel.prototype._checkParentType = function () {\n            if (!(this._parent instanceof NgModelGroup) &&\n                this._parent instanceof AbstractFormGroupDirective) {\n                TemplateDrivenErrors.formGroupNameException();\n            }\n            else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {\n                TemplateDrivenErrors.modelParentException();\n            }\n        };\n        NgModel.prototype._checkName = function () {\n            if (this.options && this.options.name)\n                this.name = this.options.name;\n            if (!this._isStandalone() && !this.name) {\n                TemplateDrivenErrors.missingNameException();\n            }\n        };\n        NgModel.prototype._updateValue = function (value) {\n            var _this = this;\n            resolvedPromise$1.then(function () { _this.control.setValue(value, { emitViewToModelChange: false }); });\n        };\n        NgModel.prototype._updateDisabled = function (changes) {\n            var _this = this;\n            var disabledValue = changes['isDisabled'].currentValue;\n            var isDisabled = disabledValue === '' || (disabledValue && disabledValue !== 'false');\n            resolvedPromise$1.then(function () {\n                if (isDisabled && !_this.control.disabled) {\n                    _this.control.disable();\n                }\n                else if (!isDisabled && _this.control.disabled) {\n                    _this.control.enable();\n                }\n            });\n        };\n        NgModel.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[ngModel]:not([formControlName]):not([formControl])',\n                        providers: [formControlBinding],\n                        exportAs: 'ngModel'\n                    },] },\n        ];\n        /** @nocollapse */\n        NgModel.ctorParameters = [\n            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },\n        ];\n        NgModel.propDecorators = {\n            'name': [{ type: _angular_core.Input },],\n            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],\n            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],\n            'options': [{ type: _angular_core.Input, args: ['ngModelOptions',] },],\n            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],\n        };\n        return NgModel;\n    }(NgControl));\n\n    var ReactiveErrors = (function () {\n        function ReactiveErrors() {\n        }\n        ReactiveErrors.controlParentException = function () {\n            throw new Error(\"formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup\\n       directive and pass it an existing FormGroup instance (you can create one in your class).\\n\\n      Example:\\n\\n      \" + Examples.formControlName);\n        };\n        ReactiveErrors.ngModelGroupException = function () {\n            throw new Error(\"formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\\n       that also have a \\\"form\\\" prefix: formGroupName, formArrayName, or formGroup.\\n\\n       Option 1:  Update the parent to be formGroupName (reactive form strategy)\\n\\n        \" + Examples.formGroupName + \"\\n\\n        Option 2: Use ngModel instead of formControlName (template-driven strategy)\\n\\n        \" + Examples.ngModelGroup);\n        };\n        ReactiveErrors.missingFormException = function () {\n            throw new Error(\"formGroup expects a FormGroup instance. Please pass one in.\\n\\n       Example:\\n\\n       \" + Examples.formControlName);\n        };\n        ReactiveErrors.groupParentException = function () {\n            throw new Error(\"formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\\n      directive and pass it an existing FormGroup instance (you can create one in your class).\\n\\n      Example:\\n\\n      \" + Examples.formGroupName);\n        };\n        ReactiveErrors.arrayParentException = function () {\n            throw new Error(\"formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup\\n       directive and pass it an existing FormGroup instance (you can create one in your class).\\n\\n        Example:\\n\\n        \" + Examples.formArrayName);\n        };\n        ReactiveErrors.disabledAttrWarning = function () {\n            console.warn(\"\\n      It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\\n      when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\\n      you. We recommend using this approach to avoid 'changed after checked' errors.\\n       \\n      Example: \\n      form = new FormGroup({\\n        first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\\n        last: new FormControl('Drew', Validators.required)\\n      });\\n    \");\n        };\n        return ReactiveErrors;\n    }());\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$9 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var formControlBinding$1 = {\n        provide: NgControl,\n        useExisting: _angular_core.forwardRef(function () { return FormControlDirective; })\n    };\n    /**\n     * @whatItDoes Syncs a standalone {@link FormControl} instance to a form control element.\n     *\n     * In other words, this directive ensures that any values written to the {@link FormControl}\n     * instance programmatically will be written to the DOM element (model -> view). Conversely,\n     * any values written to the DOM element through user input will be reflected in the\n     * {@link FormControl} instance (view -> model).\n     *\n     * @howToUse\n     *\n     * Use this directive if you'd like to create and manage a {@link FormControl} instance directly.\n     * Simply create a {@link FormControl}, save it to your component class, and pass it into the\n     * {@link FormControlDirective}.\n     *\n     * This directive is designed to be used as a standalone control.  Unlike {@link FormControlName},\n     * it does not require that your {@link FormControl} instance be part of any parent\n     * {@link FormGroup}, and it won't be registered to any {@link FormGroupDirective} that\n     * exists above it.\n     *\n     * **Get the value**: the `value` property is always synced and available on the\n     * {@link FormControl} instance. See a full list of available properties in\n     * {@link AbstractControl}.\n     *\n     * **Set the value**: You can pass in an initial value when instantiating the {@link FormControl},\n     * or you can set it programmatically later using {@link AbstractControl.setValue} or\n     * {@link AbstractControl.patchValue}.\n     *\n     * **Listen to value**: If you want to listen to changes in the value of the control, you can\n     * subscribe to the {@link AbstractControl.valueChanges} event.  You can also listen to\n     * {@link AbstractControl.statusChanges} to be notified when the validation status is\n     * re-calculated.\n     *\n     * ### Example\n     *\n     * {@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}\n     *\n     * * **npm package**: `@angular/forms`\n     *\n     * * **NgModule**: `ReactiveFormsModule`\n     *\n     *  @stable\n     */\n    var FormControlDirective = (function (_super) {\n        __extends$9(FormControlDirective, _super);\n        function FormControlDirective(validators, asyncValidators, valueAccessors) {\n            _super.call(this);\n            this.update = new EventEmitter();\n            this._rawValidators = validators || [];\n            this._rawAsyncValidators = asyncValidators || [];\n            this.valueAccessor = selectValueAccessor(this, valueAccessors);\n        }\n        Object.defineProperty(FormControlDirective.prototype, \"isDisabled\", {\n            set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },\n            enumerable: true,\n            configurable: true\n        });\n        FormControlDirective.prototype.ngOnChanges = function (changes) {\n            if (this._isControlChanged(changes)) {\n                setUpControl(this.form, this);\n                if (this.control.disabled && this.valueAccessor.setDisabledState) {\n                    this.valueAccessor.setDisabledState(true);\n                }\n                this.form.updateValueAndValidity({ emitEvent: false });\n            }\n            if (isPropertyUpdated(changes, this.viewModel)) {\n                this.form.setValue(this.model);\n                this.viewModel = this.model;\n            }\n        };\n        Object.defineProperty(FormControlDirective.prototype, \"path\", {\n            get: function () { return []; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormControlDirective.prototype, \"validator\", {\n            get: function () { return composeValidators(this._rawValidators); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormControlDirective.prototype, \"asyncValidator\", {\n            get: function () {\n                return composeAsyncValidators(this._rawAsyncValidators);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormControlDirective.prototype, \"control\", {\n            get: function () { return this.form; },\n            enumerable: true,\n            configurable: true\n        });\n        FormControlDirective.prototype.viewToModelUpdate = function (newValue) {\n            this.viewModel = newValue;\n            this.update.emit(newValue);\n        };\n        FormControlDirective.prototype._isControlChanged = function (changes) {\n            return changes.hasOwnProperty('form');\n        };\n        FormControlDirective.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[formControl]', providers: [formControlBinding$1], exportAs: 'ngForm' },] },\n        ];\n        /** @nocollapse */\n        FormControlDirective.ctorParameters = [\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },\n        ];\n        FormControlDirective.propDecorators = {\n            'form': [{ type: _angular_core.Input, args: ['formControl',] },],\n            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],\n            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],\n            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],\n        };\n        return FormControlDirective;\n    }(NgControl));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$11 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var formDirectiveProvider$1 = {\n        provide: ControlContainer,\n        useExisting: _angular_core.forwardRef(function () { return FormGroupDirective; })\n    };\n    /**\n     * @whatItDoes Binds an existing {@link FormGroup} to a DOM element.\n     *\n     * @howToUse\n     *\n     * This directive accepts an existing {@link FormGroup} instance. It will then use this\n     * {@link FormGroup} instance to match any child {@link FormControl}, {@link FormGroup},\n     * and {@link FormArray} instances to child {@link FormControlName}, {@link FormGroupName},\n     * and {@link FormArrayName} directives.\n     *\n     * **Set value**: You can set the form's initial value when instantiating the\n     * {@link FormGroup}, or you can set it programmatically later using the {@link FormGroup}'s\n     * {@link AbstractControl.setValue} or {@link AbstractControl.patchValue} methods.\n     *\n     * **Listen to value**: If you want to listen to changes in the value of the form, you can subscribe\n     * to the {@link FormGroup}'s {@link AbstractControl.valueChanges} event.  You can also listen to\n     * its {@link AbstractControl.statusChanges} event to be notified when the validation status is\n     * re-calculated.\n     *\n     * Furthermore, you can listen to the directive's `ngSubmit` event to be notified when the user has\n     * triggered a form submission. The `ngSubmit` event will be emitted with the original form\n     * submission event.\n     *\n     * ### Example\n     *\n     * In this example, we create form controls for first name and last name.\n     *\n     * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}\n     *\n     * **npm package**: `@angular/forms`\n     *\n     * **NgModule**: {@link ReactiveFormsModule}\n     *\n     *  @stable\n     */\n    var FormGroupDirective = (function (_super) {\n        __extends$11(FormGroupDirective, _super);\n        function FormGroupDirective(_validators, _asyncValidators) {\n            _super.call(this);\n            this._validators = _validators;\n            this._asyncValidators = _asyncValidators;\n            this._submitted = false;\n            this.directives = [];\n            this.form = null;\n            this.ngSubmit = new EventEmitter();\n        }\n        FormGroupDirective.prototype.ngOnChanges = function (changes) {\n            this._checkFormPresent();\n            if (changes.hasOwnProperty('form')) {\n                this._updateValidators();\n                this._updateDomValue();\n                this._updateRegistrations();\n            }\n        };\n        Object.defineProperty(FormGroupDirective.prototype, \"submitted\", {\n            get: function () { return this._submitted; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormGroupDirective.prototype, \"formDirective\", {\n            get: function () { return this; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormGroupDirective.prototype, \"control\", {\n            get: function () { return this.form; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormGroupDirective.prototype, \"path\", {\n            get: function () { return []; },\n            enumerable: true,\n            configurable: true\n        });\n        FormGroupDirective.prototype.addControl = function (dir) {\n            var ctrl = this.form.get(dir.path);\n            setUpControl(ctrl, dir);\n            ctrl.updateValueAndValidity({ emitEvent: false });\n            this.directives.push(dir);\n            return ctrl;\n        };\n        FormGroupDirective.prototype.getControl = function (dir) { return this.form.get(dir.path); };\n        FormGroupDirective.prototype.removeControl = function (dir) { ListWrapper.remove(this.directives, dir); };\n        FormGroupDirective.prototype.addFormGroup = function (dir) {\n            var ctrl = this.form.get(dir.path);\n            setUpFormContainer(ctrl, dir);\n            ctrl.updateValueAndValidity({ emitEvent: false });\n        };\n        FormGroupDirective.prototype.removeFormGroup = function (dir) { };\n        FormGroupDirective.prototype.getFormGroup = function (dir) { return this.form.get(dir.path); };\n        FormGroupDirective.prototype.addFormArray = function (dir) {\n            var ctrl = this.form.get(dir.path);\n            setUpFormContainer(ctrl, dir);\n            ctrl.updateValueAndValidity({ emitEvent: false });\n        };\n        FormGroupDirective.prototype.removeFormArray = function (dir) { };\n        FormGroupDirective.prototype.getFormArray = function (dir) { return this.form.get(dir.path); };\n        FormGroupDirective.prototype.updateModel = function (dir, value) {\n            var ctrl = this.form.get(dir.path);\n            ctrl.setValue(value);\n        };\n        FormGroupDirective.prototype.onSubmit = function ($event) {\n            this._submitted = true;\n            this.ngSubmit.emit($event);\n            return false;\n        };\n        FormGroupDirective.prototype.onReset = function () { this.resetForm(); };\n        FormGroupDirective.prototype.resetForm = function (value) {\n            if (value === void 0) { value = undefined; }\n            this.form.reset(value);\n            this._submitted = false;\n        };\n        /** @internal */\n        FormGroupDirective.prototype._updateDomValue = function () {\n            var _this = this;\n            this.directives.forEach(function (dir) {\n                var newCtrl = _this.form.get(dir.path);\n                if (dir._control !== newCtrl) {\n                    cleanUpControl(dir._control, dir);\n                    if (newCtrl)\n                        setUpControl(newCtrl, dir);\n                    dir._control = newCtrl;\n                }\n            });\n            this.form._updateTreeValidity({ emitEvent: false });\n        };\n        FormGroupDirective.prototype._updateRegistrations = function () {\n            var _this = this;\n            this.form._registerOnCollectionChange(function () { return _this._updateDomValue(); });\n            if (this._oldForm)\n                this._oldForm._registerOnCollectionChange(function () { });\n            this._oldForm = this.form;\n        };\n        FormGroupDirective.prototype._updateValidators = function () {\n            var sync = composeValidators(this._validators);\n            this.form.validator = Validators.compose([this.form.validator, sync]);\n            var async = composeAsyncValidators(this._asyncValidators);\n            this.form.asyncValidator = Validators.composeAsync([this.form.asyncValidator, async]);\n        };\n        FormGroupDirective.prototype._checkFormPresent = function () {\n            if (!this.form) {\n                ReactiveErrors.missingFormException();\n            }\n        };\n        FormGroupDirective.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[formGroup]',\n                        providers: [formDirectiveProvider$1],\n                        host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },\n                        exportAs: 'ngForm'\n                    },] },\n        ];\n        /** @nocollapse */\n        FormGroupDirective.ctorParameters = [\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },\n        ];\n        FormGroupDirective.propDecorators = {\n            'form': [{ type: _angular_core.Input, args: ['formGroup',] },],\n            'ngSubmit': [{ type: _angular_core.Output },],\n        };\n        return FormGroupDirective;\n    }(ControlContainer));\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$12 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var formGroupNameProvider = {\n        provide: ControlContainer,\n        useExisting: _angular_core.forwardRef(function () { return FormGroupName; })\n    };\n    /**\n     * @whatItDoes Syncs a nested {@link FormGroup} to a DOM element.\n     *\n     * @howToUse\n     *\n     * This directive can only be used with a parent {@link FormGroupDirective} (selector:\n     * `[formGroup]`).\n     *\n     * It accepts the string name of the nested {@link FormGroup} you want to link, and\n     * will look for a {@link FormGroup} registered with that name in the parent\n     * {@link FormGroup} instance you passed into {@link FormGroupDirective}.\n     *\n     * Nested form groups can come in handy when you want to validate a sub-group of a\n     * form separately from the rest or when you'd like to group the values of certain\n     * controls into their own nested object.\n     *\n     * **Access the group**: You can access the associated {@link FormGroup} using the\n     * {@link AbstractControl.get} method. Ex: `this.form.get('name')`.\n     *\n     * You can also access individual controls within the group using dot syntax.\n     * Ex: `this.form.get('name.first')`\n     *\n     * **Get the value**: the `value` property is always synced and available on the\n     * {@link FormGroup}. See a full list of available properties in {@link AbstractControl}.\n     *\n     * **Set the value**: You can set an initial value for each child control when instantiating\n     * the {@link FormGroup}, or you can set it programmatically later using\n     * {@link AbstractControl.setValue} or {@link AbstractControl.patchValue}.\n     *\n     * **Listen to value**: If you want to listen to changes in the value of the group, you can\n     * subscribe to the {@link AbstractControl.valueChanges} event.  You can also listen to\n     * {@link AbstractControl.statusChanges} to be notified when the validation status is\n     * re-calculated.\n     *\n     * ### Example\n     *\n     * {@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}\n     *\n     * * **npm package**: `@angular/forms`\n     *\n     * * **NgModule**: `ReactiveFormsModule`\n     *\n     * @stable\n     */\n    var FormGroupName = (function (_super) {\n        __extends$12(FormGroupName, _super);\n        function FormGroupName(parent, validators, asyncValidators) {\n            _super.call(this);\n            this._parent = parent;\n            this._validators = validators;\n            this._asyncValidators = asyncValidators;\n        }\n        /** @internal */\n        FormGroupName.prototype._checkParentType = function () {\n            if (_hasInvalidParent(this._parent)) {\n                ReactiveErrors.groupParentException();\n            }\n        };\n        FormGroupName.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[formGroupName]', providers: [formGroupNameProvider] },] },\n        ];\n        /** @nocollapse */\n        FormGroupName.ctorParameters = [\n            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },\n        ];\n        FormGroupName.propDecorators = {\n            'name': [{ type: _angular_core.Input, args: ['formGroupName',] },],\n        };\n        return FormGroupName;\n    }(AbstractFormGroupDirective));\n    var formArrayNameProvider = {\n        provide: ControlContainer,\n        useExisting: _angular_core.forwardRef(function () { return FormArrayName; })\n    };\n    /**\n     * @whatItDoes Syncs a nested {@link FormArray} to a DOM element.\n     *\n     * @howToUse\n     *\n     * This directive is designed to be used with a parent {@link FormGroupDirective} (selector:\n     * `[formGroup]`).\n     *\n     * It accepts the string name of the nested {@link FormArray} you want to link, and\n     * will look for a {@link FormArray} registered with that name in the parent\n     * {@link FormGroup} instance you passed into {@link FormGroupDirective}.\n     *\n     * Nested form arrays can come in handy when you have a group of form controls but\n     * you're not sure how many there will be. Form arrays allow you to create new\n     * form controls dynamically.\n     *\n     * **Access the array**: You can access the associated {@link FormArray} using the\n     * {@link AbstractControl.get} method on the parent {@link FormGroup}.\n     * Ex: `this.form.get('cities')`.\n     *\n     * **Get the value**: the `value` property is always synced and available on the\n     * {@link FormArray}. See a full list of available properties in {@link AbstractControl}.\n     *\n     * **Set the value**: You can set an initial value for each child control when instantiating\n     * the {@link FormArray}, or you can set the value programmatically later using the\n     * {@link FormArray}'s {@link AbstractControl.setValue} or {@link AbstractControl.patchValue}\n     * methods.\n     *\n     * **Listen to value**: If you want to listen to changes in the value of the array, you can\n     * subscribe to the {@link FormArray}'s {@link AbstractControl.valueChanges} event.  You can also\n     * listen to its {@link AbstractControl.statusChanges} event to be notified when the validation\n     * status is re-calculated.\n     *\n     * **Add new controls**: You can add new controls to the {@link FormArray} dynamically by\n     * calling its {@link FormArray.push} method.\n     *  Ex: `this.form.get('cities').push(new FormControl());`\n     *\n     * ### Example\n     *\n     * {@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}\n     *\n     * * **npm package**: `@angular/forms`\n     *\n     * * **NgModule**: `ReactiveFormsModule`\n     *\n     * @stable\n     */\n    var FormArrayName = (function (_super) {\n        __extends$12(FormArrayName, _super);\n        function FormArrayName(parent, validators, asyncValidators) {\n            _super.call(this);\n            this._parent = parent;\n            this._validators = validators;\n            this._asyncValidators = asyncValidators;\n        }\n        FormArrayName.prototype.ngOnInit = function () {\n            this._checkParentType();\n            this.formDirective.addFormArray(this);\n        };\n        FormArrayName.prototype.ngOnDestroy = function () {\n            if (this.formDirective) {\n                this.formDirective.removeFormArray(this);\n            }\n        };\n        Object.defineProperty(FormArrayName.prototype, \"control\", {\n            get: function () { return this.formDirective.getFormArray(this); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormArrayName.prototype, \"formDirective\", {\n            get: function () {\n                return this._parent ? this._parent.formDirective : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormArrayName.prototype, \"path\", {\n            get: function () { return controlPath(this.name, this._parent); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormArrayName.prototype, \"validator\", {\n            get: function () { return composeValidators(this._validators); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormArrayName.prototype, \"asyncValidator\", {\n            get: function () { return composeAsyncValidators(this._asyncValidators); },\n            enumerable: true,\n            configurable: true\n        });\n        FormArrayName.prototype._checkParentType = function () {\n            if (_hasInvalidParent(this._parent)) {\n                ReactiveErrors.arrayParentException();\n            }\n        };\n        FormArrayName.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[formArrayName]', providers: [formArrayNameProvider] },] },\n        ];\n        /** @nocollapse */\n        FormArrayName.ctorParameters = [\n            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },\n        ];\n        FormArrayName.propDecorators = {\n            'name': [{ type: _angular_core.Input, args: ['formArrayName',] },],\n        };\n        return FormArrayName;\n    }(ControlContainer));\n    function _hasInvalidParent(parent) {\n        return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) &&\n            !(parent instanceof FormArrayName);\n    }\n\n    /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var __extends$10 = (this && this.__extends) || function (d, b) {\n        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n    var controlNameBinding = {\n        provide: NgControl,\n        useExisting: _angular_core.forwardRef(function () { return FormControlName; })\n    };\n    /**\n     * @whatItDoes  Syncs a {@link FormControl} in an existing {@link FormGroup} to a form control\n     * element by name.\n     *\n     * In other words, this directive ensures that any values written to the {@link FormControl}\n     * instance programmatically will be written to the DOM element (model -> view). Conversely,\n     * any values written to the DOM element through user input will be reflected in the\n     * {@link FormControl} instance (view -> model).\n     *\n     * @howToUse\n     *\n     * This directive is designed to be used with a parent {@link FormGroupDirective} (selector:\n     * `[formGroup]`).\n     *\n     * It accepts the string name of the {@link FormControl} instance you want to\n     * link, and will look for a {@link FormControl} registered with that name in the\n     * closest {@link FormGroup} or {@link FormArray} above it.\n     *\n     * **Access the control**: You can access the {@link FormControl} associated with\n     * this directive by using the {@link AbstractControl.get} method.\n     * Ex: `this.form.get('first');`\n     *\n     * **Get value**: the `value` property is always synced and available on the {@link FormControl}.\n     * See a full list of available properties in {@link AbstractControl}.\n     *\n     *  **Set value**: You can set an initial value for the control when instantiating the\n     *  {@link FormControl}, or you can set it programmatically later using\n     *  {@link AbstractControl.setValue} or {@link AbstractControl.patchValue}.\n     *\n     * **Listen to value**: If you want to listen to changes in the value of the control, you can\n     * subscribe to the {@link AbstractControl.valueChanges} event.  You can also listen to\n     * {@link AbstractControl.statusChanges} to be notified when the validation status is\n     * re-calculated.\n     *\n     * ### Example\n     *\n     * In this example, we create form controls for first name and last name.\n     *\n     * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}\n     *\n     * To see `formControlName` examples with different form control types, see:\n     *\n     * * Radio buttons: {@link RadioControlValueAccessor}\n     * * Selects: {@link SelectControlValueAccessor}\n     *\n     * **npm package**: `@angular/forms`\n     *\n     * **NgModule**: {@link ReactiveFormsModule}\n     *\n     *  @stable\n     */\n    var FormControlName = (function (_super) {\n        __extends$10(FormControlName, _super);\n        function FormControlName(parent, validators, asyncValidators, valueAccessors) {\n            _super.call(this);\n            this._added = false;\n            this.update = new EventEmitter();\n            this._parent = parent;\n            this._rawValidators = validators || [];\n            this._rawAsyncValidators = asyncValidators || [];\n            this.valueAccessor = selectValueAccessor(this, valueAccessors);\n        }\n        Object.defineProperty(FormControlName.prototype, \"isDisabled\", {\n            set: function (isDisabled) { ReactiveErrors.disabledAttrWarning(); },\n            enumerable: true,\n            configurable: true\n        });\n        FormControlName.prototype.ngOnChanges = function (changes) {\n            if (!this._added)\n                this._setUpControl();\n            if (isPropertyUpdated(changes, this.viewModel)) {\n                this.viewModel = this.model;\n                this.formDirective.updateModel(this, this.model);\n            }\n        };\n        FormControlName.prototype.ngOnDestroy = function () {\n            if (this.formDirective) {\n                this.formDirective.removeControl(this);\n            }\n        };\n        FormControlName.prototype.viewToModelUpdate = function (newValue) {\n            this.viewModel = newValue;\n            this.update.emit(newValue);\n        };\n        Object.defineProperty(FormControlName.prototype, \"path\", {\n            get: function () { return controlPath(this.name, this._parent); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormControlName.prototype, \"formDirective\", {\n            get: function () { return this._parent ? this._parent.formDirective : null; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormControlName.prototype, \"validator\", {\n            get: function () { return composeValidators(this._rawValidators); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormControlName.prototype, \"asyncValidator\", {\n            get: function () {\n                return composeAsyncValidators(this._rawAsyncValidators);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormControlName.prototype, \"control\", {\n            get: function () { return this._control; },\n            enumerable: true,\n            configurable: true\n        });\n        FormControlName.prototype._checkParentType = function () {\n            if (!(this._parent instanceof FormGroupName) &&\n                this._parent instanceof AbstractFormGroupDirective) {\n                ReactiveErrors.ngModelGroupException();\n            }\n            else if (!(this._parent instanceof FormGroupName) && !(this._parent instanceof FormGroupDirective) &&\n                !(this._parent instanceof FormArrayName)) {\n                ReactiveErrors.controlParentException();\n            }\n        };\n        FormControlName.prototype._setUpControl = function () {\n            this._checkParentType();\n            this._control = this.formDirective.addControl(this);\n            if (this.control.disabled && this.valueAccessor.setDisabledState) {\n                this.valueAccessor.setDisabledState(true);\n            }\n            this._added = true;\n        };\n        FormControlName.decorators = [\n            { type: _angular_core.Directive, args: [{ selector: '[formControlName]', providers: [controlNameBinding] },] },\n        ];\n        /** @nocollapse */\n        FormControlName.ctorParameters = [\n            { type: ControlContainer, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Host }, { type: _angular_core.SkipSelf },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_ASYNC_VALIDATORS,] },] },\n            { type: Array, decorators: [{ type: _angular_core.Optional }, { type: _angular_core.Self }, { type: _angular_core.Inject, args: [NG_VALUE_ACCESSOR,] },] },\n        ];\n        FormControlName.propDecorators = {\n            'name': [{ type: _angular_core.Input, args: ['formControlName',] },],\n            'model': [{ type: _angular_core.Input, args: ['ngModel',] },],\n            'update': [{ type: _angular_core.Output, args: ['ngModelChange',] },],\n            'isDisabled': [{ type: _angular_core.Input, args: ['disabled',] },],\n        };\n        return FormControlName;\n    }(NgControl));\n\n    var REQUIRED_VALIDATOR = {\n        provide: NG_VALIDATORS,\n        useExisting: _angular_core.forwardRef(function () { return RequiredValidator; }),\n        multi: true\n    };\n    /**\n     * A Directive that adds the `required` validator to any controls marked with the\n     * `required` attribute, via the {@link NG_VALIDATORS} binding.\n     *\n     * ### Example\n     *\n     * ```\n     * <input name=\"fullName\" ngModel required>\n     * ```\n     *\n     * @stable\n     */\n    var RequiredValidator = (function () {\n        function RequiredValidator() {\n        }\n        Object.defineProperty(RequiredValidator.prototype, \"required\", {\n            get: function () { return this._required; },\n            set: function (value) {\n                this._required = isPresent(value) && \"\" + value !== 'false';\n                if (this._onChange)\n                    this._onChange();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        RequiredValidator.prototype.validate = function (c) {\n            return this.required ? Validators.required(c) : null;\n        };\n        RequiredValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };\n        RequiredValidator.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[required][formControlName],[required][formControl],[required][ngModel]',\n                        providers: [REQUIRED_VALIDATOR],\n                        host: { '[attr.required]': 'required? \"\" : null' }\n                    },] },\n        ];\n        /** @nocollapse */\n        RequiredValidator.ctorParameters = [];\n        RequiredValidator.propDecorators = {\n            'required': [{ type: _angular_core.Input },],\n        };\n        return RequiredValidator;\n    }());\n    /**\n     * Provider which adds {@link MinLengthValidator} to {@link NG_VALIDATORS}.\n     *\n     * ## Example:\n     *\n     * {@example common/forms/ts/validators/validators.ts region='min'}\n     */\n    var MIN_LENGTH_VALIDATOR = {\n        provide: NG_VALIDATORS,\n        useExisting: _angular_core.forwardRef(function () { return MinLengthValidator; }),\n        multi: true\n    };\n    /**\n     * A directive which installs the {@link MinLengthValidator} for any `formControlName`,\n     * `formControl`, or control with `ngModel` that also has a `minlength` attribute.\n     *\n     * @stable\n     */\n    var MinLengthValidator = (function () {\n        function MinLengthValidator() {\n        }\n        MinLengthValidator.prototype._createValidator = function () {\n            this._validator = Validators.minLength(parseInt(this.minlength, 10));\n        };\n        MinLengthValidator.prototype.ngOnChanges = function (changes) {\n            if (changes['minlength']) {\n                this._createValidator();\n                if (this._onChange)\n                    this._onChange();\n            }\n        };\n        MinLengthValidator.prototype.validate = function (c) {\n            return isPresent(this.minlength) ? this._validator(c) : null;\n        };\n        MinLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };\n        MinLengthValidator.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[minlength][formControlName],[minlength][formControl],[minlength][ngModel]',\n                        providers: [MIN_LENGTH_VALIDATOR],\n                        host: { '[attr.minlength]': 'minlength? minlength : null' }\n                    },] },\n        ];\n        /** @nocollapse */\n        MinLengthValidator.ctorParameters = [];\n        MinLengthValidator.propDecorators = {\n            'minlength': [{ type: _angular_core.Input },],\n        };\n        return MinLengthValidator;\n    }());\n    /**\n     * Provider which adds {@link MaxLengthValidator} to {@link NG_VALIDATORS}.\n     *\n     * ## Example:\n     *\n     * {@example common/forms/ts/validators/validators.ts region='max'}\n     */\n    var MAX_LENGTH_VALIDATOR = {\n        provide: NG_VALIDATORS,\n        useExisting: _angular_core.forwardRef(function () { return MaxLengthValidator; }),\n        multi: true\n    };\n    /**\n     * A directive which installs the {@link MaxLengthValidator} for any `formControlName,\n     * `formControl`,\n     * or control with `ngModel` that also has a `maxlength` attribute.\n     *\n     * @stable\n     */\n    var MaxLengthValidator = (function () {\n        function MaxLengthValidator() {\n        }\n        MaxLengthValidator.prototype._createValidator = function () {\n            this._validator = Validators.maxLength(parseInt(this.maxlength, 10));\n        };\n        MaxLengthValidator.prototype.ngOnChanges = function (changes) {\n            if (changes['maxlength']) {\n                this._createValidator();\n                if (this._onChange)\n                    this._onChange();\n            }\n        };\n        MaxLengthValidator.prototype.validate = function (c) {\n            return isPresent(this.maxlength) ? this._validator(c) : null;\n        };\n        MaxLengthValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };\n        MaxLengthValidator.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]',\n                        providers: [MAX_LENGTH_VALIDATOR],\n                        host: { '[attr.maxlength]': 'maxlength? maxlength : null' }\n                    },] },\n        ];\n        /** @nocollapse */\n        MaxLengthValidator.ctorParameters = [];\n        MaxLengthValidator.propDecorators = {\n            'maxlength': [{ type: _angular_core.Input },],\n        };\n        return MaxLengthValidator;\n    }());\n    var PATTERN_VALIDATOR = {\n        provide: NG_VALIDATORS,\n        useExisting: _angular_core.forwardRef(function () { return PatternValidator; }),\n        multi: true\n    };\n    /**\n     * A Directive that adds the `pattern` validator to any controls marked with the\n     * `pattern` attribute, via the {@link NG_VALIDATORS} binding. Uses attribute value\n     * as the regex to validate Control value against.  Follows pattern attribute\n     * semantics; i.e. regex must match entire Control value.\n     *\n     * ### Example\n     *\n     * ```\n     * <input [name]=\"fullName\" pattern=\"[a-zA-Z ]*\" ngModel>\n     * ```\n     * @stable\n     */\n    var PatternValidator = (function () {\n        function PatternValidator() {\n        }\n        PatternValidator.prototype._createValidator = function () { this._validator = Validators.pattern(this.pattern); };\n        PatternValidator.prototype.ngOnChanges = function (changes) {\n            if (changes['pattern']) {\n                this._createValidator();\n                if (this._onChange)\n                    this._onChange();\n            }\n        };\n        PatternValidator.prototype.validate = function (c) {\n            return isPresent(this.pattern) ? this._validator(c) : null;\n        };\n        PatternValidator.prototype.registerOnValidatorChange = function (fn) { this._onChange = fn; };\n        PatternValidator.decorators = [\n            { type: _angular_core.Directive, args: [{\n                        selector: '[pattern][formControlName],[pattern][formControl],[pattern][ngModel]',\n                        providers: [PATTERN_VALIDATOR],\n                        host: { '[attr.pattern]': 'pattern? pattern : null' }\n                    },] },\n        ];\n        /** @nocollapse */\n        PatternValidator.ctorParameters = [];\n        PatternValidator.propDecorators = {\n            'pattern': [{ type: _angular_core.Input },],\n        };\n        return PatternValidator;\n    }());\n\n    /**\n     * @whatItDoes Creates an {@link AbstractControl} from a user-specified configuration.\n     *\n     * It is essentially syntactic sugar that shortens the `new FormGroup()`,\n     * `new FormControl()`, and `new FormArray()` boilerplate that can build up in larger\n     * forms.\n     *\n     * @howToUse\n     *\n     * To use, inject `FormBuilder` into your component class. You can then call its methods\n     * directly.\n     *\n     * {@example forms/ts/formBuilder/form_builder_example.ts region='Component'}\n     *\n     *  * **npm package**: `@angular/forms`\n     *\n     *  * **NgModule**: {@link ReactiveFormsModule}\n     *\n     * @stable\n     */\n    var FormBuilder = (function () {\n        function FormBuilder() {\n        }\n        /**\n         * Construct a new {@link FormGroup} with the given map of configuration.\n         * Valid keys for the `extra` parameter map are `validator` and `asyncValidator`.\n         *\n         * See the {@link FormGroup} constructor for more details.\n         */\n        FormBuilder.prototype.group = function (controlsConfig, extra) {\n            if (extra === void 0) { extra = null; }\n            var controls = this._reduceControls(controlsConfig);\n            var validator = isPresent(extra) ? extra['validator'] : null;\n            var asyncValidator = isPresent(extra) ? extra['asyncValidator'] : null;\n            return new FormGroup(controls, validator, asyncValidator);\n        };\n        /**\n         * Construct a new {@link FormControl} with the given `formState`,`validator`, and\n         * `asyncValidator`.\n         *\n         * `formState` can either be a standalone value for the form control or an object\n         * that contains both a value and a disabled status.\n         *\n         */\n        FormBuilder.prototype.control = function (formState, validator, asyncValidator) {\n            if (validator === void 0) { validator = null; }\n            if (asyncValidator === void 0) { asyncValidator = null; }\n            return new FormControl(formState, validator, asyncValidator);\n        };\n        /**\n         * Construct a {@link FormArray} from the given `controlsConfig` array of\n         * configuration, with the given optional `validator` and `asyncValidator`.\n         */\n        FormBuilder.prototype.array = function (controlsConfig, validator, asyncValidator) {\n            var _this = this;\n            if (validator === void 0) { validator = null; }\n            if (asyncValidator === void 0) { asyncValidator = null; }\n            var controls = controlsConfig.map(function (c) { return _this._createControl(c); });\n            return new FormArray(controls, validator, asyncValidator);\n        };\n        /** @internal */\n        FormBuilder.prototype._reduceControls = function (controlsConfig) {\n            var _this = this;\n            var controls = {};\n            Object.keys(controlsConfig).forEach(function (controlName) {\n                controls[controlName] = _this._createControl(controlsConfig[controlName]);\n            });\n            return controls;\n        };\n        /** @internal */\n        FormBuilder.prototype._createControl = function (controlConfig) {\n            if (controlConfig instanceof FormControl || controlConfig instanceof FormGroup ||\n                controlConfig instanceof FormArray) {\n                return controlConfig;\n            }\n            else if (Array.isArray(controlConfig)) {\n                var value = controlConfig[0];\n                var validator = controlConfig.length > 1 ? controlConfig[1] : null;\n                var asyncValidator = controlConfig.length > 2 ? controlConfig[2] : null;\n                return this.control(value, validator, asyncValidator);\n            }\n            else {\n                return this.control(controlConfig);\n            }\n        };\n        FormBuilder.decorators = [\n            { type: _angular_core.Injectable },\n        ];\n        /** @nocollapse */\n        FormBuilder.ctorParameters = [];\n        return FormBuilder;\n    }());\n\n    var SHARED_FORM_DIRECTIVES = [\n        NgSelectOption, NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor,\n        CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor,\n        RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator,\n        MinLengthValidator, MaxLengthValidator, PatternValidator\n    ];\n    var TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];\n    var REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];\n    /**\n     * Internal module used for sharing directives between FormsModule and ReactiveFormsModule\n     */\n    var InternalFormsSharedModule = (function () {\n        function InternalFormsSharedModule() {\n        }\n        InternalFormsSharedModule.decorators = [\n            { type: _angular_core.NgModule, args: [{ declarations: SHARED_FORM_DIRECTIVES, exports: SHARED_FORM_DIRECTIVES },] },\n        ];\n        /** @nocollapse */\n        InternalFormsSharedModule.ctorParameters = [];\n        return InternalFormsSharedModule;\n    }());\n\n    /**\n     * The ng module for forms.\n     * @stable\n     */\n    var FormsModule = (function () {\n        function FormsModule() {\n        }\n        FormsModule.decorators = [\n            { type: _angular_core.NgModule, args: [{\n                        declarations: TEMPLATE_DRIVEN_DIRECTIVES,\n                        providers: [RadioControlRegistry],\n                        exports: [InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]\n                    },] },\n        ];\n        /** @nocollapse */\n        FormsModule.ctorParameters = [];\n        return FormsModule;\n    }());\n    /**\n     * The ng module for reactive forms.\n     * @stable\n     */\n    var ReactiveFormsModule = (function () {\n        function ReactiveFormsModule() {\n        }\n        ReactiveFormsModule.decorators = [\n            { type: _angular_core.NgModule, args: [{\n                        declarations: [REACTIVE_DRIVEN_DIRECTIVES],\n                        providers: [FormBuilder, RadioControlRegistry],\n                        exports: [InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]\n                    },] },\n        ];\n        /** @nocollapse */\n        ReactiveFormsModule.ctorParameters = [];\n        return ReactiveFormsModule;\n    }());\n\n    exports.AbstractControlDirective = AbstractControlDirective;\n    exports.AbstractFormGroupDirective = AbstractFormGroupDirective;\n    exports.CheckboxControlValueAccessor = CheckboxControlValueAccessor;\n    exports.ControlContainer = ControlContainer;\n    exports.NG_VALUE_ACCESSOR = NG_VALUE_ACCESSOR;\n    exports.DefaultValueAccessor = DefaultValueAccessor;\n    exports.NgControl = NgControl;\n    exports.NgControlStatus = NgControlStatus;\n    exports.NgControlStatusGroup = NgControlStatusGroup;\n    exports.NgForm = NgForm;\n    exports.NgModel = NgModel;\n    exports.NgModelGroup = NgModelGroup;\n    exports.RadioControlValueAccessor = RadioControlValueAccessor;\n    exports.FormControlDirective = FormControlDirective;\n    exports.FormControlName = FormControlName;\n    exports.FormGroupDirective = FormGroupDirective;\n    exports.FormArrayName = FormArrayName;\n    exports.FormGroupName = FormGroupName;\n    exports.NgSelectOption = NgSelectOption;\n    exports.SelectControlValueAccessor = SelectControlValueAccessor;\n    exports.SelectMultipleControlValueAccessor = SelectMultipleControlValueAccessor;\n    exports.MaxLengthValidator = MaxLengthValidator;\n    exports.MinLengthValidator = MinLengthValidator;\n    exports.PatternValidator = PatternValidator;\n    exports.RequiredValidator = RequiredValidator;\n    exports.FormBuilder = FormBuilder;\n    exports.AbstractControl = AbstractControl;\n    exports.FormArray = FormArray;\n    exports.FormControl = FormControl;\n    exports.FormGroup = FormGroup;\n    exports.NG_ASYNC_VALIDATORS = NG_ASYNC_VALIDATORS;\n    exports.NG_VALIDATORS = NG_VALIDATORS;\n    exports.Validators = Validators;\n    exports.FormsModule = FormsModule;\n    exports.ReactiveFormsModule = ReactiveFormsModule;\n\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9mb3Jtcy9idW5kbGVzL2Zvcm1zLnVtZC5qcz85MTI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgQW5ndWxhciB2Mi4xLjJcbiAqIChjKSAyMDEwLTIwMTYgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpLCByZXF1aXJlKCdyeGpzL29wZXJhdG9yL3RvUHJvbWlzZScpLCByZXF1aXJlKCdyeGpzL1N1YmplY3QnKSwgcmVxdWlyZSgncnhqcy9PYnNlcnZhYmxlJyksIHJlcXVpcmUoJ3J4anMvb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZScpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAYW5ndWxhci9jb3JlJywgJ3J4anMvb3BlcmF0b3IvdG9Qcm9taXNlJywgJ3J4anMvU3ViamVjdCcsICdyeGpzL09ic2VydmFibGUnLCAncnhqcy9vYnNlcnZhYmxlL2Zyb21Qcm9taXNlJ10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsLm5nID0gZ2xvYmFsLm5nIHx8IHt9LCBnbG9iYWwubmcuZm9ybXMgPSBnbG9iYWwubmcuZm9ybXMgfHwge30pLGdsb2JhbC5uZy5jb3JlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwuUngsZ2xvYmFsLlJ4LGdsb2JhbC5SeC5PYnNlcnZhYmxlKSk7XG59KHRoaXMsIGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvcmUscnhqc19vcGVyYXRvcl90b1Byb21pc2Uscnhqc19TdWJqZWN0LHJ4anNfT2JzZXJ2YWJsZSxyeGpzX29ic2VydmFibGVfZnJvbVByb21pc2UpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZnVuY3Rpb24gaXNQcmVzZW50KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICE9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzQmxhbmsob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogPT0gbnVsbDtcbiAgICB9XG4gICAgLy8gSlMgaGFzIE5hTiAhPT0gTmFOXG4gICAgZnVuY3Rpb24gbG9vc2VJZGVudGljYWwoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA9PT0gYiB8fCB0eXBlb2YgYSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGIgPT09ICdudW1iZXInICYmIGlzTmFOKGEpICYmIGlzTmFOKGIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0pzT2JqZWN0KG8pIHtcbiAgICAgICAgcmV0dXJuIG8gIT09IG51bGwgJiYgKHR5cGVvZiBvID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvID09PSAnb2JqZWN0Jyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICAgICAgICByZXR1cm4gIWlzSnNPYmplY3Qob2JqKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCYXNlIGNsYXNzIGZvciBjb250cm9sIGRpcmVjdGl2ZXMuXG4gICAgICpcbiAgICAgKiBPbmx5IHVzZWQgaW50ZXJuYWxseSBpbiB0aGUgZm9ybXMgbW9kdWxlLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKCd1bmltcGxlbWVudGVkJyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLnZhbHVlIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInZhbGlkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNQcmVzZW50KHRoaXMuY29udHJvbCkgPyB0aGlzLmNvbnRyb2wudmFsaWQgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaW52YWxpZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLmludmFsaWQgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGVuZGluZ1wiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLnBlbmRpbmcgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZXJyb3JzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5jb250cm9sKSA/IHRoaXMuY29udHJvbC5lcnJvcnMgOiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcInByaXN0aW5lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNQcmVzZW50KHRoaXMuY29udHJvbCkgPyB0aGlzLmNvbnRyb2wucHJpc3RpbmUgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGlydHlcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1ByZXNlbnQodGhpcy5jb250cm9sKSA/IHRoaXMuY29udHJvbC5kaXJ0eSA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0b3VjaGVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNQcmVzZW50KHRoaXMuY29udHJvbCkgPyB0aGlzLmNvbnRyb2wudG91Y2hlZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ1bnRvdWNoZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1ByZXNlbnQodGhpcy5jb250cm9sKSA/IHRoaXMuY29udHJvbC51bnRvdWNoZWQgOiBudWxsOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpc1ByZXNlbnQodGhpcy5jb250cm9sKSA/IHRoaXMuY29udHJvbC5kaXNhYmxlZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNQcmVzZW50KHRoaXMuY29udHJvbCkgPyB0aGlzLmNvbnRyb2wuZW5hYmxlZCA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzdGF0dXNDaGFuZ2VzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5jb250cm9sKSA/IHRoaXMuY29udHJvbC5zdGF0dXNDaGFuZ2VzIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWx1ZUNoYW5nZXNcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmNvbnRyb2wpID8gdGhpcy5jb250cm9sLnZhbHVlQ2hhbmdlcyA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IHVuZGVmaW5lZDsgfVxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmNvbnRyb2wpKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbC5yZXNldCh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGRpcmVjdGl2ZSB0aGF0IGNvbnRhaW5zIG11bHRpcGxlIHtAbGluayBOZ0NvbnRyb2x9cy5cbiAgICAgKlxuICAgICAqIE9ubHkgdXNlZCBieSB0aGUgZm9ybXMgbW9kdWxlLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBDb250cm9sQ29udGFpbmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoQ29udHJvbENvbnRhaW5lciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ29udHJvbENvbnRhaW5lcigpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250cm9sQ29udGFpbmVyLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBmb3JtIHRvIHdoaWNoIHRoaXMgY29udGFpbmVyIGJlbG9uZ3MuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb250cm9sQ29udGFpbmVyLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBwYXRoIHRvIHRoaXMgY29udGFpbmVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gQ29udHJvbENvbnRhaW5lcjtcbiAgICB9KEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSkpO1xuXG4gICAgLy8gU2FmYXJpIGRvZXNuJ3QgaW1wbGVtZW50IE1hcEl0ZXJhdG9yLm5leHQoKSwgd2hpY2ggaXMgdXNlZCBpcyBUcmFjZXVyJ3MgcG9seWZpbGwgb2YgQXJyYXkuZnJvbVxuICAgIC8vIFRPRE8obWxhdmFsKTogcmVtb3ZlIHRoZSB3b3JrIGFyb3VuZCBvbmNlIHdlIGhhdmUgYSB3b3JraW5nIHBvbHlmaWxsIG9mIEFycmF5LmZyb21cbiAgICB2YXIgX2FycmF5RnJvbU1hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoKG5ldyBNYXAoKSkudmFsdWVzKCkubmV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NYXAobSwgZ2V0VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRWYWx1ZXMgPyBBcnJheS5mcm9tKG0udmFsdWVzKCkpIDogQXJyYXkuZnJvbShtLmtleXMoKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NYXBXaXRoRm9yZWFjaChtLCBnZXRWYWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkobS5zaXplKSwgaSA9IDA7XG4gICAgICAgICAgICBtLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBnZXRWYWx1ZXMgPyB2IDogaztcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICB2YXIgTWFwV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1hcFdyYXBwZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgTWFwV3JhcHBlci5jcmVhdGVGcm9tU3RyaW5nTWFwID0gZnVuY3Rpb24gKHN0cmluZ01hcCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc3RyaW5nTWFwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnNldChwcm9wLCBzdHJpbmdNYXBbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgTWFwV3JhcHBlci5rZXlzID0gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIF9hcnJheUZyb21NYXAobSwgZmFsc2UpOyB9O1xuICAgICAgICBNYXBXcmFwcGVyLnZhbHVlcyA9IGZ1bmN0aW9uIChtKSB7IHJldHVybiBfYXJyYXlGcm9tTWFwKG0sIHRydWUpOyB9O1xuICAgICAgICByZXR1cm4gTWFwV3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFdyYXBzIEphdmFzY3JpcHQgT2JqZWN0c1xuICAgICAqL1xuICAgIHZhciBTdHJpbmdNYXBXcmFwcGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU3RyaW5nTWFwV3JhcHBlcigpIHtcbiAgICAgICAgfVxuICAgICAgICBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgICAgdmFyIG0gPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhtMSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgbVtrXSA9IG0xW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IE9iamVjdC5rZXlzKG0yKTsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBtW2tdID0gbTJba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfTtcbiAgICAgICAgU3RyaW5nTWFwV3JhcHBlci5lcXVhbHMgPSBmdW5jdGlvbiAobTEsIG0yKSB7XG4gICAgICAgICAgICB2YXIgazEgPSBPYmplY3Qua2V5cyhtMSk7XG4gICAgICAgICAgICB2YXIgazIgPSBPYmplY3Qua2V5cyhtMik7XG4gICAgICAgICAgICBpZiAoazEubGVuZ3RoICE9IGsyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgazEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gazFbaV07XG4gICAgICAgICAgICAgICAgaWYgKG0xW2tleV0gIT09IG0yW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU3RyaW5nTWFwV3JhcHBlcjtcbiAgICB9KCkpO1xuICAgIHZhciBMaXN0V3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIExpc3RXcmFwcGVyKCkge1xuICAgICAgICB9XG4gICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUFsbCA9IGZ1bmN0aW9uIChsaXN0LCBpdGVtcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihpdGVtc1tpXSk7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmUgPSBmdW5jdGlvbiAobGlzdCwgZWwpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihlbCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIExpc3RXcmFwcGVyLm1heGltdW0gPSBmdW5jdGlvbiAobGlzdCwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgICBpZiAobGlzdC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNvbHV0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBtYXhWYWx1ZSA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSBsaXN0W2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjYW5kaWRhdGVWYWx1ZSA9IHByZWRpY2F0ZShjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGVWYWx1ZSA+IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvbHV0aW9uID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IGNhbmRpZGF0ZVZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb2x1dGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgTGlzdFdyYXBwZXIuZmxhdHRlbiA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gW107XG4gICAgICAgICAgICBfZmxhdHRlbkFycmF5KGxpc3QsIHRhcmdldCk7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTGlzdFdyYXBwZXI7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfZmxhdHRlbkFycmF5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoc291cmNlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICBfZmxhdHRlbkFycmF5KGl0ZW0sIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICB2YXIgaXNQcm9taXNlID0gX2FuZ3VsYXJfY29yZS5fX2NvcmVfcHJpdmF0ZV9fLmlzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGlzRW1wdHlJbnB1dFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcnMgZm9yIHZhbGlkYXRvcnMgdG8gYmUgdXNlZCBmb3Ige0BsaW5rIEZvcm1Db250cm9sfXMgaW4gYSBmb3JtLlxuICAgICAqXG4gICAgICogUHJvdmlkZSB0aGlzIHVzaW5nIGBtdWx0aTogdHJ1ZWAgdG8gYWRkIHZhbGlkYXRvcnMuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGNvcmUvZm9ybXMvdHMvbmdfdmFsaWRhdG9ycy9uZ192YWxpZGF0b3JzLnRzIHJlZ2lvbj0nbmdfdmFsaWRhdG9ycyd9XG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOR19WQUxJREFUT1JTID0gbmV3IF9hbmd1bGFyX2NvcmUuT3BhcXVlVG9rZW4oJ05nVmFsaWRhdG9ycycpO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVycyBmb3IgYXN5bmNocm9ub3VzIHZhbGlkYXRvcnMgdG8gYmUgdXNlZCBmb3Ige0BsaW5rIEZvcm1Db250cm9sfXNcbiAgICAgKiBpbiBhIGZvcm0uXG4gICAgICpcbiAgICAgKiBQcm92aWRlIHRoaXMgdXNpbmcgYG11bHRpOiB0cnVlYCB0byBhZGQgdmFsaWRhdG9ycy5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgTkdfVkFMSURBVE9SU30gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTkdfQVNZTkNfVkFMSURBVE9SUyA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdOZ0FzeW5jVmFsaWRhdG9ycycpO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgc2V0IG9mIHZhbGlkYXRvcnMgdXNlZCBieSBmb3JtIGNvbnRyb2xzLlxuICAgICAqXG4gICAgICogQSB2YWxpZGF0b3IgaXMgYSBmdW5jdGlvbiB0aGF0IHByb2Nlc3NlcyBhIHtAbGluayBGb3JtQ29udHJvbH0gb3IgY29sbGVjdGlvbiBvZlxuICAgICAqIGNvbnRyb2xzIGFuZCByZXR1cm5zIGEgbWFwIG9mIGVycm9ycy4gQSBudWxsIG1hcCBtZWFucyB0aGF0IHZhbGlkYXRpb24gaGFzIHBhc3NlZC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdmFyIGxvZ2luQ29udHJvbCA9IG5ldyBGb3JtQ29udHJvbChcIlwiLCBWYWxpZGF0b3JzLnJlcXVpcmVkKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBWYWxpZGF0b3JzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gVmFsaWRhdG9ycygpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgY29udHJvbHMgdG8gaGF2ZSBhIG5vbi1lbXB0eSB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIFZhbGlkYXRvcnMucmVxdWlyZWQgPSBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRW1wdHlJbnB1dFZhbHVlKGNvbnRyb2wudmFsdWUpID8geyAncmVxdWlyZWQnOiB0cnVlIH0gOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgY29udHJvbHMgdG8gaGF2ZSBhIHZhbHVlIG9mIGEgbWluaW11bSBsZW5ndGguXG4gICAgICAgICAqL1xuICAgICAgICBWYWxpZGF0b3JzLm1pbkxlbmd0aCA9IGZ1bmN0aW9uIChtaW5MZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5SW5wdXRWYWx1ZShjb250cm9sLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gZG9uJ3QgdmFsaWRhdGUgZW1wdHkgdmFsdWVzIHRvIGFsbG93IG9wdGlvbmFsIGNvbnRyb2xzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSB0eXBlb2YgY29udHJvbC52YWx1ZSA9PT0gJ3N0cmluZycgPyBjb250cm9sLnZhbHVlLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCA8IG1pbkxlbmd0aCA/XG4gICAgICAgICAgICAgICAgICAgIHsgJ21pbmxlbmd0aCc6IHsgJ3JlcXVpcmVkTGVuZ3RoJzogbWluTGVuZ3RoLCAnYWN0dWFsTGVuZ3RoJzogbGVuZ3RoIH0gfSA6XG4gICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgY29udHJvbHMgdG8gaGF2ZSBhIHZhbHVlIG9mIGEgbWF4aW11bSBsZW5ndGguXG4gICAgICAgICAqL1xuICAgICAgICBWYWxpZGF0b3JzLm1heExlbmd0aCA9IGZ1bmN0aW9uIChtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSB0eXBlb2YgY29udHJvbC52YWx1ZSA9PT0gJ3N0cmluZycgPyBjb250cm9sLnZhbHVlLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aCA+IG1heExlbmd0aCA/XG4gICAgICAgICAgICAgICAgICAgIHsgJ21heGxlbmd0aCc6IHsgJ3JlcXVpcmVkTGVuZ3RoJzogbWF4TGVuZ3RoLCAnYWN0dWFsTGVuZ3RoJzogbGVuZ3RoIH0gfSA6XG4gICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgYSBjb250cm9sIHRvIG1hdGNoIGEgcmVnZXggdG8gaXRzIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgVmFsaWRhdG9ycy5wYXR0ZXJuID0gZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5SW5wdXRWYWx1ZShjb250cm9sLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gZG9uJ3QgdmFsaWRhdGUgZW1wdHkgdmFsdWVzIHRvIGFsbG93IG9wdGlvbmFsIGNvbnRyb2xzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoXCJeXCIgKyBwYXR0ZXJuICsgXCIkXCIpO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbnRyb2wudmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QodmFsdWUpID9cbiAgICAgICAgICAgICAgICAgICAgbnVsbCA6XG4gICAgICAgICAgICAgICAgICAgIHsgJ3BhdHRlcm4nOiB7ICdyZXF1aXJlZFBhdHRlcm4nOiBcIl5cIiArIHBhdHRlcm4gKyBcIiRcIiwgJ2FjdHVhbFZhbHVlJzogdmFsdWUgfSB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vLW9wIHZhbGlkYXRvci5cbiAgICAgICAgICovXG4gICAgICAgIFZhbGlkYXRvcnMubnVsbFZhbGlkYXRvciA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBudWxsOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9zZSBtdWx0aXBsZSB2YWxpZGF0b3JzIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB1bmlvblxuICAgICAgICAgKiBvZiB0aGUgaW5kaXZpZHVhbCBlcnJvciBtYXBzLlxuICAgICAgICAgKi9cbiAgICAgICAgVmFsaWRhdG9ycy5jb21wb3NlID0gZnVuY3Rpb24gKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdG9ycylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHZhciBwcmVzZW50VmFsaWRhdG9ycyA9IHZhbGlkYXRvcnMuZmlsdGVyKGlzUHJlc2VudCk7XG4gICAgICAgICAgICBpZiAocHJlc2VudFZhbGlkYXRvcnMubGVuZ3RoID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX21lcmdlRXJyb3JzKF9leGVjdXRlVmFsaWRhdG9ycyhjb250cm9sLCBwcmVzZW50VmFsaWRhdG9ycykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgVmFsaWRhdG9ycy5jb21wb3NlQXN5bmMgPSBmdW5jdGlvbiAodmFsaWRhdG9ycykge1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0b3JzKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdmFyIHByZXNlbnRWYWxpZGF0b3JzID0gdmFsaWRhdG9ycy5maWx0ZXIoaXNQcmVzZW50KTtcbiAgICAgICAgICAgIGlmIChwcmVzZW50VmFsaWRhdG9ycy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IF9leGVjdXRlQXN5bmNWYWxpZGF0b3JzKGNvbnRyb2wsIHByZXNlbnRWYWxpZGF0b3JzKS5tYXAoX2NvbnZlcnRUb1Byb21pc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihfbWVyZ2VFcnJvcnMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFZhbGlkYXRvcnM7XG4gICAgfSgpKTtcbiAgICBmdW5jdGlvbiBfY29udmVydFRvUHJvbWlzZShvYmopIHtcbiAgICAgICAgcmV0dXJuIGlzUHJvbWlzZShvYmopID8gb2JqIDogcnhqc19vcGVyYXRvcl90b1Byb21pc2UudG9Qcm9taXNlLmNhbGwob2JqKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2V4ZWN1dGVWYWxpZGF0b3JzKGNvbnRyb2wsIHZhbGlkYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcnMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2KGNvbnRyb2wpOyB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2V4ZWN1dGVBc3luY1ZhbGlkYXRvcnMoY29udHJvbCwgdmFsaWRhdG9ycykge1xuICAgICAgICByZXR1cm4gdmFsaWRhdG9ycy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYoY29udHJvbCk7IH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfbWVyZ2VFcnJvcnMoYXJyYXlPZkVycm9ycykge1xuICAgICAgICB2YXIgcmVzID0gYXJyYXlPZkVycm9ycy5yZWR1Y2UoZnVuY3Rpb24gKHJlcywgZXJyb3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KGVycm9ycykgPyBTdHJpbmdNYXBXcmFwcGVyLm1lcmdlKHJlcywgZXJyb3JzKSA6IHJlcztcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVzKS5sZW5ndGggPT09IDAgPyBudWxsIDogcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcHJvdmlkZSBhIHtAbGluayBDb250cm9sVmFsdWVBY2Nlc3Nvcn0gZm9yIGZvcm0gY29udHJvbHMuXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rIERlZmF1bHRWYWx1ZUFjY2Vzc29yfSBmb3IgaG93IHRvIGltcGxlbWVudCBvbmUuXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOR19WQUxVRV9BQ0NFU1NPUiA9IG5ldyBfYW5ndWxhcl9jb3JlLk9wYXF1ZVRva2VuKCdOZ1ZhbHVlQWNjZXNzb3InKTtcblxuICAgIHZhciBDSEVDS0JPWF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgYWNjZXNzb3IgZm9yIHdyaXRpbmcgYSB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgb24gYSBjaGVja2JveCBpbnB1dCBlbGVtZW50LlxuICAgICAqXG4gICAgICogICMjIyBFeGFtcGxlXG4gICAgICogIGBgYFxuICAgICAqICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmFtZT1cInJlbWVtYmVyTG9naW5cIiBuZ01vZGVsPlxuICAgICAqICBgYGBcbiAgICAgKlxuICAgICAqICBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnY2hlY2tlZCcsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uQ2hhbmdlID0gZm47IH07XG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMub25Ub3VjaGVkID0gZm47IH07XG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W3R5cGU9Y2hlY2tib3hdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1jaGVja2JveF1bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9Y2hlY2tib3hdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQuY2hlY2tlZCknLCAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbQ0hFQ0tCT1hfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIERFRkFVTFRfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIERlZmF1bHRWYWx1ZUFjY2Vzc29yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGFjY2Vzc29yIGZvciB3cml0aW5nIGEgdmFsdWUgYW5kIGxpc3RlbmluZyB0byBjaGFuZ2VzIHRoYXQgaXMgdXNlZCBieSB0aGVcbiAgICAgKiB7QGxpbmsgTmdNb2RlbH0sIHtAbGluayBGb3JtQ29udHJvbERpcmVjdGl2ZX0sIGFuZCB7QGxpbmsgRm9ybUNvbnRyb2xOYW1lfSBkaXJlY3RpdmVzLlxuICAgICAqXG4gICAgICogICMjIyBFeGFtcGxlXG4gICAgICogIGBgYFxuICAgICAqICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwic2VhcmNoUXVlcnlcIiBuZ01vZGVsPlxuICAgICAqICBgYGBcbiAgICAgKlxuICAgICAqICBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIERlZmF1bHRWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRGVmYXVsdFZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9XG4gICAgICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZFZhbHVlID0gaXNCbGFuayh2YWx1ZSkgPyAnJyA6IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgbm9ybWFsaXplZFZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vbkNoYW5nZSA9IGZuOyB9O1xuICAgICAgICBEZWZhdWx0VmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vblRvdWNoZWQgPSBmbjsgfTtcbiAgICAgICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dDpub3QoW3R5cGU9Y2hlY2tib3hdKVtmb3JtQ29udHJvbE5hbWVdLHRleHRhcmVhW2Zvcm1Db250cm9sTmFtZV0saW5wdXQ6bm90KFt0eXBlPWNoZWNrYm94XSlbZm9ybUNvbnRyb2xdLHRleHRhcmVhW2Zvcm1Db250cm9sXSxpbnB1dDpub3QoW3R5cGU9Y2hlY2tib3hdKVtuZ01vZGVsXSx0ZXh0YXJlYVtuZ01vZGVsXSxbbmdEZWZhdWx0Q29udHJvbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdnNhdmtpbiByZXBsYWNlIHRoZSBhYm92ZSBzZWxlY3RvciB3aXRoIHRoZSBvbmUgYmVsb3cgaXQgb25jZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMzAxMSBpcyBpbXBsZW1lbnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VsZWN0b3I6ICdbbmdDb250cm9sXSxbbmdNb2RlbF0sW25nRm9ybUNvbnRyb2xdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhpbnB1dCknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSknLCAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbREVGQVVMVF9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBEZWZhdWx0VmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gRGVmYXVsdFZhbHVlQWNjZXNzb3I7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVWYWxpZGF0b3IodmFsaWRhdG9yKSB7XG4gICAgICAgIGlmICh2YWxpZGF0b3IudmFsaWRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjKSB7IHJldHVybiB2YWxpZGF0b3IudmFsaWRhdGUoYyk7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdG9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUFzeW5jVmFsaWRhdG9yKHZhbGlkYXRvcikge1xuICAgICAgICBpZiAodmFsaWRhdG9yLnZhbGlkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYykgeyByZXR1cm4gdmFsaWRhdG9yLnZhbGlkYXRlKGMpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBOVU1CRVJfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE51bWJlclZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIGFjY2Vzc29yIGZvciB3cml0aW5nIGEgbnVtYmVyIHZhbHVlIGFuZCBsaXN0ZW5pbmcgdG8gY2hhbmdlcyB0aGF0IGlzIHVzZWQgYnkgdGhlXG4gICAgICoge0BsaW5rIE5nTW9kZWx9LCB7QGxpbmsgRm9ybUNvbnRyb2xEaXJlY3RpdmV9LCBhbmQge0BsaW5rIEZvcm1Db250cm9sTmFtZX0gZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqICAjIyMgRXhhbXBsZVxuICAgICAqICBgYGBcbiAgICAgKiAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBbKG5nTW9kZWwpXT1cImFnZVwiPlxuICAgICAqICBgYGBcbiAgICAgKi9cbiAgICB2YXIgTnVtYmVyVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE51bWJlclZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHsgfTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICB9XG4gICAgICAgIE51bWJlclZhbHVlQWNjZXNzb3IucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBuZWVkcyB0byBiZSBub3JtYWxpemVkIGZvciBJRTksIG90aGVyd2lzZSBpdCBpcyBzZXQgdG8gJ251bGwnIHdoZW4gbnVsbFxuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRWYWx1ZSA9IGlzQmxhbmsodmFsdWUpID8gJycgOiB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5vcm1hbGl6ZWRWYWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIE51bWJlclZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAodmFsdWUpIHsgZm4odmFsdWUgPT0gJycgPyBudWxsIDogcGFyc2VGbG9hdCh2YWx1ZSkpOyB9O1xuICAgICAgICB9O1xuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFt0eXBlPW51bWJlcl1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPW51bWJlcl1bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9bnVtYmVyXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKGlucHV0KSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyhibHVyKSc6ICdvblRvdWNoZWQoKSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtOVU1CRVJfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gTnVtYmVyVmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHVuaW1wbGVtZW50ZWQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5pbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGJhc2UgY2xhc3MgdGhhdCBhbGwgY29udHJvbCBkaXJlY3RpdmUgZXh0ZW5kLlxuICAgICAqIEl0IGJpbmRzIGEge0BsaW5rIEZvcm1Db250cm9sfSBvYmplY3QgdG8gYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIFVzZWQgaW50ZXJuYWxseSBieSBBbmd1bGFyIGZvcm1zLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBOZ0NvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMihOZ0NvbnRyb2wsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5nQ29udHJvbCgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3IgPSBudWxsO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcmF3VmFsaWRhdG9ycyA9IFtdO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbC5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5pbXBsZW1lbnRlZCgpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nQ29udHJvbC5wcm90b3R5cGUsIFwiYXN5bmNWYWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmltcGxlbWVudGVkKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gTmdDb250cm9sO1xuICAgIH0oQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlKSk7XG5cbiAgICB2YXIgUkFESU9fVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgY2xhc3MgdXNlZCBieSBBbmd1bGFyIHRvIHVuY2hlY2sgcmFkaW8gYnV0dG9ucyB3aXRoIHRoZSBtYXRjaGluZyBuYW1lLlxuICAgICAqL1xuICAgIHZhciBSYWRpb0NvbnRyb2xSZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJhZGlvQ29udHJvbFJlZ2lzdHJ5KCkge1xuICAgICAgICAgICAgdGhpcy5fYWNjZXNzb3JzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgUmFkaW9Db250cm9sUmVnaXN0cnkucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChjb250cm9sLCBhY2Nlc3Nvcikge1xuICAgICAgICAgICAgdGhpcy5fYWNjZXNzb3JzLnB1c2goW2NvbnRyb2wsIGFjY2Vzc29yXSk7XG4gICAgICAgIH07XG4gICAgICAgIFJhZGlvQ29udHJvbFJlZ2lzdHJ5LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoYWNjZXNzb3IpIHtcbiAgICAgICAgICAgIHZhciBpbmRleFRvUmVtb3ZlID0gLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2FjY2Vzc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hY2Nlc3NvcnNbaV1bMV0gPT09IGFjY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4VG9SZW1vdmUgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FjY2Vzc29ycy5zcGxpY2UoaW5kZXhUb1JlbW92ZSwgMSk7XG4gICAgICAgIH07XG4gICAgICAgIFJhZGlvQ29udHJvbFJlZ2lzdHJ5LnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoYWNjZXNzb3IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9hY2Nlc3NvcnMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faXNTYW1lR3JvdXAoYywgYWNjZXNzb3IpICYmIGNbMV0gIT09IGFjY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNbMV0uZmlyZVVuY2hlY2soYWNjZXNzb3IudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xSZWdpc3RyeS5wcm90b3R5cGUuX2lzU2FtZUdyb3VwID0gZnVuY3Rpb24gKGNvbnRyb2xQYWlyLCBhY2Nlc3Nvcikge1xuICAgICAgICAgICAgaWYgKCFjb250cm9sUGFpclswXS5jb250cm9sKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sUGFpclswXS5fcGFyZW50ID09PSBhY2Nlc3Nvci5fY29udHJvbC5fcGFyZW50ICYmXG4gICAgICAgICAgICAgICAgY29udHJvbFBhaXJbMV0ubmFtZSA9PT0gYWNjZXNzb3IubmFtZTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFkaW9Db250cm9sUmVnaXN0cnkuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBSYWRpb0NvbnRyb2xSZWdpc3RyeS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gUmFkaW9Db250cm9sUmVnaXN0cnk7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyAgV3JpdGVzIHJhZGlvIGNvbnRyb2wgdmFsdWVzIGFuZCBsaXN0ZW5zIHRvIHJhZGlvIGNvbnRyb2wgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIFVzZWQgYnkge0BsaW5rIE5nTW9kZWx9LCB7QGxpbmsgRm9ybUNvbnRyb2xEaXJlY3RpdmV9LCBhbmQge0BsaW5rIEZvcm1Db250cm9sTmFtZX1cbiAgICAgKiB0byBrZWVwIHRoZSB2aWV3IHN5bmNlZCB3aXRoIHRoZSB7QGxpbmsgRm9ybUNvbnRyb2x9IG1vZGVsLlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBJZiB5b3UgaGF2ZSBpbXBvcnRlZCB0aGUge0BsaW5rIEZvcm1zTW9kdWxlfSBvciB0aGUge0BsaW5rIFJlYWN0aXZlRm9ybXNNb2R1bGV9LCB0aGlzXG4gICAgICogdmFsdWUgYWNjZXNzb3Igd2lsbCBiZSBhY3RpdmUgb24gYW55IHJhZGlvIGNvbnRyb2wgdGhhdCBoYXMgYSBmb3JtIGRpcmVjdGl2ZS4gWW91IGRvXG4gICAgICogKipub3QqKiBuZWVkIHRvIGFkZCBhIHNwZWNpYWwgc2VsZWN0b3IgdG8gYWN0aXZhdGUgaXQuXG4gICAgICpcbiAgICAgKiAjIyMgSG93IHRvIHVzZSByYWRpbyBidXR0b25zIHdpdGggZm9ybSBkaXJlY3RpdmVzXG4gICAgICpcbiAgICAgKiBUbyB1c2UgcmFkaW8gYnV0dG9ucyBpbiBhIHRlbXBsYXRlLWRyaXZlbiBmb3JtLCB5b3UnbGwgd2FudCB0byBlbnN1cmUgdGhhdCByYWRpbyBidXR0b25zXG4gICAgICogaW4gdGhlIHNhbWUgZ3JvdXAgaGF2ZSB0aGUgc2FtZSBgbmFtZWAgYXR0cmlidXRlLiAgUmFkaW8gYnV0dG9ucyB3aXRoIGRpZmZlcmVudCBgbmFtZWBcbiAgICAgKiBhdHRyaWJ1dGVzIGRvIG5vdCBhZmZlY3QgZWFjaCBvdGhlci5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9yYWRpb0J1dHRvbnMvcmFkaW9fYnV0dG9uX2V4YW1wbGUudHMgcmVnaW9uPSdUZW1wbGF0ZURyaXZlbid9XG4gICAgICpcbiAgICAgKiBXaGVuIHVzaW5nIHJhZGlvIGJ1dHRvbnMgaW4gYSByZWFjdGl2ZSBmb3JtLCByYWRpbyBidXR0b25zIGluIHRoZSBzYW1lIGdyb3VwIHNob3VsZCBoYXZlIHRoZVxuICAgICAqIHNhbWUgYGZvcm1Db250cm9sTmFtZWAuIFlvdSBjYW4gYWxzbyBhZGQgYSBgbmFtZWAgYXR0cmlidXRlLCBidXQgaXQncyBvcHRpb25hbC5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9yZWFjdGl2ZVJhZGlvQnV0dG9ucy9yZWFjdGl2ZV9yYWRpb19idXR0b25fZXhhbXBsZS50cyByZWdpb249J1JlYWN0aXZlJ31cbiAgICAgKlxuICAgICAqICAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZiwgX3JlZ2lzdHJ5LCBfaW5qZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0cnkgPSBfcmVnaXN0cnk7XG4gICAgICAgICAgICB0aGlzLl9pbmplY3RvciA9IF9pbmplY3RvcjtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wgPSB0aGlzLl9pbmplY3Rvci5nZXQoTmdDb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrTmFtZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0cnkuYWRkKHRoaXMuX2NvbnRyb2wsIHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fcmVnaXN0cnkucmVtb3ZlKHRoaXMpOyB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IHZhbHVlID09PSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2NoZWNrZWQnLCB0aGlzLl9zdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl9mbiA9IGZuO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBmbihfdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlZ2lzdHJ5LnNlbGVjdChfdGhpcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5maXJlVW5jaGVjayA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB0aGlzLndyaXRlVmFsdWUodmFsdWUpOyB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLm9uVG91Y2hlZCA9IGZuOyB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fY2hlY2tOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmFtZSAmJiB0aGlzLmZvcm1Db250cm9sTmFtZSAmJiB0aGlzLm5hbWUgIT09IHRoaXMuZm9ybUNvbnRyb2xOYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dOYW1lRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5uYW1lICYmIHRoaXMuZm9ybUNvbnRyb2xOYW1lKVxuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMuZm9ybUNvbnRyb2xOYW1lO1xuICAgICAgICB9O1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fdGhyb3dOYW1lRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICBJZiB5b3UgZGVmaW5lIGJvdGggYSBuYW1lIGFuZCBhIGZvcm1Db250cm9sTmFtZSBhdHRyaWJ1dGUgb24geW91ciByYWRpbyBidXR0b24sIHRoZWlyIHZhbHVlc1xcbiAgICAgIG11c3QgbWF0Y2guIEV4OiA8aW5wdXQgdHlwZT1cXFwicmFkaW9cXFwiIGZvcm1Db250cm9sTmFtZT1cXFwiZm9vZFxcXCIgbmFtZT1cXFwiZm9vZFxcXCI+XFxuICAgIFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmFkaW9Db250cm9sVmFsdWVBY2Nlc3Nvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1yYWRpb11bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPXJhZGlvXVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1yYWRpb11bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKGNoYW5nZSknOiAnb25DaGFuZ2UoKScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtSQURJT19WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFJhZGlvQ29udHJvbFJlZ2lzdHJ5LCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdG9yLCB9LFxuICAgICAgICBdO1xuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgICAgICdmb3JtQ29udHJvbE5hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0IH0sXSxcbiAgICAgICAgICAgICd2YWx1ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIFNFTEVDVF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgZnVuY3Rpb24gX2J1aWxkVmFsdWVTdHJpbmcoaWQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0JsYW5rKGlkKSlcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgIGlmICghaXNQcmltaXRpdmUodmFsdWUpKVxuICAgICAgICAgICAgdmFsdWUgPSAnT2JqZWN0JztcbiAgICAgICAgcmV0dXJuIChpZCArIFwiOiBcIiArIHZhbHVlKS5zbGljZSgwLCA1MCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9leHRyYWN0SWQodmFsdWVTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlU3RyaW5nLnNwbGl0KCc6JylbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFdyaXRlcyB2YWx1ZXMgYW5kIGxpc3RlbnMgdG8gY2hhbmdlcyBvbiBhIHNlbGVjdCBlbGVtZW50LlxuICAgICAqXG4gICAgICogVXNlZCBieSB7QGxpbmsgTmdNb2RlbH0sIHtAbGluayBGb3JtQ29udHJvbERpcmVjdGl2ZX0sIGFuZCB7QGxpbmsgRm9ybUNvbnRyb2xOYW1lfVxuICAgICAqIHRvIGtlZXAgdGhlIHZpZXcgc3luY2VkIHdpdGggdGhlIHtAbGluayBGb3JtQ29udHJvbH0gbW9kZWwuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIElmIHlvdSBoYXZlIGltcG9ydGVkIHRoZSB7QGxpbmsgRm9ybXNNb2R1bGV9IG9yIHRoZSB7QGxpbmsgUmVhY3RpdmVGb3Jtc01vZHVsZX0sIHRoaXNcbiAgICAgKiB2YWx1ZSBhY2Nlc3NvciB3aWxsIGJlIGFjdGl2ZSBvbiBhbnkgc2VsZWN0IGNvbnRyb2wgdGhhdCBoYXMgYSBmb3JtIGRpcmVjdGl2ZS4gWW91IGRvXG4gICAgICogKipub3QqKiBuZWVkIHRvIGFkZCBhIHNwZWNpYWwgc2VsZWN0b3IgdG8gYWN0aXZhdGUgaXQuXG4gICAgICpcbiAgICAgKiAjIyMgSG93IHRvIHVzZSBzZWxlY3QgY29udHJvbHMgd2l0aCBmb3JtIGRpcmVjdGl2ZXNcbiAgICAgKlxuICAgICAqIFRvIHVzZSBhIHNlbGVjdCBpbiBhIHRlbXBsYXRlLWRyaXZlbiBmb3JtLCBzaW1wbHkgYWRkIGFuIGBuZ01vZGVsYCBhbmQgYSBgbmFtZWBcbiAgICAgKiBhdHRyaWJ1dGUgdG8gdGhlIG1haW4gYDxzZWxlY3Q+YCB0YWcuXG4gICAgICpcbiAgICAgKiBJZiB5b3VyIG9wdGlvbiB2YWx1ZXMgYXJlIHNpbXBsZSBzdHJpbmdzLCB5b3UgY2FuIGJpbmQgdG8gdGhlIG5vcm1hbCBgdmFsdWVgIHByb3BlcnR5XG4gICAgICogb24gdGhlIG9wdGlvbi4gIElmIHlvdXIgb3B0aW9uIHZhbHVlcyBoYXBwZW4gdG8gYmUgb2JqZWN0cyAoYW5kIHlvdSdkIGxpa2UgdG8gc2F2ZSB0aGVcbiAgICAgKiBzZWxlY3Rpb24gaW4geW91ciBmb3JtIGFzIGFuIG9iamVjdCksIHVzZSBgbmdWYWx1ZWAgaW5zdGVhZDpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zZWxlY3RDb250cm9sL3NlbGVjdF9jb250cm9sX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogSW4gcmVhY3RpdmUgZm9ybXMsIHlvdSdsbCBhbHNvIHdhbnQgdG8gYWRkIHlvdXIgZm9ybSBkaXJlY3RpdmUgKGBmb3JtQ29udHJvbE5hbWVgIG9yXG4gICAgICogYGZvcm1Db250cm9sYCkgb24gdGhlIG1haW4gYDxzZWxlY3Q+YCB0YWcuIExpa2UgaW4gdGhlIGZvcm1lciBleGFtcGxlLCB5b3UgaGF2ZSB0aGVcbiAgICAgKiBjaG9pY2Ugb2YgYmluZGluZyB0byB0aGUgIGB2YWx1ZWAgb3IgYG5nVmFsdWVgIHByb3BlcnR5IG9uIHRoZSBzZWxlY3QncyBvcHRpb25zLlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL3JlYWN0aXZlU2VsZWN0Q29udHJvbC9yZWFjdGl2ZV9zZWxlY3RfY29udHJvbF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIE5vdGU6IFdlIGxpc3RlbiB0byB0aGUgJ2NoYW5nZScgZXZlbnQgYmVjYXVzZSAnaW5wdXQnIGV2ZW50cyBhcmVuJ3QgZmlyZWRcbiAgICAgKiBmb3Igc2VsZWN0cyBpbiBGaXJlZm94IGFuZCBJRTpcbiAgICAgKiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMDI0MzUwXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvNDY2MDA0NS9cbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IoX3JlbmRlcmVyLCBfZWxlbWVudFJlZikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25NYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICB0aGlzLl9pZENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgfVxuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdmFyIHZhbHVlU3RyaW5nID0gX2J1aWxkVmFsdWVTdHJpbmcodGhpcy5fZ2V0T3B0aW9uSWQodmFsdWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndmFsdWUnLCB2YWx1ZVN0cmluZyk7XG4gICAgICAgIH07XG4gICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uICh2YWx1ZVN0cmluZykge1xuICAgICAgICAgICAgICAgIF90aGlzLnZhbHVlID0gdmFsdWVTdHJpbmc7XG4gICAgICAgICAgICAgICAgZm4oX3RoaXMuX2dldE9wdGlvblZhbHVlKHZhbHVlU3RyaW5nKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vblRvdWNoZWQgPSBmbjsgfTtcbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLl9yZWdpc3Rlck9wdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLl9pZENvdW50ZXIrKykudG9TdHJpbmcoKTsgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX2dldE9wdGlvbklkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gTWFwV3JhcHBlci5rZXlzKHRoaXMuX29wdGlvbk1hcCk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGlmIChsb29zZUlkZW50aWNhbCh0aGlzLl9vcHRpb25NYXAuZ2V0KGlkKSwgdmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuX2dldE9wdGlvblZhbHVlID0gZnVuY3Rpb24gKHZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9vcHRpb25NYXAuZ2V0KF9leHRyYWN0SWQodmFsdWVTdHJpbmcpKTtcbiAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodmFsdWUpID8gdmFsdWUgOiB2YWx1ZVN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ3NlbGVjdDpub3QoW211bHRpcGxlXSlbZm9ybUNvbnRyb2xOYW1lXSxzZWxlY3Q6bm90KFttdWx0aXBsZV0pW2Zvcm1Db250cm9sXSxzZWxlY3Q6bm90KFttdWx0aXBsZV0pW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJywgJyhibHVyKSc6ICdvblRvdWNoZWQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1NFTEVDVF9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBNYXJrcyBgPG9wdGlvbj5gIGFzIGR5bmFtaWMsIHNvIEFuZ3VsYXIgY2FuIGJlIG5vdGlmaWVkIHdoZW4gb3B0aW9ucyBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFNlZSBkb2NzIGZvciB7QGxpbmsgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3J9IGZvciB1c2FnZSBleGFtcGxlcy5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdTZWxlY3RPcHRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBOZ1NlbGVjdE9wdGlvbihfZWxlbWVudCwgX3JlbmRlcmVyLCBfc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdCA9IF9zZWxlY3Q7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX3NlbGVjdCkpXG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMuX3NlbGVjdC5fcmVnaXN0ZXJPcHRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTZWxlY3RPcHRpb24ucHJvdG90eXBlLCBcIm5nVmFsdWVcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3QuX29wdGlvbk1hcC5zZXQodGhpcy5pZCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZShfYnVpbGRWYWx1ZVN0cmluZyh0aGlzLmlkLCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU2VsZWN0T3B0aW9uLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9zZWxlY3QpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTmdTZWxlY3RPcHRpb24ucHJvdG90eXBlLl9zZXRFbGVtZW50VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdTZWxlY3RPcHRpb24ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9zZWxlY3QpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0Ll9vcHRpb25NYXAuZGVsZXRlKHRoaXMuaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE5nU2VsZWN0T3B0aW9uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ29wdGlvbicgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ1NlbGVjdE9wdGlvbi5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgTmdTZWxlY3RPcHRpb24ucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdWYWx1ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdWYWx1ZScsXSB9LF0sXG4gICAgICAgICAgICAndmFsdWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ3ZhbHVlJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nU2VsZWN0T3B0aW9uO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgU0VMRUNUX01VTFRJUExFX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yOyB9KSxcbiAgICAgICAgbXVsdGk6IHRydWVcbiAgICB9O1xuICAgIGZ1bmN0aW9uIF9idWlsZFZhbHVlU3RyaW5nJDEoaWQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0JsYW5rKGlkKSlcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdmFsdWUgPSBcIidcIiArIHZhbHVlICsgXCInXCI7XG4gICAgICAgIGlmICghaXNQcmltaXRpdmUodmFsdWUpKVxuICAgICAgICAgICAgdmFsdWUgPSAnT2JqZWN0JztcbiAgICAgICAgcmV0dXJuIChpZCArIFwiOiBcIiArIHZhbHVlKS5zbGljZSgwLCA1MCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9leHRyYWN0SWQkMSh2YWx1ZVN0cmluZykge1xuICAgICAgICByZXR1cm4gdmFsdWVTdHJpbmcuc3BsaXQoJzonKVswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFjY2Vzc29yIGZvciB3cml0aW5nIGEgdmFsdWUgYW5kIGxpc3RlbmluZyB0byBjaGFuZ2VzIG9uIGEgc2VsZWN0IGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5faWRDb3VudGVyID0gMDtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoXykgeyB9O1xuICAgICAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH1cbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdmFsdWVzIHRvIGlkc1xuICAgICAgICAgICAgdmFyIGlkcyA9IHZhbHVlcy5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLl9nZXRPcHRpb25JZCh2KTsgfSk7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25NYXAuZm9yRWFjaChmdW5jdGlvbiAob3B0LCBvKSB7IG9wdC5fc2V0U2VsZWN0ZWQoaWRzLmluZGV4T2Yoby50b1N0cmluZygpKSA+IC0xKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IucHJvdG90eXBlLnJlZ2lzdGVyT25DaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoXy5oYXNPd25Qcm9wZXJ0eSgnc2VsZWN0ZWRPcHRpb25zJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBfLnNlbGVjdGVkT3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0ID0gb3B0aW9ucy5pdGVtKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IF90aGlzLl9nZXRPcHRpb25WYWx1ZShvcHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IF8ub3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0ID0gb3B0aW9ucy5pdGVtKGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdC5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfdGhpcy5fZ2V0T3B0aW9uVmFsdWUob3B0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZC5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm4oc2VsZWN0ZWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5vblRvdWNoZWQgPSBmbjsgfTtcbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fcmVnaXN0ZXJPcHRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBpZCA9ICh0aGlzLl9pZENvdW50ZXIrKykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbk1hcC5zZXQoaWQsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fZ2V0T3B0aW9uSWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBNYXBXcmFwcGVyLmtleXModGhpcy5fb3B0aW9uTWFwKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKGxvb3NlSWRlbnRpY2FsKHRoaXMuX29wdGlvbk1hcC5nZXQoaWQpLl92YWx1ZSwgdmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLnByb3RvdHlwZS5fZ2V0T3B0aW9uVmFsdWUgPSBmdW5jdGlvbiAodmFsdWVTdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBvcHQgPSB0aGlzLl9vcHRpb25NYXAuZ2V0KF9leHRyYWN0SWQkMSh2YWx1ZVN0cmluZykpO1xuICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudChvcHQpID8gb3B0Ll92YWx1ZSA6IHZhbHVlU3RyaW5nO1xuICAgICAgICB9O1xuICAgICAgICBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWxlY3RbbXVsdGlwbGVdW2Zvcm1Db250cm9sTmFtZV0sc2VsZWN0W211bHRpcGxlXVtmb3JtQ29udHJvbF0sc2VsZWN0W211bHRpcGxlXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0KScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtTRUxFQ1RfTVVMVElQTEVfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvci5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCB9LFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIE1hcmtzIGA8b3B0aW9uPmAgYXMgZHluYW1pYywgc28gQW5ndWxhciBjYW4gYmUgbm90aWZpZWQgd2hlbiBvcHRpb25zIGNoYW5nZS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8c2VsZWN0IG11bHRpcGxlIG5hbWU9XCJjaXR5XCIgbmdNb2RlbD5cbiAgICAgKiAgIDxvcHRpb24gKm5nRm9yPVwibGV0IGMgb2YgY2l0aWVzXCIgW3ZhbHVlXT1cImNcIj48L29wdGlvbj5cbiAgICAgKiA8L3NlbGVjdD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB2YXIgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24oX2VsZW1lbnQsIF9yZW5kZXJlciwgX3NlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3QgPSBfc2VsZWN0O1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLl9zZWxlY3QpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMuX3NlbGVjdC5fcmVnaXN0ZXJPcHRpb24odGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nU2VsZWN0TXVsdGlwbGVPcHRpb24ucHJvdG90eXBlLCBcIm5nVmFsdWVcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2VsZWN0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZShfYnVpbGRWYWx1ZVN0cmluZyQxKHRoaXMuaWQsIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0LndyaXRlVmFsdWUodGhpcy5fc2VsZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX3NlbGVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKF9idWlsZFZhbHVlU3RyaW5nJDEodGhpcy5pZCwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0LndyaXRlVmFsdWUodGhpcy5fc2VsZWN0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbi5wcm90b3R5cGUuX3NldEVsZW1lbnRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24ucHJvdG90eXBlLl9zZXRTZWxlY3RlZCA9IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFByb3BlcnR5KHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ3NlbGVjdGVkJywgc2VsZWN0ZWQpO1xuICAgICAgICB9O1xuICAgICAgICBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fc2VsZWN0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdC5fb3B0aW9uTWFwLmRlbGV0ZSh0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ29wdGlvbicgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIE5nU2VsZWN0TXVsdGlwbGVPcHRpb24ucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmdWYWx1ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdWYWx1ZScsXSB9LF0sXG4gICAgICAgICAgICAndmFsdWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ3ZhbHVlJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nU2VsZWN0TXVsdGlwbGVPcHRpb247XG4gICAgfSgpKTtcblxuICAgIGZ1bmN0aW9uIGNvbnRyb2xQYXRoKG5hbWUsIHBhcmVudCkge1xuICAgICAgICByZXR1cm4gcGFyZW50LnBhdGguY29uY2F0KFtuYW1lXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFVwQ29udHJvbChjb250cm9sLCBkaXIpIHtcbiAgICAgICAgaWYgKCFjb250cm9sKVxuICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnQ2Fubm90IGZpbmQgY29udHJvbCB3aXRoJyk7XG4gICAgICAgIGlmICghZGlyLnZhbHVlQWNjZXNzb3IpXG4gICAgICAgICAgICBfdGhyb3dFcnJvcihkaXIsICdObyB2YWx1ZSBhY2Nlc3NvciBmb3IgZm9ybSBjb250cm9sIHdpdGgnKTtcbiAgICAgICAgY29udHJvbC52YWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2UoW2NvbnRyb2wudmFsaWRhdG9yLCBkaXIudmFsaWRhdG9yXSk7XG4gICAgICAgIGNvbnRyb2wuYXN5bmNWYWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2VBc3luYyhbY29udHJvbC5hc3luY1ZhbGlkYXRvciwgZGlyLmFzeW5jVmFsaWRhdG9yXSk7XG4gICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLndyaXRlVmFsdWUoY29udHJvbC52YWx1ZSk7XG4gICAgICAgIC8vIHZpZXcgLT4gbW9kZWxcbiAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3IucmVnaXN0ZXJPbkNoYW5nZShmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGRpci52aWV3VG9Nb2RlbFVwZGF0ZShuZXdWYWx1ZSk7XG4gICAgICAgICAgICBjb250cm9sLm1hcmtBc0RpcnR5KCk7XG4gICAgICAgICAgICBjb250cm9sLnNldFZhbHVlKG5ld1ZhbHVlLCB7IGVtaXRNb2RlbFRvVmlld0NoYW5nZTogZmFsc2UgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0b3VjaGVkXG4gICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLnJlZ2lzdGVyT25Ub3VjaGVkKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2wubWFya0FzVG91Y2hlZCgpOyB9KTtcbiAgICAgICAgY29udHJvbC5yZWdpc3Rlck9uQ2hhbmdlKGZ1bmN0aW9uIChuZXdWYWx1ZSwgZW1pdE1vZGVsRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIGNvbnRyb2wgLT4gdmlld1xuICAgICAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3Iud3JpdGVWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICAgICAgICAvLyBjb250cm9sIC0+IG5nTW9kZWxcbiAgICAgICAgICAgIGlmIChlbWl0TW9kZWxFdmVudClcbiAgICAgICAgICAgICAgICBkaXIudmlld1RvTW9kZWxVcGRhdGUobmV3VmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRpci52YWx1ZUFjY2Vzc29yLnNldERpc2FibGVkU3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnRyb2wucmVnaXN0ZXJPbkRpc2FibGVkQ2hhbmdlKGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7IGRpci52YWx1ZUFjY2Vzc29yLnNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlLXJ1biB2YWxpZGF0aW9uIHdoZW4gdmFsaWRhdG9yIGJpbmRpbmcgY2hhbmdlcywgZS5nLiBtaW5sZW5ndGg9MyAtPiBtaW5sZW5ndGg9NFxuICAgICAgICBkaXIuX3Jhd1ZhbGlkYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UpXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZGlyLl9yYXdBc3luY1ZhbGlkYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBpZiAodmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UpXG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xlYW5VcENvbnRyb2woY29udHJvbCwgZGlyKSB7XG4gICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLnJlZ2lzdGVyT25DaGFuZ2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gX25vQ29udHJvbEVycm9yKGRpcik7IH0pO1xuICAgICAgICBkaXIudmFsdWVBY2Nlc3Nvci5yZWdpc3Rlck9uVG91Y2hlZChmdW5jdGlvbiAoKSB7IHJldHVybiBfbm9Db250cm9sRXJyb3IoZGlyKTsgfSk7XG4gICAgICAgIGRpci5fcmF3VmFsaWRhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWxpZGF0b3IpIHsgcmV0dXJuIHZhbGlkYXRvci5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKG51bGwpOyB9KTtcbiAgICAgICAgZGlyLl9yYXdBc3luY1ZhbGlkYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAodmFsaWRhdG9yKSB7IHJldHVybiB2YWxpZGF0b3IucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShudWxsKTsgfSk7XG4gICAgICAgIGlmIChjb250cm9sKVxuICAgICAgICAgICAgY29udHJvbC5fY2xlYXJDaGFuZ2VGbnMoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VXBGb3JtQ29udGFpbmVyKGNvbnRyb2wsIGRpcikge1xuICAgICAgICBpZiAoaXNCbGFuayhjb250cm9sKSlcbiAgICAgICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ0Nhbm5vdCBmaW5kIGNvbnRyb2wgd2l0aCcpO1xuICAgICAgICBjb250cm9sLnZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZShbY29udHJvbC52YWxpZGF0b3IsIGRpci52YWxpZGF0b3JdKTtcbiAgICAgICAgY29udHJvbC5hc3luY1ZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZUFzeW5jKFtjb250cm9sLmFzeW5jVmFsaWRhdG9yLCBkaXIuYXN5bmNWYWxpZGF0b3JdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX25vQ29udHJvbEVycm9yKGRpcikge1xuICAgICAgICByZXR1cm4gX3Rocm93RXJyb3IoZGlyLCAnVGhlcmUgaXMgbm8gRm9ybUNvbnRyb2wgaW5zdGFuY2UgYXR0YWNoZWQgdG8gZm9ybSBjb250cm9sIGVsZW1lbnQgd2l0aCcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfdGhyb3dFcnJvcihkaXIsIG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VFbmQ7XG4gICAgICAgIGlmIChkaXIucGF0aC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBtZXNzYWdlRW5kID0gXCJwYXRoOiAnXCIgKyBkaXIucGF0aC5qb2luKCcgLT4gJykgKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXIucGF0aFswXSkge1xuICAgICAgICAgICAgbWVzc2FnZUVuZCA9IFwibmFtZTogJ1wiICsgZGlyLnBhdGggKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2VFbmQgPSAndW5zcGVjaWZpZWQgbmFtZSBhdHRyaWJ1dGUnO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlICsgXCIgXCIgKyBtZXNzYWdlRW5kKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcG9zZVZhbGlkYXRvcnModmFsaWRhdG9ycykge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHZhbGlkYXRvcnMpID8gVmFsaWRhdG9ycy5jb21wb3NlKHZhbGlkYXRvcnMubWFwKG5vcm1hbGl6ZVZhbGlkYXRvcikpIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh2YWxpZGF0b3JzKSB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodmFsaWRhdG9ycykgPyBWYWxpZGF0b3JzLmNvbXBvc2VBc3luYyh2YWxpZGF0b3JzLm1hcChub3JtYWxpemVBc3luY1ZhbGlkYXRvcikpIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHZpZXdNb2RlbCkge1xuICAgICAgICBpZiAoIWNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ21vZGVsJykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzWydtb2RlbCddO1xuICAgICAgICBpZiAoY2hhbmdlLmlzRmlyc3RDaGFuZ2UoKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gIWxvb3NlSWRlbnRpY2FsKHZpZXdNb2RlbCwgY2hhbmdlLmN1cnJlbnRWYWx1ZSk7XG4gICAgfVxuICAgIHZhciBCVUlMVElOX0FDQ0VTU09SUyA9IFtcbiAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgTnVtYmVyVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgICAgIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgXTtcbiAgICBmdW5jdGlvbiBpc0J1aWx0SW5BY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yKSB7XG4gICAgICAgIHJldHVybiBCVUlMVElOX0FDQ0VTU09SUy5zb21lKGZ1bmN0aW9uIChhKSB7IHJldHVybiB2YWx1ZUFjY2Vzc29yLmNvbnN0cnVjdG9yID09PSBhOyB9KTtcbiAgICB9XG4gICAgLy8gVE9ETzogdnNhdmtpbiByZW1vdmUgaXQgb25jZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8zMDExIGlzIGltcGxlbWVudGVkXG4gICAgZnVuY3Rpb24gc2VsZWN0VmFsdWVBY2Nlc3NvcihkaXIsIHZhbHVlQWNjZXNzb3JzKSB7XG4gICAgICAgIGlmICghdmFsdWVBY2Nlc3NvcnMpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGRlZmF1bHRBY2Nlc3NvcjtcbiAgICAgICAgdmFyIGJ1aWx0aW5BY2Nlc3NvcjtcbiAgICAgICAgdmFyIGN1c3RvbUFjY2Vzc29yO1xuICAgICAgICB2YWx1ZUFjY2Vzc29ycy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICBpZiAodi5jb25zdHJ1Y3RvciA9PT0gRGVmYXVsdFZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0QWNjZXNzb3IgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNCdWlsdEluQWNjZXNzb3IodikpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVpbHRpbkFjY2Vzc29yKVxuICAgICAgICAgICAgICAgICAgICBfdGhyb3dFcnJvcihkaXIsICdNb3JlIHRoYW4gb25lIGJ1aWx0LWluIHZhbHVlIGFjY2Vzc29yIG1hdGNoZXMgZm9ybSBjb250cm9sIHdpdGgnKTtcbiAgICAgICAgICAgICAgICBidWlsdGluQWNjZXNzb3IgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbUFjY2Vzc29yKVxuICAgICAgICAgICAgICAgICAgICBfdGhyb3dFcnJvcihkaXIsICdNb3JlIHRoYW4gb25lIGN1c3RvbSB2YWx1ZSBhY2Nlc3NvciBtYXRjaGVzIGZvcm0gY29udHJvbCB3aXRoJyk7XG4gICAgICAgICAgICAgICAgY3VzdG9tQWNjZXNzb3IgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN1c3RvbUFjY2Vzc29yKVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUFjY2Vzc29yO1xuICAgICAgICBpZiAoYnVpbHRpbkFjY2Vzc29yKVxuICAgICAgICAgICAgcmV0dXJuIGJ1aWx0aW5BY2Nlc3NvcjtcbiAgICAgICAgaWYgKGRlZmF1bHRBY2Nlc3NvcilcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0QWNjZXNzb3I7XG4gICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ05vIHZhbGlkIHZhbHVlIGFjY2Vzc29yIGZvciBmb3JtIGNvbnRyb2wgd2l0aCcpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBiYXNlIGNsYXNzIGZvciBjb2RlIHNoYXJlZCBiZXR3ZWVuIHtAbGluayBOZ01vZGVsR3JvdXB9IGFuZCB7QGxpbmsgRm9ybUdyb3VwTmFtZX0uXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSgpIHtcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFyZW50VHlwZSgpO1xuICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLmFkZEZvcm1Hcm91cCh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybURpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS5yZW1vdmVGb3JtR3JvdXAodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUge0BsaW5rIEZvcm1Hcm91cH0gYmFja2luZyB0aGlzIGJpbmRpbmcuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtRGlyZWN0aXZlLmdldEZvcm1Hcm91cCh0aGlzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgcGF0aCB0byB0aGlzIGNvbnRyb2wgZ3JvdXAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbFBhdGgodGhpcy5uYW1lLCB0aGlzLl9wYXJlbnQpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSB7QGxpbmsgRm9ybX0gdG8gd2hpY2ggdGhpcyBncm91cCBiZWxvbmdzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5mb3JtRGlyZWN0aXZlIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zZVZhbGlkYXRvcnModGhpcy5fdmFsaWRhdG9ycyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImFzeW5jVmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyh0aGlzLl9hc3luY1ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuX2NoZWNrUGFyZW50VHlwZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlO1xuICAgIH0oQ29udHJvbENvbnRhaW5lcikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBBYnN0cmFjdENvbnRyb2xTdGF0dXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBBYnN0cmFjdENvbnRyb2xTdGF0dXMoY2QpIHtcbiAgICAgICAgICAgIHRoaXMuX2NkID0gY2Q7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1VudG91Y2hlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuX2NkLmNvbnRyb2wpID8gdGhpcy5fY2QuY29udHJvbC51bnRvdWNoZWQgOiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sU3RhdHVzLnByb3RvdHlwZSwgXCJuZ0NsYXNzVG91Y2hlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuX2NkLmNvbnRyb2wpID8gdGhpcy5fY2QuY29udHJvbC50b3VjaGVkIDogZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1ByaXN0aW5lXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5fY2QuY29udHJvbCkgPyB0aGlzLl9jZC5jb250cm9sLnByaXN0aW5lIDogZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc0RpcnR5XCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5fY2QuY29udHJvbCkgPyB0aGlzLl9jZC5jb250cm9sLmRpcnR5IDogZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc1ZhbGlkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5fY2QuY29udHJvbCkgPyB0aGlzLl9jZC5jb250cm9sLnZhbGlkIDogZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbFN0YXR1cy5wcm90b3R5cGUsIFwibmdDbGFzc0ludmFsaWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLl9jZC5jb250cm9sKSA/IHRoaXMuX2NkLmNvbnRyb2wuaW52YWxpZCA6IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBBYnN0cmFjdENvbnRyb2xTdGF0dXM7XG4gICAgfSgpKTtcbiAgICB2YXIgbmdDb250cm9sU3RhdHVzSG9zdCA9IHtcbiAgICAgICAgJ1tjbGFzcy5uZy11bnRvdWNoZWRdJzogJ25nQ2xhc3NVbnRvdWNoZWQnLFxuICAgICAgICAnW2NsYXNzLm5nLXRvdWNoZWRdJzogJ25nQ2xhc3NUb3VjaGVkJyxcbiAgICAgICAgJ1tjbGFzcy5uZy1wcmlzdGluZV0nOiAnbmdDbGFzc1ByaXN0aW5lJyxcbiAgICAgICAgJ1tjbGFzcy5uZy1kaXJ0eV0nOiAnbmdDbGFzc0RpcnR5JyxcbiAgICAgICAgJ1tjbGFzcy5uZy12YWxpZF0nOiAnbmdDbGFzc1ZhbGlkJyxcbiAgICAgICAgJ1tjbGFzcy5uZy1pbnZhbGlkXSc6ICduZ0NsYXNzSW52YWxpZCdcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpcmVjdGl2ZSBhdXRvbWF0aWNhbGx5IGFwcGxpZWQgdG8gQW5ndWxhciBmb3JtIGNvbnRyb2xzIHRoYXQgc2V0cyBDU1MgY2xhc3Nlc1xuICAgICAqIGJhc2VkIG9uIGNvbnRyb2wgc3RhdHVzICh2YWxpZC9pbnZhbGlkL2RpcnR5L2V0YykuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nQ29udHJvbFN0YXR1cyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQzKE5nQ29udHJvbFN0YXR1cywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmdDb250cm9sU3RhdHVzKGNkKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBjZCk7XG4gICAgICAgIH1cbiAgICAgICAgTmdDb250cm9sU3RhdHVzLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tmb3JtQ29udHJvbE5hbWVdLFtuZ01vZGVsXSxbZm9ybUNvbnRyb2xdJywgaG9zdDogbmdDb250cm9sU3RhdHVzSG9zdCB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nQ29udHJvbFN0YXR1cy5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBOZ0NvbnRyb2xTdGF0dXM7XG4gICAgfShBYnN0cmFjdENvbnRyb2xTdGF0dXMpKTtcbiAgICAvKipcbiAgICAgKiBEaXJlY3RpdmUgYXV0b21hdGljYWxseSBhcHBsaWVkIHRvIEFuZ3VsYXIgZm9ybSBncm91cHMgdGhhdCBzZXRzIENTUyBjbGFzc2VzXG4gICAgICogYmFzZWQgb24gY29udHJvbCBzdGF0dXMgKHZhbGlkL2ludmFsaWQvZGlydHkvZXRjKS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdDb250cm9sU3RhdHVzR3JvdXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMyhOZ0NvbnRyb2xTdGF0dXNHcm91cCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmdDb250cm9sU3RhdHVzR3JvdXAoY2QpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGNkKTtcbiAgICAgICAgfVxuICAgICAgICBOZ0NvbnRyb2xTdGF0dXNHcm91cC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Zvcm1Hcm91cE5hbWVdLFtmb3JtQXJyYXlOYW1lXSxbbmdNb2RlbEdyb3VwXSxbZm9ybUdyb3VwXSxmb3JtOm5vdChbbmdOb0Zvcm1dKSxbbmdGb3JtXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBuZ0NvbnRyb2xTdGF0dXNIb3N0XG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdDb250cm9sU3RhdHVzR3JvdXAuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIE5nQ29udHJvbFN0YXR1c0dyb3VwO1xuICAgIH0oQWJzdHJhY3RDb250cm9sU3RhdHVzKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ1ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXNlIGJ5IGRpcmVjdGl2ZXMgYW5kIGNvbXBvbmVudHMgdG8gZW1pdCBjdXN0b20gRXZlbnRzLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVzXG4gICAgICpcbiAgICAgKiBJbiB0aGUgZm9sbG93aW5nIGV4YW1wbGUsIGBaaXBweWAgYWx0ZXJuYXRpdmVseSBlbWl0cyBgb3BlbmAgYW5kIGBjbG9zZWAgZXZlbnRzIHdoZW4gaXRzXG4gICAgICogdGl0bGUgZ2V0cyBjbGlja2VkOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ3ppcHB5JyxcbiAgICAgKiAgIHRlbXBsYXRlOiBgXG4gICAgICogICA8ZGl2IGNsYXNzPVwiemlwcHlcIj5cbiAgICAgKiAgICAgPGRpdiAoY2xpY2spPVwidG9nZ2xlKClcIj5Ub2dnbGU8L2Rpdj5cbiAgICAgKiAgICAgPGRpdiBbaGlkZGVuXT1cIiF2aXNpYmxlXCI+XG4gICAgICogICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAqICAgICA8L2Rpdj5cbiAgICAgKiAgPC9kaXY+YH0pXG4gICAgICogZXhwb3J0IGNsYXNzIFppcHB5IHtcbiAgICAgKiAgIHZpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuICAgICAqICAgQE91dHB1dCgpIG9wZW46IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAqICAgQE91dHB1dCgpIGNsb3NlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgKlxuICAgICAqICAgdG9nZ2xlKCkge1xuICAgICAqICAgICB0aGlzLnZpc2libGUgPSAhdGhpcy52aXNpYmxlO1xuICAgICAqICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICogICAgICAgdGhpcy5vcGVuLmVtaXQobnVsbCk7XG4gICAgICogICAgIH0gZWxzZSB7XG4gICAgICogICAgICAgdGhpcy5jbG9zZS5lbWl0KG51bGwpO1xuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlIGV2ZW50cyBwYXlsb2FkIGNhbiBiZSBhY2Nlc3NlZCBieSB0aGUgcGFyYW1ldGVyIGAkZXZlbnRgIG9uIHRoZSBjb21wb25lbnRzIG91dHB1dCBldmVudFxuICAgICAqIGhhbmRsZXI6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8emlwcHkgKG9wZW4pPVwib25PcGVuKCRldmVudClcIiAoY2xvc2UpPVwib25DbG9zZSgkZXZlbnQpXCI+PC96aXBweT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFVzZXMgUnguT2JzZXJ2YWJsZSBidXQgcHJvdmlkZXMgYW4gYWRhcHRlciB0byBtYWtlIGl0IHdvcmsgYXMgc3BlY2lmaWVkIGhlcmU6XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2podXNhaW4vb2JzZXJ2YWJsZS1zcGVjXG4gICAgICpcbiAgICAgKiBPbmNlIGEgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBzcGVjIGlzIGF2YWlsYWJsZSwgc3dpdGNoIHRvIGl0LlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRXZlbnRFbWl0dGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDUoRXZlbnRFbWl0dGVyLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBbRXZlbnRFbWl0dGVyXSwgd2hpY2ggZGVwZW5kaW5nIG9uIFtpc0FzeW5jXSxcbiAgICAgICAgICogZGVsaXZlcnMgZXZlbnRzIHN5bmNocm9ub3VzbHkgb3IgYXN5bmNocm9ub3VzbHkuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoaXNBc3luYykge1xuICAgICAgICAgICAgaWYgKGlzQXN5bmMgPT09IHZvaWQgMCkgeyBpc0FzeW5jID0gZmFsc2U7IH1cbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fX2lzQXN5bmMgPSBpc0FzeW5jO1xuICAgICAgICB9XG4gICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkgeyBfc3VwZXIucHJvdG90eXBlLm5leHQuY2FsbCh0aGlzLCB2YWx1ZSk7IH07XG4gICAgICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGdlbmVyYXRvck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgICAgICB2YXIgc2NoZWR1bGVyRm47XG4gICAgICAgICAgICB2YXIgZXJyb3JGbiA9IGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgICAgICB2YXIgY29tcGxldGVGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdG9yT3JOZXh0ICYmIHR5cGVvZiBnZW5lcmF0b3JPck5leHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyRm4gPSB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dC5uZXh0KHZhbHVlKTsgfSk7XG4gICAgICAgICAgICAgICAgfSA6IGZ1bmN0aW9uICh2YWx1ZSkgeyBnZW5lcmF0b3JPck5leHQubmV4dCh2YWx1ZSk7IH07XG4gICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRvck9yTmV4dC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAoZXJyKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VuZXJhdG9yT3JOZXh0LmVycm9yKGVycik7IH0pOyB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIpIHsgZ2VuZXJhdG9yT3JOZXh0LmVycm9yKGVycik7IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0b3JPck5leHQuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVGbiA9IHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKCkgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlbmVyYXRvck9yTmV4dC5jb21wbGV0ZSgpOyB9KTsgfSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7IGdlbmVyYXRvck9yTmV4dC5jb21wbGV0ZSgpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlckZuID0gdGhpcy5fX2lzQXN5bmMgPyBmdW5jdGlvbiAodmFsdWUpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0b3JPck5leHQodmFsdWUpOyB9KTsgfSA6XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkgeyBnZW5lcmF0b3JPck5leHQodmFsdWUpOyB9O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckZuID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19pc0FzeW5jID8gZnVuY3Rpb24gKGVycikgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yKGVycik7IH0pOyB9IDogZnVuY3Rpb24gKGVycikgeyBlcnJvcihlcnIpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVGbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faXNBc3luYyA/IGZ1bmN0aW9uICgpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wbGV0ZSgpOyB9KTsgfSA6IGZ1bmN0aW9uICgpIHsgY29tcGxldGUoKTsgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5zdWJzY3JpYmUuY2FsbCh0aGlzLCBzY2hlZHVsZXJGbiwgZXJyb3JGbiwgY29tcGxldGVGbik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG4gICAgfShyeGpzX1N1YmplY3QuU3ViamVjdCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGEgRm9ybUNvbnRyb2wgaXMgdmFsaWQsIGkuZS4gdGhhdCBubyBlcnJvcnMgZXhpc3QgaW4gdGhlIGlucHV0IHZhbHVlLlxuICAgICAqL1xuICAgIHZhciBWQUxJRCA9ICdWQUxJRCc7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBGb3JtQ29udHJvbCBpcyBpbnZhbGlkLCBpLmUuIHRoYXQgYW4gZXJyb3IgZXhpc3RzIGluIHRoZSBpbnB1dCB2YWx1ZS5cbiAgICAgKi9cbiAgICB2YXIgSU5WQUxJRCA9ICdJTlZBTElEJztcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIEZvcm1Db250cm9sIGlzIHBlbmRpbmcsIGkuZS4gdGhhdCBhc3luYyB2YWxpZGF0aW9uIGlzIG9jY3VycmluZyBhbmRcbiAgICAgKiBlcnJvcnMgYXJlIG5vdCB5ZXQgYXZhaWxhYmxlIGZvciB0aGUgaW5wdXQgdmFsdWUuXG4gICAgICovXG4gICAgdmFyIFBFTkRJTkcgPSAnUEVORElORyc7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBGb3JtQ29udHJvbCBpcyBkaXNhYmxlZCwgaS5lLiB0aGF0IHRoZSBjb250cm9sIGlzIGV4ZW1wdCBmcm9tIGFuY2VzdG9yXG4gICAgICogY2FsY3VsYXRpb25zIG9mIHZhbGlkaXR5IG9yIHZhbHVlLlxuICAgICAqL1xuICAgIHZhciBESVNBQkxFRCA9ICdESVNBQkxFRCc7XG4gICAgZnVuY3Rpb24gX2ZpbmQoY29udHJvbCwgcGF0aCwgZGVsaW1pdGVyKSB7XG4gICAgICAgIGlmIChwYXRoID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc3BsaXQoZGVsaW1pdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCBpbnN0YW5jZW9mIEFycmF5ICYmIChwYXRoLmxlbmd0aCA9PT0gMCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHBhdGgucmVkdWNlKGZ1bmN0aW9uICh2LCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAodiBpbnN0YW5jZW9mIEZvcm1Hcm91cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2LmNvbnRyb2xzW25hbWVdIHx8IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodiBpbnN0YW5jZW9mIEZvcm1BcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2LmF0KG5hbWUpIHx8IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSwgY29udHJvbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvT2JzZXJ2YWJsZShyKSB7XG4gICAgICAgIHJldHVybiBpc1Byb21pc2UocikgPyByeGpzX29ic2VydmFibGVfZnJvbVByb21pc2UuZnJvbVByb21pc2UocikgOiByO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb2VyY2VUb1ZhbGlkYXRvcih2YWxpZGF0b3IpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsaWRhdG9yKSA/IGNvbXBvc2VWYWxpZGF0b3JzKHZhbGlkYXRvcikgOiB2YWxpZGF0b3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvZXJjZVRvQXN5bmNWYWxpZGF0b3IoYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXN5bmNWYWxpZGF0b3IpID8gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyhhc3luY1ZhbGlkYXRvcikgOiBhc3luY1ZhbGlkYXRvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3Ige0BsaW5rIEZvcm1Db250cm9sfSwge0BsaW5rIEZvcm1Hcm91cH0sIGFuZFxuICAgICAqIHtAbGluayBGb3JtQXJyYXl9LlxuICAgICAqXG4gICAgICogSXQgcHJvdmlkZXMgc29tZSBvZiB0aGUgc2hhcmVkIGJlaGF2aW9yIHRoYXQgYWxsIGNvbnRyb2xzIGFuZCBncm91cHMgb2YgY29udHJvbHMgaGF2ZSwgbGlrZVxuICAgICAqIHJ1bm5pbmcgdmFsaWRhdG9ycywgY2FsY3VsYXRpbmcgc3RhdHVzLCBhbmQgcmVzZXR0aW5nIHN0YXRlLiBJdCBhbHNvIGRlZmluZXMgdGhlIHByb3BlcnRpZXNcbiAgICAgKiB0aGF0IGFyZSBzaGFyZWQgYmV0d2VlbiBhbGwgc3ViLWNsYXNzZXMsIGxpa2UgYHZhbHVlYCwgYHZhbGlkYCwgYW5kIGBkaXJ0eWAuIEl0IHNob3VsZG4ndCBiZVxuICAgICAqIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgQWJzdHJhY3RDb250cm9sID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQWJzdHJhY3RDb250cm9sKHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gdmFsaWRhdG9yO1xuICAgICAgICAgICAgdGhpcy5hc3luY1ZhbGlkYXRvciA9IGFzeW5jVmFsaWRhdG9yO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAgICAgdGhpcy5fcHJpc3RpbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICAgICAgdGhpcy5fb25EaXNhYmxlZENoYW5nZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHZhbHVlIG9mIHRoZSBjb250cm9sLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwic3RhdHVzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHZhbGlkYXRpb24gc3RhdHVzIG9mIHRoZSBjb250cm9sLiBUaGVyZSBhcmUgZm91ciBwb3NzaWJsZVxuICAgICAgICAgICAgICogdmFsaWRhdGlvbiBzdGF0dXNlczpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAqICoqVkFMSUQqKjogIGNvbnRyb2wgaGFzIHBhc3NlZCBhbGwgdmFsaWRhdGlvbiBjaGVja3NcbiAgICAgICAgICAgICAqICogKipJTlZBTElEKio6IGNvbnRyb2wgaGFzIGZhaWxlZCBhdCBsZWFzdCBvbmUgdmFsaWRhdGlvbiBjaGVja1xuICAgICAgICAgICAgICogKiAqKlBFTkRJTkcqKjogY29udHJvbCBpcyBpbiB0aGUgbWlkc3Qgb2YgY29uZHVjdGluZyBhIHZhbGlkYXRpb24gY2hlY2tcbiAgICAgICAgICAgICAqICogKipESVNBQkxFRCoqOiBjb250cm9sIGlzIGV4ZW1wdCBmcm9tIHZhbGlkYXRpb24gY2hlY2tzXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhlc2Ugc3RhdHVzZXMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSwgc28gYSBjb250cm9sIGNhbm5vdCBiZVxuICAgICAgICAgICAgICogYm90aCB2YWxpZCBBTkQgaW52YWxpZCBvciBpbnZhbGlkIEFORCBkaXNhYmxlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJ2YWxpZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgdmFsaWRgIHdoZW4gaXRzIGBzdGF0dXMgPT09IFZBTElEYC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJbiBvcmRlciB0byBoYXZlIHRoaXMgc3RhdHVzLCB0aGUgY29udHJvbCBtdXN0IGhhdmUgcGFzc2VkIGFsbCBpdHNcbiAgICAgICAgICAgICAqIHZhbGlkYXRpb24gY2hlY2tzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gVkFMSUQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJpbnZhbGlkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGBpbnZhbGlkYCB3aGVuIGl0cyBgc3RhdHVzID09PSBJTlZBTElEYC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJbiBvcmRlciB0byBoYXZlIHRoaXMgc3RhdHVzLCB0aGUgY29udHJvbCBtdXN0IGhhdmUgZmFpbGVkXG4gICAgICAgICAgICAgKiBhdCBsZWFzdCBvbmUgb2YgaXRzIHZhbGlkYXRpb24gY2hlY2tzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gSU5WQUxJRDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInBlbmRpbmdcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGNvbnRyb2wgaXMgYHBlbmRpbmdgIHdoZW4gaXRzIGBzdGF0dXMgPT09IFBFTkRJTkdgLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEluIG9yZGVyIHRvIGhhdmUgdGhpcyBzdGF0dXMsIHRoZSBjb250cm9sIG11c3QgYmUgaW4gdGhlXG4gICAgICAgICAgICAgKiBtaWRkbGUgb2YgY29uZHVjdGluZyBhIHZhbGlkYXRpb24gY2hlY2suXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhdHVzID09IFBFTkRJTkc7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgZGlzYWJsZWRgIHdoZW4gaXRzIGBzdGF0dXMgPT09IERJU0FCTEVEYC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBEaXNhYmxlZCBjb250cm9scyBhcmUgZXhlbXB0IGZyb20gdmFsaWRhdGlvbiBjaGVja3MgYW5kXG4gICAgICAgICAgICAgKiBhcmUgbm90IGluY2x1ZGVkIGluIHRoZSBhZ2dyZWdhdGUgdmFsdWUgb2YgdGhlaXIgYW5jZXN0b3JcbiAgICAgICAgICAgICAqIGNvbnRyb2xzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N0YXR1cyA9PT0gRElTQUJMRUQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBjb250cm9sIGlzIGBlbmFibGVkYCBhcyBsb25nIGFzIGl0cyBgc3RhdHVzICE9PSBESVNBQkxFRGAuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSW4gb3RoZXIgd29yZHMsIGl0IGhhcyBhIHN0YXR1cyBvZiBgVkFMSURgLCBgSU5WQUxJRGAsIG9yXG4gICAgICAgICAgICAgKiBgUEVORElOR2AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc3RhdHVzICE9PSBESVNBQkxFRDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcImVycm9yc1wiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgYW55IGVycm9ycyBnZW5lcmF0ZWQgYnkgZmFpbGluZyB2YWxpZGF0aW9uLiBJZiB0aGVyZVxuICAgICAgICAgICAgICogYXJlIG5vIGVycm9ycywgaXQgd2lsbCByZXR1cm4gbnVsbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lcnJvcnM7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJwcmlzdGluZVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgcHJpc3RpbmVgIGlmIHRoZSB1c2VyIGhhcyBub3QgeWV0IGNoYW5nZWRcbiAgICAgICAgICAgICAqIHRoZSB2YWx1ZSBpbiB0aGUgVUkuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTm90ZSB0aGF0IHByb2dyYW1tYXRpYyBjaGFuZ2VzIHRvIGEgY29udHJvbCdzIHZhbHVlIHdpbGxcbiAgICAgICAgICAgICAqICpub3QqIG1hcmsgaXQgZGlydHkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJpc3RpbmU7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZSwgXCJkaXJ0eVwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgZGlydHlgIGlmIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICogaW4gdGhlIFVJLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIE5vdGUgdGhhdCBwcm9ncmFtbWF0aWMgY2hhbmdlcyB0byBhIGNvbnRyb2wncyB2YWx1ZSB3aWxsXG4gICAgICAgICAgICAgKiAqbm90KiBtYXJrIGl0IGRpcnR5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLnByaXN0aW5lOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwidG91Y2hlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICogQSBjb250cm9sIGlzIG1hcmtlZCBgdG91Y2hlZGAgb25jZSB0aGUgdXNlciBoYXMgdHJpZ2dlcmVkXG4gICAgICAgICAgICAqIGEgYGJsdXJgIGV2ZW50IG9uIGl0LlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fdG91Y2hlZDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInVudG91Y2hlZFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgY29udHJvbCBpcyBgdW50b3VjaGVkYCBpZiB0aGUgdXNlciBoYXMgbm90IHlldCB0cmlnZ2VyZWRcbiAgICAgICAgICAgICAqIGEgYGJsdXJgIGV2ZW50IG9uIGl0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLl90b3VjaGVkOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwidmFsdWVDaGFuZ2VzXCIsIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW1pdHMgYW4gZXZlbnQgZXZlcnkgdGltZSB0aGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wgY2hhbmdlcywgaW5cbiAgICAgICAgICAgICAqIHRoZSBVSSBvciBwcm9ncmFtbWF0aWNhbGx5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlQ2hhbmdlczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLCBcInN0YXR1c0NoYW5nZXNcIiwge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbWl0cyBhbiBldmVudCBldmVyeSB0aW1lIHRoZSB2YWxpZGF0aW9uIHN0YXR1cyBvZiB0aGUgY29udHJvbFxuICAgICAgICAgICAgICogaXMgcmUtY2FsY3VsYXRlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGF0dXNDaGFuZ2VzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHN5bmNocm9ub3VzIHZhbGlkYXRvcnMgdGhhdCBhcmUgYWN0aXZlIG9uIHRoaXMgY29udHJvbC4gIENhbGxpbmdcbiAgICAgICAgICogdGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgZXhpc3Rpbmcgc3luYyB2YWxpZGF0b3JzLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5zZXRWYWxpZGF0b3JzID0gZnVuY3Rpb24gKG5ld1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0b3IgPSBjb2VyY2VUb1ZhbGlkYXRvcihuZXdWYWxpZGF0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgYXN5bmMgdmFsaWRhdG9ycyB0aGF0IGFyZSBhY3RpdmUgb24gdGhpcyBjb250cm9sLiBDYWxsaW5nIHRoaXNcbiAgICAgICAgICogd2lsbCBvdmVyd3JpdGUgYW55IGV4aXN0aW5nIGFzeW5jIHZhbGlkYXRvcnMuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLnNldEFzeW5jVmFsaWRhdG9ycyA9IGZ1bmN0aW9uIChuZXdWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuYXN5bmNWYWxpZGF0b3IgPSBjb2VyY2VUb0FzeW5jVmFsaWRhdG9yKG5ld1ZhbGlkYXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbXB0aWVzIG91dCB0aGUgc3luYyB2YWxpZGF0b3IgbGlzdC5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuY2xlYXJWYWxpZGF0b3JzID0gZnVuY3Rpb24gKCkgeyB0aGlzLnZhbGlkYXRvciA9IG51bGw7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbXB0aWVzIG91dCB0aGUgYXN5bmMgdmFsaWRhdG9yIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLmNsZWFyQXN5bmNWYWxpZGF0b3JzID0gZnVuY3Rpb24gKCkgeyB0aGlzLmFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBjb250cm9sIGFzIGB0b3VjaGVkYC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB3aWxsIGFsc28gbWFyayBhbGwgZGlyZWN0IGFuY2VzdG9ycyBhcyBgdG91Y2hlZGAgdG8gbWFpbnRhaW5cbiAgICAgICAgICogdGhlIG1vZGVsLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5tYXJrQXNUb3VjaGVkID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5tYXJrQXNUb3VjaGVkKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFya3MgdGhlIGNvbnRyb2wgYXMgYHVudG91Y2hlZGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBjb250cm9sIGhhcyBhbnkgY2hpbGRyZW4sIGl0IHdpbGwgYWxzbyBtYXJrIGFsbCBjaGlsZHJlbiBhcyBgdW50b3VjaGVkYFxuICAgICAgICAgKiB0byBtYWludGFpbiB0aGUgbW9kZWwsIGFuZCByZS1jYWxjdWxhdGUgdGhlIGB0b3VjaGVkYCBzdGF0dXMgb2YgYWxsIHBhcmVudFxuICAgICAgICAgKiBjb250cm9scy5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUubWFya0FzVW50b3VjaGVkID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sKSB7IGNvbnRyb2wubWFya0FzVW50b3VjaGVkKHsgb25seVNlbGY6IHRydWUgfSk7IH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVRvdWNoZWQoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrcyB0aGUgY29udHJvbCBhcyBgZGlydHlgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHdpbGwgYWxzbyBtYXJrIGFsbCBkaXJlY3QgYW5jZXN0b3JzIGFzIGBkaXJ0eWAgdG8gbWFpbnRhaW5cbiAgICAgICAgICogdGhlIG1vZGVsLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5tYXJrQXNEaXJ0eSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX3ByaXN0aW5lID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5tYXJrQXNEaXJ0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBjb250cm9sIGFzIGBwcmlzdGluZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBjb250cm9sIGhhcyBhbnkgY2hpbGRyZW4sIGl0IHdpbGwgYWxzbyBtYXJrIGFsbCBjaGlsZHJlbiBhcyBgcHJpc3RpbmVgXG4gICAgICAgICAqIHRvIG1haW50YWluIHRoZSBtb2RlbCwgYW5kIHJlLWNhbGN1bGF0ZSB0aGUgYHByaXN0aW5lYCBzdGF0dXMgb2YgYWxsIHBhcmVudFxuICAgICAgICAgKiBjb250cm9scy5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUubWFya0FzUHJpc3RpbmUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl9wcmlzdGluZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wpIHsgY29udHJvbC5tYXJrQXNQcmlzdGluZSh7IG9ubHlTZWxmOiB0cnVlIH0pOyB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVQcmlzdGluZSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmtzIHRoZSBjb250cm9sIGFzIGBwZW5kaW5nYC5cbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUubWFya0FzUGVuZGluZyA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IFBFTkRJTkc7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvbmx5U2VsZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5tYXJrQXNQZW5kaW5nKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgdGhlIGNvbnRyb2wuIFRoaXMgbWVhbnMgdGhlIGNvbnRyb2wgd2lsbCBiZSBleGVtcHQgZnJvbSB2YWxpZGF0aW9uIGNoZWNrcyBhbmRcbiAgICAgICAgICogZXhjbHVkZWQgZnJvbSB0aGUgYWdncmVnYXRlIHZhbHVlIG9mIGFueSBwYXJlbnQuIEl0cyBzdGF0dXMgaXMgYERJU0FCTEVEYC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGNvbnRyb2wgaGFzIGNoaWxkcmVuLCBhbGwgY2hpbGRyZW4gd2lsbCBiZSBkaXNhYmxlZCB0byBtYWludGFpbiB0aGUgbW9kZWwuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSBESVNBQkxFRDtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wpIHsgY29udHJvbC5kaXNhYmxlKHsgb25seVNlbGY6IHRydWUgfSk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmIChlbWl0RXZlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVDaGFuZ2VzLmVtaXQodGhpcy5fdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1c0NoYW5nZXMuZW1pdCh0aGlzLl9zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQW5jZXN0b3JzKG9ubHlTZWxmKTtcbiAgICAgICAgICAgIHRoaXMuX29uRGlzYWJsZWRDaGFuZ2UuZm9yRWFjaChmdW5jdGlvbiAoY2hhbmdlRm4pIHsgcmV0dXJuIGNoYW5nZUZuKHRydWUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZXMgdGhlIGNvbnRyb2wuIFRoaXMgbWVhbnMgdGhlIGNvbnRyb2wgd2lsbCBiZSBpbmNsdWRlZCBpbiB2YWxpZGF0aW9uIGNoZWNrcyBhbmRcbiAgICAgICAgICogdGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiBpdHMgcGFyZW50LiBJdHMgc3RhdHVzIGlzIHJlLWNhbGN1bGF0ZWQgYmFzZWQgb24gaXRzIHZhbHVlIGFuZFxuICAgICAgICAgKiBpdHMgdmFsaWRhdG9ycy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhlIGNvbnRyb2wgaGFzIGNoaWxkcmVuLCBhbGwgY2hpbGRyZW4gd2lsbCBiZSBlbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBvbmx5U2VsZiA9IF9iLm9ubHlTZWxmLCBlbWl0RXZlbnQgPSBfYi5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSBWQUxJRDtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCkgeyBjb250cm9sLmVuYWJsZSh7IG9ubHlTZWxmOiB0cnVlIH0pOyB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUFuY2VzdG9ycyhvbmx5U2VsZik7XG4gICAgICAgICAgICB0aGlzLl9vbkRpc2FibGVkQ2hhbmdlLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZUZuKSB7IHJldHVybiBjaGFuZ2VGbihmYWxzZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl91cGRhdGVBbmNlc3RvcnMgPSBmdW5jdGlvbiAob25seVNlbGYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVByaXN0aW5lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVUb3VjaGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudCkgeyB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZS1jYWxjdWxhdGVzIHRoZSB2YWx1ZSBhbmQgdmFsaWRhdGlvbiBzdGF0dXMgb2YgdGhlIGNvbnRyb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIGl0IHdpbGwgYWxzbyB1cGRhdGUgdGhlIHZhbHVlIGFuZCB2YWxpZGl0eSBvZiBpdHMgYW5jZXN0b3JzLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50O1xuICAgICAgICAgICAgdGhpcy5fc2V0SW5pdGlhbFN0YXR1cygpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvcnMgPSB0aGlzLl9ydW5WYWxpZGF0b3IoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSB0aGlzLl9jYWxjdWxhdGVTdGF0dXMoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdHVzID09PSBWQUxJRCB8fCB0aGlzLl9zdGF0dXMgPT09IFBFTkRJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcnVuQXN5bmNWYWxpZGF0b3IoZW1pdEV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW1pdEV2ZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlQ2hhbmdlcy5lbWl0KHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXNDaGFuZ2VzLmVtaXQodGhpcy5fc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3VwZGF0ZVRyZWVWYWxpZGl0eSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGVtaXRFdmVudCA9IChfYSA9PT0gdm9pZCAwID8geyBlbWl0RXZlbnQ6IHRydWUgfSA6IF9hKS5lbWl0RXZlbnQ7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGN0cmwpIHsgcmV0dXJuIGN0cmwuX3VwZGF0ZVRyZWVWYWxpZGl0eSh7IGVtaXRFdmVudDogZW1pdEV2ZW50IH0pOyB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGVtaXRFdmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fc2V0SW5pdGlhbFN0YXR1cyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fc3RhdHVzID0gdGhpcy5fYWxsQ29udHJvbHNEaXNhYmxlZCgpID8gRElTQUJMRUQgOiBWQUxJRDsgfTtcbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5fcnVuVmFsaWRhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yID8gdGhpcy52YWxpZGF0b3IodGhpcykgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9ydW5Bc3luY1ZhbGlkYXRvciA9IGZ1bmN0aW9uIChlbWl0RXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5hc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IFBFTkRJTkc7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsRXhpc3RpbmdTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgb2JzID0gdG9PYnNlcnZhYmxlKHRoaXMuYXN5bmNWYWxpZGF0b3IodGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdGlvblN1YnNjcmlwdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIG9icy5zdWJzY3JpYmUoeyBuZXh0OiBmdW5jdGlvbiAocmVzKSB7IHJldHVybiBfdGhpcy5zZXRFcnJvcnMocmVzLCB7IGVtaXRFdmVudDogZW1pdEV2ZW50IH0pOyB9IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9jYW5jZWxFeGlzdGluZ1N1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hc3luY1ZhbGlkYXRpb25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hc3luY1ZhbGlkYXRpb25TdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgZXJyb3JzIG9uIGEgZm9ybSBjb250cm9sLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIHVzZWQgd2hlbiB2YWxpZGF0aW9ucyBhcmUgcnVuIG1hbnVhbGx5IGJ5IHRoZSB1c2VyLCByYXRoZXIgdGhhbiBhdXRvbWF0aWNhbGx5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBDYWxsaW5nIGBzZXRFcnJvcnNgIHdpbGwgYWxzbyB1cGRhdGUgdGhlIHZhbGlkaXR5IG9mIHRoZSBwYXJlbnQgY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIGNvbnN0IGxvZ2luID0gbmV3IEZvcm1Db250cm9sKFwic29tZUxvZ2luXCIpO1xuICAgICAgICAgKiBsb2dpbi5zZXRFcnJvcnMoe1xuICAgICAgICAgKiAgIFwibm90VW5pcXVlXCI6IHRydWVcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGV4cGVjdChsb2dpbi52YWxpZCkudG9FcXVhbChmYWxzZSk7XG4gICAgICAgICAqIGV4cGVjdChsb2dpbi5lcnJvcnMpLnRvRXF1YWwoe1wibm90VW5pcXVlXCI6IHRydWV9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogbG9naW4uc2V0VmFsdWUoXCJzb21lT3RoZXJMb2dpblwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogZXhwZWN0KGxvZ2luLnZhbGlkKS50b0VxdWFsKHRydWUpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuc2V0RXJyb3JzID0gZnVuY3Rpb24gKGVycm9ycywgX2EpIHtcbiAgICAgICAgICAgIHZhciBlbWl0RXZlbnQgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLmVtaXRFdmVudDtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycyA9IGVycm9ycztcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbnRyb2xzRXJyb3JzKGVtaXRFdmVudCAhPT0gZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIGEgY2hpbGQgY29udHJvbCBnaXZlbiB0aGUgY29udHJvbCdzIG5hbWUgb3IgcGF0aC5cbiAgICAgICAgICpcbiAgICAgICAgICogUGF0aHMgY2FuIGJlIHBhc3NlZCBpbiBhcyBhbiBhcnJheSBvciBhIHN0cmluZyBkZWxpbWl0ZWQgYnkgYSBkb3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIGdldCBhIGNvbnRyb2wgbmVzdGVkIHdpdGhpbiBhIGBwZXJzb25gIHN1Yi1ncm91cDpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBgdGhpcy5mb3JtLmdldCgncGVyc29uLm5hbWUnKTtgXG4gICAgICAgICAqXG4gICAgICAgICAqIC1PUi1cbiAgICAgICAgICpcbiAgICAgICAgICogKiBgdGhpcy5mb3JtLmdldChbJ3BlcnNvbicsICduYW1lJ10pO2BcbiAgICAgICAgICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIF9maW5kKHRoaXMsIHBhdGgsICcuJyk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gcGF0aCBoYXMgdGhlIGVycm9yIHNwZWNpZmllZC4gT3RoZXJ3aXNlXG4gICAgICAgICAqIHJldHVybnMgbnVsbCBvciB1bmRlZmluZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIG5vIHBhdGggaXMgZ2l2ZW4sIGl0IGNoZWNrcyBmb3IgdGhlIGVycm9yIG9uIHRoZSBwcmVzZW50IGNvbnRyb2wuXG4gICAgICAgICAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLmdldEVycm9yID0gZnVuY3Rpb24gKGVycm9yQ29kZSwgcGF0aCkge1xuICAgICAgICAgICAgaWYgKHBhdGggPT09IHZvaWQgMCkgeyBwYXRoID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSBwYXRoID8gdGhpcy5nZXQocGF0aCkgOiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2wgJiYgY29udHJvbC5fZXJyb3JzID8gY29udHJvbC5fZXJyb3JzW2Vycm9yQ29kZV0gOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIHBhdGggaGFzIHRoZSBlcnJvciBzcGVjaWZpZWQuIE90aGVyd2lzZVxuICAgICAgICAgKiByZXR1cm5zIGZhbHNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBubyBwYXRoIGlzIGdpdmVuLCBpdCBjaGVja3MgZm9yIHRoZSBlcnJvciBvbiB0aGUgcHJlc2VudCBjb250cm9sLlxuICAgICAgICAgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5oYXNFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIHBhdGgpIHtcbiAgICAgICAgICAgIGlmIChwYXRoID09PSB2b2lkIDApIHsgcGF0aCA9IG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuZ2V0RXJyb3IoZXJyb3JDb2RlLCBwYXRoKTtcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUsIFwicm9vdFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHJpZXZlcyB0aGUgdG9wLWxldmVsIGFuY2VzdG9yIG9mIHRoaXMgY29udHJvbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzO1xuICAgICAgICAgICAgICAgIHdoaWxlICh4Ll9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHguX3BhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl91cGRhdGVDb250cm9sc0Vycm9ycyA9IGZ1bmN0aW9uIChlbWl0RXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IHRoaXMuX2NhbGN1bGF0ZVN0YXR1cygpO1xuICAgICAgICAgICAgaWYgKGVtaXRFdmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1c0NoYW5nZXMuZW1pdCh0aGlzLl9zdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlQ29udHJvbHNFcnJvcnMoZW1pdEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9pbml0T2JzZXJ2YWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZUNoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXNDaGFuZ2VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB9O1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9jYWxjdWxhdGVTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYWxsQ29udHJvbHNEaXNhYmxlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBESVNBQkxFRDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fYW55Q29udHJvbHNIYXZlU3RhdHVzKFBFTkRJTkcpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQRU5ESU5HO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FueUNvbnRyb2xzSGF2ZVN0YXR1cyhJTlZBTElEKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIHJldHVybiBWQUxJRDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl9hbnlDb250cm9sc0hhdmVTdGF0dXMgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW55Q29udHJvbHMoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wuc3RhdHVzID09PSBzdGF0dXM7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX2FueUNvbnRyb2xzRGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW55Q29udHJvbHMoZnVuY3Rpb24gKGNvbnRyb2wpIHsgcmV0dXJuIGNvbnRyb2wuZGlydHk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX2FueUNvbnRyb2xzVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbnlDb250cm9scyhmdW5jdGlvbiAoY29udHJvbCkgeyByZXR1cm4gY29udHJvbC50b3VjaGVkOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl91cGRhdGVQcmlzdGluZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX3ByaXN0aW5lID0gIXRoaXMuX2FueUNvbnRyb2xzRGlydHkoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9ubHlTZWxmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVQcmlzdGluZSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBBYnN0cmFjdENvbnRyb2wucHJvdG90eXBlLl91cGRhdGVUb3VjaGVkID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgb25seVNlbGYgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLm9ubHlTZWxmO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hlZCA9IHRoaXMuX2FueUNvbnRyb2xzVG91Y2hlZCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb25seVNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVRvdWNoZWQoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgQWJzdHJhY3RDb250cm9sLnByb3RvdHlwZS5faXNCb3hlZFZhbHVlID0gZnVuY3Rpb24gKGZvcm1TdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBmb3JtU3RhdGUgPT09ICdvYmplY3QnICYmIGZvcm1TdGF0ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGZvcm1TdGF0ZSkubGVuZ3RoID09PSAyICYmICd2YWx1ZScgaW4gZm9ybVN0YXRlICYmICdkaXNhYmxlZCcgaW4gZm9ybVN0YXRlO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEFic3RyYWN0Q29udHJvbC5wcm90b3R5cGUuX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSA9IGZuOyB9O1xuICAgICAgICByZXR1cm4gQWJzdHJhY3RDb250cm9sO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgVHJhY2tzIHRoZSB2YWx1ZSBhbmQgdmFsaWRhdGlvbiBzdGF0dXMgb2YgYW4gaW5kaXZpZHVhbCBmb3JtIGNvbnRyb2wuXG4gICAgICpcbiAgICAgKiBJdCBpcyBvbmUgb2YgdGhlIHRocmVlIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrcyBvZiBBbmd1bGFyIGZvcm1zLCBhbG9uZyB3aXRoXG4gICAgICoge0BsaW5rIEZvcm1Hcm91cH0gYW5kIHtAbGluayBGb3JtQXJyYXl9LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBXaGVuIGluc3RhbnRpYXRpbmcgYSB7QGxpbmsgRm9ybUNvbnRyb2x9LCB5b3UgY2FuIHBhc3MgaW4gYW4gaW5pdGlhbCB2YWx1ZSBhcyB0aGVcbiAgICAgKiBmaXJzdCBhcmd1bWVudC4gRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY3RybCA9IG5ldyBGb3JtQ29udHJvbCgnc29tZSB2YWx1ZScpO1xuICAgICAqIGNvbnNvbGUubG9nKGN0cmwudmFsdWUpOyAgICAgLy8gJ3NvbWUgdmFsdWUnXG4gICAgICpgYGBcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWxzbyBpbml0aWFsaXplIHRoZSBjb250cm9sIHdpdGggYSBmb3JtIHN0YXRlIG9iamVjdCBvbiBpbnN0YW50aWF0aW9uLFxuICAgICAqIHdoaWNoIGluY2x1ZGVzIGJvdGggdGhlIHZhbHVlIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGUgY29udHJvbCBpcyBkaXNhYmxlZC5cbiAgICAgKiBZb3UgY2FuJ3QgdXNlIHRoZSB2YWx1ZSBrZXkgd2l0aG91dCB0aGUgZGlzYWJsZWQga2V5OyBib3RoIGFyZSByZXF1aXJlZFxuICAgICAqIHRvIHVzZSB0aGlzIHdheSBvZiBpbml0aWFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY3RybCA9IG5ldyBGb3JtQ29udHJvbCh7dmFsdWU6ICduL2EnLCBkaXNhYmxlZDogdHJ1ZX0pO1xuICAgICAqIGNvbnNvbGUubG9nKGN0cmwudmFsdWUpOyAgICAgLy8gJ24vYSdcbiAgICAgKiBjb25zb2xlLmxvZyhjdHJsLnN0YXR1cyk7ICAgLy8gJ0RJU0FCTEVEJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVG8gaW5jbHVkZSBhIHN5bmMgdmFsaWRhdG9yIChvciBhbiBhcnJheSBvZiBzeW5jIHZhbGlkYXRvcnMpIHdpdGggdGhlIGNvbnRyb2wsXG4gICAgICogcGFzcyBpdCBpbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LiBBc3luYyB2YWxpZGF0b3JzIGFyZSBhbHNvIHN1cHBvcnRlZCwgYnV0XG4gICAgICogaGF2ZSB0byBiZSBwYXNzZWQgaW4gc2VwYXJhdGVseSBhcyB0aGUgdGhpcmQgYXJnLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjdHJsID0gbmV3IEZvcm1Db250cm9sKCcnLCBWYWxpZGF0b3JzLnJlcXVpcmVkKTtcbiAgICAgKiBjb25zb2xlLmxvZyhjdHJsLnZhbHVlKTsgICAgIC8vICcnXG4gICAgICogY29uc29sZS5sb2coY3RybC5zdGF0dXMpOyAgIC8vICdJTlZBTElEJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogU2VlIGl0cyBzdXBlcmNsYXNzLCB7QGxpbmsgQWJzdHJhY3RDb250cm9sfSwgZm9yIG1vcmUgcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1Db250cm9sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDYoRm9ybUNvbnRyb2wsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEZvcm1Db250cm9sKGZvcm1TdGF0ZSwgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKGZvcm1TdGF0ZSA9PT0gdm9pZCAwKSB7IGZvcm1TdGF0ZSA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IgPT09IHZvaWQgMCkgeyB2YWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAoYXN5bmNWYWxpZGF0b3IgPT09IHZvaWQgMCkgeyBhc3luY1ZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGNvZXJjZVRvVmFsaWRhdG9yKHZhbGlkYXRvciksIGNvZXJjZVRvQXN5bmNWYWxpZGF0b3IoYXN5bmNWYWxpZGF0b3IpKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlID0gW107XG4gICAgICAgICAgICB0aGlzLl9hcHBseUZvcm1TdGF0ZShmb3JtU3RhdGUpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgICAgICB0aGlzLl9pbml0T2JzZXJ2YWJsZXMoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSB2YWx1ZSBvZiB0aGUgZm9ybSBjb250cm9sIHRvIGB2YWx1ZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGBvbmx5U2VsZmAgaXMgYHRydWVgLCB0aGlzIGNoYW5nZSB3aWxsIG9ubHkgYWZmZWN0IHRoZSB2YWxpZGF0aW9uIG9mIHRoaXMgYEZvcm1Db250cm9sYFxuICAgICAgICAgKiBhbmQgbm90IGl0cyBwYXJlbnQgY29tcG9uZW50LiBUaGlzIGRlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgZW1pdEV2ZW50YCBpcyBgdHJ1ZWAsIHRoaXNcbiAgICAgICAgICogY2hhbmdlIHdpbGwgY2F1c2UgYSBgdmFsdWVDaGFuZ2VzYCBldmVudCBvbiB0aGUgYEZvcm1Db250cm9sYCB0byBiZSBlbWl0dGVkLiBUaGlzIGRlZmF1bHRzXG4gICAgICAgICAqIHRvIHRydWUgKGFzIGl0IGZhbGxzIHRocm91Z2ggdG8gYHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHlgKS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGVtaXRNb2RlbFRvVmlld0NoYW5nZWAgaXMgYHRydWVgLCB0aGUgdmlldyB3aWxsIGJlIG5vdGlmaWVkIGFib3V0IHRoZSBuZXcgdmFsdWVcbiAgICAgICAgICogdmlhIGFuIGBvbkNoYW5nZWAgZXZlbnQuIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaWYgYGVtaXRNb2RlbFRvVmlld0NoYW5nZWAgaXMgbm90XG4gICAgICAgICAqIHNwZWNpZmllZC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGVtaXRWaWV3VG9Nb2RlbENoYW5nZWAgaXMgYHRydWVgLCBhbiBuZ01vZGVsQ2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgdG8gdXBkYXRlIHRoZVxuICAgICAgICAgKiBtb2RlbC4gIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaWYgYGVtaXRWaWV3VG9Nb2RlbENoYW5nZWAgaXMgbm90IHNwZWNpZmllZC5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgb25seVNlbGYgPSBfYi5vbmx5U2VsZiwgZW1pdEV2ZW50ID0gX2IuZW1pdEV2ZW50LCBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2UgPSBfYi5lbWl0TW9kZWxUb1ZpZXdDaGFuZ2UsIGVtaXRWaWV3VG9Nb2RlbENoYW5nZSA9IF9iLmVtaXRWaWV3VG9Nb2RlbENoYW5nZTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2UubGVuZ3RoICYmIGVtaXRNb2RlbFRvVmlld0NoYW5nZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkNoYW5nZS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFuZ2VGbikgeyByZXR1cm4gY2hhbmdlRm4oX3RoaXMuX3ZhbHVlLCBlbWl0Vmlld1RvTW9kZWxDaGFuZ2UgIT09IGZhbHNlKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYsIGVtaXRFdmVudDogZW1pdEV2ZW50IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUGF0Y2hlcyB0aGUgdmFsdWUgb2YgYSBjb250cm9sLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGZ1bmN0aW9uYWxseSB0aGUgc2FtZSBhcyB7QGxpbmsgRm9ybUNvbnRyb2wuc2V0VmFsdWV9IGF0IHRoaXMgbGV2ZWwuXG4gICAgICAgICAqIEl0IGV4aXN0cyBmb3Igc3ltbWV0cnkgd2l0aCB7QGxpbmsgRm9ybUdyb3VwLnBhdGNoVmFsdWV9IG9uIGBGb3JtR3JvdXBzYCBhbmQgYEZvcm1BcnJheXNgLFxuICAgICAgICAgKiB3aGVyZSBpdCBkb2VzIGJlaGF2ZSBkaWZmZXJlbnRseS5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5wYXRjaFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIGZvcm0gY29udHJvbC4gVGhpcyBtZWFucyBieSBkZWZhdWx0OlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIGl0IGlzIG1hcmtlZCBhcyBgcHJpc3RpbmVgXG4gICAgICAgICAqICogaXQgaXMgbWFya2VkIGFzIGB1bnRvdWNoZWRgXG4gICAgICAgICAqICogdmFsdWUgaXMgc2V0IHRvIG51bGxcbiAgICAgICAgICpcbiAgICAgICAgICogWW91IGNhbiBhbHNvIHJlc2V0IHRvIGEgc3BlY2lmaWMgZm9ybSBzdGF0ZSBieSBwYXNzaW5nIHRocm91Z2ggYSBzdGFuZGFsb25lXG4gICAgICAgICAqIHZhbHVlIG9yIGEgZm9ybSBzdGF0ZSBvYmplY3QgdGhhdCBjb250YWlucyBib3RoIGEgdmFsdWUgYW5kIGEgZGlzYWJsZWQgc3RhdGVcbiAgICAgICAgICogKHRoZXNlIGFyZSB0aGUgb25seSB0d28gcHJvcGVydGllcyB0aGF0IGNhbm5vdCBiZSBjYWxjdWxhdGVkKS5cbiAgICAgICAgICpcbiAgICAgICAgICogRXg6XG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIHRoaXMuY29udHJvbC5yZXNldCgnTmFuY3knKTtcbiAgICAgICAgICpcbiAgICAgICAgICogY29uc29sZS5sb2codGhpcy5jb250cm9sLnZhbHVlKTsgIC8vICdOYW5jeSdcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIE9SXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiB0aGlzLmNvbnRyb2wucmVzZXQoe3ZhbHVlOiAnTmFuY3knLCBkaXNhYmxlZDogdHJ1ZX0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmNvbnRyb2wudmFsdWUpOyAgLy8gJ05hbmN5J1xuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmNvbnRyb2wuc3RhdHVzKTsgIC8vICdESVNBQkxFRCdcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoZm9ybVN0YXRlLCBfYSkge1xuICAgICAgICAgICAgaWYgKGZvcm1TdGF0ZSA9PT0gdm9pZCAwKSB7IGZvcm1TdGF0ZSA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl9hcHBseUZvcm1TdGF0ZShmb3JtU3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5tYXJrQXNQcmlzdGluZSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIHRoaXMubWFya0FzVW50b3VjaGVkKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLl92YWx1ZSwgeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5fdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Db250cm9sLnByb3RvdHlwZS5fYW55Q29udHJvbHMgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiBmYWxzZTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLl9hbGxDb250cm9sc0Rpc2FibGVkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kaXNhYmxlZDsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGEgbGlzdGVuZXIgZm9yIGNoYW5nZSBldmVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkNoYW5nZS5wdXNoKGZuKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUNvbnRyb2wucHJvdG90eXBlLl9jbGVhckNoYW5nZUZucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlID0gW107XG4gICAgICAgICAgICB0aGlzLl9vbkRpc2FibGVkQ2hhbmdlID0gW107XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciBhIGxpc3RlbmVyIGZvciBkaXNhYmxlZCBldmVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUucmVnaXN0ZXJPbkRpc2FibGVkQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkRpc2FibGVkQ2hhbmdlLnB1c2goZm4pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuX2ZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIChjYikgeyB9O1xuICAgICAgICBGb3JtQ29udHJvbC5wcm90b3R5cGUuX2FwcGx5Rm9ybVN0YXRlID0gZnVuY3Rpb24gKGZvcm1TdGF0ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQm94ZWRWYWx1ZShmb3JtU3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBmb3JtU3RhdGUudmFsdWU7XG4gICAgICAgICAgICAgICAgZm9ybVN0YXRlLmRpc2FibGVkID8gdGhpcy5kaXNhYmxlKHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2UgfSkgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBmb3JtU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtQ29udHJvbDtcbiAgICB9KEFic3RyYWN0Q29udHJvbCkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFRyYWNrcyB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IHN0YXRlIG9mIGEgZ3JvdXAgb2Yge0BsaW5rIEZvcm1Db250cm9sfVxuICAgICAqIGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIEEgYEZvcm1Hcm91cGAgYWdncmVnYXRlcyB0aGUgdmFsdWVzIG9mIGVhY2ggY2hpbGQge0BsaW5rIEZvcm1Db250cm9sfSBpbnRvIG9uZSBvYmplY3QsXG4gICAgICogd2l0aCBlYWNoIGNvbnRyb2wgbmFtZSBhcyB0aGUga2V5LiAgSXQgY2FsY3VsYXRlcyBpdHMgc3RhdHVzIGJ5IHJlZHVjaW5nIHRoZSBzdGF0dXNlc1xuICAgICAqIG9mIGl0cyBjaGlsZHJlbi4gRm9yIGV4YW1wbGUsIGlmIG9uZSBvZiB0aGUgY29udHJvbHMgaW4gYSBncm91cCBpcyBpbnZhbGlkLCB0aGUgZW50aXJlXG4gICAgICogZ3JvdXAgYmVjb21lcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogYEZvcm1Hcm91cGAgaXMgb25lIG9mIHRoZSB0aHJlZSBmdW5kYW1lbnRhbCBidWlsZGluZyBibG9ja3MgdXNlZCB0byBkZWZpbmUgZm9ybXMgaW4gQW5ndWxhcixcbiAgICAgKiBhbG9uZyB3aXRoIHtAbGluayBGb3JtQ29udHJvbH0gYW5kIHtAbGluayBGb3JtQXJyYXl9LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBXaGVuIGluc3RhbnRpYXRpbmcgYSB7QGxpbmsgRm9ybUdyb3VwfSwgcGFzcyBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGQgY29udHJvbHMgYXMgdGhlIGZpcnN0XG4gICAgICogYXJndW1lbnQuIFRoZSBrZXkgZm9yIGVhY2ggY2hpbGQgd2lsbCBiZSB0aGUgbmFtZSB1bmRlciB3aGljaCBpdCBpcyByZWdpc3RlcmVkLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgKiAgIGZpcnN0OiBuZXcgRm9ybUNvbnRyb2woJ05hbmN5JywgVmFsaWRhdG9ycy5taW5MZW5ndGgoMikpLFxuICAgICAqICAgbGFzdDogbmV3IEZvcm1Db250cm9sKCdEcmV3JyksXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhmb3JtLnZhbHVlKTsgICAvLyB7Zmlyc3Q6ICdOYW5jeScsIGxhc3Q7ICdEcmV3J31cbiAgICAgKiBjb25zb2xlLmxvZyhmb3JtLnN0YXR1cyk7ICAvLyAnVkFMSUQnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGFsc28gaW5jbHVkZSBncm91cC1sZXZlbCB2YWxpZGF0b3JzIGFzIHRoZSBzZWNvbmQgYXJnLCBvciBncm91cC1sZXZlbCBhc3luY1xuICAgICAqIHZhbGlkYXRvcnMgYXMgdGhlIHRoaXJkIGFyZy4gVGhlc2UgY29tZSBpbiBoYW5keSB3aGVuIHlvdSB3YW50IHRvIHBlcmZvcm0gdmFsaWRhdGlvblxuICAgICAqIHRoYXQgY29uc2lkZXJzIHRoZSB2YWx1ZSBvZiBtb3JlIHRoYW4gb25lIGNoaWxkIGNvbnRyb2wuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAqICAgcGFzc3dvcmQ6IG5ldyBGb3JtQ29udHJvbCgnJywgVmFsaWRhdG9ycy5taW5MZW5ndGgoMikpLFxuICAgICAqICAgcGFzc3dvcmRDb25maXJtOiBuZXcgRm9ybUNvbnRyb2woJycsIFZhbGlkYXRvcnMubWluTGVuZ3RoKDIpKSxcbiAgICAgKiB9LCBwYXNzd29yZE1hdGNoVmFsaWRhdG9yKTtcbiAgICAgKlxuICAgICAqXG4gICAgICogZnVuY3Rpb24gcGFzc3dvcmRNYXRjaFZhbGlkYXRvcihnOiBGb3JtR3JvdXApIHtcbiAgICAgKiAgICByZXR1cm4gZy5nZXQoJ3Bhc3N3b3JkJykudmFsdWUgPT09IGcuZ2V0KCdwYXNzd29yZENvbmZpcm0nKS52YWx1ZVxuICAgICAqICAgICAgID8gbnVsbCA6IHsnbWlzbWF0Y2gnOiB0cnVlfTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3JtR3JvdXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNihGb3JtR3JvdXAsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEZvcm1Hcm91cChjb250cm9scywgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IHZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChhc3luY1ZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IGFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzID0gY29udHJvbHM7XG4gICAgICAgICAgICB0aGlzLl9pbml0T2JzZXJ2YWJsZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFVwQ29udHJvbHMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlcnMgYSBjb250cm9sIHdpdGggdGhlIGdyb3VwJ3MgbGlzdCBvZiBjb250cm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgZG9lcyBub3QgdXBkYXRlIHZhbHVlIG9yIHZhbGlkaXR5IG9mIHRoZSBjb250cm9sLCBzbyBmb3JcbiAgICAgICAgICogbW9zdCBjYXNlcyB5b3UnbGwgd2FudCB0byB1c2Uge0BsaW5rIEZvcm1Hcm91cC5hZGRDb250cm9sfSBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5yZWdpc3RlckNvbnRyb2wgPSBmdW5jdGlvbiAobmFtZSwgY29udHJvbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbHNbbmFtZV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHNbbmFtZV07XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdID0gY29udHJvbDtcbiAgICAgICAgICAgIGNvbnRyb2wuc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICAgICAgY29udHJvbC5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UodGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKTtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGEgY29udHJvbCB0byB0aGlzIGdyb3VwLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5hZGRDb250cm9sID0gZnVuY3Rpb24gKG5hbWUsIGNvbnRyb2wpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJDb250cm9sKG5hbWUsIGNvbnRyb2wpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhIGNvbnRyb2wgZnJvbSB0aGlzIGdyb3VwLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5yZW1vdmVDb250cm9sID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xzW25hbWVdKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbHNbbmFtZV0uX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICBkZWxldGUgKHRoaXMuY29udHJvbHNbbmFtZV0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGxhY2UgYW4gZXhpc3RpbmcgY29udHJvbC5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuc2V0Q29udHJvbCA9IGZ1bmN0aW9uIChuYW1lLCBjb250cm9sKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tuYW1lXSlcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgZGVsZXRlICh0aGlzLmNvbnRyb2xzW25hbWVdKTtcbiAgICAgICAgICAgIGlmIChjb250cm9sKVxuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJDb250cm9sKG5hbWUsIGNvbnRyb2wpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIHdoZXRoZXIgdGhlcmUgaXMgYW4gZW5hYmxlZCBjb250cm9sIHdpdGggdGhlIGdpdmVuIG5hbWUgaW4gdGhlIGdyb3VwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJdCB3aWxsIHJldHVybiBmYWxzZSBmb3IgZGlzYWJsZWQgY29udHJvbHMuIElmIHlvdSdkIGxpa2UgdG8gY2hlY2sgZm9yXG4gICAgICAgICAqIGV4aXN0ZW5jZSBpbiB0aGUgZ3JvdXAgb25seSwgdXNlIHtAbGluayBBYnN0cmFjdENvbnRyb2wuZ2V0fSBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChjb250cm9sTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHMuaGFzT3duUHJvcGVydHkoY29udHJvbE5hbWUpICYmIHRoaXMuY29udHJvbHNbY29udHJvbE5hbWVdLmVuYWJsZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHtAbGluayBGb3JtR3JvdXB9LiBJdCBhY2NlcHRzIGFuIG9iamVjdCB0aGF0IG1hdGNoZXNcbiAgICAgICAgICogIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGdyb3VwLCB3aXRoIGNvbnRyb2wgbmFtZXMgYXMga2V5cy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgcGVyZm9ybXMgc3RyaWN0IGNoZWNrcywgc28gaXQgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgdHJ5XG4gICAgICAgICAqIHRvIHNldCB0aGUgdmFsdWUgb2YgYSBjb250cm9sIHRoYXQgZG9lc24ndCBleGlzdCBvciBpZiB5b3UgZXhjbHVkZSB0aGVcbiAgICAgICAgICogdmFsdWUgb2YgYSBjb250cm9sLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKiAgY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAgICAgKiAgICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCgpLFxuICAgICAgICAgKiAgICAgbGFzdDogbmV3IEZvcm1Db250cm9sKClcbiAgICAgICAgICogIH0pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiBudWxsLCBsYXN0OiBudWxsfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgZm9ybS5zZXRWYWx1ZSh7Zmlyc3Q6ICdOYW5jeScsIGxhc3Q6ICdEcmV3J30pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiAnTmFuY3knLCBsYXN0OiAnRHJldyd9XG4gICAgICAgICAqXG4gICAgICAgICAqICBgYGBcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrQWxsVmFsdWVzUHJlc2VudCh2YWx1ZSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl90aHJvd0lmQ29udHJvbE1pc3NpbmcobmFtZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udHJvbHNbbmFtZV0uc2V0VmFsdWUodmFsdWVbbmFtZV0sIHsgb25seVNlbGY6IHRydWUgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBQYXRjaGVzIHRoZSB2YWx1ZSBvZiB0aGUge0BsaW5rIEZvcm1Hcm91cH0uIEl0IGFjY2VwdHMgYW4gb2JqZWN0IHdpdGggY29udHJvbFxuICAgICAgICAgKiAgbmFtZXMgYXMga2V5cywgYW5kIHdpbGwgZG8gaXRzIGJlc3QgdG8gbWF0Y2ggdGhlIHZhbHVlcyB0byB0aGUgY29ycmVjdCBjb250cm9sc1xuICAgICAgICAgKiAgaW4gdGhlIGdyb3VwLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgSXQgYWNjZXB0cyBib3RoIHN1cGVyLXNldHMgYW5kIHN1Yi1zZXRzIG9mIHRoZSBncm91cCB3aXRob3V0IHRocm93aW5nIGFuIGVycm9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKiAgY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAgICAgKiAgICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCgpLFxuICAgICAgICAgKiAgICAgbGFzdDogbmV3IEZvcm1Db250cm9sKClcbiAgICAgICAgICogIH0pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiBudWxsLCBsYXN0OiBudWxsfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgZm9ybS5wYXRjaFZhbHVlKHtmaXJzdDogJ05hbmN5J30pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiAnTmFuY3knLCBsYXN0OiBudWxsfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLnBhdGNoVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHZhbHVlKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbnRyb2xzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyb2xzW25hbWVdLnBhdGNoVmFsdWUodmFsdWVbbmFtZV0sIHsgb25seVNlbGY6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgdGhlIHtAbGluayBGb3JtR3JvdXB9LiBUaGlzIG1lYW5zIGJ5IGRlZmF1bHQ6XG4gICAgICAgICAqXG4gICAgICAgICAqICogVGhlIGdyb3VwIGFuZCBhbGwgZGVzY2VuZGFudHMgYXJlIG1hcmtlZCBgcHJpc3RpbmVgXG4gICAgICAgICAqICogVGhlIGdyb3VwIGFuZCBhbGwgZGVzY2VuZGFudHMgYXJlIG1hcmtlZCBgdW50b3VjaGVkYFxuICAgICAgICAgKiAqIFRoZSB2YWx1ZSBvZiBhbGwgZGVzY2VuZGFudHMgd2lsbCBiZSBudWxsIG9yIG51bGwgbWFwc1xuICAgICAgICAgKlxuICAgICAgICAgKiBZb3UgY2FuIGFsc28gcmVzZXQgdG8gYSBzcGVjaWZpYyBmb3JtIHN0YXRlIGJ5IHBhc3NpbmcgaW4gYSBtYXAgb2Ygc3RhdGVzXG4gICAgICAgICAqIHRoYXQgbWF0Y2hlcyB0aGUgc3RydWN0dXJlIG9mIHlvdXIgZm9ybSwgd2l0aCBjb250cm9sIG5hbWVzIGFzIGtleXMuIFRoZSBzdGF0ZVxuICAgICAgICAgKiBjYW4gYmUgYSBzdGFuZGFsb25lIHZhbHVlIG9yIGEgZm9ybSBzdGF0ZSBvYmplY3Qgd2l0aCBib3RoIGEgdmFsdWUgYW5kIGEgZGlzYWJsZWRcbiAgICAgICAgICogc3RhdHVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiB0aGlzLmZvcm0ucmVzZXQoe2ZpcnN0OiAnbmFtZScsIGxhc3Q6ICdsYXN0IG5hbWUnfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuZm9ybS52YWx1ZSk7ICAvLyB7Zmlyc3Q6ICduYW1lJywgbGFzdDogJ2xhc3QgbmFtZSd9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiAtIE9SIC1cbiAgICAgICAgICpcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqIHRoaXMuZm9ybS5yZXNldCh7XG4gICAgICAgICAqICAgZmlyc3Q6IHt2YWx1ZTogJ25hbWUnLCBkaXNhYmxlZDogdHJ1ZX0sXG4gICAgICAgICAqICAgbGFzdDogJ2xhc3QnXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmZvcm0udmFsdWUpOyAgLy8ge2ZpcnN0OiAnbmFtZScsIGxhc3Q6ICdsYXN0IG5hbWUnfVxuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmZvcm0uZ2V0KCdmaXJzdCcpLnN0YXR1cyk7ICAvLyAnRElTQUJMRUQnXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0ge307IH1cbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLnJlc2V0KHZhbHVlW25hbWVdLCB7IG9ubHlTZWxmOiB0cnVlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQcmlzdGluZSh7IG9ubHlTZWxmOiBvbmx5U2VsZiB9KTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRvdWNoZWQoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYWdncmVnYXRlIHZhbHVlIG9mIHRoZSB7QGxpbmsgRm9ybUdyb3VwfSwgaW5jbHVkaW5nIGFueSBkaXNhYmxlZCBjb250cm9scy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgeW91J2QgbGlrZSB0byBpbmNsdWRlIGFsbCB2YWx1ZXMgcmVnYXJkbGVzcyBvZiBkaXNhYmxlZCBzdGF0dXMsIHVzZSB0aGlzIG1ldGhvZC5cbiAgICAgICAgICogT3RoZXJ3aXNlLCB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBpcyB0aGUgYmVzdCB3YXkgdG8gZ2V0IHRoZSB2YWx1ZSBvZiB0aGUgZ3JvdXAuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLmdldFJhd1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZUNoaWxkcmVuKHt9LCBmdW5jdGlvbiAoYWNjLCBjb250cm9sLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgYWNjW25hbWVdID0gY29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fdGhyb3dJZkNvbnRyb2xNaXNzaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5jb250cm9scykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuICAgICAgICBUaGVyZSBhcmUgbm8gZm9ybSBjb250cm9scyByZWdpc3RlcmVkIHdpdGggdGhpcyBncm91cCB5ZXQuICBJZiB5b3UncmUgdXNpbmcgbmdNb2RlbCxcXG4gICAgICAgIHlvdSBtYXkgd2FudCB0byBjaGVjayBuZXh0IHRpY2sgKGUuZy4gdXNlIHNldFRpbWVvdXQpLlxcbiAgICAgIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5jb250cm9sc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGZvcm0gY29udHJvbCB3aXRoIG5hbWU6IFwiICsgbmFtZSArIFwiLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLl9mb3JFYWNoQ2hpbGQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmNvbnRyb2xzKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IHJldHVybiBjYihfdGhpcy5jb250cm9sc1trXSwgayk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1Hcm91cC5wcm90b3R5cGUuX3NldFVwQ29udHJvbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbC5zZXRQYXJlbnQoX3RoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKF90aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX3ZhbHVlID0gdGhpcy5fcmVkdWNlVmFsdWUoKTsgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtR3JvdXAucHJvdG90eXBlLl9hbnlDb250cm9scyA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgcmVzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMgfHwgKF90aGlzLmNvbnRhaW5zKG5hbWUpICYmIGNvbmRpdGlvbihjb250cm9sKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fcmVkdWNlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZUNoaWxkcmVuKHt9LCBmdW5jdGlvbiAoYWNjLCBjb250cm9sLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuZW5hYmxlZCB8fCBfdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBhY2NbbmFtZV0gPSBjb250cm9sLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fcmVkdWNlQ2hpbGRyZW4gPSBmdW5jdGlvbiAoaW5pdFZhbHVlLCBmbikge1xuICAgICAgICAgICAgdmFyIHJlcyA9IGluaXRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCwgbmFtZSkgeyByZXMgPSBmbihyZXMsIGNvbnRyb2wsIG5hbWUpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fYWxsQ29udHJvbHNEaXNhYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyh0aGlzLmNvbnRyb2xzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbE5hbWUgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbHNbY29udHJvbE5hbWVdLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmNvbnRyb2xzKS5sZW5ndGggPiAwIHx8IHRoaXMuZGlzYWJsZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUdyb3VwLnByb3RvdHlwZS5fY2hlY2tBbGxWYWx1ZXNQcmVzZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHN1cHBseSBhIHZhbHVlIGZvciBmb3JtIGNvbnRyb2wgd2l0aCBuYW1lOiAnXCIgKyBuYW1lICsgXCInLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1Hcm91cDtcbiAgICB9KEFic3RyYWN0Q29udHJvbCkpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFRyYWNrcyB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IHN0YXRlIG9mIGFuIGFycmF5IG9mIHtAbGluayBGb3JtQ29udHJvbH1cbiAgICAgKiBpbnN0YW5jZXMuXG4gICAgICpcbiAgICAgKiBBIGBGb3JtQXJyYXlgIGFnZ3JlZ2F0ZXMgdGhlIHZhbHVlcyBvZiBlYWNoIGNoaWxkIHtAbGluayBGb3JtQ29udHJvbH0gaW50byBhbiBhcnJheS5cbiAgICAgKiBJdCBjYWxjdWxhdGVzIGl0cyBzdGF0dXMgYnkgcmVkdWNpbmcgdGhlIHN0YXR1c2VzIG9mIGl0cyBjaGlsZHJlbi4gRm9yIGV4YW1wbGUsIGlmIG9uZSBvZlxuICAgICAqIHRoZSBjb250cm9scyBpbiBhIGBGb3JtQXJyYXlgIGlzIGludmFsaWQsIHRoZSBlbnRpcmUgYXJyYXkgYmVjb21lcyBpbnZhbGlkLlxuICAgICAqXG4gICAgICogYEZvcm1BcnJheWAgaXMgb25lIG9mIHRoZSB0aHJlZSBmdW5kYW1lbnRhbCBidWlsZGluZyBibG9ja3MgdXNlZCB0byBkZWZpbmUgZm9ybXMgaW4gQW5ndWxhcixcbiAgICAgKiBhbG9uZyB3aXRoIHtAbGluayBGb3JtQ29udHJvbH0gYW5kIHtAbGluayBGb3JtR3JvdXB9LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBXaGVuIGluc3RhbnRpYXRpbmcgYSB7QGxpbmsgRm9ybUFycmF5fSwgcGFzcyBpbiBhbiBhcnJheSBvZiBjaGlsZCBjb250cm9scyBhcyB0aGUgZmlyc3RcbiAgICAgKiBhcmd1bWVudC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBhcnIgPSBuZXcgRm9ybUFycmF5KFtcbiAgICAgKiAgIG5ldyBGb3JtQ29udHJvbCgnTmFuY3knLCBWYWxpZGF0b3JzLm1pbkxlbmd0aCgyKSksXG4gICAgICogICBuZXcgRm9ybUNvbnRyb2woJ0RyZXcnKSxcbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFyci52YWx1ZSk7ICAgLy8gWydOYW5jeScsICdEcmV3J11cbiAgICAgKiBjb25zb2xlLmxvZyhhcnIuc3RhdHVzKTsgIC8vICdWQUxJRCdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWxzbyBpbmNsdWRlIGFycmF5LWxldmVsIHZhbGlkYXRvcnMgYXMgdGhlIHNlY29uZCBhcmcsIG9yIGFycmF5LWxldmVsIGFzeW5jXG4gICAgICogdmFsaWRhdG9ycyBhcyB0aGUgdGhpcmQgYXJnLiBUaGVzZSBjb21lIGluIGhhbmR5IHdoZW4geW91IHdhbnQgdG8gcGVyZm9ybSB2YWxpZGF0aW9uXG4gICAgICogdGhhdCBjb25zaWRlcnMgdGhlIHZhbHVlIG9mIG1vcmUgdGhhbiBvbmUgY2hpbGQgY29udHJvbC5cbiAgICAgKlxuICAgICAqICMjIyBBZGRpbmcgb3IgcmVtb3ZpbmcgY29udHJvbHNcbiAgICAgKlxuICAgICAqIFRvIGNoYW5nZSB0aGUgY29udHJvbHMgaW4gdGhlIGFycmF5LCB1c2UgdGhlIGBwdXNoYCwgYGluc2VydGAsIG9yIGByZW1vdmVBdGAgbWV0aG9kc1xuICAgICAqIGluIGBGb3JtQXJyYXlgIGl0c2VsZi4gVGhlc2UgbWV0aG9kcyBlbnN1cmUgdGhlIGNvbnRyb2xzIGFyZSBwcm9wZXJseSB0cmFja2VkIGluIHRoZVxuICAgICAqIGZvcm0ncyBoaWVyYXJjaHkuIERvIG5vdCBtb2RpZnkgdGhlIGFycmF5IG9mIGBBYnN0cmFjdENvbnRyb2xgcyB1c2VkIHRvIGluc3RhbnRpYXRlXG4gICAgICogdGhlIGBGb3JtQXJyYXlgIGRpcmVjdGx5LCBhcyB0aGF0IHdpbGwgcmVzdWx0IGluIHN0cmFuZ2UgYW5kIHVuZXhwZWN0ZWQgYmVoYXZpb3Igc3VjaFxuICAgICAqIGFzIGJyb2tlbiBjaGFuZ2UgZGV0ZWN0aW9uLlxuICAgICAqXG4gICAgICogKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUFycmF5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDYoRm9ybUFycmF5LCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBGb3JtQXJyYXkoY29udHJvbHMsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IgPT09IHZvaWQgMCkgeyB2YWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAoYXN5bmNWYWxpZGF0b3IgPT09IHZvaWQgMCkgeyBhc3luY1ZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpO1xuICAgICAgICAgICAgdGhpcy5jb250cm9scyA9IGNvbnRyb2xzO1xuICAgICAgICAgICAgdGhpcy5faW5pdE9ic2VydmFibGVzKCk7XG4gICAgICAgICAgICB0aGlzLl9zZXRVcENvbnRyb2xzKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sfSBhdCB0aGUgZ2l2ZW4gYGluZGV4YCBpbiB0aGUgYXJyYXkuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB0aGlzLmNvbnRyb2xzW2luZGV4XTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydCBhIG5ldyB7QGxpbmsgQWJzdHJhY3RDb250cm9sfSBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnB1c2goY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlckNvbnRyb2woY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0IGEgbmV3IHtAbGluayBBYnN0cmFjdENvbnRyb2x9IGF0IHRoZSBnaXZlbiBgaW5kZXhgIGluIHRoZSBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGluZGV4LCBjb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnNwbGljZShpbmRleCwgMCwgY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlckNvbnRyb2woY29udHJvbCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHRoZSBjb250cm9sIGF0IHRoZSBnaXZlbiBgaW5kZXhgIGluIHRoZSBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1BcnJheS5wcm90b3R5cGUucmVtb3ZlQXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xzW2luZGV4XSlcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzW2luZGV4XS5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXBsYWNlIGFuIGV4aXN0aW5nIGNvbnRyb2wuXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLnNldENvbnRyb2wgPSBmdW5jdGlvbiAoaW5kZXgsIGNvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2xzW2luZGV4XSlcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xzW2luZGV4XS5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGlmIChjb250cm9sKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9scy5zcGxpY2UoaW5kZXgsIDAsIGNvbnRyb2wpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQ29udHJvbChjb250cm9sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQXJyYXkucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExlbmd0aCBvZiB0aGUgY29udHJvbCBhcnJheS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNvbnRyb2xzLmxlbmd0aDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHtAbGluayBGb3JtQXJyYXl9LiBJdCBhY2NlcHRzIGFuIGFycmF5IHRoYXQgbWF0Y2hlc1xuICAgICAgICAgKiAgdGhlIHN0cnVjdHVyZSBvZiB0aGUgY29udHJvbC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtZXRob2QgcGVyZm9ybXMgc3RyaWN0IGNoZWNrcywgc28gaXQgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgdHJ5XG4gICAgICAgICAqIHRvIHNldCB0aGUgdmFsdWUgb2YgYSBjb250cm9sIHRoYXQgZG9lc24ndCBleGlzdCBvciBpZiB5b3UgZXhjbHVkZSB0aGVcbiAgICAgICAgICogdmFsdWUgb2YgYSBjb250cm9sLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKiAgY29uc3QgYXJyID0gbmV3IEZvcm1BcnJheShbXG4gICAgICAgICAqICAgICBuZXcgRm9ybUNvbnRyb2woKSxcbiAgICAgICAgICogICAgIG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICAgICAqICBdKTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGFyci52YWx1ZSk7ICAgLy8gW251bGwsIG51bGxdXG4gICAgICAgICAqXG4gICAgICAgICAqICBhcnIuc2V0VmFsdWUoWydOYW5jeScsICdEcmV3J10pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbJ05hbmN5JywgJ0RyZXcnXVxuICAgICAgICAgKiAgYGBgXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0FsbFZhbHVlc1ByZXNlbnQodmFsdWUpO1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAobmV3VmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3Rocm93SWZDb250cm9sTWlzc2luZyhpbmRleCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYXQoaW5kZXgpLnNldFZhbHVlKG5ld1ZhbHVlLCB7IG9ubHlTZWxmOiB0cnVlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgUGF0Y2hlcyB0aGUgdmFsdWUgb2YgdGhlIHtAbGluayBGb3JtQXJyYXl9LiBJdCBhY2NlcHRzIGFuIGFycmF5IHRoYXQgbWF0Y2hlcyB0aGVcbiAgICAgICAgICogIHN0cnVjdHVyZSBvZiB0aGUgY29udHJvbCwgYW5kIHdpbGwgZG8gaXRzIGJlc3QgdG8gbWF0Y2ggdGhlIHZhbHVlcyB0byB0aGUgY29ycmVjdFxuICAgICAgICAgKiAgY29udHJvbHMgaW4gdGhlIGdyb3VwLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgSXQgYWNjZXB0cyBib3RoIHN1cGVyLXNldHMgYW5kIHN1Yi1zZXRzIG9mIHRoZSBhcnJheSB3aXRob3V0IHRocm93aW5nIGFuIGVycm9yLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgIyMjIEV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKiAgY29uc3QgYXJyID0gbmV3IEZvcm1BcnJheShbXG4gICAgICAgICAqICAgICBuZXcgRm9ybUNvbnRyb2woKSxcbiAgICAgICAgICogICAgIG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICAgICAqICBdKTtcbiAgICAgICAgICogIGNvbnNvbGUubG9nKGFyci52YWx1ZSk7ICAgLy8gW251bGwsIG51bGxdXG4gICAgICAgICAqXG4gICAgICAgICAqICBhcnIucGF0Y2hWYWx1ZShbJ05hbmN5J10pO1xuICAgICAgICAgKiAgY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbJ05hbmN5JywgbnVsbF1cbiAgICAgICAgICogIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5wYXRjaFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciBvbmx5U2VsZiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seVNlbGY7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChuZXdWYWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXQoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmF0KGluZGV4KS5wYXRjaFZhbHVlKG5ld1ZhbHVlLCB7IG9ubHlTZWxmOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzZXRzIHRoZSB7QGxpbmsgRm9ybUFycmF5fS4gVGhpcyBtZWFucyBieSBkZWZhdWx0OlxuICAgICAgICAgKlxuICAgICAgICAgKiAqIFRoZSBhcnJheSBhbmQgYWxsIGRlc2NlbmRhbnRzIGFyZSBtYXJrZWQgYHByaXN0aW5lYFxuICAgICAgICAgKiAqIFRoZSBhcnJheSBhbmQgYWxsIGRlc2NlbmRhbnRzIGFyZSBtYXJrZWQgYHVudG91Y2hlZGBcbiAgICAgICAgICogKiBUaGUgdmFsdWUgb2YgYWxsIGRlc2NlbmRhbnRzIHdpbGwgYmUgbnVsbCBvciBudWxsIG1hcHNcbiAgICAgICAgICpcbiAgICAgICAgICogWW91IGNhbiBhbHNvIHJlc2V0IHRvIGEgc3BlY2lmaWMgZm9ybSBzdGF0ZSBieSBwYXNzaW5nIGluIGFuIGFycmF5IG9mIHN0YXRlc1xuICAgICAgICAgKiB0aGF0IG1hdGNoZXMgdGhlIHN0cnVjdHVyZSBvZiB0aGUgY29udHJvbC4gVGhlIHN0YXRlIGNhbiBiZSBhIHN0YW5kYWxvbmUgdmFsdWVcbiAgICAgICAgICogb3IgYSBmb3JtIHN0YXRlIG9iamVjdCB3aXRoIGJvdGggYSB2YWx1ZSBhbmQgYSBkaXNhYmxlZCBzdGF0dXMuXG4gICAgICAgICAqXG4gICAgICAgICAqICMjIyBFeGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIHRoaXMuYXJyLnJlc2V0KFsnbmFtZScsICdsYXN0IG5hbWUnXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuYXJyLnZhbHVlKTsgIC8vIFsnbmFtZScsICdsYXN0IG5hbWUnXVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogLSBPUiAtXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiB0aGlzLmFyci5yZXNldChbXG4gICAgICAgICAqICAge3ZhbHVlOiAnbmFtZScsIGRpc2FibGVkOiB0cnVlfSxcbiAgICAgICAgICogICAnbGFzdCdcbiAgICAgICAgICogXSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKHRoaXMuYXJyLnZhbHVlKTsgIC8vIFsnbmFtZScsICdsYXN0IG5hbWUnXVxuICAgICAgICAgKiBjb25zb2xlLmxvZyh0aGlzLmFyci5nZXQoMCkuc3RhdHVzKTsgIC8vICdESVNBQkxFRCdcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSBbXTsgfVxuICAgICAgICAgICAgdmFyIG9ubHlTZWxmID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5vbmx5U2VsZjtcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLnJlc2V0KHZhbHVlW2luZGV4XSwgeyBvbmx5U2VsZjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJpc3RpbmUoeyBvbmx5U2VsZjogb25seVNlbGYgfSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUb3VjaGVkKHsgb25seVNlbGY6IG9ubHlTZWxmIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiB0aGUgYXJyYXksIGluY2x1ZGluZyBhbnkgZGlzYWJsZWQgY29udHJvbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHlvdSdkIGxpa2UgdG8gaW5jbHVkZSBhbGwgdmFsdWVzIHJlZ2FyZGxlc3Mgb2YgZGlzYWJsZWQgc3RhdHVzLCB1c2UgdGhpcyBtZXRob2QuXG4gICAgICAgICAqIE90aGVyd2lzZSwgdGhlIGB2YWx1ZWAgcHJvcGVydHkgaXMgdGhlIGJlc3Qgd2F5IHRvIGdldCB0aGUgdmFsdWUgb2YgdGhlIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5nZXRSYXdWYWx1ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuY29udHJvbHMubWFwKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLnZhbHVlOyB9KTsgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl90aHJvd0lmQ29udHJvbE1pc3NpbmcgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250cm9scy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICAgIFRoZXJlIGFyZSBubyBmb3JtIGNvbnRyb2xzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzIGFycmF5IHlldC4gIElmIHlvdSdyZSB1c2luZyBuZ01vZGVsLFxcbiAgICAgICAgeW91IG1heSB3YW50IHRvIGNoZWNrIG5leHQgdGljayAoZS5nLiB1c2Ugc2V0VGltZW91dCkuXFxuICAgICAgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmF0KGluZGV4KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGZvcm0gY29udHJvbCBhdCBpbmRleCBcIiArIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl9mb3JFYWNoQ2hpbGQgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbCwgaW5kZXgpIHsgY2IoY29udHJvbCwgaW5kZXgpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl91cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuY29udHJvbHMuZmlsdGVyKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLmVuYWJsZWQgfHwgX3RoaXMuZGlzYWJsZWQ7IH0pXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoY29udHJvbCkgeyByZXR1cm4gY29udHJvbC52YWx1ZTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5fYW55Q29udHJvbHMgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9scy5zb21lKGZ1bmN0aW9uIChjb250cm9sKSB7IHJldHVybiBjb250cm9sLmVuYWJsZWQgJiYgY29uZGl0aW9uKGNvbnRyb2wpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl9zZXRVcENvbnRyb2xzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbiAoY29udHJvbCkgeyByZXR1cm4gX3RoaXMuX3JlZ2lzdGVyQ29udHJvbChjb250cm9sKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgRm9ybUFycmF5LnByb3RvdHlwZS5fY2hlY2tBbGxWYWx1ZXNQcmVzZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNvbnRyb2wsIGkpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVbaV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHN1cHBseSBhIHZhbHVlIGZvciBmb3JtIGNvbnRyb2wgYXQgaW5kZXg6IFwiICsgaSArIFwiLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl9hbGxDb250cm9sc0Rpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY29udHJvbHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuZW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHMubGVuZ3RoID4gMCB8fCB0aGlzLmRpc2FibGVkO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtQXJyYXkucHJvdG90eXBlLl9yZWdpc3RlckNvbnRyb2wgPSBmdW5jdGlvbiAoY29udHJvbCkge1xuICAgICAgICAgICAgY29udHJvbC5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgICAgICBjb250cm9sLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZSh0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUFycmF5O1xuICAgIH0oQWJzdHJhY3RDb250cm9sKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ0ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIGZvcm1EaXJlY3RpdmVQcm92aWRlciA9IHtcbiAgICAgICAgcHJvdmlkZTogQ29udHJvbENvbnRhaW5lcixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBOZ0Zvcm07IH0pXG4gICAgfTtcbiAgICB2YXIgcmVzb2x2ZWRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIENyZWF0ZXMgYSB0b3AtbGV2ZWwge0BsaW5rIEZvcm1Hcm91cH0gaW5zdGFuY2UgYW5kIGJpbmRzIGl0IHRvIGEgZm9ybVxuICAgICAqIHRvIHRyYWNrIGFnZ3JlZ2F0ZSBmb3JtIHZhbHVlIGFuZCB2YWxpZGF0aW9uIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogQXMgc29vbiBhcyB5b3UgaW1wb3J0IHRoZSBgRm9ybXNNb2R1bGVgLCB0aGlzIGRpcmVjdGl2ZSBiZWNvbWVzIGFjdGl2ZSBieSBkZWZhdWx0IG9uXG4gICAgICogYWxsIGA8Zm9ybT5gIHRhZ3MuICBZb3UgZG9uJ3QgbmVlZCB0byBhZGQgYSBzcGVjaWFsIHNlbGVjdG9yLlxuICAgICAqXG4gICAgICogWW91IGNhbiBleHBvcnQgdGhlIGRpcmVjdGl2ZSBpbnRvIGEgbG9jYWwgdGVtcGxhdGUgdmFyaWFibGUgdXNpbmcgYG5nRm9ybWAgYXMgdGhlIGtleVxuICAgICAqIChleDogYCNteUZvcm09XCJuZ0Zvcm1cImApLiBUaGlzIGlzIG9wdGlvbmFsLCBidXQgdXNlZnVsLiAgTWFueSBwcm9wZXJ0aWVzIGZyb20gdGhlIHVuZGVybHlpbmdcbiAgICAgKiB7QGxpbmsgRm9ybUdyb3VwfSBpbnN0YW5jZSBhcmUgZHVwbGljYXRlZCBvbiB0aGUgZGlyZWN0aXZlIGl0c2VsZiwgc28gYSByZWZlcmVuY2UgdG8gaXRcbiAgICAgKiB3aWxsIGdpdmUgeW91IGFjY2VzcyB0byB0aGUgYWdncmVnYXRlIHZhbHVlIGFuZCB2YWxpZGl0eSBzdGF0dXMgb2YgdGhlIGZvcm0sIGFzIHdlbGwgYXNcbiAgICAgKiB1c2VyIGludGVyYWN0aW9uIHByb3BlcnRpZXMgbGlrZSBgZGlydHlgIGFuZCBgdG91Y2hlZGAuXG4gICAgICpcbiAgICAgKiBUbyByZWdpc3RlciBjaGlsZCBjb250cm9scyB3aXRoIHRoZSBmb3JtLCB5b3UnbGwgd2FudCB0byB1c2Uge0BsaW5rIE5nTW9kZWx9IHdpdGggYVxuICAgICAqIGBuYW1lYCBhdHRyaWJ1dGUuICBZb3UgY2FuIGFsc28gdXNlIHtAbGluayBOZ01vZGVsR3JvdXB9IGlmIHlvdSdkIGxpa2UgdG8gY3JlYXRlXG4gICAgICogc3ViLWdyb3VwcyB3aXRoaW4gdGhlIGZvcm0uXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGxpc3RlbiB0byB0aGUgZGlyZWN0aXZlJ3MgYG5nU3VibWl0YCBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB1c2VyIGhhc1xuICAgICAqIHRyaWdnZXJlZCBhIGZvcm0gc3VibWlzc2lvbi4gVGhlIGBuZ1N1Ym1pdGAgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIHdpdGggdGhlIG9yaWdpbmFsIGZvcm1cbiAgICAgKiBzdWJtaXNzaW9uIGV2ZW50LlxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL3NpbXBsZUZvcm0vc2ltcGxlX2Zvcm1fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKiAqKk5nTW9kdWxlKio6IGBGb3Jtc01vZHVsZWBcbiAgICAgKlxuICAgICAqICBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE5nRm9ybSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ0KE5nRm9ybSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gTmdGb3JtKHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9zdWJtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubmdTdWJtaXQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLmZvcm0gPVxuICAgICAgICAgICAgICAgIG5ldyBGb3JtR3JvdXAoe30sIGNvbXBvc2VWYWxpZGF0b3JzKHZhbGlkYXRvcnMpLCBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9ycykpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcInN1Ym1pdHRlZFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3N1Ym1pdHRlZDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nRm9ybS5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZm9ybTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOZ0Zvcm0ucHJvdG90eXBlLCBcImNvbnRyb2xzXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5mb3JtLmNvbnRyb2xzOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5hZGRDb250cm9sID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMuX2ZpbmRDb250YWluZXIoZGlyLnBhdGgpO1xuICAgICAgICAgICAgICAgIGRpci5fY29udHJvbCA9IGNvbnRhaW5lci5yZWdpc3RlckNvbnRyb2woZGlyLm5hbWUsIGRpci5jb250cm9sKTtcbiAgICAgICAgICAgICAgICBzZXRVcENvbnRyb2woZGlyLmNvbnRyb2wsIGRpcik7XG4gICAgICAgICAgICAgICAgZGlyLmNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5nZXRDb250cm9sID0gZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7IH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUucmVtb3ZlQ29udHJvbCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IF90aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNvbnRyb2woZGlyLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLmFkZEZvcm1Hcm91cCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IF90aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBuZXcgRm9ybUdyb3VwKHt9KTtcbiAgICAgICAgICAgICAgICBzZXRVcEZvcm1Db250YWluZXIoZ3JvdXAsIGRpcik7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlZ2lzdGVyQ29udHJvbChkaXIubmFtZSwgZ3JvdXApO1xuICAgICAgICAgICAgICAgIGdyb3VwLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUucmVtb3ZlRm9ybUdyb3VwID0gZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gX3RoaXMuX2ZpbmRDb250YWluZXIoZGlyLnBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoY29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ29udHJvbChkaXIubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUuZ2V0Rm9ybUdyb3VwID0gZnVuY3Rpb24gKGRpcikgeyByZXR1cm4gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7IH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUudXBkYXRlTW9kZWwgPSBmdW5jdGlvbiAoZGlyLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJlc29sdmVkUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3RybCA9IF90aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTtcbiAgICAgICAgICAgICAgICBjdHJsLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBOZ0Zvcm0ucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7IHRoaXMuY29udHJvbC5zZXRWYWx1ZSh2YWx1ZSk7IH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUub25TdWJtaXQgPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJtaXR0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5uZ1N1Ym1pdC5lbWl0KCRldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIE5nRm9ybS5wcm90b3R5cGUub25SZXNldCA9IGZ1bmN0aW9uICgpIHsgdGhpcy5yZXNldEZvcm0oKTsgfTtcbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5yZXNldEZvcm0gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gdW5kZWZpbmVkOyB9XG4gICAgICAgICAgICB0aGlzLmZvcm0ucmVzZXQodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fc3VibWl0dGVkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgTmdGb3JtLnByb3RvdHlwZS5fZmluZENvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID8gdGhpcy5mb3JtLmdldChwYXRoKSA6IHRoaXMuZm9ybTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdGb3JtLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdmb3JtOm5vdChbbmdOb0Zvcm1dKTpub3QoW2Zvcm1Hcm91cF0pLG5nRm9ybSxbbmdGb3JtXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtmb3JtRGlyZWN0aXZlUHJvdmlkZXJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKHN1Ym1pdCknOiAnb25TdWJtaXQoJGV2ZW50KScsICcocmVzZXQpJzogJ29uUmVzZXQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IFsnbmdTdWJtaXQnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmdGb3JtJ1xuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE5nRm9ybS5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIE5nRm9ybTtcbiAgICB9KENvbnRyb2xDb250YWluZXIpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgRXhhbXBsZXMgPSB7XG4gICAgICAgIGZvcm1Db250cm9sTmFtZTogXCJcXG4gICAgPGRpdiBbZm9ybUdyb3VwXT1cXFwibXlHcm91cFxcXCI+XFxuICAgICAgPGlucHV0IGZvcm1Db250cm9sTmFtZT1cXFwiZmlyc3ROYW1lXFxcIj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIEluIHlvdXIgY2xhc3M6XFxuXFxuICAgIHRoaXMubXlHcm91cCA9IG5ldyBGb3JtR3JvdXAoe1xcbiAgICAgICBmaXJzdE5hbWU6IG5ldyBGb3JtQ29udHJvbCgpXFxuICAgIH0pO1wiLFxuICAgICAgICBmb3JtR3JvdXBOYW1lOiBcIlxcbiAgICA8ZGl2IFtmb3JtR3JvdXBdPVxcXCJteUdyb3VwXFxcIj5cXG4gICAgICAgPGRpdiBmb3JtR3JvdXBOYW1lPVxcXCJwZXJzb25cXFwiPlxcbiAgICAgICAgICA8aW5wdXQgZm9ybUNvbnRyb2xOYW1lPVxcXCJmaXJzdE5hbWVcXFwiPlxcbiAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIEluIHlvdXIgY2xhc3M6XFxuXFxuICAgIHRoaXMubXlHcm91cCA9IG5ldyBGb3JtR3JvdXAoe1xcbiAgICAgICBwZXJzb246IG5ldyBGb3JtR3JvdXAoeyBmaXJzdE5hbWU6IG5ldyBGb3JtQ29udHJvbCgpIH0pXFxuICAgIH0pO1wiLFxuICAgICAgICBmb3JtQXJyYXlOYW1lOiBcIlxcbiAgICA8ZGl2IFtmb3JtR3JvdXBdPVxcXCJteUdyb3VwXFxcIj5cXG4gICAgICA8ZGl2IGZvcm1BcnJheU5hbWU9XFxcImNpdGllc1xcXCI+XFxuICAgICAgICA8ZGl2ICpuZ0Zvcj1cXFwibGV0IGNpdHkgb2YgY2l0eUFycmF5LmNvbnRyb2xzOyBsZXQgaT1pbmRleFxcXCI+XFxuICAgICAgICAgIDxpbnB1dCBbZm9ybUNvbnRyb2xOYW1lXT1cXFwiaVxcXCI+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXFxuICAgIEluIHlvdXIgY2xhc3M6XFxuXFxuICAgIHRoaXMuY2l0eUFycmF5ID0gbmV3IEZvcm1BcnJheShbbmV3IEZvcm1Db250cm9sKCdTRicpXSk7XFxuICAgIHRoaXMubXlHcm91cCA9IG5ldyBGb3JtR3JvdXAoe1xcbiAgICAgIGNpdGllczogdGhpcy5jaXR5QXJyYXlcXG4gICAgfSk7XCIsXG4gICAgICAgIG5nTW9kZWxHcm91cDogXCJcXG4gICAgPGZvcm0+XFxuICAgICAgIDxkaXYgbmdNb2RlbEdyb3VwPVxcXCJwZXJzb25cXFwiPlxcbiAgICAgICAgICA8aW5wdXQgWyhuZ01vZGVsKV09XFxcInBlcnNvbi5uYW1lXFxcIiBuYW1lPVxcXCJmaXJzdE5hbWVcXFwiPlxcbiAgICAgICA8L2Rpdj5cXG4gICAgPC9mb3JtPlwiLFxuICAgICAgICBuZ01vZGVsV2l0aEZvcm1Hcm91cDogXCJcXG4gICAgPGRpdiBbZm9ybUdyb3VwXT1cXFwibXlHcm91cFxcXCI+XFxuICAgICAgIDxpbnB1dCBmb3JtQ29udHJvbE5hbWU9XFxcImZpcnN0TmFtZVxcXCI+XFxuICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwic2hvd01vcmVDb250cm9sc1xcXCIgW25nTW9kZWxPcHRpb25zXT1cXFwie3N0YW5kYWxvbmU6IHRydWV9XFxcIj5cXG4gICAgPC9kaXY+XFxuICBcIlxuICAgIH07XG5cbiAgICB2YXIgVGVtcGxhdGVEcml2ZW5FcnJvcnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBUZW1wbGF0ZURyaXZlbkVycm9ycygpIHtcbiAgICAgICAgfVxuICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5tb2RlbFBhcmVudEV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgIG5nTW9kZWwgY2Fubm90IGJlIHVzZWQgdG8gcmVnaXN0ZXIgZm9ybSBjb250cm9scyB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuICBUcnkgdXNpbmdcXG4gICAgICBmb3JtR3JvdXAncyBwYXJ0bmVyIGRpcmVjdGl2ZSBcXFwiZm9ybUNvbnRyb2xOYW1lXFxcIiBpbnN0ZWFkLiAgRXhhbXBsZTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLmZvcm1Db250cm9sTmFtZSArIFwiXFxuXFxuICAgICAgT3IsIGlmIHlvdSdkIGxpa2UgdG8gYXZvaWQgcmVnaXN0ZXJpbmcgdGhpcyBmb3JtIGNvbnRyb2wsIGluZGljYXRlIHRoYXQgaXQncyBzdGFuZGFsb25lIGluIG5nTW9kZWxPcHRpb25zOlxcblxcbiAgICAgIEV4YW1wbGU6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5uZ01vZGVsV2l0aEZvcm1Hcm91cCk7XG4gICAgICAgIH07XG4gICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLmZvcm1Hcm91cE5hbWVFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICBuZ01vZGVsIGNhbm5vdCBiZSB1c2VkIHRvIHJlZ2lzdGVyIGZvcm0gY29udHJvbHMgd2l0aCBhIHBhcmVudCBmb3JtR3JvdXBOYW1lIG9yIGZvcm1BcnJheU5hbWUgZGlyZWN0aXZlLlxcblxcbiAgICAgIE9wdGlvbiAxOiBVc2UgZm9ybUNvbnRyb2xOYW1lIGluc3RlYWQgb2YgbmdNb2RlbCAocmVhY3RpdmUgc3RyYXRlZ3kpOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUdyb3VwTmFtZSArIFwiXFxuXFxuICAgICAgT3B0aW9uIDI6ICBVcGRhdGUgbmdNb2RlbCdzIHBhcmVudCBiZSBuZ01vZGVsR3JvdXAgKHRlbXBsYXRlLWRyaXZlbiBzdHJhdGVneSk6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5uZ01vZGVsR3JvdXApO1xuICAgICAgICB9O1xuICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5taXNzaW5nTmFtZUV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklmIG5nTW9kZWwgaXMgdXNlZCB3aXRoaW4gYSBmb3JtIHRhZywgZWl0aGVyIHRoZSBuYW1lIGF0dHJpYnV0ZSBtdXN0IGJlIHNldCBvciB0aGUgZm9ybVxcbiAgICAgIGNvbnRyb2wgbXVzdCBiZSBkZWZpbmVkIGFzICdzdGFuZGFsb25lJyBpbiBuZ01vZGVsT3B0aW9ucy5cXG5cXG4gICAgICBFeGFtcGxlIDE6IDxpbnB1dCBbKG5nTW9kZWwpXT1cXFwicGVyc29uLmZpcnN0TmFtZVxcXCIgbmFtZT1cXFwiZmlyc3RcXFwiPlxcbiAgICAgIEV4YW1wbGUgMjogPGlucHV0IFsobmdNb2RlbCldPVxcXCJwZXJzb24uZmlyc3ROYW1lXFxcIiBbbmdNb2RlbE9wdGlvbnNdPVxcXCJ7c3RhbmRhbG9uZTogdHJ1ZX1cXFwiPlwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgVGVtcGxhdGVEcml2ZW5FcnJvcnMubW9kZWxHcm91cFBhcmVudEV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgIG5nTW9kZWxHcm91cCBjYW5ub3QgYmUgdXNlZCB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuXFxuXFxuICAgICAgT3B0aW9uIDE6IFVzZSBmb3JtR3JvdXBOYW1lIGluc3RlYWQgb2YgbmdNb2RlbEdyb3VwIChyZWFjdGl2ZSBzdHJhdGVneSk6XFxuXFxuICAgICAgXCIgKyBFeGFtcGxlcy5mb3JtR3JvdXBOYW1lICsgXCJcXG5cXG4gICAgICBPcHRpb24gMjogIFVzZSBhIHJlZ3VsYXIgZm9ybSB0YWcgaW5zdGVhZCBvZiB0aGUgZm9ybUdyb3VwIGRpcmVjdGl2ZSAodGVtcGxhdGUtZHJpdmVuIHN0cmF0ZWd5KTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLm5nTW9kZWxHcm91cCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBUZW1wbGF0ZURyaXZlbkVycm9ycztcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkOCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIHZhciBtb2RlbEdyb3VwUHJvdmlkZXIgPSB7XG4gICAgICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTmdNb2RlbEdyb3VwOyB9KVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhbmQgYmluZHMgYSB7QGxpbmsgRm9ybUdyb3VwfSBpbnN0YW5jZSB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBUaGlzIGRpcmVjdGl2ZSBjYW4gb25seSBiZSB1c2VkIGFzIGEgY2hpbGQgb2Yge0BsaW5rIE5nRm9ybX0gKG9yIGluIG90aGVyIHdvcmRzLFxuICAgICAqIHdpdGhpbiBgPGZvcm0+YCB0YWdzKS5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGRpcmVjdGl2ZSBpZiB5b3UnZCBsaWtlIHRvIGNyZWF0ZSBhIHN1Yi1ncm91cCB3aXRoaW4gYSBmb3JtLiBUaGlzIGNhblxuICAgICAqIGNvbWUgaW4gaGFuZHkgaWYgeW91IHdhbnQgdG8gdmFsaWRhdGUgYSBzdWItZ3JvdXAgb2YgeW91ciBmb3JtIHNlcGFyYXRlbHkgZnJvbVxuICAgICAqIHRoZSByZXN0IG9mIHlvdXIgZm9ybSwgb3IgaWYgc29tZSB2YWx1ZXMgaW4geW91ciBkb21haW4gbW9kZWwgbWFrZSBtb3JlIHNlbnNlIHRvXG4gICAgICogY29uc3VtZSB0b2dldGhlciBpbiBhIG5lc3RlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBQYXNzIGluIHRoZSBuYW1lIHlvdSdkIGxpa2UgdGhpcyBzdWItZ3JvdXAgdG8gaGF2ZSBhbmQgaXQgd2lsbCBiZWNvbWUgdGhlIGtleVxuICAgICAqIGZvciB0aGUgc3ViLWdyb3VwIGluIHRoZSBmb3JtJ3MgZnVsbCB2YWx1ZS4gWW91IGNhbiBhbHNvIGV4cG9ydCB0aGUgZGlyZWN0aXZlIGludG9cbiAgICAgKiBhIGxvY2FsIHRlbXBsYXRlIHZhcmlhYmxlIHVzaW5nIGBuZ01vZGVsR3JvdXBgIChleDogYCNteUdyb3VwPVwibmdNb2RlbEdyb3VwXCJgKS5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9uZ01vZGVsR3JvdXAvbmdfbW9kZWxfZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKiAqKk5nTW9kdWxlKio6IGBGb3Jtc01vZHVsZWBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdNb2RlbEdyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDgoTmdNb2RlbEdyb3VwLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBOZ01vZGVsR3JvdXAocGFyZW50LCB2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9ycyA9IHZhbGlkYXRvcnM7XG4gICAgICAgICAgICB0aGlzLl9hc3luY1ZhbGlkYXRvcnMgPSBhc3luY1ZhbGlkYXRvcnM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBOZ01vZGVsR3JvdXAucHJvdG90eXBlLl9jaGVja1BhcmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBOZ01vZGVsR3JvdXApICYmICEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgTmdGb3JtKSkge1xuICAgICAgICAgICAgICAgIFRlbXBsYXRlRHJpdmVuRXJyb3JzLm1vZGVsR3JvdXBQYXJlbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbEdyb3VwLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ01vZGVsR3JvdXBdJywgcHJvdmlkZXJzOiBbbW9kZWxHcm91cFByb3ZpZGVyXSwgZXhwb3J0QXM6ICduZ01vZGVsR3JvdXAnIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdNb2RlbEdyb3VwLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBDb250cm9sQ29udGFpbmVyLCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNraXBTZWxmIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBOZ01vZGVsR3JvdXAucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdNb2RlbEdyb3VwJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE5nTW9kZWxHcm91cDtcbiAgICB9KEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgdmFyIF9fZXh0ZW5kcyQ3ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIGZvcm1Db250cm9sQmluZGluZyA9IHtcbiAgICAgICAgcHJvdmlkZTogTmdDb250cm9sLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5nTW9kZWw7IH0pXG4gICAgfTtcbiAgICB2YXIgcmVzb2x2ZWRQcm9taXNlJDEgPSBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhIHtAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2UgZnJvbSBhIGRvbWFpbiBtb2RlbCBhbmQgYmluZHMgaXRcbiAgICAgKiB0byBhIGZvcm0gY29udHJvbCBlbGVtZW50LlxuICAgICAqXG4gICAgICogVGhlIHtAbGluayBGb3JtQ29udHJvbH0gaW5zdGFuY2Ugd2lsbCB0cmFjayB0aGUgdmFsdWUsIHVzZXIgaW50ZXJhY3Rpb24sIGFuZFxuICAgICAqIHZhbGlkYXRpb24gc3RhdHVzIG9mIHRoZSBjb250cm9sIGFuZCBrZWVwIHRoZSB2aWV3IHN5bmNlZCB3aXRoIHRoZSBtb2RlbC4gSWYgdXNlZFxuICAgICAqIHdpdGhpbiBhIHBhcmVudCBmb3JtLCB0aGUgZGlyZWN0aXZlIHdpbGwgYWxzbyByZWdpc3RlciBpdHNlbGYgd2l0aCB0aGUgZm9ybSBhcyBhIGNoaWxkXG4gICAgICogY29udHJvbC5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgY2FuIGJlIHVzZWQgYnkgaXRzZWxmIG9yIGFzIHBhcnQgb2YgYSBsYXJnZXIgZm9ybS4gQWxsIHlvdSBuZWVkIGlzIHRoZVxuICAgICAqIGBuZ01vZGVsYCBzZWxlY3RvciB0byBhY3RpdmF0ZSBpdC5cbiAgICAgKlxuICAgICAqIEl0IGFjY2VwdHMgYSBkb21haW4gbW9kZWwgYXMgYW4gb3B0aW9uYWwge0BsaW5rIEBJbnB1dH0uIElmIHlvdSBoYXZlIGEgb25lLXdheSBiaW5kaW5nXG4gICAgICogdG8gYG5nTW9kZWxgIHdpdGggYFtdYCBzeW50YXgsIGNoYW5naW5nIHRoZSB2YWx1ZSBvZiB0aGUgZG9tYWluIG1vZGVsIGluIHRoZSBjb21wb25lbnRcbiAgICAgKiBjbGFzcyB3aWxsIHNldCB0aGUgdmFsdWUgaW4gdGhlIHZpZXcuIElmIHlvdSBoYXZlIGEgdHdvLXdheSBiaW5kaW5nIHdpdGggYFsoKV1gIHN5bnRheFxuICAgICAqIChhbHNvIGtub3duIGFzICdiYW5hbmEtYm94IHN5bnRheCcpLCB0aGUgdmFsdWUgaW4gdGhlIFVJIHdpbGwgYWx3YXlzIGJlIHN5bmNlZCBiYWNrIHRvXG4gICAgICogdGhlIGRvbWFpbiBtb2RlbCBpbiB5b3VyIGNsYXNzIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBJZiB5b3Ugd2lzaCB0byBpbnNwZWN0IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBhc3NvY2lhdGVkIHtAbGluayBGb3JtQ29udHJvbH0gKGxpa2VcbiAgICAgKiB2YWxpZGl0eSBzdGF0ZSksIHlvdSBjYW4gYWxzbyBleHBvcnQgdGhlIGRpcmVjdGl2ZSBpbnRvIGEgbG9jYWwgdGVtcGxhdGUgdmFyaWFibGUgdXNpbmdcbiAgICAgKiBgbmdNb2RlbGAgYXMgdGhlIGtleSAoZXg6IGAjbXlWYXI9XCJuZ01vZGVsXCJgKS4gWW91IGNhbiB0aGVuIGFjY2VzcyB0aGUgY29udHJvbCB1c2luZyB0aGVcbiAgICAgKiBkaXJlY3RpdmUncyBgY29udHJvbGAgcHJvcGVydHksIGJ1dCBtb3N0IHByb3BlcnRpZXMgeW91J2xsIG5lZWQgKGxpa2UgYHZhbGlkYCBhbmQgYGRpcnR5YClcbiAgICAgKiB3aWxsIGZhbGwgdGhyb3VnaCB0byB0aGUgY29udHJvbCBhbnl3YXksIHNvIHlvdSBjYW4gYWNjZXNzIHRoZW0gZGlyZWN0bHkuIFlvdSBjYW4gc2VlIGFcbiAgICAgKiBmdWxsIGxpc3Qgb2YgcHJvcGVydGllcyBkaXJlY3RseSBhdmFpbGFibGUgaW4ge0BsaW5rIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZX0uXG4gICAgICpcbiAgICAgKiBUaGUgZm9sbG93aW5nIGlzIGFuIGV4YW1wbGUgb2YgYSBzaW1wbGUgc3RhbmRhbG9uZSBjb250cm9sIHVzaW5nIGBuZ01vZGVsYDpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVOZ01vZGVsL3NpbXBsZV9uZ19tb2RlbF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqIFdoZW4gdXNpbmcgdGhlIGBuZ01vZGVsYCB3aXRoaW4gYDxmb3JtPmAgdGFncywgeW91J2xsIGFsc28gbmVlZCB0byBzdXBwbHkgYSBgbmFtZWAgYXR0cmlidXRlXG4gICAgICogc28gdGhhdCB0aGUgY29udHJvbCBjYW4gYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBwYXJlbnQgZm9ybSB1bmRlciB0aGF0IG5hbWUuXG4gICAgICpcbiAgICAgKiBJdCdzIHdvcnRoIG5vdGluZyB0aGF0IGluIHRoZSBjb250ZXh0IG9mIGEgcGFyZW50IGZvcm0sIHlvdSBvZnRlbiBjYW4gc2tpcCBvbmUtd2F5IG9yXG4gICAgICogdHdvLXdheSBiaW5kaW5nIGJlY2F1c2UgdGhlIHBhcmVudCBmb3JtIHdpbGwgc3luYyB0aGUgdmFsdWUgZm9yIHlvdS4gWW91IGNhbiBhY2Nlc3NcbiAgICAgKiBpdHMgcHJvcGVydGllcyBieSBleHBvcnRpbmcgaXQgaW50byBhIGxvY2FsIHRlbXBsYXRlIHZhcmlhYmxlIHVzaW5nIGBuZ0Zvcm1gIChleDpcbiAgICAgKiBgI2Y9XCJuZ0Zvcm1cImApLiBUaGVuIHlvdSBjYW4gcGFzcyBpdCB3aGVyZSBpdCBuZWVkcyB0byBnbyBvbiBzdWJtaXQuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgZG8gbmVlZCB0byBwb3B1bGF0ZSBpbml0aWFsIHZhbHVlcyBpbnRvIHlvdXIgZm9ybSwgdXNpbmcgYSBvbmUtd2F5IGJpbmRpbmcgZm9yXG4gICAgICogYG5nTW9kZWxgIHRlbmRzIHRvIGJlIHN1ZmZpY2llbnQgYXMgbG9uZyBhcyB5b3UgdXNlIHRoZSBleHBvcnRlZCBmb3JtJ3MgdmFsdWUgcmF0aGVyXG4gICAgICogdGhhbiB0aGUgZG9tYWluIG1vZGVsJ3MgdmFsdWUgb24gc3VibWl0LlxuICAgICAqXG4gICAgICogVGFrZSBhIGxvb2sgYXQgYW4gZXhhbXBsZSBvZiB1c2luZyBgbmdNb2RlbGAgd2l0aGluIGEgZm9ybTpcbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtL3NpbXBsZV9mb3JtX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogVG8gc2VlIGBuZ01vZGVsYCBleGFtcGxlcyB3aXRoIGRpZmZlcmVudCBmb3JtIGNvbnRyb2wgdHlwZXMsIHNlZTpcbiAgICAgKlxuICAgICAqICogUmFkaW8gYnV0dG9uczoge0BsaW5rIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3J9XG4gICAgICogKiBTZWxlY3RzOiB7QGxpbmsgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3J9XG4gICAgICpcbiAgICAgKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICoqTmdNb2R1bGUqKjogYEZvcm1zTW9kdWxlYFxuICAgICAqXG4gICAgICogIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgTmdNb2RlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQ3KE5nTW9kZWwsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE5nTW9kZWwocGFyZW50LCB2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMsIHZhbHVlQWNjZXNzb3JzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5fcmF3VmFsaWRhdG9ycyA9IHZhbGlkYXRvcnMgfHwgW107XG4gICAgICAgICAgICB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMgPSBhc3luY1ZhbGlkYXRvcnMgfHwgW107XG4gICAgICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3IgPSBzZWxlY3RWYWx1ZUFjY2Vzc29yKHRoaXMsIHZhbHVlQWNjZXNzb3JzKTtcbiAgICAgICAgfVxuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0ZvckVycm9ycygpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9yZWdpc3RlcmVkKVxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFVwQ29udHJvbCgpO1xuICAgICAgICAgICAgaWYgKCdpc0Rpc2FibGVkJyBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGlzYWJsZWQoY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcm9wZXJ0eVVwZGF0ZWQoY2hhbmdlcywgdGhpcy52aWV3TW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgdGhpcy5mb3JtRGlyZWN0aXZlICYmIHRoaXMuZm9ybURpcmVjdGl2ZS5yZW1vdmVDb250cm9sKHRoaXMpOyB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2RlbC5wcm90b3R5cGUsIFwiY29udHJvbFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2NvbnRyb2w7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2RlbC5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gY29udHJvbFBhdGgodGhpcy5uYW1lLCB0aGlzLl9wYXJlbnQpIDogW3RoaXMubmFtZV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5nTW9kZWwucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuZm9ybURpcmVjdGl2ZSA6IG51bGw7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2RlbC5wcm90b3R5cGUsIFwidmFsaWRhdG9yXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcG9zZVZhbGlkYXRvcnModGhpcy5fcmF3VmFsaWRhdG9ycyk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmdNb2RlbC5wcm90b3R5cGUsIFwiYXN5bmNWYWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2VBc3luY1ZhbGlkYXRvcnModGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS52aWV3VG9Nb2RlbFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlLmVtaXQobmV3VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5fc2V0VXBDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5faXNTdGFuZGFsb25lKCkgPyB0aGlzLl9zZXRVcFN0YW5kYWxvbmUoKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLmFkZENvbnRyb2wodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX2lzU3RhbmRhbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5fcGFyZW50IHx8ICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnN0YW5kYWxvbmUpO1xuICAgICAgICB9O1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5fc2V0VXBTdGFuZGFsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0VXBDb250cm9sKHRoaXMuX2NvbnRyb2wsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX2NoZWNrRm9yRXJyb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1N0YW5kYWxvbmUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFyZW50VHlwZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2hlY2tOYW1lKCk7XG4gICAgICAgIH07XG4gICAgICAgIE5nTW9kZWwucHJvdG90eXBlLl9jaGVja1BhcmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBOZ01vZGVsR3JvdXApICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50IGluc3RhbmNlb2YgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5mb3JtR3JvdXBOYW1lRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIE5nTW9kZWxHcm91cCkgJiYgISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBOZ0Zvcm0pKSB7XG4gICAgICAgICAgICAgICAgVGVtcGxhdGVEcml2ZW5FcnJvcnMubW9kZWxQYXJlbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX2NoZWNrTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm5hbWUpXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5vcHRpb25zLm5hbWU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzU3RhbmRhbG9uZSgpICYmICF0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZURyaXZlbkVycm9ycy5taXNzaW5nTmFtZUV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBOZ01vZGVsLnByb3RvdHlwZS5fdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UkMS50aGVuKGZ1bmN0aW9uICgpIHsgX3RoaXMuY29udHJvbC5zZXRWYWx1ZSh2YWx1ZSwgeyBlbWl0Vmlld1RvTW9kZWxDaGFuZ2U6IGZhbHNlIH0pOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5wcm90b3R5cGUuX3VwZGF0ZURpc2FibGVkID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZGlzYWJsZWRWYWx1ZSA9IGNoYW5nZXNbJ2lzRGlzYWJsZWQnXS5jdXJyZW50VmFsdWU7XG4gICAgICAgICAgICB2YXIgaXNEaXNhYmxlZCA9IGRpc2FibGVkVmFsdWUgPT09ICcnIHx8IChkaXNhYmxlZFZhbHVlICYmIGRpc2FibGVkVmFsdWUgIT09ICdmYWxzZScpO1xuICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlJDEudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQgJiYgIV90aGlzLmNvbnRyb2wuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29udHJvbC5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0Rpc2FibGVkICYmIF90aGlzLmNvbnRyb2wuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29udHJvbC5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgTmdNb2RlbC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW25nTW9kZWxdOm5vdChbZm9ybUNvbnRyb2xOYW1lXSk6bm90KFtmb3JtQ29udHJvbF0pJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW2Zvcm1Db250cm9sQmluZGluZ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ25nTW9kZWwnXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgTmdNb2RlbC5jdG9yUGFyYW1ldGVycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSG9zdCB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlMsXSB9LF0gfSxcbiAgICAgICAgICAgIHsgdHlwZTogQXJyYXksIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNlbGYgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdCwgYXJnczogW05HX1ZBTFVFX0FDQ0VTU09SLF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIE5nTW9kZWwucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbmFtZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICAgICAgJ2lzRGlzYWJsZWQnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Rpc2FibGVkJyxdIH0sXSxcbiAgICAgICAgICAgICdtb2RlbCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdNb2RlbCcsXSB9LF0sXG4gICAgICAgICAgICAnb3B0aW9ucyc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnbmdNb2RlbE9wdGlvbnMnLF0gfSxdLFxuICAgICAgICAgICAgJ3VwZGF0ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3V0cHV0LCBhcmdzOiBbJ25nTW9kZWxDaGFuZ2UnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTmdNb2RlbDtcbiAgICB9KE5nQ29udHJvbCkpO1xuXG4gICAgdmFyIFJlYWN0aXZlRXJyb3JzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gUmVhY3RpdmVFcnJvcnMoKSB7XG4gICAgICAgIH1cbiAgICAgICAgUmVhY3RpdmVFcnJvcnMuY29udHJvbFBhcmVudEV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm1Db250cm9sTmFtZSBtdXN0IGJlIHVzZWQgd2l0aCBhIHBhcmVudCBmb3JtR3JvdXAgZGlyZWN0aXZlLiAgWW91J2xsIHdhbnQgdG8gYWRkIGEgZm9ybUdyb3VwXFxuICAgICAgIGRpcmVjdGl2ZSBhbmQgcGFzcyBpdCBhbiBleGlzdGluZyBGb3JtR3JvdXAgaW5zdGFuY2UgKHlvdSBjYW4gY3JlYXRlIG9uZSBpbiB5b3VyIGNsYXNzKS5cXG5cXG4gICAgICBFeGFtcGxlOlxcblxcbiAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUNvbnRyb2xOYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVhY3RpdmVFcnJvcnMubmdNb2RlbEdyb3VwRXhjZXB0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZm9ybUNvbnRyb2xOYW1lIGNhbm5vdCBiZSB1c2VkIHdpdGggYW4gbmdNb2RlbEdyb3VwIHBhcmVudC4gSXQgaXMgb25seSBjb21wYXRpYmxlIHdpdGggcGFyZW50c1xcbiAgICAgICB0aGF0IGFsc28gaGF2ZSBhIFxcXCJmb3JtXFxcIiBwcmVmaXg6IGZvcm1Hcm91cE5hbWUsIGZvcm1BcnJheU5hbWUsIG9yIGZvcm1Hcm91cC5cXG5cXG4gICAgICAgT3B0aW9uIDE6ICBVcGRhdGUgdGhlIHBhcmVudCB0byBiZSBmb3JtR3JvdXBOYW1lIChyZWFjdGl2ZSBmb3JtIHN0cmF0ZWd5KVxcblxcbiAgICAgICAgXCIgKyBFeGFtcGxlcy5mb3JtR3JvdXBOYW1lICsgXCJcXG5cXG4gICAgICAgIE9wdGlvbiAyOiBVc2UgbmdNb2RlbCBpbnN0ZWFkIG9mIGZvcm1Db250cm9sTmFtZSAodGVtcGxhdGUtZHJpdmVuIHN0cmF0ZWd5KVxcblxcbiAgICAgICAgXCIgKyBFeGFtcGxlcy5uZ01vZGVsR3JvdXApO1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdGl2ZUVycm9ycy5taXNzaW5nRm9ybUV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm1Hcm91cCBleHBlY3RzIGEgRm9ybUdyb3VwIGluc3RhbmNlLiBQbGVhc2UgcGFzcyBvbmUgaW4uXFxuXFxuICAgICAgIEV4YW1wbGU6XFxuXFxuICAgICAgIFwiICsgRXhhbXBsZXMuZm9ybUNvbnRyb2xOYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVhY3RpdmVFcnJvcnMuZ3JvdXBQYXJlbnRFeGNlcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtR3JvdXBOYW1lIG11c3QgYmUgdXNlZCB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuICBZb3UnbGwgd2FudCB0byBhZGQgYSBmb3JtR3JvdXBcXG4gICAgICBkaXJlY3RpdmUgYW5kIHBhc3MgaXQgYW4gZXhpc3RpbmcgRm9ybUdyb3VwIGluc3RhbmNlICh5b3UgY2FuIGNyZWF0ZSBvbmUgaW4geW91ciBjbGFzcykuXFxuXFxuICAgICAgRXhhbXBsZTpcXG5cXG4gICAgICBcIiArIEV4YW1wbGVzLmZvcm1Hcm91cE5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdGl2ZUVycm9ycy5hcnJheVBhcmVudEV4Y2VwdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvcm1BcnJheU5hbWUgbXVzdCBiZSB1c2VkIHdpdGggYSBwYXJlbnQgZm9ybUdyb3VwIGRpcmVjdGl2ZS4gIFlvdSdsbCB3YW50IHRvIGFkZCBhIGZvcm1Hcm91cFxcbiAgICAgICBkaXJlY3RpdmUgYW5kIHBhc3MgaXQgYW4gZXhpc3RpbmcgRm9ybUdyb3VwIGluc3RhbmNlICh5b3UgY2FuIGNyZWF0ZSBvbmUgaW4geW91ciBjbGFzcykuXFxuXFxuICAgICAgICBFeGFtcGxlOlxcblxcbiAgICAgICAgXCIgKyBFeGFtcGxlcy5mb3JtQXJyYXlOYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVhY3RpdmVFcnJvcnMuZGlzYWJsZWRBdHRyV2FybmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlxcbiAgICAgIEl0IGxvb2tzIGxpa2UgeW91J3JlIHVzaW5nIHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUgd2l0aCBhIHJlYWN0aXZlIGZvcm0gZGlyZWN0aXZlLiBJZiB5b3Ugc2V0IGRpc2FibGVkIHRvIHRydWVcXG4gICAgICB3aGVuIHlvdSBzZXQgdXAgdGhpcyBjb250cm9sIGluIHlvdXIgY29tcG9uZW50IGNsYXNzLCB0aGUgZGlzYWJsZWQgYXR0cmlidXRlIHdpbGwgYWN0dWFsbHkgYmUgc2V0IGluIHRoZSBET00gZm9yXFxuICAgICAgeW91LiBXZSByZWNvbW1lbmQgdXNpbmcgdGhpcyBhcHByb2FjaCB0byBhdm9pZCAnY2hhbmdlZCBhZnRlciBjaGVja2VkJyBlcnJvcnMuXFxuICAgICAgIFxcbiAgICAgIEV4YW1wbGU6IFxcbiAgICAgIGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcXG4gICAgICAgIGZpcnN0OiBuZXcgRm9ybUNvbnRyb2woe3ZhbHVlOiAnTmFuY3knLCBkaXNhYmxlZDogdHJ1ZX0sIFZhbGlkYXRvcnMucmVxdWlyZWQpLFxcbiAgICAgICAgbGFzdDogbmV3IEZvcm1Db250cm9sKCdEcmV3JywgVmFsaWRhdG9ycy5yZXF1aXJlZClcXG4gICAgICB9KTtcXG4gICAgXCIpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVhY3RpdmVFcnJvcnM7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDkgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgZm9ybUNvbnRyb2xCaW5kaW5nJDEgPSB7XG4gICAgICAgIHByb3ZpZGU6IE5nQ29udHJvbCxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBGb3JtQ29udHJvbERpcmVjdGl2ZTsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzIFN5bmNzIGEgc3RhbmRhbG9uZSB7QGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlIHRvIGEgZm9ybSBjb250cm9sIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBJbiBvdGhlciB3b3JkcywgdGhpcyBkaXJlY3RpdmUgZW5zdXJlcyB0aGF0IGFueSB2YWx1ZXMgd3JpdHRlbiB0byB0aGUge0BsaW5rIEZvcm1Db250cm9sfVxuICAgICAqIGluc3RhbmNlIHByb2dyYW1tYXRpY2FsbHkgd2lsbCBiZSB3cml0dGVuIHRvIHRoZSBET00gZWxlbWVudCAobW9kZWwgLT4gdmlldykuIENvbnZlcnNlbHksXG4gICAgICogYW55IHZhbHVlcyB3cml0dGVuIHRvIHRoZSBET00gZWxlbWVudCB0aHJvdWdoIHVzZXIgaW5wdXQgd2lsbCBiZSByZWZsZWN0ZWQgaW4gdGhlXG4gICAgICoge0BsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSAodmlldyAtPiBtb2RlbCkuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGRpcmVjdGl2ZSBpZiB5b3UnZCBsaWtlIHRvIGNyZWF0ZSBhbmQgbWFuYWdlIGEge0BsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSBkaXJlY3RseS5cbiAgICAgKiBTaW1wbHkgY3JlYXRlIGEge0BsaW5rIEZvcm1Db250cm9sfSwgc2F2ZSBpdCB0byB5b3VyIGNvbXBvbmVudCBjbGFzcywgYW5kIHBhc3MgaXQgaW50byB0aGVcbiAgICAgKiB7QGxpbmsgRm9ybUNvbnRyb2xEaXJlY3RpdmV9LlxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBhcyBhIHN0YW5kYWxvbmUgY29udHJvbC4gIFVubGlrZSB7QGxpbmsgRm9ybUNvbnRyb2xOYW1lfSxcbiAgICAgKiBpdCBkb2VzIG5vdCByZXF1aXJlIHRoYXQgeW91ciB7QGxpbmsgRm9ybUNvbnRyb2x9IGluc3RhbmNlIGJlIHBhcnQgb2YgYW55IHBhcmVudFxuICAgICAqIHtAbGluayBGb3JtR3JvdXB9LCBhbmQgaXQgd29uJ3QgYmUgcmVnaXN0ZXJlZCB0byBhbnkge0BsaW5rIEZvcm1Hcm91cERpcmVjdGl2ZX0gdGhhdFxuICAgICAqIGV4aXN0cyBhYm92ZSBpdC5cbiAgICAgKlxuICAgICAqICoqR2V0IHRoZSB2YWx1ZSoqOiB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBpcyBhbHdheXMgc3luY2VkIGFuZCBhdmFpbGFibGUgb24gdGhlXG4gICAgICoge0BsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZS4gU2VlIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBwcm9wZXJ0aWVzIGluXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbH0uXG4gICAgICpcbiAgICAgKiAqKlNldCB0aGUgdmFsdWUqKjogWW91IGNhbiBwYXNzIGluIGFuIGluaXRpYWwgdmFsdWUgd2hlbiBpbnN0YW50aWF0aW5nIHRoZSB7QGxpbmsgRm9ybUNvbnRyb2x9LFxuICAgICAqIG9yIHlvdSBjYW4gc2V0IGl0IHByb2dyYW1tYXRpY2FsbHkgbGF0ZXIgdXNpbmcge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zZXRWYWx1ZX0gb3JcbiAgICAgKiB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnBhdGNoVmFsdWV9LlxuICAgICAqXG4gICAgICogKipMaXN0ZW4gdG8gdmFsdWUqKjogSWYgeW91IHdhbnQgdG8gbGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sLCB5b3UgY2FuXG4gICAgICogc3Vic2NyaWJlIHRvIHRoZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnZhbHVlQ2hhbmdlc30gZXZlbnQuICBZb3UgY2FuIGFsc28gbGlzdGVuIHRvXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXNDaGFuZ2VzfSB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB2YWxpZGF0aW9uIHN0YXR1cyBpc1xuICAgICAqIHJlLWNhbGN1bGF0ZWQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL3NpbXBsZUZvcm1Db250cm9sL3NpbXBsZV9mb3JtX2NvbnRyb2xfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAqICoqbnBtIHBhY2thZ2UqKjogYEBhbmd1bGFyL2Zvcm1zYFxuICAgICAqXG4gICAgICogKiAqKk5nTW9kdWxlKio6IGBSZWFjdGl2ZUZvcm1zTW9kdWxlYFxuICAgICAqXG4gICAgICogIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUNvbnRyb2xEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkOShGb3JtQ29udHJvbERpcmVjdGl2ZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRm9ybUNvbnRyb2xEaXJlY3RpdmUodmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzLCB2YWx1ZUFjY2Vzc29ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3Jhd1ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzID0gYXN5bmNWYWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yID0gc2VsZWN0VmFsdWVBY2Nlc3Nvcih0aGlzLCB2YWx1ZUFjY2Vzc29ycyk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpc0Rpc2FibGVkXCIsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHsgUmVhY3RpdmVFcnJvcnMuZGlzYWJsZWRBdHRyV2FybmluZygpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0NvbnRyb2xDaGFuZ2VkKGNoYW5nZXMpKSB7XG4gICAgICAgICAgICAgICAgc2V0VXBDb250cm9sKHRoaXMuZm9ybSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbC5kaXNhYmxlZCAmJiB0aGlzLnZhbHVlQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHRoaXMudmlld01vZGVsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybS5zZXRWYWx1ZSh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ2YWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb3NlVmFsaWRhdG9ycyh0aGlzLl9yYXdWYWxpZGF0b3JzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYXN5bmNWYWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2VBc3luY1ZhbGlkYXRvcnModGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmZvcm07IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBGb3JtQ29udHJvbERpcmVjdGl2ZS5wcm90b3R5cGUudmlld1RvTW9kZWxVcGRhdGUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZS5lbWl0KG5ld1ZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvdG90eXBlLl9pc0NvbnRyb2xDaGFuZ2VkID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VzLmhhc093blByb3BlcnR5KCdmb3JtJyk7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Db250cm9sRGlyZWN0aXZlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbeyBzZWxlY3RvcjogJ1tmb3JtQ29udHJvbF0nLCBwcm92aWRlcnM6IFtmb3JtQ29udHJvbEJpbmRpbmckMV0sIGV4cG9ydEFzOiAnbmdGb3JtJyB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1Db250cm9sRGlyZWN0aXZlLmN0b3JQYXJhbWV0ZXJzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMVUVfQUNDRVNTT1IsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgRm9ybUNvbnRyb2xEaXJlY3RpdmUucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnZm9ybSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQsIGFyZ3M6IFsnZm9ybUNvbnRyb2wnLF0gfSxdLFxuICAgICAgICAgICAgJ21vZGVsJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWyduZ01vZGVsJyxdIH0sXSxcbiAgICAgICAgICAgICd1cGRhdGUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk91dHB1dCwgYXJnczogWyduZ01vZGVsQ2hhbmdlJyxdIH0sXSxcbiAgICAgICAgICAgICdpc0Rpc2FibGVkJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWydkaXNhYmxlZCcsXSB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBGb3JtQ29udHJvbERpcmVjdGl2ZTtcbiAgICB9KE5nQ29udHJvbCkpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgZm9ybURpcmVjdGl2ZVByb3ZpZGVyJDEgPSB7XG4gICAgICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gRm9ybUdyb3VwRGlyZWN0aXZlOyB9KVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgQmluZHMgYW4gZXhpc3Rpbmcge0BsaW5rIEZvcm1Hcm91cH0gdG8gYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgYWNjZXB0cyBhbiBleGlzdGluZyB7QGxpbmsgRm9ybUdyb3VwfSBpbnN0YW5jZS4gSXQgd2lsbCB0aGVuIHVzZSB0aGlzXG4gICAgICoge0BsaW5rIEZvcm1Hcm91cH0gaW5zdGFuY2UgdG8gbWF0Y2ggYW55IGNoaWxkIHtAbGluayBGb3JtQ29udHJvbH0sIHtAbGluayBGb3JtR3JvdXB9LFxuICAgICAqIGFuZCB7QGxpbmsgRm9ybUFycmF5fSBpbnN0YW5jZXMgdG8gY2hpbGQge0BsaW5rIEZvcm1Db250cm9sTmFtZX0sIHtAbGluayBGb3JtR3JvdXBOYW1lfSxcbiAgICAgKiBhbmQge0BsaW5rIEZvcm1BcnJheU5hbWV9IGRpcmVjdGl2ZXMuXG4gICAgICpcbiAgICAgKiAqKlNldCB2YWx1ZSoqOiBZb3UgY2FuIHNldCB0aGUgZm9ybSdzIGluaXRpYWwgdmFsdWUgd2hlbiBpbnN0YW50aWF0aW5nIHRoZVxuICAgICAqIHtAbGluayBGb3JtR3JvdXB9LCBvciB5b3UgY2FuIHNldCBpdCBwcm9ncmFtbWF0aWNhbGx5IGxhdGVyIHVzaW5nIHRoZSB7QGxpbmsgRm9ybUdyb3VwfSdzXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zZXRWYWx1ZX0gb3Ige0BsaW5rIEFic3RyYWN0Q29udHJvbC5wYXRjaFZhbHVlfSBtZXRob2RzLlxuICAgICAqXG4gICAgICogKipMaXN0ZW4gdG8gdmFsdWUqKjogSWYgeW91IHdhbnQgdG8gbGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIHZhbHVlIG9mIHRoZSBmb3JtLCB5b3UgY2FuIHN1YnNjcmliZVxuICAgICAqIHRvIHRoZSB7QGxpbmsgRm9ybUdyb3VwfSdzIHtAbGluayBBYnN0cmFjdENvbnRyb2wudmFsdWVDaGFuZ2VzfSBldmVudC4gIFlvdSBjYW4gYWxzbyBsaXN0ZW4gdG9cbiAgICAgKiBpdHMge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXNDaGFuZ2VzfSBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB2YWxpZGF0aW9uIHN0YXR1cyBpc1xuICAgICAqIHJlLWNhbGN1bGF0ZWQuXG4gICAgICpcbiAgICAgKiBGdXJ0aGVybW9yZSwgeW91IGNhbiBsaXN0ZW4gdG8gdGhlIGRpcmVjdGl2ZSdzIGBuZ1N1Ym1pdGAgZXZlbnQgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdXNlciBoYXNcbiAgICAgKiB0cmlnZ2VyZWQgYSBmb3JtIHN1Ym1pc3Npb24uIFRoZSBgbmdTdWJtaXRgIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCB3aXRoIHRoZSBvcmlnaW5hbCBmb3JtXG4gICAgICogc3VibWlzc2lvbiBldmVudC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGV4YW1wbGUsIHdlIGNyZWF0ZSBmb3JtIGNvbnRyb2xzIGZvciBmaXJzdCBuYW1lIGFuZCBsYXN0IG5hbWUuXG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgZm9ybXMvdHMvc2ltcGxlRm9ybUdyb3VwL3NpbXBsZV9mb3JtX2dyb3VwX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICAgICAqXG4gICAgICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAqKk5nTW9kdWxlKio6IHtAbGluayBSZWFjdGl2ZUZvcm1zTW9kdWxlfVxuICAgICAqXG4gICAgICogIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUdyb3VwRGlyZWN0aXZlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDExKEZvcm1Hcm91cERpcmVjdGl2ZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRm9ybUdyb3VwRGlyZWN0aXZlKF92YWxpZGF0b3JzLCBfYXN5bmNWYWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRvcnMgPSBfdmFsaWRhdG9ycztcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdG9ycyA9IF9hc3luY1ZhbGlkYXRvcnM7XG4gICAgICAgICAgICB0aGlzLl9zdWJtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubmdTdWJtaXQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja0Zvcm1QcmVzZW50KCk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnZm9ybScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsaWRhdG9ycygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURvbVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUmVnaXN0cmF0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzdWJtaXR0ZWRcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdWJtaXR0ZWQ7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJmb3JtRGlyZWN0aXZlXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmZvcm07IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLmFkZENvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICB2YXIgY3RybCA9IHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgICAgICAgICAgc2V0VXBDb250cm9sKGN0cmwsIGRpcik7XG4gICAgICAgICAgICBjdHJsLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnB1c2goZGlyKTtcbiAgICAgICAgICAgIHJldHVybiBjdHJsO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLmdldENvbnRyb2wgPSBmdW5jdGlvbiAoZGlyKSB7IHJldHVybiB0aGlzLmZvcm0uZ2V0KGRpci5wYXRoKTsgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5yZW1vdmVDb250cm9sID0gZnVuY3Rpb24gKGRpcikgeyBMaXN0V3JhcHBlci5yZW1vdmUodGhpcy5kaXJlY3RpdmVzLCBkaXIpOyB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLmFkZEZvcm1Hcm91cCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICBzZXRVcEZvcm1Db250YWluZXIoY3RybCwgZGlyKTtcbiAgICAgICAgICAgIGN0cmwudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUucmVtb3ZlRm9ybUdyb3VwID0gZnVuY3Rpb24gKGRpcikgeyB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLmdldEZvcm1Hcm91cCA9IGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpOyB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLmFkZEZvcm1BcnJheSA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICBzZXRVcEZvcm1Db250YWluZXIoY3RybCwgZGlyKTtcbiAgICAgICAgICAgIGN0cmwudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUucmVtb3ZlRm9ybUFycmF5ID0gZnVuY3Rpb24gKGRpcikgeyB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLmdldEZvcm1BcnJheSA9IGZ1bmN0aW9uIChkaXIpIHsgcmV0dXJuIHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpOyB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLnVwZGF0ZU1vZGVsID0gZnVuY3Rpb24gKGRpciwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICBjdHJsLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5vblN1Ym1pdCA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1Ym1pdHRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm5nU3VibWl0LmVtaXQoJGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5vblJlc2V0ID0gZnVuY3Rpb24gKCkgeyB0aGlzLnJlc2V0Rm9ybSgpOyB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLnJlc2V0Rm9ybSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSB1bmRlZmluZWQ7IH1cbiAgICAgICAgICAgIHRoaXMuZm9ybS5yZXNldCh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9zdWJtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLl91cGRhdGVEb21WYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0N0cmwgPSBfdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpci5fY29udHJvbCAhPT0gbmV3Q3RybCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhblVwQ29udHJvbChkaXIuX2NvbnRyb2wsIGRpcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdDdHJsKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VXBDb250cm9sKG5ld0N0cmwsIGRpcik7XG4gICAgICAgICAgICAgICAgICAgIGRpci5fY29udHJvbCA9IG5ld0N0cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmZvcm0uX3VwZGF0ZVRyZWVWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm90b3R5cGUuX3VwZGF0ZVJlZ2lzdHJhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5mb3JtLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdXBkYXRlRG9tVmFsdWUoKTsgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fb2xkRm9ybSlcbiAgICAgICAgICAgICAgICB0aGlzLl9vbGRGb3JtLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZShmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgdGhpcy5fb2xkRm9ybSA9IHRoaXMuZm9ybTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUdyb3VwRGlyZWN0aXZlLnByb3RvdHlwZS5fdXBkYXRlVmFsaWRhdG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzeW5jID0gY29tcG9zZVZhbGlkYXRvcnModGhpcy5fdmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB0aGlzLmZvcm0udmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlKFt0aGlzLmZvcm0udmFsaWRhdG9yLCBzeW5jXSk7XG4gICAgICAgICAgICB2YXIgYXN5bmMgPSBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX2FzeW5jVmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB0aGlzLmZvcm0uYXN5bmNWYWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2VBc3luYyhbdGhpcy5mb3JtLmFzeW5jVmFsaWRhdG9yLCBhc3luY10pO1xuICAgICAgICB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUucHJvdG90eXBlLl9jaGVja0Zvcm1QcmVzZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICAgICAgICAgICAgICBSZWFjdGl2ZUVycm9ycy5taXNzaW5nRm9ybUV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tmb3JtR3JvdXBdJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW2Zvcm1EaXJlY3RpdmVQcm92aWRlciQxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhzdWJtaXQpJzogJ29uU3VibWl0KCRldmVudCknLCAnKHJlc2V0KSc6ICdvblJlc2V0KCknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ25nRm9ybSdcbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3JtR3JvdXBEaXJlY3RpdmUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgICAgICB7IHR5cGU6IEFycmF5LCBkZWNvcmF0b3JzOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5TZWxmIH0sIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3QsIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTLF0gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIEZvcm1Hcm91cERpcmVjdGl2ZS5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICdmb3JtJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCwgYXJnczogWydmb3JtR3JvdXAnLF0gfSxdLFxuICAgICAgICAgICAgJ25nU3VibWl0JzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PdXRwdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUdyb3VwRGlyZWN0aXZlO1xuICAgIH0oQ29udHJvbENvbnRhaW5lcikpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkMTIgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICB2YXIgZm9ybUdyb3VwTmFtZVByb3ZpZGVyID0ge1xuICAgICAgICBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZvcm1Hcm91cE5hbWU7IH0pXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAd2hhdEl0RG9lcyBTeW5jcyBhIG5lc3RlZCB7QGxpbmsgRm9ybUdyb3VwfSB0byBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQGhvd1RvVXNlXG4gICAgICpcbiAgICAgKiBUaGlzIGRpcmVjdGl2ZSBjYW4gb25seSBiZSB1c2VkIHdpdGggYSBwYXJlbnQge0BsaW5rIEZvcm1Hcm91cERpcmVjdGl2ZX0gKHNlbGVjdG9yOlxuICAgICAqIGBbZm9ybUdyb3VwXWApLlxuICAgICAqXG4gICAgICogSXQgYWNjZXB0cyB0aGUgc3RyaW5nIG5hbWUgb2YgdGhlIG5lc3RlZCB7QGxpbmsgRm9ybUdyb3VwfSB5b3Ugd2FudCB0byBsaW5rLCBhbmRcbiAgICAgKiB3aWxsIGxvb2sgZm9yIGEge0BsaW5rIEZvcm1Hcm91cH0gcmVnaXN0ZXJlZCB3aXRoIHRoYXQgbmFtZSBpbiB0aGUgcGFyZW50XG4gICAgICoge0BsaW5rIEZvcm1Hcm91cH0gaW5zdGFuY2UgeW91IHBhc3NlZCBpbnRvIHtAbGluayBGb3JtR3JvdXBEaXJlY3RpdmV9LlxuICAgICAqXG4gICAgICogTmVzdGVkIGZvcm0gZ3JvdXBzIGNhbiBjb21lIGluIGhhbmR5IHdoZW4geW91IHdhbnQgdG8gdmFsaWRhdGUgYSBzdWItZ3JvdXAgb2YgYVxuICAgICAqIGZvcm0gc2VwYXJhdGVseSBmcm9tIHRoZSByZXN0IG9yIHdoZW4geW91J2QgbGlrZSB0byBncm91cCB0aGUgdmFsdWVzIG9mIGNlcnRhaW5cbiAgICAgKiBjb250cm9scyBpbnRvIHRoZWlyIG93biBuZXN0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogKipBY2Nlc3MgdGhlIGdyb3VwKio6IFlvdSBjYW4gYWNjZXNzIHRoZSBhc3NvY2lhdGVkIHtAbGluayBGb3JtR3JvdXB9IHVzaW5nIHRoZVxuICAgICAqIHtAbGluayBBYnN0cmFjdENvbnRyb2wuZ2V0fSBtZXRob2QuIEV4OiBgdGhpcy5mb3JtLmdldCgnbmFtZScpYC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWxzbyBhY2Nlc3MgaW5kaXZpZHVhbCBjb250cm9scyB3aXRoaW4gdGhlIGdyb3VwIHVzaW5nIGRvdCBzeW50YXguXG4gICAgICogRXg6IGB0aGlzLmZvcm0uZ2V0KCduYW1lLmZpcnN0JylgXG4gICAgICpcbiAgICAgKiAqKkdldCB0aGUgdmFsdWUqKjogdGhlIGB2YWx1ZWAgcHJvcGVydHkgaXMgYWx3YXlzIHN5bmNlZCBhbmQgYXZhaWxhYmxlIG9uIHRoZVxuICAgICAqIHtAbGluayBGb3JtR3JvdXB9LiBTZWUgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIHByb3BlcnRpZXMgaW4ge0BsaW5rIEFic3RyYWN0Q29udHJvbH0uXG4gICAgICpcbiAgICAgKiAqKlNldCB0aGUgdmFsdWUqKjogWW91IGNhbiBzZXQgYW4gaW5pdGlhbCB2YWx1ZSBmb3IgZWFjaCBjaGlsZCBjb250cm9sIHdoZW4gaW5zdGFudGlhdGluZ1xuICAgICAqIHRoZSB7QGxpbmsgRm9ybUdyb3VwfSwgb3IgeW91IGNhbiBzZXQgaXQgcHJvZ3JhbW1hdGljYWxseSBsYXRlciB1c2luZ1xuICAgICAqIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc2V0VmFsdWV9IG9yIHtAbGluayBBYnN0cmFjdENvbnRyb2wucGF0Y2hWYWx1ZX0uXG4gICAgICpcbiAgICAgKiAqKkxpc3RlbiB0byB2YWx1ZSoqOiBJZiB5b3Ugd2FudCB0byBsaXN0ZW4gdG8gY2hhbmdlcyBpbiB0aGUgdmFsdWUgb2YgdGhlIGdyb3VwLCB5b3UgY2FuXG4gICAgICogc3Vic2NyaWJlIHRvIHRoZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnZhbHVlQ2hhbmdlc30gZXZlbnQuICBZb3UgY2FuIGFsc28gbGlzdGVuIHRvXG4gICAgICoge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXNDaGFuZ2VzfSB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB2YWxpZGF0aW9uIHN0YXR1cyBpc1xuICAgICAqIHJlLWNhbGN1bGF0ZWQuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL25lc3RlZEZvcm1Hcm91cC9uZXN0ZWRfZm9ybV9ncm91cF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAqICoqTmdNb2R1bGUqKjogYFJlYWN0aXZlRm9ybXNNb2R1bGVgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1Hcm91cE5hbWUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTIoRm9ybUdyb3VwTmFtZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRm9ybUdyb3VwTmFtZShwYXJlbnQsIHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3JzID0gdmFsaWRhdG9ycztcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9ycztcbiAgICAgICAgfVxuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1Hcm91cE5hbWUucHJvdG90eXBlLl9jaGVja1BhcmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX2hhc0ludmFsaWRQYXJlbnQodGhpcy5fcGFyZW50KSkge1xuICAgICAgICAgICAgICAgIFJlYWN0aXZlRXJyb3JzLmdyb3VwUGFyZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Hcm91cE5hbWUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Zvcm1Hcm91cE5hbWVdJywgcHJvdmlkZXJzOiBbZm9ybUdyb3VwTmFtZVByb3ZpZGVyXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1Hcm91cE5hbWUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNraXBTZWxmIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBGb3JtR3JvdXBOYW1lLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Zvcm1Hcm91cE5hbWUnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUdyb3VwTmFtZTtcbiAgICB9KEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlKSk7XG4gICAgdmFyIGZvcm1BcnJheU5hbWVQcm92aWRlciA9IHtcbiAgICAgICAgcHJvdmlkZTogQ29udHJvbENvbnRhaW5lcixcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBGb3JtQXJyYXlOYW1lOyB9KVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgU3luY3MgYSBuZXN0ZWQge0BsaW5rIEZvcm1BcnJheX0gdG8gYSBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBob3dUb1VzZVxuICAgICAqXG4gICAgICogVGhpcyBkaXJlY3RpdmUgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCB3aXRoIGEgcGFyZW50IHtAbGluayBGb3JtR3JvdXBEaXJlY3RpdmV9IChzZWxlY3RvcjpcbiAgICAgKiBgW2Zvcm1Hcm91cF1gKS5cbiAgICAgKlxuICAgICAqIEl0IGFjY2VwdHMgdGhlIHN0cmluZyBuYW1lIG9mIHRoZSBuZXN0ZWQge0BsaW5rIEZvcm1BcnJheX0geW91IHdhbnQgdG8gbGluaywgYW5kXG4gICAgICogd2lsbCBsb29rIGZvciBhIHtAbGluayBGb3JtQXJyYXl9IHJlZ2lzdGVyZWQgd2l0aCB0aGF0IG5hbWUgaW4gdGhlIHBhcmVudFxuICAgICAqIHtAbGluayBGb3JtR3JvdXB9IGluc3RhbmNlIHlvdSBwYXNzZWQgaW50byB7QGxpbmsgRm9ybUdyb3VwRGlyZWN0aXZlfS5cbiAgICAgKlxuICAgICAqIE5lc3RlZCBmb3JtIGFycmF5cyBjYW4gY29tZSBpbiBoYW5keSB3aGVuIHlvdSBoYXZlIGEgZ3JvdXAgb2YgZm9ybSBjb250cm9scyBidXRcbiAgICAgKiB5b3UncmUgbm90IHN1cmUgaG93IG1hbnkgdGhlcmUgd2lsbCBiZS4gRm9ybSBhcnJheXMgYWxsb3cgeW91IHRvIGNyZWF0ZSBuZXdcbiAgICAgKiBmb3JtIGNvbnRyb2xzIGR5bmFtaWNhbGx5LlxuICAgICAqXG4gICAgICogKipBY2Nlc3MgdGhlIGFycmF5Kio6IFlvdSBjYW4gYWNjZXNzIHRoZSBhc3NvY2lhdGVkIHtAbGluayBGb3JtQXJyYXl9IHVzaW5nIHRoZVxuICAgICAqIHtAbGluayBBYnN0cmFjdENvbnRyb2wuZ2V0fSBtZXRob2Qgb24gdGhlIHBhcmVudCB7QGxpbmsgRm9ybUdyb3VwfS5cbiAgICAgKiBFeDogYHRoaXMuZm9ybS5nZXQoJ2NpdGllcycpYC5cbiAgICAgKlxuICAgICAqICoqR2V0IHRoZSB2YWx1ZSoqOiB0aGUgYHZhbHVlYCBwcm9wZXJ0eSBpcyBhbHdheXMgc3luY2VkIGFuZCBhdmFpbGFibGUgb24gdGhlXG4gICAgICoge0BsaW5rIEZvcm1BcnJheX0uIFNlZSBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgcHJvcGVydGllcyBpbiB7QGxpbmsgQWJzdHJhY3RDb250cm9sfS5cbiAgICAgKlxuICAgICAqICoqU2V0IHRoZSB2YWx1ZSoqOiBZb3UgY2FuIHNldCBhbiBpbml0aWFsIHZhbHVlIGZvciBlYWNoIGNoaWxkIGNvbnRyb2wgd2hlbiBpbnN0YW50aWF0aW5nXG4gICAgICogdGhlIHtAbGluayBGb3JtQXJyYXl9LCBvciB5b3UgY2FuIHNldCB0aGUgdmFsdWUgcHJvZ3JhbW1hdGljYWxseSBsYXRlciB1c2luZyB0aGVcbiAgICAgKiB7QGxpbmsgRm9ybUFycmF5fSdzIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc2V0VmFsdWV9IG9yIHtAbGluayBBYnN0cmFjdENvbnRyb2wucGF0Y2hWYWx1ZX1cbiAgICAgKiBtZXRob2RzLlxuICAgICAqXG4gICAgICogKipMaXN0ZW4gdG8gdmFsdWUqKjogSWYgeW91IHdhbnQgdG8gbGlzdGVuIHRvIGNoYW5nZXMgaW4gdGhlIHZhbHVlIG9mIHRoZSBhcnJheSwgeW91IGNhblxuICAgICAqIHN1YnNjcmliZSB0byB0aGUge0BsaW5rIEZvcm1BcnJheX0ncyB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnZhbHVlQ2hhbmdlc30gZXZlbnQuICBZb3UgY2FuIGFsc29cbiAgICAgKiBsaXN0ZW4gdG8gaXRzIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc3RhdHVzQ2hhbmdlc30gZXZlbnQgdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdmFsaWRhdGlvblxuICAgICAqIHN0YXR1cyBpcyByZS1jYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogKipBZGQgbmV3IGNvbnRyb2xzKio6IFlvdSBjYW4gYWRkIG5ldyBjb250cm9scyB0byB0aGUge0BsaW5rIEZvcm1BcnJheX0gZHluYW1pY2FsbHkgYnlcbiAgICAgKiBjYWxsaW5nIGl0cyB7QGxpbmsgRm9ybUFycmF5LnB1c2h9IG1ldGhvZC5cbiAgICAgKiAgRXg6IGB0aGlzLmZvcm0uZ2V0KCdjaXRpZXMnKS5wdXNoKG5ldyBGb3JtQ29udHJvbCgpKTtgXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICoge0BleGFtcGxlIGZvcm1zL3RzL25lc3RlZEZvcm1BcnJheS9uZXN0ZWRfZm9ybV9hcnJheV9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAgICAgKlxuICAgICAqICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAqICoqTmdNb2R1bGUqKjogYFJlYWN0aXZlRm9ybXNNb2R1bGVgXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1BcnJheU5hbWUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkMTIoRm9ybUFycmF5TmFtZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRm9ybUFycmF5TmFtZShwYXJlbnQsIHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3JzID0gdmFsaWRhdG9ycztcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9ycztcbiAgICAgICAgfVxuICAgICAgICBGb3JtQXJyYXlOYW1lLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFyZW50VHlwZSgpO1xuICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLmFkZEZvcm1BcnJheSh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUFycmF5TmFtZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mb3JtRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLnJlbW92ZUZvcm1BcnJheSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1BcnJheU5hbWUucHJvdG90eXBlLCBcImNvbnRyb2xcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmZvcm1EaXJlY3RpdmUuZ2V0Rm9ybUFycmF5KHRoaXMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1BcnJheU5hbWUucHJvdG90eXBlLCBcImZvcm1EaXJlY3RpdmVcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5mb3JtRGlyZWN0aXZlIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUFycmF5TmFtZS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyb2xQYXRoKHRoaXMubmFtZSwgdGhpcy5fcGFyZW50KTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQXJyYXlOYW1lLnByb3RvdHlwZSwgXCJ2YWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wb3NlVmFsaWRhdG9ycyh0aGlzLl92YWxpZGF0b3JzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQXJyYXlOYW1lLnByb3RvdHlwZSwgXCJhc3luY1ZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2VBc3luY1ZhbGlkYXRvcnModGhpcy5fYXN5bmNWYWxpZGF0b3JzKTsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEZvcm1BcnJheU5hbWUucHJvdG90eXBlLl9jaGVja1BhcmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX2hhc0ludmFsaWRQYXJlbnQodGhpcy5fcGFyZW50KSkge1xuICAgICAgICAgICAgICAgIFJlYWN0aXZlRXJyb3JzLmFycmF5UGFyZW50RXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1BcnJheU5hbWUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUsIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Zvcm1BcnJheU5hbWVdJywgcHJvdmlkZXJzOiBbZm9ybUFycmF5TmFtZVByb3ZpZGVyXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1BcnJheU5hbWUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNraXBTZWxmIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICBGb3JtQXJyYXlOYW1lLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Zvcm1BcnJheU5hbWUnLF0gfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gRm9ybUFycmF5TmFtZTtcbiAgICB9KENvbnRyb2xDb250YWluZXIpKTtcbiAgICBmdW5jdGlvbiBfaGFzSW52YWxpZFBhcmVudChwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuICEocGFyZW50IGluc3RhbmNlb2YgRm9ybUdyb3VwTmFtZSkgJiYgIShwYXJlbnQgaW5zdGFuY2VvZiBGb3JtR3JvdXBEaXJlY3RpdmUpICYmXG4gICAgICAgICAgICAhKHBhcmVudCBpbnN0YW5jZW9mIEZvcm1BcnJheU5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEwID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIGNvbnRyb2xOYW1lQmluZGluZyA9IHtcbiAgICAgICAgcHJvdmlkZTogTmdDb250cm9sLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZvcm1Db250cm9sTmFtZTsgfSlcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEB3aGF0SXREb2VzICBTeW5jcyBhIHtAbGluayBGb3JtQ29udHJvbH0gaW4gYW4gZXhpc3Rpbmcge0BsaW5rIEZvcm1Hcm91cH0gdG8gYSBmb3JtIGNvbnRyb2xcbiAgICAgKiBlbGVtZW50IGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBJbiBvdGhlciB3b3JkcywgdGhpcyBkaXJlY3RpdmUgZW5zdXJlcyB0aGF0IGFueSB2YWx1ZXMgd3JpdHRlbiB0byB0aGUge0BsaW5rIEZvcm1Db250cm9sfVxuICAgICAqIGluc3RhbmNlIHByb2dyYW1tYXRpY2FsbHkgd2lsbCBiZSB3cml0dGVuIHRvIHRoZSBET00gZWxlbWVudCAobW9kZWwgLT4gdmlldykuIENvbnZlcnNlbHksXG4gICAgICogYW55IHZhbHVlcyB3cml0dGVuIHRvIHRoZSBET00gZWxlbWVudCB0aHJvdWdoIHVzZXIgaW5wdXQgd2lsbCBiZSByZWZsZWN0ZWQgaW4gdGhlXG4gICAgICoge0BsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSAodmlldyAtPiBtb2RlbCkuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFRoaXMgZGlyZWN0aXZlIGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgd2l0aCBhIHBhcmVudCB7QGxpbmsgRm9ybUdyb3VwRGlyZWN0aXZlfSAoc2VsZWN0b3I6XG4gICAgICogYFtmb3JtR3JvdXBdYCkuXG4gICAgICpcbiAgICAgKiBJdCBhY2NlcHRzIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUge0BsaW5rIEZvcm1Db250cm9sfSBpbnN0YW5jZSB5b3Ugd2FudCB0b1xuICAgICAqIGxpbmssIGFuZCB3aWxsIGxvb2sgZm9yIGEge0BsaW5rIEZvcm1Db250cm9sfSByZWdpc3RlcmVkIHdpdGggdGhhdCBuYW1lIGluIHRoZVxuICAgICAqIGNsb3Nlc3Qge0BsaW5rIEZvcm1Hcm91cH0gb3Ige0BsaW5rIEZvcm1BcnJheX0gYWJvdmUgaXQuXG4gICAgICpcbiAgICAgKiAqKkFjY2VzcyB0aGUgY29udHJvbCoqOiBZb3UgY2FuIGFjY2VzcyB0aGUge0BsaW5rIEZvcm1Db250cm9sfSBhc3NvY2lhdGVkIHdpdGhcbiAgICAgKiB0aGlzIGRpcmVjdGl2ZSBieSB1c2luZyB0aGUge0BsaW5rIEFic3RyYWN0Q29udHJvbC5nZXR9IG1ldGhvZC5cbiAgICAgKiBFeDogYHRoaXMuZm9ybS5nZXQoJ2ZpcnN0Jyk7YFxuICAgICAqXG4gICAgICogKipHZXQgdmFsdWUqKjogdGhlIGB2YWx1ZWAgcHJvcGVydHkgaXMgYWx3YXlzIHN5bmNlZCBhbmQgYXZhaWxhYmxlIG9uIHRoZSB7QGxpbmsgRm9ybUNvbnRyb2x9LlxuICAgICAqIFNlZSBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgcHJvcGVydGllcyBpbiB7QGxpbmsgQWJzdHJhY3RDb250cm9sfS5cbiAgICAgKlxuICAgICAqICAqKlNldCB2YWx1ZSoqOiBZb3UgY2FuIHNldCBhbiBpbml0aWFsIHZhbHVlIGZvciB0aGUgY29udHJvbCB3aGVuIGluc3RhbnRpYXRpbmcgdGhlXG4gICAgICogIHtAbGluayBGb3JtQ29udHJvbH0sIG9yIHlvdSBjYW4gc2V0IGl0IHByb2dyYW1tYXRpY2FsbHkgbGF0ZXIgdXNpbmdcbiAgICAgKiAge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zZXRWYWx1ZX0gb3Ige0BsaW5rIEFic3RyYWN0Q29udHJvbC5wYXRjaFZhbHVlfS5cbiAgICAgKlxuICAgICAqICoqTGlzdGVuIHRvIHZhbHVlKio6IElmIHlvdSB3YW50IHRvIGxpc3RlbiB0byBjaGFuZ2VzIGluIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbCwgeW91IGNhblxuICAgICAqIHN1YnNjcmliZSB0byB0aGUge0BsaW5rIEFic3RyYWN0Q29udHJvbC52YWx1ZUNoYW5nZXN9IGV2ZW50LiAgWW91IGNhbiBhbHNvIGxpc3RlbiB0b1xuICAgICAqIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc3RhdHVzQ2hhbmdlc30gdG8gYmUgbm90aWZpZWQgd2hlbiB0aGUgdmFsaWRhdGlvbiBzdGF0dXMgaXNcbiAgICAgKiByZS1jYWxjdWxhdGVkLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIEluIHRoaXMgZXhhbXBsZSwgd2UgY3JlYXRlIGZvcm0gY29udHJvbHMgZm9yIGZpcnN0IG5hbWUgYW5kIGxhc3QgbmFtZS5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtR3JvdXAvc2ltcGxlX2Zvcm1fZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiBUbyBzZWUgYGZvcm1Db250cm9sTmFtZWAgZXhhbXBsZXMgd2l0aCBkaWZmZXJlbnQgZm9ybSBjb250cm9sIHR5cGVzLCBzZWU6XG4gICAgICpcbiAgICAgKiAqIFJhZGlvIGJ1dHRvbnM6IHtAbGluayBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yfVxuICAgICAqICogU2VsZWN0czoge0BsaW5rIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yfVxuICAgICAqXG4gICAgICogKipucG0gcGFja2FnZSoqOiBgQGFuZ3VsYXIvZm9ybXNgXG4gICAgICpcbiAgICAgKiAqKk5nTW9kdWxlKio6IHtAbGluayBSZWFjdGl2ZUZvcm1zTW9kdWxlfVxuICAgICAqXG4gICAgICogIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgRm9ybUNvbnRyb2xOYW1lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEwKEZvcm1Db250cm9sTmFtZSwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gRm9ybUNvbnRyb2xOYW1lKHBhcmVudCwgdmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzLCB2YWx1ZUFjY2Vzc29ycykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9hZGRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl9yYXdWYWxpZGF0b3JzID0gdmFsaWRhdG9ycyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9ycyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVBY2Nlc3NvciA9IHNlbGVjdFZhbHVlQWNjZXNzb3IodGhpcywgdmFsdWVBY2Nlc3NvcnMpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLCBcImlzRGlzYWJsZWRcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoaXNEaXNhYmxlZCkgeyBSZWFjdGl2ZUVycm9ycy5kaXNhYmxlZEF0dHJXYXJuaW5nKCk7IH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYWRkZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VXBDb250cm9sKCk7XG4gICAgICAgICAgICBpZiAoaXNQcm9wZXJ0eVVwZGF0ZWQoY2hhbmdlcywgdGhpcy52aWV3TW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB0aGlzLm1vZGVsO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybURpcmVjdGl2ZS51cGRhdGVNb2RlbCh0aGlzLCB0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUucmVtb3ZlQ29udHJvbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZS52aWV3VG9Nb2RlbFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlLmVtaXQobmV3VmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJwYXRoXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJvbFBhdGgodGhpcy5uYW1lLCB0aGlzLl9wYXJlbnQpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUsIFwiZm9ybURpcmVjdGl2ZVwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5mb3JtRGlyZWN0aXZlIDogbnVsbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGb3JtQ29udHJvbE5hbWUucHJvdG90eXBlLCBcInZhbGlkYXRvclwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBvc2VWYWxpZGF0b3JzKHRoaXMuX3Jhd1ZhbGlkYXRvcnMpOyB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUsIFwiYXN5bmNWYWxpZGF0b3JcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2VBc3luY1ZhbGlkYXRvcnModGhpcy5fcmF3QXN5bmNWYWxpZGF0b3JzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZSwgXCJjb250cm9sXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fY29udHJvbDsgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5wcm90b3R5cGUuX2NoZWNrUGFyZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cE5hbWUpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50IGluc3RhbmNlb2YgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBSZWFjdGl2ZUVycm9ycy5uZ01vZGVsR3JvdXBFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgRm9ybUdyb3VwTmFtZSkgJiYgISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBGb3JtR3JvdXBEaXJlY3RpdmUpICYmXG4gICAgICAgICAgICAgICAgISh0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBGb3JtQXJyYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIFJlYWN0aXZlRXJyb3JzLmNvbnRyb2xQYXJlbnRFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLnByb3RvdHlwZS5fc2V0VXBDb250cm9sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXJlbnRUeXBlKCk7XG4gICAgICAgICAgICB0aGlzLl9jb250cm9sID0gdGhpcy5mb3JtRGlyZWN0aXZlLmFkZENvbnRyb2wodGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sLmRpc2FibGVkICYmIHRoaXMudmFsdWVBY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yLnNldERpc2FibGVkU3RhdGUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hZGRlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIEZvcm1Db250cm9sTmFtZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUNvbnRyb2xOYW1lXScsIHByb3ZpZGVyczogW2NvbnRyb2xOYW1lQmluZGluZ10gfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3JtQ29udHJvbE5hbWUuY3RvclBhcmFtZXRlcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbnRyb2xDb250YWluZXIsIGRlY29yYXRvcnM6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkhvc3QgfSwgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLlNraXBTZWxmIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SUyxdIH0sXSB9LFxuICAgICAgICAgICAgeyB0eXBlOiBBcnJheSwgZGVjb3JhdG9yczogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5PcHRpb25hbCB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuU2VsZiB9LCB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0LCBhcmdzOiBbTkdfVkFMVUVfQUNDRVNTT1IsXSB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgRm9ybUNvbnRyb2xOYW1lLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ25hbWUnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Zvcm1Db250cm9sTmFtZScsXSB9LF0sXG4gICAgICAgICAgICAnbW9kZWwnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ25nTW9kZWwnLF0gfSxdLFxuICAgICAgICAgICAgJ3VwZGF0ZSc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuT3V0cHV0LCBhcmdzOiBbJ25nTW9kZWxDaGFuZ2UnLF0gfSxdLFxuICAgICAgICAgICAgJ2lzRGlzYWJsZWQnOiBbeyB0eXBlOiBfYW5ndWxhcl9jb3JlLklucHV0LCBhcmdzOiBbJ2Rpc2FibGVkJyxdIH0sXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEZvcm1Db250cm9sTmFtZTtcbiAgICB9KE5nQ29udHJvbCkpO1xuXG4gICAgdmFyIFJFUVVJUkVEX1ZBTElEQVRPUiA9IHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBSZXF1aXJlZFZhbGlkYXRvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIERpcmVjdGl2ZSB0aGF0IGFkZHMgdGhlIGByZXF1aXJlZGAgdmFsaWRhdG9yIHRvIGFueSBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcbiAgICAgKiBgcmVxdWlyZWRgIGF0dHJpYnV0ZSwgdmlhIHRoZSB7QGxpbmsgTkdfVkFMSURBVE9SU30gYmluZGluZy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiA8aW5wdXQgbmFtZT1cImZ1bGxOYW1lXCIgbmdNb2RlbCByZXF1aXJlZD5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUmVxdWlyZWRWYWxpZGF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBSZXF1aXJlZFZhbGlkYXRvcigpIHtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVxdWlyZWRWYWxpZGF0b3IucHJvdG90eXBlLCBcInJlcXVpcmVkXCIsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcmVxdWlyZWQ7IH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVpcmVkID0gaXNQcmVzZW50KHZhbHVlKSAmJiBcIlwiICsgdmFsdWUgIT09ICdmYWxzZSc7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFJlcXVpcmVkVmFsaWRhdG9yLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1aXJlZCA/IFZhbGlkYXRvcnMucmVxdWlyZWQoYykgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBSZXF1aXJlZFZhbGlkYXRvci5wcm90b3R5cGUucmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSA9IGZ1bmN0aW9uIChmbikgeyB0aGlzLl9vbkNoYW5nZSA9IGZuOyB9O1xuICAgICAgICBSZXF1aXJlZFZhbGlkYXRvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW3JlcXVpcmVkXVtmb3JtQ29udHJvbE5hbWVdLFtyZXF1aXJlZF1bZm9ybUNvbnRyb2xdLFtyZXF1aXJlZF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUkVRVUlSRURfVkFMSURBVE9SXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ1thdHRyLnJlcXVpcmVkXSc6ICdyZXF1aXJlZD8gXCJcIiA6IG51bGwnIH1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBSZXF1aXJlZFZhbGlkYXRvci5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICBSZXF1aXJlZFZhbGlkYXRvci5wcm9wRGVjb3JhdG9ycyA9IHtcbiAgICAgICAgICAgICdyZXF1aXJlZCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVxdWlyZWRWYWxpZGF0b3I7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlciB3aGljaCBhZGRzIHtAbGluayBNaW5MZW5ndGhWYWxpZGF0b3J9IHRvIHtAbGluayBOR19WQUxJREFUT1JTfS5cbiAgICAgKlxuICAgICAqICMjIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL2Zvcm1zL3RzL3ZhbGlkYXRvcnMvdmFsaWRhdG9ycy50cyByZWdpb249J21pbid9XG4gICAgICovXG4gICAgdmFyIE1JTl9MRU5HVEhfVkFMSURBVE9SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1pbkxlbmd0aFZhbGlkYXRvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGRpcmVjdGl2ZSB3aGljaCBpbnN0YWxscyB0aGUge0BsaW5rIE1pbkxlbmd0aFZhbGlkYXRvcn0gZm9yIGFueSBgZm9ybUNvbnRyb2xOYW1lYCxcbiAgICAgKiBgZm9ybUNvbnRyb2xgLCBvciBjb250cm9sIHdpdGggYG5nTW9kZWxgIHRoYXQgYWxzbyBoYXMgYSBgbWlubGVuZ3RoYCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIE1pbkxlbmd0aFZhbGlkYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIE1pbkxlbmd0aFZhbGlkYXRvcigpIHtcbiAgICAgICAgfVxuICAgICAgICBNaW5MZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLl9jcmVhdGVWYWxpZGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3IgPSBWYWxpZGF0b3JzLm1pbkxlbmd0aChwYXJzZUludCh0aGlzLm1pbmxlbmd0aCwgMTApKTtcbiAgICAgICAgfTtcbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlc1snbWlubGVuZ3RoJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVWYWxpZGF0b3IoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLm1pbmxlbmd0aCkgPyB0aGlzLl92YWxpZGF0b3IoYykgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBNaW5MZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWlubGVuZ3RoXVtmb3JtQ29udHJvbE5hbWVdLFttaW5sZW5ndGhdW2Zvcm1Db250cm9sXSxbbWlubGVuZ3RoXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNSU5fTEVOR1RIX1ZBTElEQVRPUl0sXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5taW5sZW5ndGhdJzogJ21pbmxlbmd0aD8gbWlubGVuZ3RoIDogbnVsbCcgfVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIE1pbkxlbmd0aFZhbGlkYXRvci5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICBNaW5MZW5ndGhWYWxpZGF0b3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAnbWlubGVuZ3RoJzogW3sgdHlwZTogX2FuZ3VsYXJfY29yZS5JbnB1dCB9LF0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBNaW5MZW5ndGhWYWxpZGF0b3I7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlciB3aGljaCBhZGRzIHtAbGluayBNYXhMZW5ndGhWYWxpZGF0b3J9IHRvIHtAbGluayBOR19WQUxJREFUT1JTfS5cbiAgICAgKlxuICAgICAqICMjIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiB7QGV4YW1wbGUgY29tbW9uL2Zvcm1zL3RzL3ZhbGlkYXRvcnMvdmFsaWRhdG9ycy50cyByZWdpb249J21heCd9XG4gICAgICovXG4gICAgdmFyIE1BWF9MRU5HVEhfVkFMSURBVE9SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1heExlbmd0aFZhbGlkYXRvcjsgfSksXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGRpcmVjdGl2ZSB3aGljaCBpbnN0YWxscyB0aGUge0BsaW5rIE1heExlbmd0aFZhbGlkYXRvcn0gZm9yIGFueSBgZm9ybUNvbnRyb2xOYW1lLFxuICAgICAqIGBmb3JtQ29udHJvbGAsXG4gICAgICogb3IgY29udHJvbCB3aXRoIGBuZ01vZGVsYCB0aGF0IGFsc28gaGFzIGEgYG1heGxlbmd0aGAgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBNYXhMZW5ndGhWYWxpZGF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBNYXhMZW5ndGhWYWxpZGF0b3IoKSB7XG4gICAgICAgIH1cbiAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS5fY3JlYXRlVmFsaWRhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdG9yID0gVmFsaWRhdG9ycy5tYXhMZW5ndGgocGFyc2VJbnQodGhpcy5tYXhsZW5ndGgsIDEwKSk7XG4gICAgICAgIH07XG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXNbJ21heGxlbmd0aCddKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlVmFsaWRhdG9yKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29uQ2hhbmdlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBNYXhMZW5ndGhWYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5tYXhsZW5ndGgpID8gdGhpcy5fdmFsaWRhdG9yKGMpIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLnByb3RvdHlwZS5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7IHRoaXMuX29uQ2hhbmdlID0gZm47IH07XG4gICAgICAgIE1heExlbmd0aFZhbGlkYXRvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21heGxlbmd0aF1bZm9ybUNvbnRyb2xOYW1lXSxbbWF4bGVuZ3RoXVtmb3JtQ29udHJvbF0sW21heGxlbmd0aF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTUFYX0xFTkdUSF9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnW2F0dHIubWF4bGVuZ3RoXSc6ICdtYXhsZW5ndGg/IG1heGxlbmd0aCA6IG51bGwnIH1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBNYXhMZW5ndGhWYWxpZGF0b3IuY3RvclBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLnByb3BEZWNvcmF0b3JzID0ge1xuICAgICAgICAgICAgJ21heGxlbmd0aCc6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gTWF4TGVuZ3RoVmFsaWRhdG9yO1xuICAgIH0oKSk7XG4gICAgdmFyIFBBVFRFUk5fVkFMSURBVE9SID0ge1xuICAgICAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgICAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIFBhdHRlcm5WYWxpZGF0b3I7IH0pLFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBEaXJlY3RpdmUgdGhhdCBhZGRzIHRoZSBgcGF0dGVybmAgdmFsaWRhdG9yIHRvIGFueSBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcbiAgICAgKiBgcGF0dGVybmAgYXR0cmlidXRlLCB2aWEgdGhlIHtAbGluayBOR19WQUxJREFUT1JTfSBiaW5kaW5nLiBVc2VzIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAqIGFzIHRoZSByZWdleCB0byB2YWxpZGF0ZSBDb250cm9sIHZhbHVlIGFnYWluc3QuICBGb2xsb3dzIHBhdHRlcm4gYXR0cmlidXRlXG4gICAgICogc2VtYW50aWNzOyBpLmUuIHJlZ2V4IG11c3QgbWF0Y2ggZW50aXJlIENvbnRyb2wgdmFsdWUuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPGlucHV0IFtuYW1lXT1cImZ1bGxOYW1lXCIgcGF0dGVybj1cIlthLXpBLVogXSpcIiBuZ01vZGVsPlxuICAgICAqIGBgYFxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUGF0dGVyblZhbGlkYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFBhdHRlcm5WYWxpZGF0b3IoKSB7XG4gICAgICAgIH1cbiAgICAgICAgUGF0dGVyblZhbGlkYXRvci5wcm90b3R5cGUuX2NyZWF0ZVZhbGlkYXRvciA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fdmFsaWRhdG9yID0gVmFsaWRhdG9ycy5wYXR0ZXJuKHRoaXMucGF0dGVybik7IH07XG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IucHJvdG90eXBlLm5nT25DaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzWydwYXR0ZXJuJ10pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVWYWxpZGF0b3IoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25DaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5wYXR0ZXJuKSA/IHRoaXMuX3ZhbGlkYXRvcihjKSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IucHJvdG90eXBlLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UgPSBmdW5jdGlvbiAoZm4pIHsgdGhpcy5fb25DaGFuZ2UgPSBmbjsgfTtcbiAgICAgICAgUGF0dGVyblZhbGlkYXRvci5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW3BhdHRlcm5dW2Zvcm1Db250cm9sTmFtZV0sW3BhdHRlcm5dW2Zvcm1Db250cm9sXSxbcGF0dGVybl1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUEFUVEVSTl9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnW2F0dHIucGF0dGVybl0nOiAncGF0dGVybj8gcGF0dGVybiA6IG51bGwnIH1cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBQYXR0ZXJuVmFsaWRhdG9yLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIFBhdHRlcm5WYWxpZGF0b3IucHJvcERlY29yYXRvcnMgPSB7XG4gICAgICAgICAgICAncGF0dGVybic6IFt7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5wdXQgfSxdLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUGF0dGVyblZhbGlkYXRvcjtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogQHdoYXRJdERvZXMgQ3JlYXRlcyBhbiB7QGxpbmsgQWJzdHJhY3RDb250cm9sfSBmcm9tIGEgdXNlci1zcGVjaWZpZWQgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEl0IGlzIGVzc2VudGlhbGx5IHN5bnRhY3RpYyBzdWdhciB0aGF0IHNob3J0ZW5zIHRoZSBgbmV3IEZvcm1Hcm91cCgpYCxcbiAgICAgKiBgbmV3IEZvcm1Db250cm9sKClgLCBhbmQgYG5ldyBGb3JtQXJyYXkoKWAgYm9pbGVycGxhdGUgdGhhdCBjYW4gYnVpbGQgdXAgaW4gbGFyZ2VyXG4gICAgICogZm9ybXMuXG4gICAgICpcbiAgICAgKiBAaG93VG9Vc2VcbiAgICAgKlxuICAgICAqIFRvIHVzZSwgaW5qZWN0IGBGb3JtQnVpbGRlcmAgaW50byB5b3VyIGNvbXBvbmVudCBjbGFzcy4gWW91IGNhbiB0aGVuIGNhbGwgaXRzIG1ldGhvZHNcbiAgICAgKiBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIHtAZXhhbXBsZSBmb3Jtcy90cy9mb3JtQnVpbGRlci9mb3JtX2J1aWxkZXJfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gICAgICpcbiAgICAgKiAgKiAqKm5wbSBwYWNrYWdlKio6IGBAYW5ndWxhci9mb3Jtc2BcbiAgICAgKlxuICAgICAqICAqICoqTmdNb2R1bGUqKjoge0BsaW5rIFJlYWN0aXZlRm9ybXNNb2R1bGV9XG4gICAgICpcbiAgICAgKiBAc3RhYmxlXG4gICAgICovXG4gICAgdmFyIEZvcm1CdWlsZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRm9ybUJ1aWxkZXIoKSB7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIG5ldyB7QGxpbmsgRm9ybUdyb3VwfSB3aXRoIHRoZSBnaXZlbiBtYXAgb2YgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogVmFsaWQga2V5cyBmb3IgdGhlIGBleHRyYWAgcGFyYW1ldGVyIG1hcCBhcmUgYHZhbGlkYXRvcmAgYW5kIGBhc3luY1ZhbGlkYXRvcmAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNlZSB0aGUge0BsaW5rIEZvcm1Hcm91cH0gY29uc3RydWN0b3IgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1CdWlsZGVyLnByb3RvdHlwZS5ncm91cCA9IGZ1bmN0aW9uIChjb250cm9sc0NvbmZpZywgZXh0cmEpIHtcbiAgICAgICAgICAgIGlmIChleHRyYSA9PT0gdm9pZCAwKSB7IGV4dHJhID0gbnVsbDsgfVxuICAgICAgICAgICAgdmFyIGNvbnRyb2xzID0gdGhpcy5fcmVkdWNlQ29udHJvbHMoY29udHJvbHNDb25maWcpO1xuICAgICAgICAgICAgdmFyIHZhbGlkYXRvciA9IGlzUHJlc2VudChleHRyYSkgPyBleHRyYVsndmFsaWRhdG9yJ10gOiBudWxsO1xuICAgICAgICAgICAgdmFyIGFzeW5jVmFsaWRhdG9yID0gaXNQcmVzZW50KGV4dHJhKSA/IGV4dHJhWydhc3luY1ZhbGlkYXRvciddIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRm9ybUdyb3VwKGNvbnRyb2xzLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdCBhIG5ldyB7QGxpbmsgRm9ybUNvbnRyb2x9IHdpdGggdGhlIGdpdmVuIGBmb3JtU3RhdGVgLGB2YWxpZGF0b3JgLCBhbmRcbiAgICAgICAgICogYGFzeW5jVmFsaWRhdG9yYC5cbiAgICAgICAgICpcbiAgICAgICAgICogYGZvcm1TdGF0ZWAgY2FuIGVpdGhlciBiZSBhIHN0YW5kYWxvbmUgdmFsdWUgZm9yIHRoZSBmb3JtIGNvbnRyb2wgb3IgYW4gb2JqZWN0XG4gICAgICAgICAqIHRoYXQgY29udGFpbnMgYm90aCBhIHZhbHVlIGFuZCBhIGRpc2FibGVkIHN0YXR1cy5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIEZvcm1CdWlsZGVyLnByb3RvdHlwZS5jb250cm9sID0gZnVuY3Rpb24gKGZvcm1TdGF0ZSwgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IHZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIGlmIChhc3luY1ZhbGlkYXRvciA9PT0gdm9pZCAwKSB7IGFzeW5jVmFsaWRhdG9yID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtQ29udHJvbChmb3JtU3RhdGUsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0IGEge0BsaW5rIEZvcm1BcnJheX0gZnJvbSB0aGUgZ2l2ZW4gYGNvbnRyb2xzQ29uZmlnYCBhcnJheSBvZlxuICAgICAgICAgKiBjb25maWd1cmF0aW9uLCB3aXRoIHRoZSBnaXZlbiBvcHRpb25hbCBgdmFsaWRhdG9yYCBhbmQgYGFzeW5jVmFsaWRhdG9yYC5cbiAgICAgICAgICovXG4gICAgICAgIEZvcm1CdWlsZGVyLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uIChjb250cm9sc0NvbmZpZywgdmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmICh2YWxpZGF0b3IgPT09IHZvaWQgMCkgeyB2YWxpZGF0b3IgPSBudWxsOyB9XG4gICAgICAgICAgICBpZiAoYXN5bmNWYWxpZGF0b3IgPT09IHZvaWQgMCkgeyBhc3luY1ZhbGlkYXRvciA9IG51bGw7IH1cbiAgICAgICAgICAgIHZhciBjb250cm9scyA9IGNvbnRyb2xzQ29uZmlnLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gX3RoaXMuX2NyZWF0ZUNvbnRyb2woYyk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtQXJyYXkoY29udHJvbHMsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIEZvcm1CdWlsZGVyLnByb3RvdHlwZS5fcmVkdWNlQ29udHJvbHMgPSBmdW5jdGlvbiAoY29udHJvbHNDb25maWcpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29udHJvbHMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvbnRyb2xzQ29uZmlnKS5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sTmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xzW2NvbnRyb2xOYW1lXSA9IF90aGlzLl9jcmVhdGVDb250cm9sKGNvbnRyb2xzQ29uZmlnW2NvbnRyb2xOYW1lXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9scztcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBGb3JtQnVpbGRlci5wcm90b3R5cGUuX2NyZWF0ZUNvbnRyb2wgPSBmdW5jdGlvbiAoY29udHJvbENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xDb25maWcgaW5zdGFuY2VvZiBGb3JtQ29udHJvbCB8fCBjb250cm9sQ29uZmlnIGluc3RhbmNlb2YgRm9ybUdyb3VwIHx8XG4gICAgICAgICAgICAgICAgY29udHJvbENvbmZpZyBpbnN0YW5jZW9mIEZvcm1BcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sQ29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb250cm9sQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvbnRyb2xDb25maWdbMF07XG4gICAgICAgICAgICAgICAgdmFyIHZhbGlkYXRvciA9IGNvbnRyb2xDb25maWcubGVuZ3RoID4gMSA/IGNvbnRyb2xDb25maWdbMV0gOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBhc3luY1ZhbGlkYXRvciA9IGNvbnRyb2xDb25maWcubGVuZ3RoID4gMiA/IGNvbnRyb2xDb25maWdbMl0gOiBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wodmFsdWUsIHZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbChjb250cm9sQ29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRm9ybUJ1aWxkZXIuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBGb3JtQnVpbGRlci5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gRm9ybUJ1aWxkZXI7XG4gICAgfSgpKTtcblxuICAgIHZhciBTSEFSRURfRk9STV9ESVJFQ1RJVkVTID0gW1xuICAgICAgICBOZ1NlbGVjdE9wdGlvbiwgTmdTZWxlY3RNdWx0aXBsZU9wdGlvbiwgRGVmYXVsdFZhbHVlQWNjZXNzb3IsIE51bWJlclZhbHVlQWNjZXNzb3IsXG4gICAgICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IsIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgICAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOZ0NvbnRyb2xTdGF0dXMsIE5nQ29udHJvbFN0YXR1c0dyb3VwLCBSZXF1aXJlZFZhbGlkYXRvcixcbiAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLCBNYXhMZW5ndGhWYWxpZGF0b3IsIFBhdHRlcm5WYWxpZGF0b3JcbiAgICBdO1xuICAgIHZhciBURU1QTEFURV9EUklWRU5fRElSRUNUSVZFUyA9IFtOZ01vZGVsLCBOZ01vZGVsR3JvdXAsIE5nRm9ybV07XG4gICAgdmFyIFJFQUNUSVZFX0RSSVZFTl9ESVJFQ1RJVkVTID0gW0Zvcm1Db250cm9sRGlyZWN0aXZlLCBGb3JtR3JvdXBEaXJlY3RpdmUsIEZvcm1Db250cm9sTmFtZSwgRm9ybUdyb3VwTmFtZSwgRm9ybUFycmF5TmFtZV07XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbW9kdWxlIHVzZWQgZm9yIHNoYXJpbmcgZGlyZWN0aXZlcyBiZXR3ZWVuIEZvcm1zTW9kdWxlIGFuZCBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gICAgICovXG4gICAgdmFyIEludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIEludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3sgZGVjbGFyYXRpb25zOiBTSEFSRURfRk9STV9ESVJFQ1RJVkVTLCBleHBvcnRzOiBTSEFSRURfRk9STV9ESVJFQ1RJVkVTIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgSW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IFtdO1xuICAgICAgICByZXR1cm4gSW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZTtcbiAgICB9KCkpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5nIG1vZHVsZSBmb3IgZm9ybXMuXG4gICAgICogQHN0YWJsZVxuICAgICAqL1xuICAgIHZhciBGb3Jtc01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEZvcm1zTW9kdWxlKCkge1xuICAgICAgICB9XG4gICAgICAgIEZvcm1zTW9kdWxlLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUsIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFRFTVBMQVRFX0RSSVZFTl9ESVJFQ1RJVkVTLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUmFkaW9Db250cm9sUmVnaXN0cnldLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW0ludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUsIFRFTVBMQVRFX0RSSVZFTl9ESVJFQ1RJVkVTXVxuICAgICAgICAgICAgICAgICAgICB9LF0gfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEZvcm1zTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBGb3Jtc01vZHVsZTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBuZyBtb2R1bGUgZm9yIHJlYWN0aXZlIGZvcm1zLlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgUmVhY3RpdmVGb3Jtc01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFJlYWN0aXZlRm9ybXNNb2R1bGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbUkVBQ1RJVkVfRFJJVkVOX0RJUkVDVElWRVNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbRm9ybUJ1aWxkZXIsIFJhZGlvQ29udHJvbFJlZ2lzdHJ5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlLCBSRUFDVElWRV9EUklWRU5fRElSRUNUSVZFU11cbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLmN0b3JQYXJhbWV0ZXJzID0gW107XG4gICAgICAgIHJldHVybiBSZWFjdGl2ZUZvcm1zTW9kdWxlO1xuICAgIH0oKSk7XG5cbiAgICBleHBvcnRzLkFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSA9IEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZTtcbiAgICBleHBvcnRzLkFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlID0gQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmU7XG4gICAgZXhwb3J0cy5DaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICBleHBvcnRzLkNvbnRyb2xDb250YWluZXIgPSBDb250cm9sQ29udGFpbmVyO1xuICAgIGV4cG9ydHMuTkdfVkFMVUVfQUNDRVNTT1IgPSBOR19WQUxVRV9BQ0NFU1NPUjtcbiAgICBleHBvcnRzLkRlZmF1bHRWYWx1ZUFjY2Vzc29yID0gRGVmYXVsdFZhbHVlQWNjZXNzb3I7XG4gICAgZXhwb3J0cy5OZ0NvbnRyb2wgPSBOZ0NvbnRyb2w7XG4gICAgZXhwb3J0cy5OZ0NvbnRyb2xTdGF0dXMgPSBOZ0NvbnRyb2xTdGF0dXM7XG4gICAgZXhwb3J0cy5OZ0NvbnRyb2xTdGF0dXNHcm91cCA9IE5nQ29udHJvbFN0YXR1c0dyb3VwO1xuICAgIGV4cG9ydHMuTmdGb3JtID0gTmdGb3JtO1xuICAgIGV4cG9ydHMuTmdNb2RlbCA9IE5nTW9kZWw7XG4gICAgZXhwb3J0cy5OZ01vZGVsR3JvdXAgPSBOZ01vZGVsR3JvdXA7XG4gICAgZXhwb3J0cy5SYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yID0gUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICBleHBvcnRzLkZvcm1Db250cm9sRGlyZWN0aXZlID0gRm9ybUNvbnRyb2xEaXJlY3RpdmU7XG4gICAgZXhwb3J0cy5Gb3JtQ29udHJvbE5hbWUgPSBGb3JtQ29udHJvbE5hbWU7XG4gICAgZXhwb3J0cy5Gb3JtR3JvdXBEaXJlY3RpdmUgPSBGb3JtR3JvdXBEaXJlY3RpdmU7XG4gICAgZXhwb3J0cy5Gb3JtQXJyYXlOYW1lID0gRm9ybUFycmF5TmFtZTtcbiAgICBleHBvcnRzLkZvcm1Hcm91cE5hbWUgPSBGb3JtR3JvdXBOYW1lO1xuICAgIGV4cG9ydHMuTmdTZWxlY3RPcHRpb24gPSBOZ1NlbGVjdE9wdGlvbjtcbiAgICBleHBvcnRzLlNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yID0gU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3I7XG4gICAgZXhwb3J0cy5TZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yID0gU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcjtcbiAgICBleHBvcnRzLk1heExlbmd0aFZhbGlkYXRvciA9IE1heExlbmd0aFZhbGlkYXRvcjtcbiAgICBleHBvcnRzLk1pbkxlbmd0aFZhbGlkYXRvciA9IE1pbkxlbmd0aFZhbGlkYXRvcjtcbiAgICBleHBvcnRzLlBhdHRlcm5WYWxpZGF0b3IgPSBQYXR0ZXJuVmFsaWRhdG9yO1xuICAgIGV4cG9ydHMuUmVxdWlyZWRWYWxpZGF0b3IgPSBSZXF1aXJlZFZhbGlkYXRvcjtcbiAgICBleHBvcnRzLkZvcm1CdWlsZGVyID0gRm9ybUJ1aWxkZXI7XG4gICAgZXhwb3J0cy5BYnN0cmFjdENvbnRyb2wgPSBBYnN0cmFjdENvbnRyb2w7XG4gICAgZXhwb3J0cy5Gb3JtQXJyYXkgPSBGb3JtQXJyYXk7XG4gICAgZXhwb3J0cy5Gb3JtQ29udHJvbCA9IEZvcm1Db250cm9sO1xuICAgIGV4cG9ydHMuRm9ybUdyb3VwID0gRm9ybUdyb3VwO1xuICAgIGV4cG9ydHMuTkdfQVNZTkNfVkFMSURBVE9SUyA9IE5HX0FTWU5DX1ZBTElEQVRPUlM7XG4gICAgZXhwb3J0cy5OR19WQUxJREFUT1JTID0gTkdfVkFMSURBVE9SUztcbiAgICBleHBvcnRzLlZhbGlkYXRvcnMgPSBWYWxpZGF0b3JzO1xuICAgIGV4cG9ydHMuRm9ybXNNb2R1bGUgPSBGb3Jtc01vZHVsZTtcbiAgICBleHBvcnRzLlJlYWN0aXZlRm9ybXNNb2R1bGUgPSBSZWFjdGl2ZUZvcm1zTW9kdWxlO1xuXG59KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vQGFuZ3VsYXIvZm9ybXMvYnVuZGxlcy9mb3Jtcy51bWQuanNcbi8vIG1vZHVsZSBpZCA9IDcwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDEgMiAzIDQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 718:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(316);\nvar login_service_1 = __webpack_require__(712);\nvar DashboardComponent = (function () {\n    function DashboardComponent(_loginService) {\n        this._loginService = _loginService;\n    }\n    DashboardComponent = __decorate([\n        core_1.Component({\n            selector: 'dashboard',\n            template: __webpack_require__(719),\n            styles: [__webpack_require__(720)]\n        }), \n        __metadata('design:paramtypes', [(typeof (_a = typeof login_service_1.LoginService !== 'undefined' && login_service_1.LoginService) === 'function' && _a) || Object])\n    ], DashboardComponent);\n    return DashboardComponent;\n    var _a;\n}());\nexports.DashboardComponent = DashboardComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Rhc2hib2FyZC9kYXNoYm9hcmQuY29tcG9uZW50LnRzP2NjN2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IFRyZWxsb1NlcnZpY2UgfSBmcm9tICcuLi9zaGFyZWQvc2VydmljZS90cmVsbG8uc2VydmljZSc7XG5pbXBvcnQgeyBMb2dpblNlcnZpY2UgfSBmcm9tICcuLi9zaGFyZWQvc2VydmljZS9sb2dpbi5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdkYXNoYm9hcmQnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2Rhc2hib2FyZC5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vZGFzaGJvYXJkLmNvbXBvbmVudC5zY3NzJyldXG59KVxuZXhwb3J0IGNsYXNzIERhc2hib2FyZENvbXBvbmVudHtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9sb2dpblNlcnZpY2U6IExvZ2luU2VydmljZVxuICAgICl7ICBcbiAgICAgICAgXG4gICAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvZGFzaGJvYXJkL2Rhc2hib2FyZC5jb21wb25lbnQudHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUVBO0FBT0E7QUFFQTtBQUNBO0FBR0E7QUFYQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFRQTs7QUFBQTtBQVBBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ 719:
/***/ function(module, exports) {

	eval("module.exports = \"<div class=\\\"wrapper\\\">\\n    <!--Flash Messages-->\\n    <flash-messages></flash-messages>\\n    <dashboard-nav></dashboard-nav>\\n    <router-outlet></router-outlet>\\n</div>\\n\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Rhc2hib2FyZC9kYXNoYm9hcmQuY29tcG9uZW50Lmh0bWw/ZjFkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwid3JhcHBlclxcXCI+XFxuICAgIDwhLS1GbGFzaCBNZXNzYWdlcy0tPlxcbiAgICA8Zmxhc2gtbWVzc2FnZXM+PC9mbGFzaC1tZXNzYWdlcz5cXG4gICAgPGRhc2hib2FyZC1uYXY+PC9kYXNoYm9hcmQtbmF2PlxcbiAgICA8cm91dGVyLW91dGxldD48L3JvdXRlci1vdXRsZXQ+XFxuPC9kaXY+XFxuXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZGFzaGJvYXJkL2Rhc2hib2FyZC5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gNzE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 720:
/***/ function(module, exports) {

	eval("module.exports = \".wrapper {\\n  background: #eeeeee;\\n  height: 100%; }\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Rhc2hib2FyZC9kYXNoYm9hcmQuY29tcG9uZW50LnNjc3M/ZGQyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLndyYXBwZXIge1xcbiAgYmFja2dyb3VuZDogI2VlZWVlZTtcXG4gIGhlaWdodDogMTAwJTsgfVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZGFzaGJvYXJkL2Rhc2hib2FyZC5jb21wb25lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gNzIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 721:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(316);\nvar trello_service_1 = __webpack_require__(710);\nvar login_service_1 = __webpack_require__(712);\nvar base_1 = __webpack_require__(722);\nvar FlashMessages_1 = __webpack_require__(714);\nvar platform_browser_1 = __webpack_require__(339);\nvar credentials_1 = __webpack_require__(669);\nvar BoardsComponent = (function () {\n    function BoardsComponent(_credentialsService, _titleService, _trelloService, _loginService, _flash) {\n        this._credentialsService = _credentialsService;\n        this._titleService = _titleService;\n        this._trelloService = _trelloService;\n        this._loginService = _loginService;\n        this._flash = _flash;\n        this.addingBoard = false;\n    }\n    BoardsComponent.prototype.ngOnInit = function () {\n        this.getBoards();\n        this._titleService.setTitle(this._credentialsService.app_name + \" | Dashboard\");\n    };\n    BoardsComponent.prototype.getBoards = function () {\n        var parent = this;\n        this._trelloService.getBoards().subscribe(function (res) {\n            if (res.success) {\n                parent.boards = res.boards;\n                parent.colabs = res.colabs;\n            }\n            else {\n                parent._flash.show(res.flash, \"danger\");\n            }\n        });\n    };\n    BoardsComponent.prototype.newBoard = function () {\n        this.addingBoard = !this.addingBoard;\n    };\n    BoardsComponent.prototype.addBoard = function () {\n        var parent = this;\n        if (this.boardName) {\n            this._trelloService.createBoard(this.boardName).subscribe(function (res) {\n                console.log(res);\n                if (res.success == true) {\n                    var board = new base_1.Board(res.board._id, res.board.title, res.board._owner, [], [], []);\n                    console.log(board);\n                    parent.boards.push(board);\n                }\n                else {\n                    parent._flash.show('Board not saved. Try again', 'danger');\n                }\n            });\n            this.boardName = '';\n        }\n        this.newBoard();\n    };\n    BoardsComponent.prototype.addBoardOnEnter = function (event) {\n        if (event.keyCode === 13) {\n            event.target.blur();\n        }\n    };\n    BoardsComponent = __decorate([\n        core_1.Component({\n            selector: 'boards',\n            template: __webpack_require__(723),\n            styles: [__webpack_require__(724)]\n        }), \n        __metadata('design:paramtypes', [(typeof (_a = typeof credentials_1.CredentialsConfig !== 'undefined' && credentials_1.CredentialsConfig) === 'function' && _a) || Object, (typeof (_b = typeof platform_browser_1.Title !== 'undefined' && platform_browser_1.Title) === 'function' && _b) || Object, (typeof (_c = typeof trello_service_1.TrelloService !== 'undefined' && trello_service_1.TrelloService) === 'function' && _c) || Object, (typeof (_d = typeof login_service_1.LoginService !== 'undefined' && login_service_1.LoginService) === 'function' && _d) || Object, (typeof (_e = typeof FlashMessages_1.FlashMessages !== 'undefined' && FlashMessages_1.FlashMessages) === 'function' && _e) || Object])\n    ], BoardsComponent);\n    return BoardsComponent;\n    var _a, _b, _c, _d, _e;\n}());\nexports.BoardsComponent = BoardsComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Rhc2hib2FyZC9ib2FyZHMvYm9hcmRzLmNvbXBvbmVudC50cz9hMGVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBUcmVsbG9TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3NlcnZpY2UvdHJlbGxvLnNlcnZpY2UnO1xuaW1wb3J0IHsgTG9naW5TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3NlcnZpY2UvbG9naW4uc2VydmljZSc7XG5pbXBvcnQgeyBCb2FyZCB9IGZyb20gJy4uLy4uL3NoYXJlZC9tb2RlbHMvYmFzZSc7XG5pbXBvcnQgeyBGbGFzaE1lc3NhZ2VzIH0gZnJvbSAnLi4vLi4vc2hhcmVkL3NlcnZpY2UvRmxhc2hNZXNzYWdlcyc7XG5pbXBvcnQgeyBUaXRsZSB9ICAgICBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IENyZWRlbnRpYWxzQ29uZmlnIH0gZnJvbSAnLi4vLi4vLi4vY29uZmlnL2NyZWRlbnRpYWxzJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdib2FyZHMnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2JvYXJkcy5jb21wb25lbnQuaHRtbCcpLFxuICAgIHN0eWxlczogW3JlcXVpcmUoJy4vYm9hcmRzLmNvbXBvbmVudC5zY3NzJyldXG59KVxuZXhwb3J0IGNsYXNzIEJvYXJkc0NvbXBvbmVudHtcbiAgICBib2FyZHM6IEFycmF5PEJvYXJkPjtcbiAgICBjb2xhYnM6IEFycmF5PEJvYXJkPjtcbiAgICBib2FyZE5hbWU6IHN0cmluZztcbiAgICBhZGRpbmdCb2FyZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX2NyZWRlbnRpYWxzU2VydmljZTogQ3JlZGVudGlhbHNDb25maWcsXG4gICAgICAgIHByaXZhdGUgX3RpdGxlU2VydmljZTogVGl0bGUsXG4gICAgICAgIHByaXZhdGUgX3RyZWxsb1NlcnZpY2U6IFRyZWxsb1NlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgX2xvZ2luU2VydmljZTogTG9naW5TZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIF9mbGFzaDogRmxhc2hNZXNzYWdlcyxcbiAgICApeyAgXG4gICAgICAgIFxuICAgICAgfVxuXG4gICAgbmdPbkluaXQoKXtcbiAgICAgICAgdGhpcy5nZXRCb2FyZHMoKTtcbiAgICAgICAgdGhpcy5fdGl0bGVTZXJ2aWNlLnNldFRpdGxlKHRoaXMuX2NyZWRlbnRpYWxzU2VydmljZS5hcHBfbmFtZStcIiB8IERhc2hib2FyZFwiKTtcbiAgICB9XG5cbiAgICBnZXRCb2FyZHMoKXtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3RyZWxsb1NlcnZpY2UuZ2V0Qm9hcmRzKCkuc3Vic2NyaWJlKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgICAgICBpZihyZXMuc3VjY2Vzcyl7XG4gICAgICAgICAgICAgICAgcGFyZW50LmJvYXJkcyA9IHJlcy5ib2FyZHM7XG4gICAgICAgICAgICAgICAgcGFyZW50LmNvbGFicyA9IHJlcy5jb2xhYnM7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBwYXJlbnQuX2ZsYXNoLnNob3cocmVzLmZsYXNoLCBcImRhbmdlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5ld0JvYXJkKCkge1xuICAgICAgICB0aGlzLmFkZGluZ0JvYXJkID0gIXRoaXMuYWRkaW5nQm9hcmQ7XG4gICAgfVxuXG4gICAgYWRkQm9hcmQoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5ib2FyZE5hbWUpIHtcblx0ICAgICAgICB0aGlzLl90cmVsbG9TZXJ2aWNlLmNyZWF0ZUJvYXJkKHRoaXMuYm9hcmROYW1lKS5zdWJzY3JpYmUoZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlcyk7IFxuICAgICAgICAgICAgaWYocmVzLnN1Y2Nlc3MgPT0gdHJ1ZSl7XG4gICAgICAgICAgICAgICAgbGV0IGJvYXJkID0gbmV3IEJvYXJkKFxuICAgICAgICAgICAgICAgICAgICByZXMuYm9hcmQuX2lkLFxuICAgICAgICAgICAgICAgICAgICByZXMuYm9hcmQudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIHJlcy5ib2FyZC5fb3duZXIsXG4gICAgICAgICAgICAgICAgICAgIFtdLFtdLFtdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhib2FyZCk7XG4gICAgICAgICAgICAgICAgcGFyZW50LmJvYXJkcy5wdXNoKGJvYXJkKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHBhcmVudC5fZmxhc2guc2hvdygnQm9hcmQgbm90IHNhdmVkLiBUcnkgYWdhaW4nLCAnZGFuZ2VyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXHQgICAgICAgIHRoaXMuYm9hcmROYW1lID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXdCb2FyZCgpO1xuICAgIH1cblxuICAgIGFkZEJvYXJkT25FbnRlcihldmVudDogYW55KSB7XG5cdCAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcblx0ICAgICAgZXZlbnQudGFyZ2V0LmJsdXIoKTtcblx0ICAgIH1cbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvZGFzaGJvYXJkL2JvYXJkcy9ib2FyZHMuY29tcG9uZW50LnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBVUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBaUVBOztBQUFBO0FBaEVBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ 722:
/***/ function(module, exports) {

	eval("\"use strict\";\nvar Card = (function () {\n    function Card() {\n    }\n    return Card;\n}());\nexports.Card = Card;\nvar Board = (function () {\n    function Board(_id, title, _owner, columns, members, labels) {\n        this._id = _id;\n        this.title = title;\n        this._owner = _owner;\n        this.columns = columns;\n        this.members = members;\n        this.labels = labels;\n    }\n    return Board;\n}());\nexports.Board = Board;\nvar Column = (function () {\n    function Column(_id, title, cards) {\n        this._id = _id;\n        this.title = title;\n        this.cards = cards;\n    }\n    return Column;\n}());\nexports.Column = Column;\nvar TextCard = (function () {\n    function TextCard(_id, title, description, tags, elements) {\n        this._id = _id;\n        this.title = title;\n        this.description = description;\n        this.tags = tags;\n        this.elements = elements;\n    }\n    return TextCard;\n}());\nexports.TextCard = TextCard;\nvar TextElement = (function () {\n    function TextElement(name) {\n        this.name = name;\n    }\n    return TextElement;\n}());\nexports.TextElement = TextElement;\nvar Tag = (function () {\n    function Tag(name) {\n        this.name = name;\n    }\n    return Tag;\n}());\nexports.Tag = Tag;\n// export class User{\n//     constructor(\n//         public _id: string,\n//         public updatedAt: string,\n//         public createdAt: string,\n//         public email: string,\n//     ) {}\n// } \n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL3NoYXJlZC9tb2RlbHMvYmFzZS50cz9iOWY2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBpbnRlcmZhY2UgTGlzdEk8VD4ge1xuICAgIGlkOiBudW1iZXI7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGl0ZW1zOiBBcnJheTxUPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYXJkSSB7XG4gICAgX2lkOiBudW1iZXI7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgIHRhZ3M6IEFycmF5PFRhZz47XG59XG5cbmV4cG9ydCBjbGFzcyBDYXJkIHtcbiAgICBfaWQ6IG51bWJlcjtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgdGFnczogQXJyYXk8VGFnPjtcbiAgICBtZW1iZXJzOmFueTtcbiAgICBkdWVkYXRlOmFueTtcbiAgICBsYWJlbHM6YW55O1xuICAgIGNvbW1lbnRzOmFueTtcbiAgICBhdHRhdGNoZW50czogQXJyYXk8U3RyaW5nPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZXh0Q2FyZEk8VD4ge1xuICAgIGVsZW1lbnRzOiBBcnJheTxUPlxufVxuXG5leHBvcnQgY2xhc3MgQm9hcmQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgX2lkOiBudW1iZXIsXG4gICAgICAgIHB1YmxpYyB0aXRsZTogc3RyaW5nLFxuICAgICAgICBwdWJsaWMgX293bmVyOiBzdHJpbmcsXG5cdFx0cHVibGljIGNvbHVtbnM6IEFycmF5PENvbHVtbj4sXG4gICAgICAgIHB1YmxpYyBtZW1iZXJzOiBBcnJheTxhbnk+LFxuICAgICAgICBwdWJsaWMgbGFiZWxzOiBBcnJheTxhbnk+LFxuICAgICkge31cbn1cblxuZXhwb3J0IGNsYXNzIENvbHVtbiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyBfaWQ6IG51bWJlcixcbiAgICAgICAgcHVibGljIHRpdGxlOiBzdHJpbmcsXG4gICAgICAgIHB1YmxpYyBjYXJkczogQXJyYXk8Q2FyZD5cbiAgICApIHt9XG59XG5cbmV4cG9ydCBjbGFzcyBUZXh0Q2FyZCBpbXBsZW1lbnRzIENhcmRJIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljIF9pZDogbnVtYmVyLFxuICAgICAgICBwdWJsaWMgdGl0bGU6IHN0cmluZyxcbiAgICAgICAgcHVibGljIGRlc2NyaXB0aW9uOiBzdHJpbmcsXG4gICAgICAgIHB1YmxpYyB0YWdzOiBBcnJheTxUYWc+LFxuICAgICAgICBwdWJsaWMgZWxlbWVudHM6IEFycmF5PFRleHRFbGVtZW50PlxuICAgICkge31cbn1cblxuZXhwb3J0IGNsYXNzIFRleHRFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljIG5hbWU6IHN0cmluZ1xuICAgICkge31cbn1cblxuZXhwb3J0IGNsYXNzIFRhZyB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyBuYW1lOiBzdHJpbmdcbiAgICApIHt9XG59XG5cbi8vIGV4cG9ydCBjbGFzcyBVc2Vye1xuLy8gICAgIGNvbnN0cnVjdG9yKFxuLy8gICAgICAgICBwdWJsaWMgX2lkOiBzdHJpbmcsXG4vLyAgICAgICAgIHB1YmxpYyB1cGRhdGVkQXQ6IHN0cmluZyxcbi8vICAgICAgICAgcHVibGljIGNyZWF0ZWRBdDogc3RyaW5nLFxuLy8gICAgICAgICBwdWJsaWMgZW1haWw6IHN0cmluZyxcblxuLy8gICAgICkge31cbi8vIH1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvc2hhcmVkL21vZGVscy9iYXNlLnRzIl0sIm1hcHBpbmdzIjoiO0FBYUE7QUFBQTtBQVVBO0FBQUE7QUFBQTtBQVZBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 723:
/***/ function(module, exports) {

	eval("module.exports = \"<div class=\\\"boards-wrapper\\\">\\n\\t<div id=\\\"boards\\\">\\n\\t\\t<div class=\\\"row\\\">\\n\\t\\t\\t<h2>My Boards</h2>\\n\\t\\t\\t<div class=\\\"grey lighten-5 board card\\\" *ngFor=\\\"let board of boards\\\" [routerLink]=\\\"['board', board._id]\\\">\\n\\t\\t\\t\\t<span class=\\\"title\\\">{{ board.title }}</span>\\n\\t\\t\\t</div>\\n\\n\\t\\t\\t<div class=\\\"board add-board card\\\">\\n\\t\\t\\t\\t<span *ngIf=\\\"!addingBoard\\\" (click)=\\\"newBoard();\\\">Create a new board...</span>\\n\\t\\t\\t\\t<input autofocus *ngIf=\\\"addingBoard\\\" (keyup)=\\\"addBoardOnEnter($event)\\\" (blur)=\\\"addBoard()\\\" [(ngModel)]=\\\"boardName\\\" />\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"row\\\" *ngIf=\\\"colabs?.length > 0\\\">\\n\\t\\t\\t<h2>Collaboration Boards</h2>\\n\\t\\t\\t<div class=\\\"grey lighten-5 board card\\\" *ngFor=\\\"let board of colabs\\\" [routerLink]=\\\"['board', board._id]\\\">\\n\\t\\t\\t\\t<span class=\\\"title\\\">{{ board.title }}</span>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</div>\\n</div>\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Rhc2hib2FyZC9ib2FyZHMvYm9hcmRzLmNvbXBvbmVudC5odG1sP2RiYzkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImJvYXJkcy13cmFwcGVyXFxcIj5cXG5cXHQ8ZGl2IGlkPVxcXCJib2FyZHNcXFwiPlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuXFx0XFx0XFx0PGgyPk15IEJvYXJkczwvaDI+XFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiZ3JleSBsaWdodGVuLTUgYm9hcmQgY2FyZFxcXCIgKm5nRm9yPVxcXCJsZXQgYm9hcmQgb2YgYm9hcmRzXFxcIiBbcm91dGVyTGlua109XFxcIlsnYm9hcmQnLCBib2FyZC5faWRdXFxcIj5cXG5cXHRcXHRcXHRcXHQ8c3BhbiBjbGFzcz1cXFwidGl0bGVcXFwiPnt7IGJvYXJkLnRpdGxlIH19PC9zcGFuPlxcblxcdFxcdFxcdDwvZGl2PlxcblxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImJvYXJkIGFkZC1ib2FyZCBjYXJkXFxcIj5cXG5cXHRcXHRcXHRcXHQ8c3BhbiAqbmdJZj1cXFwiIWFkZGluZ0JvYXJkXFxcIiAoY2xpY2spPVxcXCJuZXdCb2FyZCgpO1xcXCI+Q3JlYXRlIGEgbmV3IGJvYXJkLi4uPC9zcGFuPlxcblxcdFxcdFxcdFxcdDxpbnB1dCBhdXRvZm9jdXMgKm5nSWY9XFxcImFkZGluZ0JvYXJkXFxcIiAoa2V5dXApPVxcXCJhZGRCb2FyZE9uRW50ZXIoJGV2ZW50KVxcXCIgKGJsdXIpPVxcXCJhZGRCb2FyZCgpXFxcIiBbKG5nTW9kZWwpXT1cXFwiYm9hcmROYW1lXFxcIiAvPlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdDwvZGl2PlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcInJvd1xcXCIgKm5nSWY9XFxcImNvbGFicz8ubGVuZ3RoID4gMFxcXCI+XFxuXFx0XFx0XFx0PGgyPkNvbGxhYm9yYXRpb24gQm9hcmRzPC9oMj5cXG5cXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJncmV5IGxpZ2h0ZW4tNSBib2FyZCBjYXJkXFxcIiAqbmdGb3I9XFxcImxldCBib2FyZCBvZiBjb2xhYnNcXFwiIFtyb3V0ZXJMaW5rXT1cXFwiWydib2FyZCcsIGJvYXJkLl9pZF1cXFwiPlxcblxcdFxcdFxcdFxcdDxzcGFuIGNsYXNzPVxcXCJ0aXRsZVxcXCI+e3sgYm9hcmQudGl0bGUgfX08L3NwYW4+XFxuXFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0PC9kaXY+XFxuXFx0PC9kaXY+XFxuPC9kaXY+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZGFzaGJvYXJkL2JvYXJkcy9ib2FyZHMuY29tcG9uZW50Lmh0bWxcbi8vIG1vZHVsZSBpZCA9IDcyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 724:
/***/ function(module, exports) {

	eval("module.exports = \".boards-wrapper {\\n  padding: 2em;\\n  /*background-color: white;*/\\n  min-height: calc(100vh - 50px); }\\n\\nh2 {\\n  color: #333;\\n  font-weight: 700;\\n  /*font: 14px \\\"Helvetica Neue\\\",Arial,Helvetica,sans-serif; */\\n  line-height: 20px;\\n  font-size: 12pt; }\\n\\n.board {\\n  height: 72px;\\n  width: 280px;\\n  float: left;\\n  margin-right: 16px;\\n  margin-bottom: 16px;\\n  text-align: left;\\n  padding: 9pt 8px;\\n  border-radius: 3px;\\n  text-decoration: none; }\\n\\n.board .title {\\n  font-weight: 400;\\n  line-height: 20px;\\n  font-size: 12pt; }\\n\\n.add-board {\\n  background-color: #e2e4e6;\\n  color: #8c8c8c; }\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Rhc2hib2FyZC9ib2FyZHMvYm9hcmRzLmNvbXBvbmVudC5zY3NzPzFjNWYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIi5ib2FyZHMtd3JhcHBlciB7XFxuICBwYWRkaW5nOiAyZW07XFxuICAvKmJhY2tncm91bmQtY29sb3I6IHdoaXRlOyovXFxuICBtaW4taGVpZ2h0OiBjYWxjKDEwMHZoIC0gNTBweCk7IH1cXG5cXG5oMiB7XFxuICBjb2xvcjogIzMzMztcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICAvKmZvbnQ6IDE0cHggXFxcIkhlbHZldGljYSBOZXVlXFxcIixBcmlhbCxIZWx2ZXRpY2Esc2Fucy1zZXJpZjsgKi9cXG4gIGxpbmUtaGVpZ2h0OiAyMHB4O1xcbiAgZm9udC1zaXplOiAxMnB0OyB9XFxuXFxuLmJvYXJkIHtcXG4gIGhlaWdodDogNzJweDtcXG4gIHdpZHRoOiAyODBweDtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgbWFyZ2luLXJpZ2h0OiAxNnB4O1xcbiAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICBwYWRkaW5nOiA5cHQgOHB4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB9XFxuXFxuLmJvYXJkIC50aXRsZSB7XFxuICBmb250LXdlaWdodDogNDAwO1xcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XFxuICBmb250LXNpemU6IDEycHQ7IH1cXG5cXG4uYWRkLWJvYXJkIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlMmU0ZTY7XFxuICBjb2xvcjogIzhjOGM4YzsgfVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZGFzaGJvYXJkL2JvYXJkcy9ib2FyZHMuY29tcG9uZW50LnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDcyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 725:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(316);\nvar trello_service_1 = __webpack_require__(710);\nvar login_service_1 = __webpack_require__(712);\nvar FlashMessages_1 = __webpack_require__(714);\nvar platform_browser_1 = __webpack_require__(339);\nvar credentials_1 = __webpack_require__(669);\nvar AccountComponent = (function () {\n    function AccountComponent(_credentialsService, _titleService, _trelloService, _loginService, _flash) {\n        this._credentialsService = _credentialsService;\n        this._titleService = _titleService;\n        this._trelloService = _trelloService;\n        this._loginService = _loginService;\n        this._flash = _flash;\n        this.uploadUrl = this._credentialsService.upload_url;\n        this.defaultProfilePicture = this._credentialsService.default_profile_pic_url;\n        // const component = this;\n        // // this._titleService.setTitle(this._credentialsService.app_name+\" | Account\");\n        // // this.user = this._loginService.getUser();\n        // this._trelloService.getUser().subscribe(function(res){\n        //     if(res.success){\n        //         console.log(res.user);\n        //         component.user = res.user;\n        //     }\n        // });\n    }\n    AccountComponent.prototype.ngOnInit = function () {\n        var component = this;\n        this._titleService.setTitle(this._credentialsService.app_name + \" | Account\");\n        this.user = this._loginService.getUser();\n        this._trelloService.getUser().subscribe(function (res) {\n            if (res.success) {\n                component.user = res.user;\n            }\n            else {\n                component.user = component._loginService.getUser();\n            }\n        });\n        this._trelloService.getUser().subscribe(function (res) {\n            if (res.success) {\n                // console.log(res.user);\n                component.user = res.user;\n                component._loginService.setUser(res.user);\n            }\n        });\n    };\n    AccountComponent.prototype.blurOnEnter = function (event) {\n        if (event.keyCode === 13) {\n            event.target.blur();\n        }\n    };\n    AccountComponent.prototype.onSubmit = function (form) {\n        form.action = this.uploadUrl;\n        console.log(this.uploadUrl);\n        form.submit();\n    };\n    AccountComponent.prototype.updateInformation = function () {\n        var component = this;\n        this._trelloService.updateUser(this.user).subscribe(function (res) {\n            console.log(res);\n            if (res.success) {\n                component.user = res.user;\n                component._loginService.setUser(res.user);\n            }\n        });\n    };\n    AccountComponent = __decorate([\n        core_1.Component({\n            selector: 'account',\n            template: __webpack_require__(726),\n            styles: [__webpack_require__(727)]\n        }), \n        __metadata('design:paramtypes', [(typeof (_a = typeof credentials_1.CredentialsConfig !== 'undefined' && credentials_1.CredentialsConfig) === 'function' && _a) || Object, (typeof (_b = typeof platform_browser_1.Title !== 'undefined' && platform_browser_1.Title) === 'function' && _b) || Object, (typeof (_c = typeof trello_service_1.TrelloService !== 'undefined' && trello_service_1.TrelloService) === 'function' && _c) || Object, (typeof (_d = typeof login_service_1.LoginService !== 'undefined' && login_service_1.LoginService) === 'function' && _d) || Object, (typeof (_e = typeof FlashMessages_1.FlashMessages !== 'undefined' && FlashMessages_1.FlashMessages) === 'function' && _e) || Object])\n    ], AccountComponent);\n    return AccountComponent;\n    var _a, _b, _c, _d, _e;\n}());\nexports.AccountComponent = AccountComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Rhc2hib2FyZC9hY2NvdW50L2FjY291bnQuY29tcG9uZW50LnRzP2U4MzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IFRyZWxsb1NlcnZpY2UgfSBmcm9tICcuLi8uLi9zaGFyZWQvc2VydmljZS90cmVsbG8uc2VydmljZSc7XG5pbXBvcnQgeyBMb2dpblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zaGFyZWQvc2VydmljZS9sb2dpbi5zZXJ2aWNlJztcbmltcG9ydCB7IEJvYXJkIH0gZnJvbSAnLi4vLi4vc2hhcmVkL21vZGVscy9iYXNlJztcbmltcG9ydCB7IEZsYXNoTWVzc2FnZXMgfSBmcm9tICcuLi8uLi9zaGFyZWQvc2VydmljZS9GbGFzaE1lc3NhZ2VzJztcbmltcG9ydCB7IFRpdGxlIH0gICAgIGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgQ3JlZGVudGlhbHNDb25maWcgfSBmcm9tICcuLi8uLi8uLi9jb25maWcvY3JlZGVudGlhbHMnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FjY291bnQnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2FjY291bnQuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL2FjY291bnQuY29tcG9uZW50LnNjc3MnKV1cbn0pXG5leHBvcnQgY2xhc3MgQWNjb3VudENvbXBvbmVudHtcblxuICAgIHVwbG9hZFVybDpzdHJpbmc7XG4gICAgZGVmYXVsdFByb2ZpbGVQaWN0dXJlOnN0cmluZztcbiAgICBwcm9maWxlUGljdHVyZTpzdHJpbmc7XG4gICAgdXNlcjphbnk7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX2NyZWRlbnRpYWxzU2VydmljZTogQ3JlZGVudGlhbHNDb25maWcsXG4gICAgICAgIHByaXZhdGUgX3RpdGxlU2VydmljZTogVGl0bGUsXG4gICAgICAgIHByaXZhdGUgX3RyZWxsb1NlcnZpY2U6IFRyZWxsb1NlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgX2xvZ2luU2VydmljZTogTG9naW5TZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIF9mbGFzaDogRmxhc2hNZXNzYWdlcyxcbiAgICApeyAgXG4gICAgICAgIHRoaXMudXBsb2FkVXJsID0gdGhpcy5fY3JlZGVudGlhbHNTZXJ2aWNlLnVwbG9hZF91cmw7XG4gICAgICAgIHRoaXMuZGVmYXVsdFByb2ZpbGVQaWN0dXJlID0gdGhpcy5fY3JlZGVudGlhbHNTZXJ2aWNlLmRlZmF1bHRfcHJvZmlsZV9waWNfdXJsO1xuICAgICAgICAvLyBjb25zdCBjb21wb25lbnQgPSB0aGlzO1xuICAgICAgICAvLyAvLyB0aGlzLl90aXRsZVNlcnZpY2Uuc2V0VGl0bGUodGhpcy5fY3JlZGVudGlhbHNTZXJ2aWNlLmFwcF9uYW1lK1wiIHwgQWNjb3VudFwiKTtcbiAgICAgICAgLy8gLy8gdGhpcy51c2VyID0gdGhpcy5fbG9naW5TZXJ2aWNlLmdldFVzZXIoKTtcbiAgICAgICAgLy8gdGhpcy5fdHJlbGxvU2VydmljZS5nZXRVc2VyKCkuc3Vic2NyaWJlKGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgIC8vICAgICBpZihyZXMuc3VjY2Vzcyl7XG4gICAgICAgIC8vICAgICAgICAgY29uc29sZS5sb2cocmVzLnVzZXIpO1xuICAgICAgICAvLyAgICAgICAgIGNvbXBvbmVudC51c2VyID0gcmVzLnVzZXI7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH0pO1xuICAgICAgfVxuXG4gICAgbmdPbkluaXQoKXtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5fdGl0bGVTZXJ2aWNlLnNldFRpdGxlKHRoaXMuX2NyZWRlbnRpYWxzU2VydmljZS5hcHBfbmFtZStcIiB8IEFjY291bnRcIik7XG4gICAgICAgIHRoaXMudXNlciA9IHRoaXMuX2xvZ2luU2VydmljZS5nZXRVc2VyKCk7XG4gICAgICAgIHRoaXMuX3RyZWxsb1NlcnZpY2UuZ2V0VXNlcigpLnN1YnNjcmliZShmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgaWYocmVzLnN1Y2Nlc3Mpe1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC51c2VyID0gcmVzLnVzZXI7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQudXNlciA9IGNvbXBvbmVudC5fbG9naW5TZXJ2aWNlLmdldFVzZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3RyZWxsb1NlcnZpY2UuZ2V0VXNlcigpLnN1YnNjcmliZShmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgaWYocmVzLnN1Y2Nlc3Mpe1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHJlcy51c2VyKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQudXNlciA9IHJlcy51c2VyO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5fbG9naW5TZXJ2aWNlLnNldFVzZXIocmVzLnVzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBibHVyT25FbnRlcihldmVudDogYW55KSB7XG5cdCAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcblx0ICAgICAgZXZlbnQudGFyZ2V0LmJsdXIoKTtcblx0ICAgIH1cbiAgICB9XG5cbiAgICBvblN1Ym1pdChmb3JtOmFueSl7XG4gICAgICAgIGZvcm0uYWN0aW9uID0gdGhpcy51cGxvYWRVcmw7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMudXBsb2FkVXJsKTtcbiAgICAgICAgZm9ybS5zdWJtaXQoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVJbmZvcm1hdGlvbigpe1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzO1xuICAgICAgICB0aGlzLl90cmVsbG9TZXJ2aWNlLnVwZGF0ZVVzZXIodGhpcy51c2VyKS5zdWJzY3JpYmUoZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlcyk7XG4gICAgICAgICAgICBpZihyZXMuc3VjY2Vzcyl7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnVzZXIgPSByZXMudXNlcjtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuX2xvZ2luU2VydmljZS5zZXRVc2VyKHJlcy51c2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5vZGVfbW9kdWxlcy9hbmd1bGFyMi1yb3V0ZXItbG9hZGVyL3NyYyEuL34vYW5ndWxhcjItdGVtcGxhdGUtbG9hZGVyIS4vc3JjL2Rhc2hib2FyZC9hY2NvdW50L2FjY291bnQuY29tcG9uZW50LnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBT0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFxRUE7O0FBQUE7QUFwRUE7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 726:
/***/ function(module, exports) {

	eval("module.exports = \"<div class=\\\"container\\\">\\n\\t<div class=\\\"col s12\\\">\\n\\t\\t<div class=\\\"row\\\">\\n\\t\\t\\t<div class=\\\"col s12 account-title\\\">\\n\\t\\t\\t\\t<h3>Profile information</h3>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"row account-form\\\">\\n\\t\\t\\t<div class=\\\"col s8 offset-s2\\\">\\n\\t\\t\\t\\t<div class=\\\"input-field col s12\\\">\\n\\t\\t\\t\\t\\t<i class=\\\"material-icons prefix\\\">email</i>\\n\\t\\t\\t\\t\\t<input placeholder=\\\"Email\\\" [(ngModel)]=\\\"user.email\\\" id=\\\"email\\\" type=\\\"text\\\" class=\\\"validate\\\">\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t\\t<div class=\\\"input-field col s12\\\">\\n\\t\\t\\t\\t\\t<i class=\\\"material-icons prefix\\\">account_circle</i>\\n\\t\\t\\t\\t\\t<input placeholder=\\\"Name\\\" [(ngModel)]=\\\"user?.profile.name\\\" id=\\\"name\\\" type=\\\"text\\\" class=\\\"validate\\\">\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t\\t<div class=\\\"input-field col s12\\\">\\n\\t\\t\\t\\t\\t<button (click)=\\\"updateInformation()\\\" class=\\\"btn right\\\">Update</button>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"row\\\">\\n\\t\\t\\t<div class=\\\"col s12 account-title\\\">\\n\\t\\t\\t\\t<h3>Profile picture</h3>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"row\\\">\\n\\t\\t\\t<div class=\\\"col s8 offset-s2 account-form\\\">\\n\\t\\t\\t\\t<div class=\\\"col s4\\\">\\n\\t\\t\\t\\t\\t<img *ngIf=\\\"user.profile?.picture\\\" class=\\\"responsive-img profile-picture\\\" src=\\\"{{ user.profile.picture }}\\\" alt=\\\"\\\" />\\n\\t\\t\\t\\t\\t<img *ngIf=\\\"!user.profile?.picture\\\" class=\\\"responsive-img profile-picture\\\" src=\\\"{{ defaultProfilePicture }}\\\" alt=\\\"\\\" />\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t\\t<form class=\\\"col s8\\\" #form enctype='multipart/form-data' method=\\\"POST\\\">\\n\\t\\t\\t\\t\\t<div class=\\\"file-field input-field upload-field\\\">\\n\\t\\t\\t\\t\\t\\t<div class=\\\"btn\\\">\\n\\t\\t\\t\\t\\t\\t\\t<span>Upload</span>\\n\\t\\t\\t\\t\\t\\t\\t<input type=\\\"file\\\" accept=\\\"image/*\\\" name=\\\"profilePicture\\\">\\n\\t\\t\\t\\t\\t\\t</div>\\n\\t\\t\\t\\t\\t\\t<div class=\\\"file-path-wrapper\\\">\\n\\t\\t\\t\\t\\t\\t\\t<input class=\\\"file-path validate\\\" type=\\\"text\\\">\\n\\t\\t\\t\\t\\t\\t</div>\\n\\t\\t\\t\\t\\t</div>\\n\\t\\t\\t\\t</form>\\n\\t\\t\\t\\t<div class=\\\"col s12\\\">\\n\\t\\t\\t\\t\\t<button class=\\\"btn right\\\" (click)=\\\"onSubmit(form)\\\">Update</button>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</div>\\n</div>\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Rhc2hib2FyZC9hY2NvdW50L2FjY291bnQuY29tcG9uZW50Lmh0bWw/MzA2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG5cXHQ8ZGl2IGNsYXNzPVxcXCJjb2wgczEyXFxcIj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbCBzMTIgYWNjb3VudC10aXRsZVxcXCI+XFxuXFx0XFx0XFx0XFx0PGgzPlByb2ZpbGUgaW5mb3JtYXRpb248L2gzPlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdDwvZGl2PlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcInJvdyBhY2NvdW50LWZvcm1cXFwiPlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbCBzOCBvZmZzZXQtczJcXFwiPlxcblxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImlucHV0LWZpZWxkIGNvbCBzMTJcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxpIGNsYXNzPVxcXCJtYXRlcmlhbC1pY29ucyBwcmVmaXhcXFwiPmVtYWlsPC9pPlxcblxcdFxcdFxcdFxcdFxcdDxpbnB1dCBwbGFjZWhvbGRlcj1cXFwiRW1haWxcXFwiIFsobmdNb2RlbCldPVxcXCJ1c2VyLmVtYWlsXFxcIiBpZD1cXFwiZW1haWxcXFwiIHR5cGU9XFxcInRleHRcXFwiIGNsYXNzPVxcXCJ2YWxpZGF0ZVxcXCI+XFxuXFx0XFx0XFx0XFx0PC9kaXY+XFxuXFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiaW5wdXQtZmllbGQgY29sIHMxMlxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0PGkgY2xhc3M9XFxcIm1hdGVyaWFsLWljb25zIHByZWZpeFxcXCI+YWNjb3VudF9jaXJjbGU8L2k+XFxuXFx0XFx0XFx0XFx0XFx0PGlucHV0IHBsYWNlaG9sZGVyPVxcXCJOYW1lXFxcIiBbKG5nTW9kZWwpXT1cXFwidXNlcj8ucHJvZmlsZS5uYW1lXFxcIiBpZD1cXFwibmFtZVxcXCIgdHlwZT1cXFwidGV4dFxcXCIgY2xhc3M9XFxcInZhbGlkYXRlXFxcIj5cXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJpbnB1dC1maWVsZCBjb2wgczEyXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQ8YnV0dG9uIChjbGljayk9XFxcInVwZGF0ZUluZm9ybWF0aW9uKClcXFwiIGNsYXNzPVxcXCJidG4gcmlnaHRcXFwiPlVwZGF0ZTwvYnV0dG9uPlxcblxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdDwvZGl2PlxcblxcdFxcdDxkaXYgY2xhc3M9XFxcInJvd1xcXCI+XFxuXFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiY29sIHMxMiBhY2NvdW50LXRpdGxlXFxcIj5cXG5cXHRcXHRcXHRcXHQ8aDM+UHJvZmlsZSBwaWN0dXJlPC9oMz5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8ZGl2IGNsYXNzPVxcXCJyb3dcXFwiPlxcblxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImNvbCBzOCBvZmZzZXQtczIgYWNjb3VudC1mb3JtXFxcIj5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wgczRcXFwiPlxcblxcdFxcdFxcdFxcdFxcdDxpbWcgKm5nSWY9XFxcInVzZXIucHJvZmlsZT8ucGljdHVyZVxcXCIgY2xhc3M9XFxcInJlc3BvbnNpdmUtaW1nIHByb2ZpbGUtcGljdHVyZVxcXCIgc3JjPVxcXCJ7eyB1c2VyLnByb2ZpbGUucGljdHVyZSB9fVxcXCIgYWx0PVxcXCJcXFwiIC8+XFxuXFx0XFx0XFx0XFx0XFx0PGltZyAqbmdJZj1cXFwiIXVzZXIucHJvZmlsZT8ucGljdHVyZVxcXCIgY2xhc3M9XFxcInJlc3BvbnNpdmUtaW1nIHByb2ZpbGUtcGljdHVyZVxcXCIgc3JjPVxcXCJ7eyBkZWZhdWx0UHJvZmlsZVBpY3R1cmUgfX1cXFwiIGFsdD1cXFwiXFxcIiAvPlxcblxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdDxmb3JtIGNsYXNzPVxcXCJjb2wgczhcXFwiICNmb3JtIGVuY3R5cGU9J211bHRpcGFydC9mb3JtLWRhdGEnIG1ldGhvZD1cXFwiUE9TVFxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0PGRpdiBjbGFzcz1cXFwiZmlsZS1maWVsZCBpbnB1dC1maWVsZCB1cGxvYWQtZmllbGRcXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdDxkaXYgY2xhc3M9XFxcImJ0blxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PHNwYW4+VXBsb2FkPC9zcGFuPlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdDxpbnB1dCB0eXBlPVxcXCJmaWxlXFxcIiBhY2NlcHQ9XFxcImltYWdlLypcXFwiIG5hbWU9XFxcInByb2ZpbGVQaWN0dXJlXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJmaWxlLXBhdGgtd3JhcHBlclxcXCI+XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0PGlucHV0IGNsYXNzPVxcXCJmaWxlLXBhdGggdmFsaWRhdGVcXFwiIHR5cGU9XFxcInRleHRcXFwiPlxcblxcdFxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdFxcdDwvZGl2PlxcblxcdFxcdFxcdFxcdDwvZm9ybT5cXG5cXHRcXHRcXHRcXHQ8ZGl2IGNsYXNzPVxcXCJjb2wgczEyXFxcIj5cXG5cXHRcXHRcXHRcXHRcXHQ8YnV0dG9uIGNsYXNzPVxcXCJidG4gcmlnaHRcXFwiIChjbGljayk9XFxcIm9uU3VibWl0KGZvcm0pXFxcIj5VcGRhdGU8L2J1dHRvbj5cXG5cXHRcXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHRcXHQ8L2Rpdj5cXG5cXHRcXHQ8L2Rpdj5cXG5cXHQ8L2Rpdj5cXG48L2Rpdj5cIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9kYXNoYm9hcmQvYWNjb3VudC9hY2NvdW50LmNvbXBvbmVudC5odG1sXG4vLyBtb2R1bGUgaWQgPSA3MjZcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ 727:
/***/ function(module, exports) {

	eval("module.exports = \".account-title {\\n  padding-bottom: 0px;\\n  border-bottom: 1px solid grey; }\\n  .account-title h3 {\\n    font-size: 24px; }\\n\\n.account-form {\\n  font-size: 14px;\\n  margin-bottom: 60px; }\\n\\n.upload-field {\\n  margin-top: 75px; }\\n\\n.user-pic {\\n  width: 100%;\\n  background: grey;\\n  color: black;\\n  text-align: center;\\n  vertical-align: middle;\\n  border-radius: 10px; }\\n\\n.profile-picture {\\n  border-radius: 10px; }\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Rhc2hib2FyZC9hY2NvdW50L2FjY291bnQuY29tcG9uZW50LnNjc3M/NWE0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLmFjY291bnQtdGl0bGUge1xcbiAgcGFkZGluZy1ib3R0b206IDBweDtcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCBncmV5OyB9XFxuICAuYWNjb3VudC10aXRsZSBoMyB7XFxuICAgIGZvbnQtc2l6ZTogMjRweDsgfVxcblxcbi5hY2NvdW50LWZvcm0ge1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgbWFyZ2luLWJvdHRvbTogNjBweDsgfVxcblxcbi51cGxvYWQtZmllbGQge1xcbiAgbWFyZ2luLXRvcDogNzVweDsgfVxcblxcbi51c2VyLXBpYyB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGJhY2tncm91bmQ6IGdyZXk7XFxuICBjb2xvcjogYmxhY2s7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDsgfVxcblxcbi5wcm9maWxlLXBpY3R1cmUge1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDsgfVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZGFzaGJvYXJkL2FjY291bnQvYWNjb3VudC5jb21wb25lbnQuc2Nzc1xuLy8gbW9kdWxlIGlkID0gNzI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 728:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar core_1 = __webpack_require__(316);\nvar trello_service_1 = __webpack_require__(710);\nvar login_service_1 = __webpack_require__(712);\nvar FlashMessages_1 = __webpack_require__(714);\nvar platform_browser_1 = __webpack_require__(339);\nvar credentials_1 = __webpack_require__(669);\nvar DashboardNavComponent = (function () {\n    function DashboardNavComponent(_credentialsService, _titleService, _trelloService, _loginService, _flash) {\n        this._credentialsService = _credentialsService;\n        this._titleService = _titleService;\n        this._trelloService = _trelloService;\n        this._loginService = _loginService;\n        this._flash = _flash;\n        this.logo = this._credentialsService.app_name;\n        this.icon = this._credentialsService.logo;\n    }\n    DashboardNavComponent.prototype.ngOnInit = function () {\n    };\n    DashboardNavComponent.prototype.blurOnEnter = function (event) {\n        if (event.keyCode === 13) {\n            event.target.blur();\n        }\n    };\n    DashboardNavComponent = __decorate([\n        core_1.Component({\n            selector: 'dashboard-nav',\n            template: __webpack_require__(729),\n            styles: [__webpack_require__(730)]\n        }), \n        __metadata('design:paramtypes', [(typeof (_a = typeof credentials_1.CredentialsConfig !== 'undefined' && credentials_1.CredentialsConfig) === 'function' && _a) || Object, (typeof (_b = typeof platform_browser_1.Title !== 'undefined' && platform_browser_1.Title) === 'function' && _b) || Object, (typeof (_c = typeof trello_service_1.TrelloService !== 'undefined' && trello_service_1.TrelloService) === 'function' && _c) || Object, (typeof (_d = typeof login_service_1.LoginService !== 'undefined' && login_service_1.LoginService) === 'function' && _d) || Object, (typeof (_e = typeof FlashMessages_1.FlashMessages !== 'undefined' && FlashMessages_1.FlashMessages) === 'function' && _e) || Object])\n    ], DashboardNavComponent);\n    return DashboardNavComponent;\n    var _a, _b, _c, _d, _e;\n}());\nexports.DashboardNavComponent = DashboardNavComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Rhc2hib2FyZC9kYXNoYm9hcmQtbmF2L2Rhc2hib2FyZC1uYXYuY29tcG9uZW50LnRzPzE3NjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IFRyZWxsb1NlcnZpY2UgfSBmcm9tICcuLi8uLi9zaGFyZWQvc2VydmljZS90cmVsbG8uc2VydmljZSc7XG5pbXBvcnQgeyBMb2dpblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zaGFyZWQvc2VydmljZS9sb2dpbi5zZXJ2aWNlJztcbmltcG9ydCB7IEJvYXJkIH0gZnJvbSAnLi4vLi4vc2hhcmVkL21vZGVscy9iYXNlJztcbmltcG9ydCB7IEZsYXNoTWVzc2FnZXMgfSBmcm9tICcuLi8uLi9zaGFyZWQvc2VydmljZS9GbGFzaE1lc3NhZ2VzJztcbmltcG9ydCB7IFRpdGxlIH0gICAgIGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgQ3JlZGVudGlhbHNDb25maWcgfSBmcm9tICcuLi8uLi8uLi9jb25maWcvY3JlZGVudGlhbHMnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2Rhc2hib2FyZC1uYXYnLFxuICAgIHRlbXBsYXRlOiByZXF1aXJlKCcuL2Rhc2hib2FyZC1uYXYuY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL2Rhc2hib2FyZC1uYXYuY29tcG9uZW50LnNjc3MnKV1cbn0pXG5leHBvcnQgY2xhc3MgRGFzaGJvYXJkTmF2Q29tcG9uZW50e1xuXG4gICAgdXNlcjphbnk7XG4gICAgbG9nbzpzdHJpbmc7XG4gICAgaWNvbjpzdHJpbmc7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX2NyZWRlbnRpYWxzU2VydmljZTogQ3JlZGVudGlhbHNDb25maWcsXG4gICAgICAgIHByaXZhdGUgX3RpdGxlU2VydmljZTogVGl0bGUsXG4gICAgICAgIHByaXZhdGUgX3RyZWxsb1NlcnZpY2U6IFRyZWxsb1NlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgX2xvZ2luU2VydmljZTogTG9naW5TZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIF9mbGFzaDogRmxhc2hNZXNzYWdlcyxcbiAgICApeyAgXG4gICAgICAgIHRoaXMubG9nbyA9IHRoaXMuX2NyZWRlbnRpYWxzU2VydmljZS5hcHBfbmFtZTtcbiAgICAgICAgdGhpcy5pY29uID0gdGhpcy5fY3JlZGVudGlhbHNTZXJ2aWNlLmxvZ287XG5cbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpe1xuICAgICAgICBcbiAgICB9XG5cbiAgICBibHVyT25FbnRlcihldmVudDogYW55KSB7XG5cdCAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcblx0ICAgICAgZXZlbnQudGFyZ2V0LmJsdXIoKTtcblx0ICAgIH1cbiAgICB9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvYW5ndWxhcjItcm91dGVyLWxvYWRlci9zcmMhLi9+L2FuZ3VsYXIyLXRlbXBsYXRlLWxvYWRlciEuL3NyYy9kYXNoYm9hcmQvZGFzaGJvYXJkLW5hdi9kYXNoYm9hcmQtbmF2LmNvbXBvbmVudC50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQU9BO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5QkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBNEJBOztBQUFBO0FBM0JBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ 729:
/***/ function(module, exports) {

	eval("module.exports = \"<nav class=\\\"dashboard-nav grey lighten-5\\\">\\n    <a [routerLink]=\\\"['']\\\"  class=\\\"brand-logo center nav-item\\\"><img src=\\\"{{ icon }}\\\" class=\\\"responsive-img brand-icon left\\\" alt=\\\"\\\"><span>         \\t{{ logo }}</span></a>\\n    <user-dropdown></user-dropdown>\\n</nav>\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Rhc2hib2FyZC9kYXNoYm9hcmQtbmF2L2Rhc2hib2FyZC1uYXYuY29tcG9uZW50Lmh0bWw/OTBjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiPG5hdiBjbGFzcz1cXFwiZGFzaGJvYXJkLW5hdiBncmV5IGxpZ2h0ZW4tNVxcXCI+XFxuICAgIDxhIFtyb3V0ZXJMaW5rXT1cXFwiWycnXVxcXCIgIGNsYXNzPVxcXCJicmFuZC1sb2dvIGNlbnRlciBuYXYtaXRlbVxcXCI+PGltZyBzcmM9XFxcInt7IGljb24gfX1cXFwiIGNsYXNzPVxcXCJyZXNwb25zaXZlLWltZyBicmFuZC1pY29uIGxlZnRcXFwiIGFsdD1cXFwiXFxcIj48c3Bhbj4gICAgwrcgICAgIFxcdHt7IGxvZ28gfX08L3NwYW4+PC9hPlxcbiAgICA8dXNlci1kcm9wZG93bj48L3VzZXItZHJvcGRvd24+XFxuPC9uYXY+XCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZGFzaGJvYXJkL2Rhc2hib2FyZC1uYXYvZGFzaGJvYXJkLW5hdi5jb21wb25lbnQuaHRtbFxuLy8gbW9kdWxlIGlkID0gNzI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },

/***/ 730:
/***/ function(module, exports) {

	eval("module.exports = \".dashboard-nav {\\n  height: 50px; }\\n\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Rhc2hib2FyZC9kYXNoYm9hcmQtbmF2L2Rhc2hib2FyZC1uYXYuY29tcG9uZW50LnNjc3M/MWJlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLmRhc2hib2FyZC1uYXYge1xcbiAgaGVpZ2h0OiA1MHB4OyB9XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9kYXNoYm9hcmQvZGFzaGJvYXJkLW5hdi9kYXNoYm9hcmQtbmF2LmNvbXBvbmVudC5zY3NzXG4vLyBtb2R1bGUgaWQgPSA3MzBcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },

/***/ 731:
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\nvar router_1 = __webpack_require__(697);\nvar dashboard_component_1 = __webpack_require__(718);\nvar boards_component_1 = __webpack_require__(721);\nvar account_component_1 = __webpack_require__(725);\nvar routes = [\n    { path: '', component: dashboard_component_1.DashboardComponent, children: [\n            { path: '', component: boards_component_1.BoardsComponent },\n            { path: 'account', component: account_component_1.AccountComponent }\n        ] }\n];\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = router_1.RouterModule.forChild(routes);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2Rhc2hib2FyZC9kYXNoYm9hcmQucm91dGVzLnRzPzVmMjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUm91dGVyTW9kdWxlIH0gZnJvbSBcIkBhbmd1bGFyL3JvdXRlclwiO1xuaW1wb3J0IHsgRGFzaGJvYXJkQ29tcG9uZW50IH0gZnJvbSBcIi4vZGFzaGJvYXJkLmNvbXBvbmVudFwiO1xuaW1wb3J0IHsgQm9hcmRzQ29tcG9uZW50IH0gZnJvbSBcIi4vYm9hcmRzL2JvYXJkcy5jb21wb25lbnRcIlxuaW1wb3J0IHsgQWNjb3VudENvbXBvbmVudCB9IGZyb20gXCIuL2FjY291bnQvYWNjb3VudC5jb21wb25lbnRcIlxuXG5cbmNvbnN0IHJvdXRlcyA9IFtcbiAgICB7IHBhdGg6ICcnLCBjb21wb25lbnQ6IERhc2hib2FyZENvbXBvbmVudCwgY2hpbGRyZW46W1xuICAgICAgICB7ICBwYXRoOiAnJywgY29tcG9uZW50OiBCb2FyZHNDb21wb25lbnQgIH0sXG4gICAgICAgIHsgIHBhdGg6ICdhY2NvdW50JywgY29tcG9uZW50OiBBY2NvdW50Q29tcG9uZW50ICB9XG4gICAgXSB9XG5dO1xuXG5leHBvcnQgZGVmYXVsdCBSb3V0ZXJNb2R1bGUuZm9yQ2hpbGQocm91dGVzKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL2FuZ3VsYXIyLXJvdXRlci1sb2FkZXIvc3JjIS4vfi9hbmd1bGFyMi10ZW1wbGF0ZS1sb2FkZXIhLi9zcmMvZGFzaGJvYXJkL2Rhc2hib2FyZC5yb3V0ZXMudHMiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },

/***/ 732:
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(Hammer) {(function (global, factory) {\n     true ? factory(exports, __webpack_require__(316), __webpack_require__(317), __webpack_require__(339), __webpack_require__(700), __webpack_require__(318), __webpack_require__(336), __webpack_require__(668), __webpack_require__(369), __webpack_require__(411), __webpack_require__(535), __webpack_require__(505), __webpack_require__(494), __webpack_require__(591), __webpack_require__(507), __webpack_require__(458), __webpack_require__(513)) :\n    typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/Subject', '@angular/platform-browser', '@angular/forms', 'rxjs/Observable', '@angular/common', '@angular/http', 'rxjs/add/observable/forkJoin', 'rxjs/add/observable/of', 'rxjs/add/operator/map', 'rxjs/add/operator/filter', 'rxjs/add/operator/do', 'rxjs/add/operator/share', 'rxjs/add/operator/finally', 'rxjs/add/operator/catch', 'rxjs/add/operator/first'], factory) :\n    (factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}),global.ng.core,global.Rx,global.ng.platformBrowser,global.ng.forms,global.Rx,global.ng.common,global.ng.http,global.Rx.Observable,global.Rx.Observable,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.Rx.Observable.prototype,global.rxjs_add_operator_first));\n}(this, (function (exports,_angular_core,rxjs_Subject,_angular_platformBrowser,_angular_forms,rxjs_Observable,_angular_common,_angular_http,rxjs_add_observable_forkJoin,rxjs_add_observable_of,rxjs_add_operator_map,rxjs_add_operator_filter,rxjs_add_operator_do,rxjs_add_operator_share,rxjs_add_operator_finally,rxjs_add_operator_catch,rxjs_add_operator_first) { 'use strict';\n\nvar __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$1 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/**\n * Shared directive to count lines inside a text area, such as a list item.\n * Line elements can be extracted with a @ContentChildren(MdLine) query, then\n * counted by checking the query list's length.\n */\nvar MdLine = (function () {\n    function MdLine() {\n    }\n    MdLine = __decorate$1([\n        _angular_core.Directive({ selector: '[md-line]' }), \n        __metadata$1('design:paramtypes', [])\n    ], MdLine);\n    return MdLine;\n}());\n/* Helper that takes a query list of lines and sets the correct class on the host */\nvar MdLineSetter = (function () {\n    function MdLineSetter(_lines, _renderer, _element) {\n        var _this = this;\n        this._lines = _lines;\n        this._renderer = _renderer;\n        this._element = _element;\n        this._setLineClass(this._lines.length);\n        this._lines.changes.subscribe(function () {\n            _this._setLineClass(_this._lines.length);\n        });\n    }\n    MdLineSetter.prototype._setLineClass = function (count) {\n        this._resetClasses();\n        if (count === 2 || count === 3) {\n            this._setClass(\"md-\" + count + \"-line\", true);\n        }\n    };\n    MdLineSetter.prototype._resetClasses = function () {\n        this._setClass('md-2-line', false);\n        this._setClass('md-3-line', false);\n    };\n    MdLineSetter.prototype._setClass = function (className, bool) {\n        this._renderer.setElementClass(this._element.nativeElement, className, bool);\n    };\n    return MdLineSetter;\n}());\nvar MdLineModule = (function () {\n    function MdLineModule() {\n    }\n    MdLineModule = __decorate$1([\n        _angular_core.NgModule({\n            exports: [MdLine],\n            declarations: [MdLine],\n        }), \n        __metadata$1('design:paramtypes', [])\n    ], MdLineModule);\n    return MdLineModule;\n}());\n\nvar __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$2 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/**\n * Directive to listen to changes of direction of part of the DOM.\n *\n * Applications should use this directive instead of the native attribute so that Material\n * components can listen on changes of direction.\n */\nvar Dir = (function () {\n    function Dir() {\n        this._dir = 'ltr';\n        this.dirChange = new _angular_core.EventEmitter();\n    }\n    Object.defineProperty(Dir.prototype, \"dir\", {\n        get: function () {\n            return this._dir;\n        },\n        set: function (v) {\n            var old = this._dir;\n            this._dir = v;\n            if (old != this._dir) {\n                this.dirChange.emit(null);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Dir.prototype, \"value\", {\n        get: function () { return this.dir; },\n        set: function (v) { this.dir = v; },\n        enumerable: true,\n        configurable: true\n    });\n    __decorate$2([\n        _angular_core.Input('dir'), \n        __metadata$2('design:type', String)\n    ], Dir.prototype, \"_dir\", void 0);\n    __decorate$2([\n        _angular_core.Output(), \n        __metadata$2('design:type', Object)\n    ], Dir.prototype, \"dirChange\", void 0);\n    __decorate$2([\n        _angular_core.HostBinding('attr.dir'), \n        __metadata$2('design:type', String)\n    ], Dir.prototype, \"dir\", null);\n    Dir = __decorate$2([\n        _angular_core.Directive({\n            selector: '[dir]',\n            // TODO(hansl): maybe `$implicit` isn't the best option here, but for now that's the best we got.\n            exportAs: '$implicit'\n        }), \n        __metadata$2('design:paramtypes', [])\n    ], Dir);\n    return Dir;\n}());\nvar RtlModule = (function () {\n    function RtlModule() {\n    }\n    RtlModule.forRoot = function () {\n        return {\n            ngModule: RtlModule,\n            providers: []\n        };\n    };\n    RtlModule = __decorate$2([\n        _angular_core.NgModule({\n            exports: [Dir],\n            declarations: [Dir]\n        }), \n        __metadata$2('design:paramtypes', [])\n    ], RtlModule);\n    return RtlModule;\n}());\n\n/** TODO: internal */\nvar ForegroundRippleState;\n(function (ForegroundRippleState) {\n    ForegroundRippleState[ForegroundRippleState[\"NEW\"] = 0] = \"NEW\";\n    ForegroundRippleState[ForegroundRippleState[\"EXPANDING\"] = 1] = \"EXPANDING\";\n    ForegroundRippleState[ForegroundRippleState[\"FADING_OUT\"] = 2] = \"FADING_OUT\";\n})(ForegroundRippleState || (ForegroundRippleState = {}));\n/**\n * Wrapper for a foreground ripple DOM element and its animation state.\n * TODO: internal\n */\nvar ForegroundRipple = (function () {\n    function ForegroundRipple(rippleElement) {\n        this.rippleElement = rippleElement;\n        this.state = ForegroundRippleState.NEW;\n    }\n    return ForegroundRipple;\n}());\nvar RIPPLE_SPEED_PX_PER_SECOND = 1000;\nvar MIN_RIPPLE_FILL_TIME_SECONDS = 0.1;\nvar MAX_RIPPLE_FILL_TIME_SECONDS = 0.3;\n/**\n * Returns the distance from the point (x, y) to the furthest corner of a rectangle.\n */\nvar distanceToFurthestCorner = function (x, y, rect) {\n    var distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right));\n    var distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));\n    return Math.sqrt(distX * distX + distY * distY);\n};\n/**\n * Helper service that performs DOM manipulations. Not intended to be used outside this module.\n * The constructor takes a reference to the ripple directive's host element and a map of DOM\n * event handlers to be installed on the element that triggers ripple animations.\n * This will eventually become a custom renderer once Angular support exists.\n * TODO: internal\n */\nvar RippleRenderer = (function () {\n    function RippleRenderer(_elementRef, _eventHandlers) {\n        this._eventHandlers = _eventHandlers;\n        this._rippleElement = _elementRef.nativeElement;\n        // It might be nice to delay creating the background until it's needed, but doing this in\n        // fadeInRippleBackground causes the first click event to not be handled reliably.\n        this._backgroundDiv = document.createElement('div');\n        this._backgroundDiv.classList.add('md-ripple-background');\n        this._rippleElement.appendChild(this._backgroundDiv);\n    }\n    /**\n     * Installs event handlers on the given trigger element, and removes event handlers from the\n     * previous trigger if needed.\n     */\n    RippleRenderer.prototype.setTriggerElement = function (newTrigger) {\n        var _this = this;\n        if (this._triggerElement !== newTrigger) {\n            if (this._triggerElement) {\n                this._eventHandlers.forEach(function (eventHandler, eventName) {\n                    _this._triggerElement.removeEventListener(eventName, eventHandler);\n                });\n            }\n            this._triggerElement = newTrigger;\n            if (this._triggerElement) {\n                this._eventHandlers.forEach(function (eventHandler, eventName) {\n                    _this._triggerElement.addEventListener(eventName, eventHandler);\n                });\n            }\n        }\n    };\n    /**\n     * Installs event handlers on the host element of the md-ripple directive.\n     */\n    RippleRenderer.prototype.setTriggerElementToHost = function () {\n        this.setTriggerElement(this._rippleElement);\n    };\n    /**\n     * Removes event handlers from the current trigger element if needed.\n     */\n    RippleRenderer.prototype.clearTriggerElement = function () {\n        this.setTriggerElement(null);\n    };\n    /**\n     * Creates a foreground ripple and sets its animation to expand and fade in from the position\n     * given by rippleOriginLeft and rippleOriginTop (or from the center of the <md-ripple>\n     * bounding rect if centered is true).\n     */\n    RippleRenderer.prototype.createForegroundRipple = function (rippleOriginLeft, rippleOriginTop, color, centered, radius, speedFactor, transitionEndCallback) {\n        var parentRect = this._rippleElement.getBoundingClientRect();\n        // Create a foreground ripple div with the size and position of the fully expanded ripple.\n        // When the div is created, it's given a transform style that causes the ripple to be displayed\n        // small and centered on the event location (or the center of the bounding rect if the centered\n        // argument is true). Removing that transform causes the ripple to animate to its natural size.\n        var startX = centered ? (parentRect.left + parentRect.width / 2) : rippleOriginLeft;\n        var startY = centered ? (parentRect.top + parentRect.height / 2) : rippleOriginTop;\n        var offsetX = startX - parentRect.left;\n        var offsetY = startY - parentRect.top;\n        var maxRadius = radius > 0 ? radius : distanceToFurthestCorner(startX, startY, parentRect);\n        var rippleDiv = document.createElement('div');\n        this._rippleElement.appendChild(rippleDiv);\n        rippleDiv.classList.add('md-ripple-foreground');\n        rippleDiv.style.left = (offsetX - maxRadius) + \"px\";\n        rippleDiv.style.top = (offsetY - maxRadius) + \"px\";\n        rippleDiv.style.width = 2 * maxRadius + \"px\";\n        rippleDiv.style.height = rippleDiv.style.width;\n        // If color input is not set, this will default to the background color defined in CSS.\n        rippleDiv.style.backgroundColor = color;\n        // Start the ripple tiny.\n        rippleDiv.style.transform = \"scale(0.001)\";\n        var fadeInSeconds = (1 / (speedFactor || 1)) * Math.max(MIN_RIPPLE_FILL_TIME_SECONDS, Math.min(MAX_RIPPLE_FILL_TIME_SECONDS, maxRadius / RIPPLE_SPEED_PX_PER_SECOND));\n        rippleDiv.style.transitionDuration = fadeInSeconds + \"s\";\n        // https://timtaubert.de/blog/2012/09/css-transitions-for-dynamically-created-dom-elements/\n        window.getComputedStyle(rippleDiv).opacity;\n        rippleDiv.classList.add('md-ripple-fade-in');\n        // Clearing the transform property causes the ripple to animate to its full size.\n        rippleDiv.style.transform = '';\n        var ripple = new ForegroundRipple(rippleDiv);\n        ripple.state = ForegroundRippleState.EXPANDING;\n        rippleDiv.addEventListener('transitionend', function (event) { return transitionEndCallback(ripple, event); });\n    };\n    /**\n     * Fades out a foreground ripple after it has fully expanded and faded in.\n     */\n    RippleRenderer.prototype.fadeOutForegroundRipple = function (ripple) {\n        ripple.classList.remove('md-ripple-fade-in');\n        ripple.classList.add('md-ripple-fade-out');\n    };\n    /**\n     * Removes a foreground ripple from the DOM after it has faded out.\n     */\n    RippleRenderer.prototype.removeRippleFromDom = function (ripple) {\n        ripple.parentElement.removeChild(ripple);\n    };\n    /**\n     * Fades in the ripple background.\n     */\n    RippleRenderer.prototype.fadeInRippleBackground = function (color) {\n        this._backgroundDiv.classList.add('md-ripple-active');\n        // If color is not set, this will default to the background color defined in CSS.\n        this._backgroundDiv.style.backgroundColor = color;\n    };\n    /**\n     * Fades out the ripple background.\n     */\n    RippleRenderer.prototype.fadeOutRippleBackground = function () {\n        if (this._backgroundDiv) {\n            this._backgroundDiv.classList.remove('md-ripple-active');\n        }\n    };\n    return RippleRenderer;\n}());\n\nvar __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$3 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar MdRipple = (function () {\n    function MdRipple(_elementRef) {\n        var _this = this;\n        /**\n         * If set, the radius in pixels of foreground ripples when fully expanded. If unset, the radius\n         * will be the distance from the center of the ripple to the furthest corner of the host element's\n         * bounding rectangle.\n         */\n        this.maxRadius = 0;\n        /**\n         * If set, the normal duration of ripple animations is divided by this value. For example,\n         * setting it to 0.5 will cause the animations to take twice as long.\n         */\n        this.speedFactor = 1;\n        // These event handlers are attached to the element that triggers the ripple animations.\n        var eventHandlers = new Map();\n        eventHandlers.set('mousedown', function (event) { return _this._mouseDown(event); });\n        eventHandlers.set('click', function (event) { return _this._click(event); });\n        eventHandlers.set('mouseleave', function (event) { return _this._mouseLeave(event); });\n        this._rippleRenderer = new RippleRenderer(_elementRef, eventHandlers);\n    }\n    /** TODO: internal */\n    MdRipple.prototype.ngOnInit = function () {\n        // If no trigger element was explicity set, use the host element\n        if (!this.trigger) {\n            this._rippleRenderer.setTriggerElementToHost();\n        }\n    };\n    /** TODO: internal */\n    MdRipple.prototype.ngOnDestroy = function () {\n        // Remove event listeners on the trigger element.\n        this._rippleRenderer.clearTriggerElement();\n    };\n    /** TODO: internal */\n    MdRipple.prototype.ngOnChanges = function (changes) {\n        // If the trigger element changed (or is being initially set), add event listeners to it.\n        var changedInputs = Object.keys(changes);\n        if (changedInputs.indexOf('trigger') !== -1) {\n            this._rippleRenderer.setTriggerElement(this.trigger);\n        }\n    };\n    /**\n     * Responds to the start of a ripple animation trigger by fading the background in.\n     */\n    MdRipple.prototype.start = function () {\n        this._rippleRenderer.fadeInRippleBackground(this.backgroundColor);\n    };\n    /**\n     * Responds to the end of a ripple animation trigger by fading the background out, and creating a\n     * foreground ripple that expands from the event location (or from the center of the element if\n     * the \"centered\" property is set or forceCenter is true).\n     */\n    MdRipple.prototype.end = function (left, top, forceCenter) {\n        var _this = this;\n        if (forceCenter === void 0) { forceCenter = true; }\n        this._rippleRenderer.createForegroundRipple(left, top, this.color, this.centered || forceCenter, this.maxRadius, this.speedFactor, function (ripple, e) { return _this._rippleTransitionEnded(ripple, e); });\n        this._rippleRenderer.fadeOutRippleBackground();\n    };\n    MdRipple.prototype._rippleTransitionEnded = function (ripple, event) {\n        if (event.propertyName === 'opacity') {\n            // If the ripple finished expanding, start fading it out. If it finished fading out,\n            // remove it from the DOM.\n            switch (ripple.state) {\n                case ForegroundRippleState.EXPANDING:\n                    this._rippleRenderer.fadeOutForegroundRipple(ripple.rippleElement);\n                    ripple.state = ForegroundRippleState.FADING_OUT;\n                    break;\n                case ForegroundRippleState.FADING_OUT:\n                    this._rippleRenderer.removeRippleFromDom(ripple.rippleElement);\n                    break;\n            }\n        }\n    };\n    /**\n     * Called when the trigger element receives a mousedown event. Starts the ripple animation by\n     * fading in the background.\n     */\n    MdRipple.prototype._mouseDown = function (event) {\n        if (!this.disabled && event.button === 0) {\n            this.start();\n        }\n    };\n    /**\n     * Called when the trigger element receives a click event. Creates a foreground ripple and\n     * runs its animation.\n     */\n    MdRipple.prototype._click = function (event) {\n        if (!this.disabled && event.button === 0) {\n            // If screen and page positions are all 0, this was probably triggered by a keypress.\n            // In that case, use the center of the bounding rect as the ripple origin.\n            // FIXME: This fails on IE11, which still sets pageX/Y and screenX/Y on keyboard clicks.\n            var isKeyEvent = (event.screenX === 0 && event.screenY === 0 && event.pageX === 0 && event.pageY === 0);\n            this.end(event.pageX, event.pageY, isKeyEvent);\n        }\n    };\n    /**\n     * Called when the trigger element receives a mouseleave event. Fades out the background.\n     */\n    MdRipple.prototype._mouseLeave = function (event) {\n        // We can always fade out the background here; It's a no-op if it was already inactive.\n        this._rippleRenderer.fadeOutRippleBackground();\n    };\n    __decorate$3([\n        _angular_core.Input('md-ripple-trigger'), \n        __metadata$3('design:type', Object)\n    ], MdRipple.prototype, \"trigger\", void 0);\n    __decorate$3([\n        _angular_core.Input('md-ripple-centered'), \n        __metadata$3('design:type', Boolean)\n    ], MdRipple.prototype, \"centered\", void 0);\n    __decorate$3([\n        _angular_core.Input('md-ripple-disabled'), \n        __metadata$3('design:type', Boolean)\n    ], MdRipple.prototype, \"disabled\", void 0);\n    __decorate$3([\n        _angular_core.Input('md-ripple-max-radius'), \n        __metadata$3('design:type', Number)\n    ], MdRipple.prototype, \"maxRadius\", void 0);\n    __decorate$3([\n        _angular_core.Input('md-ripple-speed-factor'), \n        __metadata$3('design:type', Number)\n    ], MdRipple.prototype, \"speedFactor\", void 0);\n    __decorate$3([\n        _angular_core.Input('md-ripple-color'), \n        __metadata$3('design:type', String)\n    ], MdRipple.prototype, \"color\", void 0);\n    __decorate$3([\n        _angular_core.Input('md-ripple-background-color'), \n        __metadata$3('design:type', String)\n    ], MdRipple.prototype, \"backgroundColor\", void 0);\n    __decorate$3([\n        _angular_core.HostBinding('class.md-ripple-focused'),\n        _angular_core.Input('md-ripple-focused'), \n        __metadata$3('design:type', Boolean)\n    ], MdRipple.prototype, \"focused\", void 0);\n    __decorate$3([\n        _angular_core.HostBinding('class.md-ripple-unbounded'),\n        _angular_core.Input('md-ripple-unbounded'), \n        __metadata$3('design:type', Boolean)\n    ], MdRipple.prototype, \"unbounded\", void 0);\n    MdRipple = __decorate$3([\n        _angular_core.Directive({\n            selector: '[md-ripple]',\n        }), \n        __metadata$3('design:paramtypes', [_angular_core.ElementRef])\n    ], MdRipple);\n    return MdRipple;\n}());\nvar MdRippleModule = (function () {\n    function MdRippleModule() {\n    }\n    MdRippleModule.forRoot = function () {\n        return {\n            ngModule: MdRippleModule,\n            providers: []\n        };\n    };\n    MdRippleModule = __decorate$3([\n        _angular_core.NgModule({\n            exports: [MdRipple],\n            declarations: [MdRipple],\n        }), \n        __metadata$3('design:paramtypes', [])\n    ], MdRippleModule);\n    return MdRippleModule;\n}());\n\n// TODO(kara): Revisit why error messages are not being properly set.\nvar __extends$3 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * Wrapper around Error that sets the error message.\n */\nvar MdError = (function (_super) {\n    __extends$3(MdError, _super);\n    function MdError(value) {\n        _super.call(this);\n        this.message = value;\n    }\n    return MdError;\n}(Error));\n\nvar __extends$2 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/** Exception thrown when a ComponentPortal is attached to a DomPortalHost without an origin. */\nvar MdComponentPortalAttachedToDomWithoutOriginError = (function (_super) {\n    __extends$2(MdComponentPortalAttachedToDomWithoutOriginError, _super);\n    function MdComponentPortalAttachedToDomWithoutOriginError() {\n        _super.call(this, 'A ComponentPortal must have an origin set when attached to a DomPortalHost ' +\n            'because the DOM element is not part of the Angular application context.');\n    }\n    return MdComponentPortalAttachedToDomWithoutOriginError;\n}(MdError));\n/** Exception thrown when attempting to attach a null portal to a host. */\nvar MdNullPortalError = (function (_super) {\n    __extends$2(MdNullPortalError, _super);\n    function MdNullPortalError() {\n        _super.call(this, 'Must provide a portal to attach');\n    }\n    return MdNullPortalError;\n}(MdError));\n/** Exception thrown when attempting to attach a portal to a host that is already attached. */\nvar MdPortalAlreadyAttachedError = (function (_super) {\n    __extends$2(MdPortalAlreadyAttachedError, _super);\n    function MdPortalAlreadyAttachedError() {\n        _super.call(this, 'Host already has a portal attached');\n    }\n    return MdPortalAlreadyAttachedError;\n}(MdError));\n/** Exception thrown when attempting to attach a portal to an already-disposed host. */\nvar MdPortalHostAlreadyDisposedError = (function (_super) {\n    __extends$2(MdPortalHostAlreadyDisposedError, _super);\n    function MdPortalHostAlreadyDisposedError() {\n        _super.call(this, 'This PortalHost has already been disposed');\n    }\n    return MdPortalHostAlreadyDisposedError;\n}(MdError));\n/** Exception thrown when attempting to attach an unknown portal type. */\nvar MdUnknownPortalTypeError = (function (_super) {\n    __extends$2(MdUnknownPortalTypeError, _super);\n    function MdUnknownPortalTypeError() {\n        _super.call(this, 'Attempting to attach an unknown Portal type. ' +\n            'BasePortalHost accepts either a ComponentPortal or a TemplatePortal.');\n    }\n    return MdUnknownPortalTypeError;\n}(MdError));\n/** Exception thrown when attempting to attach a portal to a null host. */\nvar MdNullPortalHostError = (function (_super) {\n    __extends$2(MdNullPortalHostError, _super);\n    function MdNullPortalHostError() {\n        _super.call(this, 'Attempting to attach a portal to a null PortalHost');\n    }\n    return MdNullPortalHostError;\n}(MdError));\n/** Exception thrown when attempting to detach a portal that is not attached. */\nvar MdNoPortalAttachedError = (function (_super) {\n    __extends$2(MdNoPortalAttachedError, _super);\n    function MdNoPortalAttachedError() {\n        _super.call(this, 'Attempting to detach a portal that is not attached to a host');\n    }\n    return MdNoPortalAttachedError;\n}(MdError));\n\nvar __extends$1 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalHost`.\n */\nvar Portal = (function () {\n    function Portal() {\n    }\n    /** Attach this portal to a host. */\n    Portal.prototype.attach = function (host) {\n        if (host == null) {\n            throw new MdNullPortalHostError();\n        }\n        if (host.hasAttached()) {\n            throw new MdPortalAlreadyAttachedError();\n        }\n        this._attachedHost = host;\n        return host.attach(this);\n    };\n    /** Detach this portal from its host */\n    Portal.prototype.detach = function () {\n        var host = this._attachedHost;\n        if (host == null) {\n            throw new MdNoPortalAttachedError();\n        }\n        this._attachedHost = null;\n        return host.detach();\n    };\n    Object.defineProperty(Portal.prototype, \"isAttached\", {\n        /** Whether this portal is attached to a host. */\n        get: function () {\n            return this._attachedHost != null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the PortalHost reference without performing `attach()`. This is used directly by\n     * the PortalHost when it is performing an `attach()` or `detatch()`.\n     */\n    Portal.prototype.setAttachedHost = function (host) {\n        this._attachedHost = host;\n    };\n    return Portal;\n}());\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nvar ComponentPortal = (function (_super) {\n    __extends$1(ComponentPortal, _super);\n    function ComponentPortal(component, viewContainerRef, injector) {\n        if (viewContainerRef === void 0) { viewContainerRef = null; }\n        if (injector === void 0) { injector = null; }\n        _super.call(this);\n        this.component = component;\n        this.viewContainerRef = viewContainerRef;\n        this.injector = injector;\n    }\n    return ComponentPortal;\n}(Portal));\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nvar TemplatePortal = (function (_super) {\n    __extends$1(TemplatePortal, _super);\n    function TemplatePortal(template, viewContainerRef) {\n        _super.call(this);\n        /**\n         * Additional locals for the instantiated embedded view.\n         * These locals can be seen as \"exports\" for the template, such as how ngFor has\n         * index / event / odd.\n         * See https://angular.io/docs/ts/latest/api/core/EmbeddedViewRef-class.html\n         */\n        this.locals = new Map();\n        this.templateRef = template;\n        this.viewContainerRef = viewContainerRef;\n    }\n    Object.defineProperty(TemplatePortal.prototype, \"origin\", {\n        get: function () {\n            return this.templateRef.elementRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    TemplatePortal.prototype.attach = function (host, locals) {\n        this.locals = locals == null ? new Map() : locals;\n        return _super.prototype.attach.call(this, host);\n    };\n    TemplatePortal.prototype.detach = function () {\n        this.locals = new Map();\n        return _super.prototype.detach.call(this);\n    };\n    return TemplatePortal;\n}(Portal));\n/**\n * Partial implementation of PortalHost that only deals with attaching either a\n * ComponentPortal or a TemplatePortal.\n */\nvar BasePortalHost = (function () {\n    function BasePortalHost() {\n        /** Whether this host has already been permanently disposed. */\n        this._isDisposed = false;\n    }\n    /** Whether this host has an attached portal. */\n    BasePortalHost.prototype.hasAttached = function () {\n        return this._attachedPortal != null;\n    };\n    BasePortalHost.prototype.attach = function (portal) {\n        if (portal == null) {\n            throw new MdNullPortalError();\n        }\n        if (this.hasAttached()) {\n            throw new MdPortalAlreadyAttachedError();\n        }\n        if (this._isDisposed) {\n            throw new MdPortalHostAlreadyDisposedError();\n        }\n        if (portal instanceof ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n        }\n        throw new MdUnknownPortalTypeError();\n    };\n    BasePortalHost.prototype.detach = function () {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n        }\n        this._attachedPortal = null;\n        if (this._disposeFn != null) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    };\n    BasePortalHost.prototype.dispose = function () {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._isDisposed = true;\n    };\n    BasePortalHost.prototype.setDisposeFn = function (fn) {\n        this._disposeFn = fn;\n    };\n    return BasePortalHost;\n}());\n\nvar __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __decorate$4 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$4 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/**\n * Directive version of a `TemplatePortal`. Because the directive *is* a TemplatePortal,\n * the directive instance itself can be attached to a host, enabling declarative use of portals.\n *\n * Usage:\n * <template portal #greeting>\n *   <p> Hello {{name}} </p>\n * </template>\n */\nvar TemplatePortalDirective = (function (_super) {\n    __extends(TemplatePortalDirective, _super);\n    function TemplatePortalDirective(templateRef, viewContainerRef) {\n        _super.call(this, templateRef, viewContainerRef);\n    }\n    TemplatePortalDirective = __decorate$4([\n        _angular_core.Directive({\n            selector: '[portal]',\n            exportAs: 'portal',\n        }), \n        __metadata$4('design:paramtypes', [_angular_core.TemplateRef, _angular_core.ViewContainerRef])\n    ], TemplatePortalDirective);\n    return TemplatePortalDirective;\n}(TemplatePortal));\n/**\n * Directive version of a PortalHost. Because the directive *is* a PortalHost, portals can be\n * directly attached to it, enabling declarative use.\n *\n * Usage:\n * <template [portalHost]=\"greeting\"></template>\n */\nvar PortalHostDirective = (function (_super) {\n    __extends(PortalHostDirective, _super);\n    function PortalHostDirective(_componentFactoryResolver, _viewContainerRef) {\n        _super.call(this);\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._viewContainerRef = _viewContainerRef;\n    }\n    Object.defineProperty(PortalHostDirective.prototype, \"portal\", {\n        get: function () {\n            return this._portal;\n        },\n        set: function (p) {\n            this._replaceAttachedPortal(p);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Attach the given ComponentPortal to this PortlHost using the ComponentFactoryResolver. */\n    PortalHostDirective.prototype.attachComponentPortal = function (portal) {\n        portal.setAttachedHost(this);\n        // If the portal specifies an origin, use that as the logical location of the component\n        // in the application tree. Otherwise use the location of this PortalHost.\n        var viewContainerRef = portal.viewContainerRef != null ?\n            portal.viewContainerRef :\n            this._viewContainerRef;\n        var componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.parentInjector);\n        this.setDisposeFn(function () { return ref.destroy(); });\n        return ref;\n    };\n    /** Attach the given TemplatePortal to this PortlHost as an embedded View. */\n    PortalHostDirective.prototype.attachTemplatePortal = function (portal) {\n        var _this = this;\n        portal.setAttachedHost(this);\n        this._viewContainerRef.createEmbeddedView(portal.templateRef);\n        this.setDisposeFn(function () { return _this._viewContainerRef.clear(); });\n        // TODO(jelbourn): return locals from view\n        return new Map();\n    };\n    /** Detatches the currently attached Portal (if there is one) and attaches the given Portal. */\n    PortalHostDirective.prototype._replaceAttachedPortal = function (p) {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        if (p) {\n            this.attach(p);\n            this._portal = p;\n        }\n    };\n    PortalHostDirective = __decorate$4([\n        _angular_core.Directive({\n            selector: '[portalHost]',\n            inputs: ['portal: portalHost']\n        }), \n        __metadata$4('design:paramtypes', [_angular_core.ComponentFactoryResolver, _angular_core.ViewContainerRef])\n    ], PortalHostDirective);\n    return PortalHostDirective;\n}(BasePortalHost));\nvar PortalModule = (function () {\n    function PortalModule() {\n    }\n    PortalModule.forRoot = function () {\n        return {\n            ngModule: PortalModule,\n            providers: []\n        };\n    };\n    PortalModule = __decorate$4([\n        _angular_core.NgModule({\n            exports: [TemplatePortalDirective, PortalHostDirective],\n            declarations: [TemplatePortalDirective, PortalHostDirective],\n        }), \n        __metadata$4('design:paramtypes', [])\n    ], PortalModule);\n    return PortalModule;\n}());\n\n/**\n * OverlayState is a bag of values for either the initial configuration or current state of an\n * overlay.\n */\nvar OverlayState = (function () {\n    function OverlayState() {\n        /** Whether the overlay has a backdrop. */\n        this.hasBackdrop = false;\n    }\n    return OverlayState;\n}());\n\nvar __extends$4 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * A PortalHost for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n *\n * This is the only part of the portal core that directly touches the DOM.\n */\nvar DomPortalHost = (function (_super) {\n    __extends$4(DomPortalHost, _super);\n    function DomPortalHost(_hostDomElement, _componentFactoryResolver) {\n        _super.call(this);\n        this._hostDomElement = _hostDomElement;\n        this._componentFactoryResolver = _componentFactoryResolver;\n    }\n    /** Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver. */\n    DomPortalHost.prototype.attachComponentPortal = function (portal) {\n        if (portal.viewContainerRef == null) {\n            throw new MdComponentPortalAttachedToDomWithoutOriginError();\n        }\n        var componentFactory = this._componentFactoryResolver.resolveComponentFactory(portal.component);\n        var ref = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.parentInjector);\n        var hostView = ref.hostView;\n        this._hostDomElement.appendChild(hostView.rootNodes[0]);\n        this.setDisposeFn(function () { return ref.destroy(); });\n        return ref;\n    };\n    DomPortalHost.prototype.attachTemplatePortal = function (portal) {\n        var _this = this;\n        var viewContainer = portal.viewContainerRef;\n        var viewRef = viewContainer.createEmbeddedView(portal.templateRef);\n        viewRef.rootNodes.forEach(function (rootNode) { return _this._hostDomElement.appendChild(rootNode); });\n        this.setDisposeFn((function () {\n            var index = viewContainer.indexOf(viewRef);\n            if (index != -1) {\n                viewContainer.remove(index);\n            }\n        }));\n        // TODO(jelbourn): Return locals from view.\n        return new Map();\n    };\n    DomPortalHost.prototype.dispose = function () {\n        _super.prototype.dispose.call(this);\n        if (this._hostDomElement.parentNode != null) {\n            this._hostDomElement.parentNode.removeChild(this._hostDomElement);\n        }\n    };\n    return DomPortalHost;\n}(BasePortalHost));\n\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nvar OverlayRef = (function () {\n    function OverlayRef(_portalHost, _pane, _state) {\n        this._portalHost = _portalHost;\n        this._pane = _pane;\n        this._state = _state;\n        this._backdropElement = null;\n        this._backdropClick = new rxjs_Subject.Subject();\n    }\n    OverlayRef.prototype.attach = function (portal) {\n        if (this._state.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        var attachResult = this._portalHost.attach(portal);\n        this.updatePosition();\n        return attachResult;\n    };\n    OverlayRef.prototype.detach = function () {\n        this._detatchBackdrop();\n        return this._portalHost.detach();\n    };\n    OverlayRef.prototype.dispose = function () {\n        this._detatchBackdrop();\n        this._portalHost.dispose();\n    };\n    OverlayRef.prototype.hasAttached = function () {\n        return this._portalHost.hasAttached();\n    };\n    OverlayRef.prototype.backdropClick = function () {\n        return this._backdropClick.asObservable();\n    };\n    /** Gets the current state config of the overlay. */\n    OverlayRef.prototype.getState = function () {\n        return this._state;\n    };\n    /** Updates the position of the overlay based on the position strategy. */\n    OverlayRef.prototype.updatePosition = function () {\n        if (this._state.positionStrategy) {\n            this._state.positionStrategy.apply(this._pane);\n        }\n    };\n    /** Attaches a backdrop for this overlay. */\n    OverlayRef.prototype._attachBackdrop = function () {\n        var _this = this;\n        this._backdropElement = document.createElement('div');\n        this._backdropElement.classList.add('md-overlay-backdrop');\n        this._pane.parentElement.appendChild(this._backdropElement);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', function () {\n            _this._backdropClick.next(null);\n        });\n        // Add class to fade-in the backdrop after one frame.\n        requestAnimationFrame(function () {\n            _this._backdropElement.classList.add('md-overlay-backdrop-showing');\n        });\n    };\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    OverlayRef.prototype._detatchBackdrop = function () {\n        var _this = this;\n        var backdropToDetach = this._backdropElement;\n        if (backdropToDetach) {\n            backdropToDetach.classList.remove('md-overlay-backdrop-showing');\n            backdropToDetach.addEventListener('transitionend', function () {\n                backdropToDetach.parentNode.removeChild(backdropToDetach);\n                // It is possible that a new portal has been attached to this overlay since we started\n                // removing the backdrop. If that is the case, only clear the backdrop reference if it\n                // is still the same instance that we started to remove.\n                if (_this._backdropElement == backdropToDetach) {\n                    _this._backdropElement = null;\n                }\n            });\n        }\n    };\n    return OverlayRef;\n}());\n\nvar __decorate$8 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$8 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/**\n * Simple utility for getting the bounds of the browser viewport.\n * TODO: internal\n */\nvar ViewportRuler = (function () {\n    function ViewportRuler() {\n    }\n    // TODO(jelbourn): cache the document's bounding rect and only update it when the window\n    // is resized (debounced).\n    /** Gets a ClientRect for the viewport's bounds. */\n    ViewportRuler.prototype.getViewportRect = function () {\n        // Use the document element's bounding rect rather than the window scroll properties\n        // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n        // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n        // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n        // can disagree when the page is pinch-zoomed (on devices that support touch).\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n        // We use the documentElement instead of the body because, by default (without a css reset)\n        // browsers typically give the document body an 8px margin, which is not included in\n        // getBoundingClientRect().\n        var documentRect = document.documentElement.getBoundingClientRect();\n        var scrollPosition = this.getViewportScrollPosition(documentRect);\n        var height = window.innerHeight;\n        var width = window.innerWidth;\n        return {\n            top: scrollPosition.top,\n            left: scrollPosition.left,\n            bottom: scrollPosition.top + height,\n            right: scrollPosition.left + width,\n            height: height,\n            width: width,\n        };\n    };\n    /**\n     * Gets the (top, left) scroll position of the viewport.\n     * @param documentRect\n     */\n    ViewportRuler.prototype.getViewportScrollPosition = function (documentRect) {\n        if (documentRect === void 0) { documentRect = document.documentElement.getBoundingClientRect(); }\n        // The top-left-corner of the viewport is determined by the scroll position of the document\n        // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n        // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n        // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n        // `document.documentElement` works consistently, where the `top` and `left` values will\n        // equal negative the scroll position.\n        var top = documentRect.top < 0 && document.body.scrollTop == 0 ?\n            -documentRect.top :\n            document.body.scrollTop;\n        var left = documentRect.left < 0 && document.body.scrollLeft == 0 ?\n            -documentRect.left :\n            document.body.scrollLeft;\n        return { top: top, left: left };\n    };\n    ViewportRuler = __decorate$8([\n        _angular_core.Injectable(), \n        __metadata$8('design:paramtypes', [])\n    ], ViewportRuler);\n    return ViewportRuler;\n}());\n\n/**\n * Applies a CSS transform to an element, including browser-prefixed properties.\n * @param element\n * @param transformValue\n */\nfunction applyCssTransform(element, transformValue) {\n    // It's important to trim the result, because the browser will ignore the set operation\n    // if the string contains only whitespace.\n    var value = transformValue.trim();\n    element.style.transform = value;\n    element.style.webkitTransform = value;\n}\n\n/** The points of the origin element and the overlay element to connect. */\nvar ConnectionPositionPair = (function () {\n    function ConnectionPositionPair(origin, overlay) {\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n    return ConnectionPositionPair;\n}());\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implict position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nvar ConnectedPositionStrategy = (function () {\n    function ConnectedPositionStrategy(_connectedTo, _originPos, _overlayPos, _viewportRuler) {\n        this._connectedTo = _connectedTo;\n        this._originPos = _originPos;\n        this._overlayPos = _overlayPos;\n        this._viewportRuler = _viewportRuler;\n        // TODO(jelbourn): set RTL to the actual value from the app.\n        /** Whether the we're dealing with an RTL context */\n        this._isRtl = false;\n        /** Ordered list of preferred positions, from most to least desirable. */\n        this._preferredPositions = [];\n        this._origin = this._connectedTo.nativeElement;\n        this.withFallbackPosition(_originPos, _overlayPos);\n    }\n    Object.defineProperty(ConnectedPositionStrategy.prototype, \"positions\", {\n        get: function () {\n            return this._preferredPositions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * TODO: internal\n     */\n    ConnectedPositionStrategy.prototype.apply = function (element) {\n        // We need the bounding rects for the origin and the overlay to determine how to position\n        // the overlay relative to the origin.\n        var originRect = this._origin.getBoundingClientRect();\n        var overlayRect = element.getBoundingClientRect();\n        // We use the viewport rect to determine whether a position would go off-screen.\n        var viewportRect = this._viewportRuler.getViewportRect();\n        var firstOverlayPoint = null;\n        // We want to place the overlay in the first of the preferred positions such that the\n        // overlay fits on-screen.\n        for (var _i = 0, _a = this._preferredPositions; _i < _a.length; _i++) {\n            var pos = _a[_i];\n            // Get the (x, y) point of connection on the origin, and then use that to get the\n            // (top, left) coordinate for the overlay at `pos`.\n            var originPoint = this._getOriginConnectionPoint(originRect, pos);\n            var overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);\n            firstOverlayPoint = firstOverlayPoint || overlayPoint;\n            // If the overlay in the calculated position fits on-screen, put it there and we're done.\n            if (this._willOverlayFitWithinViewport(overlayPoint, overlayRect, viewportRect)) {\n                this._setElementPosition(element, overlayPoint);\n                return Promise.resolve(null);\n            }\n        }\n        // TODO(jelbourn): fallback behavior for when none of the preferred positions fit on-screen.\n        // For now, just stick it in the first position and let it go off-screen.\n        this._setElementPosition(element, firstOverlayPoint);\n        return Promise.resolve(null);\n    };\n    ConnectedPositionStrategy.prototype.withFallbackPosition = function (originPos, overlayPos) {\n        this._preferredPositions.push(new ConnectionPositionPair(originPos, overlayPos));\n        return this;\n    };\n    /**\n     * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\n     * @param rect\n     */\n    ConnectedPositionStrategy.prototype._getStartX = function (rect) {\n        return this._isRtl ? rect.right : rect.left;\n    };\n    /**\n     * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\n     * @param rect\n     */\n    ConnectedPositionStrategy.prototype._getEndX = function (rect) {\n        return this._isRtl ? rect.left : rect.right;\n    };\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     * @param originRect\n     * @param pos\n     */\n    ConnectedPositionStrategy.prototype._getOriginConnectionPoint = function (originRect, pos) {\n        var originStartX = this._getStartX(originRect);\n        var originEndX = this._getEndX(originRect);\n        var x;\n        if (pos.originX == 'center') {\n            x = originStartX + (originRect.width / 2);\n        }\n        else {\n            x = pos.originX == 'start' ? originStartX : originEndX;\n        }\n        var y;\n        if (pos.originY == 'center') {\n            y = originRect.top + (originRect.height / 2);\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        return { x: x, y: y };\n    };\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected.\n     * @param originPoint\n     * @param overlayRect\n     * @param pos\n     */\n    ConnectedPositionStrategy.prototype._getOverlayPoint = function (originPoint, overlayRect, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\n        // relative to the origin point.\n        var overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else {\n            overlayStartX = pos.overlayX == 'start' ? 0 : -overlayRect.width;\n        }\n        var overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        return {\n            x: originPoint.x + overlayStartX,\n            y: originPoint.y + overlayStartY\n        };\n    };\n    /**\n     * Gets whether the overlay positioned at the given point will fit on-screen.\n     * @param overlayPoint The top-left coordinate of the overlay.\n     * @param overlayRect Bounding rect of the overlay, used to get its size.\n     * @param viewportRect The bounding viewport.\n     */\n    ConnectedPositionStrategy.prototype._willOverlayFitWithinViewport = function (overlayPoint, overlayRect, viewportRect) {\n        // TODO(jelbourn): probably also want some space between overlay edge and viewport edge.\n        return overlayPoint.x >= viewportRect.left &&\n            overlayPoint.x + overlayRect.width <= viewportRect.right &&\n            overlayPoint.y >= viewportRect.top &&\n            overlayPoint.y + overlayRect.height <= viewportRect.bottom;\n    };\n    /**\n     * Physically positions the overlay element to the given coordinate.\n     * @param element\n     * @param overlayPoint\n     */\n    ConnectedPositionStrategy.prototype._setElementPosition = function (element, overlayPoint) {\n        var scrollPos = this._viewportRuler.getViewportScrollPosition();\n        var x = overlayPoint.x + scrollPos.left;\n        var y = overlayPoint.y + scrollPos.top;\n        // TODO(jelbourn): we don't want to always overwrite the transform property here,\n        // because it will need to be used for animations.\n        applyCssTransform(element, \"translateX(\" + x + \"px) translateY(\" + y + \"px)\");\n    };\n    return ConnectedPositionStrategy;\n}());\n\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport.\n */\nvar GlobalPositionStrategy = (function () {\n    function GlobalPositionStrategy() {\n        this._cssPosition = 'absolute';\n        this._top = '';\n        this._bottom = '';\n        this._left = '';\n        this._right = '';\n        /** Array of individual applications of translateX(). Currently only for centering. */\n        this._translateX = [];\n        /** Array of individual applications of translateY(). Currently only for centering. */\n        this._translateY = [];\n    }\n    /** Sets the element to use CSS position: fixed */\n    GlobalPositionStrategy.prototype.fixed = function () {\n        this._cssPosition = 'fixed';\n        return this;\n    };\n    /** Sets the element to use CSS position: absolute. This is the default. */\n    GlobalPositionStrategy.prototype.absolute = function () {\n        this._cssPosition = 'absolute';\n        return this;\n    };\n    /** Sets the top position of the overlay. Clears any previously set vertical position. */\n    GlobalPositionStrategy.prototype.top = function (value) {\n        this._bottom = '';\n        this._translateY = [];\n        this._top = value;\n        return this;\n    };\n    /** Sets the left position of the overlay. Clears any previously set horizontal position. */\n    GlobalPositionStrategy.prototype.left = function (value) {\n        this._right = '';\n        this._translateX = [];\n        this._left = value;\n        return this;\n    };\n    /** Sets the bottom position of the overlay. Clears any previously set vertical position. */\n    GlobalPositionStrategy.prototype.bottom = function (value) {\n        this._top = '';\n        this._translateY = [];\n        this._bottom = value;\n        return this;\n    };\n    /** Sets the right position of the overlay. Clears any previously set horizontal position. */\n    GlobalPositionStrategy.prototype.right = function (value) {\n        this._left = '';\n        this._translateX = [];\n        this._right = value;\n        return this;\n    };\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     */\n    GlobalPositionStrategy.prototype.centerHorizontally = function (offset) {\n        if (offset === void 0) { offset = '0px'; }\n        this._left = '50%';\n        this._right = '';\n        this._translateX = ['-50%', offset];\n        return this;\n    };\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     */\n    GlobalPositionStrategy.prototype.centerVertically = function (offset) {\n        if (offset === void 0) { offset = '0px'; }\n        this._top = '50%';\n        this._bottom = '';\n        this._translateY = ['-50%', offset];\n        return this;\n    };\n    /**\n     * Apply the position to the element.\n     * TODO: internal\n     */\n    GlobalPositionStrategy.prototype.apply = function (element) {\n        element.style.position = this._cssPosition;\n        element.style.top = this._top;\n        element.style.left = this._left;\n        element.style.bottom = this._bottom;\n        element.style.right = this._right;\n        // TODO(jelbourn): we don't want to always overwrite the transform property here,\n        // because it will need to be used for animations.\n        var tranlateX = this._reduceTranslateValues('translateX', this._translateX);\n        var translateY = this._reduceTranslateValues('translateY', this._translateY);\n        applyCssTransform(element, tranlateX + \" \" + translateY);\n        return Promise.resolve(null);\n    };\n    /** Reduce a list of translate values to a string that can be used in the transform property */\n    GlobalPositionStrategy.prototype._reduceTranslateValues = function (translateFn, values) {\n        return values.map(function (t) { return (translateFn + \"(\" + t + \")\"); }).join(' ');\n    };\n    return GlobalPositionStrategy;\n}());\n\nvar __decorate$7 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$7 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/** Builder for overlay position strategy. */\nvar OverlayPositionBuilder = (function () {\n    function OverlayPositionBuilder(_viewportRuler) {\n        this._viewportRuler = _viewportRuler;\n    }\n    /** Creates a global position strategy. */\n    OverlayPositionBuilder.prototype.global = function () {\n        return new GlobalPositionStrategy();\n    };\n    /** Creates a relative position strategy. */\n    OverlayPositionBuilder.prototype.connectedTo = function (elementRef, originPos, overlayPos) {\n        return new ConnectedPositionStrategy(elementRef, originPos, overlayPos, this._viewportRuler);\n    };\n    OverlayPositionBuilder = __decorate$7([\n        _angular_core.Injectable(), \n        __metadata$7('design:paramtypes', [ViewportRuler])\n    ], OverlayPositionBuilder);\n    return OverlayPositionBuilder;\n}());\n\n/**\n * The OverlayContainer is the container in which all overlays will load.\n * It should be provided in the root component to ensure it is properly shared.\n */\nvar OverlayContainer = (function () {\n    function OverlayContainer() {\n    }\n    /**\n     * This method returns the overlay container element.  It will lazily\n     * create the element the first time  it is called to facilitate using\n     * the container in non-browser environments.\n     * @returns {HTMLElement} the container element\n     */\n    OverlayContainer.prototype.getContainerElement = function () {\n        if (!this._containerElement) {\n            this._createContainer();\n        }\n        return this._containerElement;\n    };\n    /**\n     * Create the overlay container element, which is simply a div\n     * with the 'md-overlay-container' class on the document body.\n     */\n    OverlayContainer.prototype._createContainer = function () {\n        var container = document.createElement('div');\n        container.classList.add('md-overlay-container');\n        document.body.appendChild(container);\n        this._containerElement = container;\n    };\n    return OverlayContainer;\n}());\n\nvar __decorate$6 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$6 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/** Next overlay unique ID. */\nvar nextUniqueId = 0;\n/** The default state for newly created overlays. */\nvar defaultState = new OverlayState();\n/**\n * Service to create Overlays. Overlays are dynamically added pieces of floating UI, meant to be\n * used as a low-level building building block for other components. Dialogs, tooltips, menus,\n * selects, etc. can all be built using overlays. The service should primarily be used by authors\n * of re-usable components rather than developers building end-user applications.\n *\n * An overlay *is* a PortalHost, so any kind of Portal can be loaded into one.\n */\nvar Overlay = (function () {\n    function Overlay(_overlayContainer, _componentFactoryResolver, _positionBuilder) {\n        this._overlayContainer = _overlayContainer;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._positionBuilder = _positionBuilder;\n    }\n    /**\n     * Creates an overlay.\n     * @param state State to apply to the overlay.\n     * @returns A reference to the created overlay.\n     */\n    Overlay.prototype.create = function (state) {\n        if (state === void 0) { state = defaultState; }\n        return this._createOverlayRef(this._createPaneElement(), state);\n    };\n    /**\n     * Returns a position builder that can be used, via fluent API,\n     * to construct and configure a position strategy.\n     */\n    Overlay.prototype.position = function () {\n        return this._positionBuilder;\n    };\n    /**\n     * Creates the DOM element for an overlay and appends it to the overlay container.\n     * @returns Promise resolving to the created element.\n     */\n    Overlay.prototype._createPaneElement = function () {\n        var pane = document.createElement('div');\n        pane.id = \"md-overlay-\" + nextUniqueId++;\n        pane.classList.add('md-overlay-pane');\n        this._overlayContainer.getContainerElement().appendChild(pane);\n        return pane;\n    };\n    /**\n     * Create a DomPortalHost into which the overlay content can be loaded.\n     * @param pane The DOM element to turn into a portal host.\n     * @returns A portal host for the given DOM element.\n     */\n    Overlay.prototype._createPortalHost = function (pane) {\n        return new DomPortalHost(pane, this._componentFactoryResolver);\n    };\n    /**\n     * Creates an OverlayRef for an overlay in the given DOM element.\n     * @param pane DOM element for the overlay\n     * @param state\n     * @returns {OverlayRef}\n     */\n    Overlay.prototype._createOverlayRef = function (pane, state) {\n        return new OverlayRef(this._createPortalHost(pane), pane, state);\n    };\n    Overlay = __decorate$6([\n        _angular_core.Injectable(), \n        __metadata$6('design:paramtypes', [OverlayContainer, _angular_core.ComponentFactoryResolver, OverlayPositionBuilder])\n    ], Overlay);\n    return Overlay;\n}());\n/** Providers for Overlay and its related injectables. */\nvar OVERLAY_PROVIDERS = [\n    ViewportRuler,\n    OverlayPositionBuilder,\n    Overlay,\n    OverlayContainer,\n];\n\nvar __decorate$5 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$5 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/** Default set of positions for the overlay. Follows the behavior of a dropdown. */\nvar defaultPositionList = [\n    new ConnectionPositionPair({ originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' }),\n    new ConnectionPositionPair({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' }),\n];\n/**\n * Directive applied to an element to make it usable as an origin for an Overlay using a\n * ConnectedPositionStrategy.\n */\nvar OverlayOrigin = (function () {\n    function OverlayOrigin(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n    Object.defineProperty(OverlayOrigin.prototype, \"elementRef\", {\n        get: function () {\n            return this._elementRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    OverlayOrigin = __decorate$5([\n        _angular_core.Directive({\n            selector: '[overlay-origin]',\n            exportAs: 'overlayOrigin',\n        }), \n        __metadata$5('design:paramtypes', [_angular_core.ElementRef])\n    ], OverlayOrigin);\n    return OverlayOrigin;\n}());\n/**\n * Directive to facilitate declarative creation of an Overlay using a ConnectedPositionStrategy.\n */\nvar ConnectedOverlayDirective = (function () {\n    // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n    function ConnectedOverlayDirective(_overlay, templateRef, viewContainerRef) {\n        this._overlay = _overlay;\n        this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n    }\n    Object.defineProperty(ConnectedOverlayDirective.prototype, \"overlayRef\", {\n        get: function () {\n            return this._overlayRef;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** TODO: internal */\n    ConnectedOverlayDirective.prototype.ngOnInit = function () {\n        this._createOverlay();\n    };\n    /** TODO: internal */\n    ConnectedOverlayDirective.prototype.ngOnDestroy = function () {\n        this._destroyOverlay();\n    };\n    /** Creates an overlay and attaches this directive's template to it. */\n    ConnectedOverlayDirective.prototype._createOverlay = function () {\n        if (!this.positions || !this.positions.length) {\n            this.positions = defaultPositionList;\n        }\n        var overlayConfig = new OverlayState();\n        overlayConfig.positionStrategy =\n            this._overlay.position().connectedTo(this.origin.elementRef, { originX: this.positions[0].overlayX, originY: this.positions[0].originY }, { overlayX: this.positions[0].overlayX, overlayY: this.positions[0].overlayY });\n        this._overlayRef = this._overlay.create(overlayConfig);\n        this._overlayRef.attach(this._templatePortal);\n    };\n    /** Destroys the overlay created by this directive. */\n    ConnectedOverlayDirective.prototype._destroyOverlay = function () {\n        this._overlayRef.dispose();\n    };\n    __decorate$5([\n        _angular_core.Input(), \n        __metadata$5('design:type', OverlayOrigin)\n    ], ConnectedOverlayDirective.prototype, \"origin\", void 0);\n    __decorate$5([\n        _angular_core.Input(), \n        __metadata$5('design:type', Array)\n    ], ConnectedOverlayDirective.prototype, \"positions\", void 0);\n    ConnectedOverlayDirective = __decorate$5([\n        _angular_core.Directive({\n            selector: '[connected-overlay]'\n        }), \n        __metadata$5('design:paramtypes', [Overlay, _angular_core.TemplateRef, _angular_core.ViewContainerRef])\n    ], ConnectedOverlayDirective);\n    return ConnectedOverlayDirective;\n}());\nvar OverlayModule = (function () {\n    function OverlayModule() {\n    }\n    OverlayModule.forRoot = function () {\n        return {\n            ngModule: OverlayModule,\n            providers: OVERLAY_PROVIDERS,\n        };\n    };\n    OverlayModule = __decorate$5([\n        _angular_core.NgModule({\n            imports: [PortalModule],\n            exports: [ConnectedOverlayDirective, OverlayOrigin],\n            declarations: [ConnectedOverlayDirective, OverlayOrigin],\n        }), \n        __metadata$5('design:paramtypes', [])\n    ], OverlayModule);\n    return OverlayModule;\n}());\n\nvar __decorate$11 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$11 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/**\n * Utility for checking the interactivity of an element, such as whether is is focusable or\n * tabbable.\n *\n * NOTE: Currently does not capture any special element behaviors, browser quirks, or edge cases.\n * This is a basic/naive starting point onto which further behavior will be added.\n *\n * This class uses instance methods instead of static functions so that alternate implementations\n * can be injected.\n *\n * TODO(jelbourn): explore using ally.js directly for its significantly more robust\n * checks (need to evaluate payload size, performance, and compatibility with tree-shaking).\n */\nvar InteractivityChecker = (function () {\n    function InteractivityChecker() {\n    }\n    /** Gets whether an element is disabled. */\n    InteractivityChecker.prototype.isDisabled = function (element) {\n        // This does not capture some cases, such as a non-form control with a disabled attribute or\n        // a form control inside of a disabled form, but should capture the most common cases.\n        return element.hasAttribute('disabled');\n    };\n    /**\n     * Gets whether an element is visible for the purposes of interactivity.\n     *\n     * This will capture states like `display: none` and `visibility: hidden`, but not things like\n     * being clipped by an `overflow: hidden` parent or being outside the viewport.\n     */\n    InteractivityChecker.prototype.isVisible = function (element) {\n        // There are additional special cases that this does not capture, but this will work for\n        // the most common cases.\n        // Use logic from jQuery to check for `display: none`.\n        // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n        if (!(element.offsetWidth || element.offsetHeight || element.getClientRects().length)) {\n            return false;\n        }\n        // Check for css `visibility` property.\n        // TODO(jelbourn): do any browsers we support return an empty string instead of 'visible'?\n        return getComputedStyle(element).getPropertyValue('visibility') == 'visible';\n    };\n    /**\n     * Gets whether an element can be reached via Tab key.\n     * Assumes that the element has already been checked with isFocusable.\n     */\n    InteractivityChecker.prototype.isTabbable = function (element) {\n        // Again, naive approach that does not capture many special cases and browser quirks.\n        return element.tabIndex >= 0;\n    };\n    /** Gets whether an element can be focused by the user. */\n    InteractivityChecker.prototype.isFocusable = function (element) {\n        // Perform checks in order of left to most expensive.\n        // Again, naive approach that does not capture many edge cases and browser quirks.\n        return isPotentiallyFocusable(element) && !this.isDisabled(element) && this.isVisible(element);\n    };\n    InteractivityChecker = __decorate$11([\n        _angular_core.Injectable(), \n        __metadata$11('design:paramtypes', [])\n    ], InteractivityChecker);\n    return InteractivityChecker;\n}());\n/** Gets whether an element's  */\nfunction isNativeFormElement(element) {\n    var nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/** Gets whether an element is an <input type=\"hidden\">. */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/** Gets whether an element is an anchor that has an href attribute. */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/** Gets whether an element is an input element. */\nfunction isInputElement(element) {\n    return element.nodeName == 'input';\n}\n/** Gets whether an element is an anchor element. */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/** Gets whether an element has a valid tabindex. */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    var tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n\nvar __decorate$10 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$10 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/**\n * Directive for trapping focus within a region.\n *\n * NOTE: This directive currently uses a very simple (naive) approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like tabIndex > 0, flex `order`, and shadow roots can cause to two to misalign.\n * This will be replaced with a more intelligent solution before the library is considered stable.\n */\nvar FocusTrap = (function () {\n    function FocusTrap(_checker) {\n        this._checker = _checker;\n    }\n    /** Focuses the first tabbable element within the focus trap region. */\n    FocusTrap.prototype.focusFirstTabbableElement = function () {\n        var redirectToElement = this._getFirstTabbableElement(this.trappedContent.nativeElement);\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n    };\n    /** Focuses the last tabbable element within the focus trap region. */\n    FocusTrap.prototype.focusLastTabbableElement = function () {\n        var redirectToElement = this._getLastTabbableElement(this.trappedContent.nativeElement);\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n    };\n    /** Get the first tabbable element from a DOM subtree (inclusive). */\n    FocusTrap.prototype._getFirstTabbableElement = function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order.\n        var childCount = root.children.length;\n        for (var i = 0; i < childCount; i++) {\n            var tabbableChild = this._getFirstTabbableElement(root.children[i]);\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    /** Get the last tabbable element from a DOM subtree (inclusive). */\n    FocusTrap.prototype._getLastTabbableElement = function (root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        for (var i = root.children.length - 1; i >= 0; i--) {\n            var tabbableChild = this._getLastTabbableElement(root.children[i]);\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    };\n    __decorate$10([\n        _angular_core.ViewChild('trappedContent'), \n        __metadata$10('design:type', _angular_core.ElementRef)\n    ], FocusTrap.prototype, \"trappedContent\", void 0);\n    FocusTrap = __decorate$10([\n        _angular_core.Component({selector: 'focus-trap',\n            // TODO(jelbourn): move this to a separate file.\n            template: \"\\n  <div tabindex=\\\"0\\\" (focus)=\\\"focusLastTabbableElement()\\\"></div>\\n  <div #trappedContent><ng-content></ng-content></div>\\n  <div tabindex=\\\"0\\\" (focus)=\\\"focusFirstTabbableElement()\\\"></div>\",\n            encapsulation: _angular_core.ViewEncapsulation.None,\n        }), \n        __metadata$10('design:paramtypes', [InteractivityChecker])\n    ], FocusTrap);\n    return FocusTrap;\n}());\n\nvar __decorate$12 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$12 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar LIVE_ANNOUNCER_ELEMENT_TOKEN = new _angular_core.OpaqueToken('mdLiveAnnouncerElement');\nvar MdLiveAnnouncer = (function () {\n    function MdLiveAnnouncer(elementToken) {\n        // We inject the live element as `any` because the constructor signature cannot reference\n        // browser globals (HTMLElement) on non-browser environments, since having a class decorator\n        // causes TypeScript to preserve the constructor signature types.\n        this._liveElement = elementToken || this._createLiveElement();\n    }\n    /**\n     * @param message Message to be announced to the screenreader\n     * @param politeness The politeness of the announcer element.\n     */\n    MdLiveAnnouncer.prototype.announce = function (message, politeness) {\n        var _this = this;\n        if (politeness === void 0) { politeness = 'polite'; }\n        this._liveElement.textContent = '';\n        // TODO: ensure changing the politeness works on all environments we support.\n        this._liveElement.setAttribute('aria-live', politeness);\n        // This 100ms timeout is necessary for some browser + screen-reader combinations:\n        // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n        // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n        //   second time without clearing and then using a non-zero delay.\n        // (using JAWS 17 at time of this writing).\n        setTimeout(function () { return _this._liveElement.textContent = message; }, 100);\n    };\n    MdLiveAnnouncer.prototype._createLiveElement = function () {\n        var liveEl = document.createElement('div');\n        liveEl.classList.add('md-visually-hidden');\n        liveEl.setAttribute('aria-atomic', 'true');\n        liveEl.setAttribute('aria-live', 'polite');\n        document.body.appendChild(liveEl);\n        return liveEl;\n    };\n    MdLiveAnnouncer = __decorate$12([\n        _angular_core.Injectable(),\n        __param(0, _angular_core.Optional()),\n        __param(0, _angular_core.Inject(LIVE_ANNOUNCER_ELEMENT_TOKEN)), \n        __metadata$12('design:paramtypes', [Object])\n    ], MdLiveAnnouncer);\n    return MdLiveAnnouncer;\n}());\n\nvar __decorate$9 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$9 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar A11Y_PROVIDERS = [MdLiveAnnouncer, InteractivityChecker];\nvar A11yModule = (function () {\n    function A11yModule() {\n    }\n    A11yModule.forRoot = function () {\n        return {\n            ngModule: A11yModule,\n            providers: A11Y_PROVIDERS,\n        };\n    };\n    A11yModule = __decorate$9([\n        _angular_core.NgModule({\n            declarations: [FocusTrap],\n            exports: [FocusTrap],\n        }), \n        __metadata$9('design:paramtypes', [])\n    ], A11yModule);\n    return A11yModule;\n}());\n\nvar __extends$5 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __decorate$13 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$13 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/* Adjusts configuration of our gesture library, Hammer. */\nvar MdGestureConfig = (function (_super) {\n    __extends$5(MdGestureConfig, _super);\n    function MdGestureConfig() {\n        _super.apply(this, arguments);\n        /* List of new event names to add to the gesture support list */\n        this.events = [\n            'drag',\n            'dragstart',\n            'dragend',\n            'dragright',\n            'dragleft',\n            'longpress',\n            'slide',\n            'slidestart',\n            'slideend',\n            'slideright',\n            'slideleft'\n        ];\n    }\n    /*\n     * Builds Hammer instance manually to add custom recognizers that match the Material Design spec.\n     *\n     * Our gesture names come from the Material Design gestures spec:\n     * https://www.google.com/design/spec/patterns/gestures.html#gestures-touch-mechanics\n     *\n     * More information on default recognizers can be found in Hammer docs:\n     * http://hammerjs.github.io/recognizer-pan/\n     * http://hammerjs.github.io/recognizer-press/\n     *\n     * TODO: Confirm threshold numbers with Material Design UX Team\n     * */\n    MdGestureConfig.prototype.buildHammer = function (element) {\n        var mc = new Hammer(element);\n        // Default Hammer Recognizers.\n        var pan = new Hammer.Pan();\n        var swipe = new Hammer.Swipe();\n        var press = new Hammer.Press();\n        // Notice that a HammerJS recognizer can only depend on one other recognizer once.\n        // Otherwise the previous `recognizeWith` will be dropped.\n        var slide = this._createRecognizer(pan, { event: 'slide', threshold: 0 }, swipe);\n        var drag = this._createRecognizer(slide, { event: 'drag', threshold: 6 }, swipe);\n        var longpress = this._createRecognizer(press, { event: 'longpress', time: 500 });\n        // Overwrite the default `pan` event to use the swipe event.\n        pan.recognizeWith(swipe);\n        // Add customized gestures to Hammer manager\n        mc.add([swipe, press, pan, drag, slide, longpress]);\n        return mc;\n    };\n    /** Creates a new recognizer, without affecting the default recognizers of HammerJS */\n    MdGestureConfig.prototype._createRecognizer = function (base, options) {\n        var inheritances = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            inheritances[_i - 2] = arguments[_i];\n        }\n        var recognizer = new base.constructor(options);\n        inheritances.push(base);\n        inheritances.forEach(function (item) { return recognizer.recognizeWith(item); });\n        return recognizer;\n    };\n    MdGestureConfig = __decorate$13([\n        _angular_core.Injectable(), \n        __metadata$13('design:paramtypes', [])\n    ], MdGestureConfig);\n    return MdGestureConfig;\n}(_angular_platformBrowser.HammerGestureConfig));\n\nvar __decorate$14 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$14 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/**\n * Class to coordinate unique selection based on name.\n * Intended to be consumed as an Angular service.\n * This service is needed because native radio change events are only fired on the item currently\n * being selected, and we still need to uncheck the previous selection.\n *\n * This service does not *store* any IDs and names because they may change at any time, so it is\n * less error-prone if they are simply passed through when the events occur.\n */\nvar MdUniqueSelectionDispatcher = (function () {\n    function MdUniqueSelectionDispatcher() {\n        this._listeners = [];\n    }\n    /** Notify other items that selection for the given name has been set. */\n    MdUniqueSelectionDispatcher.prototype.notify = function (id, name) {\n        for (var _i = 0, _a = this._listeners; _i < _a.length; _i++) {\n            var listener = _a[_i];\n            listener(id, name);\n        }\n    };\n    /** Listen for future changes to item selection. */\n    MdUniqueSelectionDispatcher.prototype.listen = function (listener) {\n        this._listeners.push(listener);\n    };\n    MdUniqueSelectionDispatcher = __decorate$14([\n        _angular_core.Injectable(), \n        __metadata$14('design:paramtypes', [])\n    ], MdUniqueSelectionDispatcher);\n    return MdUniqueSelectionDispatcher;\n}());\n\n/**\n * Annotation Factory that allows HTML style boolean attributes. For example,\n * a field declared like this:\n\n * @Directive({ selector: 'component' }) class MyComponent {\n *   @Input() @BooleanFieldValueFactory() myField: boolean;\n * }\n *\n * You could set it up this way:\n *   <component myField>\n * or:\n *   <component myField=\"\">\n * @deprecated\n */\nfunction BooleanFieldValue() {\n    return function booleanFieldValueMetadata(target, key) {\n        var defaultValue = target[key];\n        var localKey = \"__md_private_symbol_\" + key;\n        target[localKey] = defaultValue;\n        Object.defineProperty(target, key, {\n            get: function () { return this[localKey]; },\n            set: function (value) {\n                this[localKey] = value != null && \"\" + value !== 'false';\n            }\n        });\n    };\n}\n\n// Due to a bug in the ChromeDriver, Angular 2 keyboard events are not triggered by `sendKeys`\n// during E2E tests when using dot notation such as `(keydown.rightArrow)`. To get around this,\n// we are temporarily using a single (keydown) handler.\n// See: https://github.com/angular/angular/issues/9419\nvar UP_ARROW = 38;\nvar DOWN_ARROW = 40;\nvar RIGHT_ARROW = 39;\nvar LEFT_ARROW = 37;\nvar ENTER = 13;\nvar TAB = 9;\n\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar MdCoreModule = (function () {\n    function MdCoreModule() {\n    }\n    MdCoreModule.forRoot = function () {\n        return {\n            ngModule: MdCoreModule,\n            providers: [A11Y_PROVIDERS, OVERLAY_PROVIDERS],\n        };\n    };\n    MdCoreModule = __decorate([\n        _angular_core.NgModule({\n            imports: [MdLineModule, RtlModule, MdRippleModule, PortalModule, OverlayModule, A11yModule],\n            exports: [MdLineModule, RtlModule, MdRippleModule, PortalModule, OverlayModule, A11yModule],\n        }), \n        __metadata('design:paramtypes', [])\n    ], MdCoreModule);\n    return MdCoreModule;\n}());\n\nvar __decorate$16 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$16 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param$1 = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\n/**\n * Provider Expression that allows md-button-toggle-group to register as a ControlValueAccessor.\n * This allows it to support [(ngModel)].\n */\nvar MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = {\n    provide: _angular_forms.NG_VALUE_ACCESSOR,\n    useExisting: _angular_core.forwardRef(function () { return MdButtonToggleGroup; }),\n    multi: true\n};\nvar _uniqueIdCounter = 0;\n/** A simple change event emitted by either MdButtonToggle or MdButtonToggleGroup. */\nvar MdButtonToggleChange = (function () {\n    function MdButtonToggleChange() {\n    }\n    return MdButtonToggleChange;\n}());\n/** Exclusive selection button toggle group that behaves like a radio-button group. */\nvar MdButtonToggleGroup = (function () {\n    function MdButtonToggleGroup() {\n        /** The value for the button toggle group. Should match currently selected button toggle. */\n        this._value = null;\n        /** The HTML name attribute applied to toggles in this group. */\n        this._name = \"md-radio-group-\" + _uniqueIdCounter++;\n        /** Disables all toggles in the group. */\n        this._disabled = null;\n        /** The currently selected button toggle, should match the value. */\n        this._selected = null;\n        /** Whether the button toggle group is initialized or not. */\n        this._isInitialized = false;\n        /** The method to be called in order to update ngModel. */\n        this._controlValueAccessorChangeFn = function (value) { };\n        /** onTouch function registered via registerOnTouch (ControlValueAccessor). */\n        this.onTouched = function () { };\n        /** Event emitted when the group's value changes. */\n        this._change = new _angular_core.EventEmitter();\n        /** Child button toggle buttons. */\n        this._buttonToggles = null;\n    }\n    Object.defineProperty(MdButtonToggleGroup.prototype, \"change\", {\n        get: function () {\n            return this._change.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** TODO: internal */\n    MdButtonToggleGroup.prototype.ngAfterViewInit = function () {\n        this._isInitialized = true;\n    };\n    Object.defineProperty(MdButtonToggleGroup.prototype, \"name\", {\n        get: function () {\n            return this._name;\n        },\n        set: function (value) {\n            this._name = value;\n            this._updateButtonToggleNames();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdButtonToggleGroup.prototype, \"disabled\", {\n        get: function () {\n            return this._disabled;\n        },\n        set: function (value) {\n            this._disabled = (value != null && value !== false) ? true : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdButtonToggleGroup.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        set: function (newValue) {\n            if (this._value != newValue) {\n                this._value = newValue;\n                this._updateSelectedButtonToggleFromValue();\n                // Only emit a change event if the view is completely initialized.\n                // We don't want to emit a change event for the initial values.\n                if (this._isInitialized) {\n                    this._emitChangeEvent();\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdButtonToggleGroup.prototype, \"selected\", {\n        get: function () {\n            return this._selected;\n        },\n        set: function (selected) {\n            this._selected = selected;\n            this.value = selected ? selected.value : null;\n            if (selected && !selected.checked) {\n                selected.checked = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MdButtonToggleGroup.prototype._updateButtonToggleNames = function () {\n        var _this = this;\n        if (this._buttonToggles) {\n            this._buttonToggles.forEach(function (toggle) {\n                toggle.name = _this._name;\n            });\n        }\n    };\n    // TODO: Refactor into shared code with radio.\n    MdButtonToggleGroup.prototype._updateSelectedButtonToggleFromValue = function () {\n        var _this = this;\n        var isAlreadySelected = this._selected != null && this._selected.value == this._value;\n        if (this._buttonToggles != null && !isAlreadySelected) {\n            var matchingButtonToggle = this._buttonToggles.filter(function (buttonToggle) { return buttonToggle.value == _this._value; })[0];\n            if (matchingButtonToggle) {\n                this.selected = matchingButtonToggle;\n            }\n            else if (this.value == null) {\n                this.selected = null;\n                this._buttonToggles.forEach(function (buttonToggle) {\n                    buttonToggle.checked = false;\n                });\n            }\n        }\n    };\n    /** Dispatch change event with current selection and group value. */\n    MdButtonToggleGroup.prototype._emitChangeEvent = function () {\n        var event = new MdButtonToggleChange();\n        event.source = this._selected;\n        event.value = this._value;\n        this._controlValueAccessorChangeFn(event.value);\n        this._change.emit(event);\n    };\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * TODO: internal\n     */\n    MdButtonToggleGroup.prototype.writeValue = function (value) {\n        this.value = value;\n    };\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * TODO: internal\n     */\n    MdButtonToggleGroup.prototype.registerOnChange = function (fn) {\n        this._controlValueAccessorChangeFn = fn;\n    };\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * TODO: internal\n     */\n    MdButtonToggleGroup.prototype.registerOnTouched = function (fn) {\n        this.onTouched = fn;\n    };\n    __decorate$16([\n        _angular_core.Output(), \n        __metadata$16('design:type', rxjs_Observable.Observable)\n    ], MdButtonToggleGroup.prototype, \"change\", null);\n    __decorate$16([\n        _angular_core.ContentChildren(_angular_core.forwardRef(function () { return MdButtonToggle; })), \n        __metadata$16('design:type', _angular_core.QueryList)\n    ], MdButtonToggleGroup.prototype, \"_buttonToggles\", void 0);\n    __decorate$16([\n        _angular_core.Input(), \n        __metadata$16('design:type', String)\n    ], MdButtonToggleGroup.prototype, \"name\", null);\n    __decorate$16([\n        _angular_core.Input(),\n        BooleanFieldValue(), \n        __metadata$16('design:type', Boolean)\n    ], MdButtonToggleGroup.prototype, \"disabled\", null);\n    __decorate$16([\n        _angular_core.Input(), \n        __metadata$16('design:type', Object)\n    ], MdButtonToggleGroup.prototype, \"value\", null);\n    __decorate$16([\n        _angular_core.Input(), \n        __metadata$16('design:type', Object)\n    ], MdButtonToggleGroup.prototype, \"selected\", null);\n    MdButtonToggleGroup = __decorate$16([\n        _angular_core.Directive({\n            selector: 'md-button-toggle-group:not([multiple])',\n            providers: [MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR],\n            host: {\n                'role': 'radiogroup',\n            },\n        }), \n        __metadata$16('design:paramtypes', [])\n    ], MdButtonToggleGroup);\n    return MdButtonToggleGroup;\n}());\n/** Multiple selection button-toggle group. */\nvar MdButtonToggleGroupMultiple = (function () {\n    function MdButtonToggleGroupMultiple() {\n        /** Disables all toggles in the group. */\n        this._disabled = null;\n    }\n    Object.defineProperty(MdButtonToggleGroupMultiple.prototype, \"disabled\", {\n        get: function () {\n            return this._disabled;\n        },\n        set: function (value) {\n            this._disabled = (value != null && value !== false) ? true : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    __decorate$16([\n        _angular_core.Input(), \n        __metadata$16('design:type', Boolean)\n    ], MdButtonToggleGroupMultiple.prototype, \"disabled\", null);\n    MdButtonToggleGroupMultiple = __decorate$16([\n        _angular_core.Directive({\n            selector: 'md-button-toggle-group[multiple]',\n        }), \n        __metadata$16('design:paramtypes', [])\n    ], MdButtonToggleGroupMultiple);\n    return MdButtonToggleGroupMultiple;\n}());\nvar MdButtonToggle = (function () {\n    function MdButtonToggle(toggleGroup, toggleGroupMultiple, buttonToggleDispatcher) {\n        var _this = this;\n        this.buttonToggleDispatcher = buttonToggleDispatcher;\n        /** Whether or not this button toggle is checked. */\n        this._checked = false;\n        /** Whether or not this button toggle is disabled. */\n        this._disabled = null;\n        /** Value assigned to this button toggle. */\n        this._value = null;\n        /** Whether or not the button toggle is a single selection. */\n        this._isSingleSelector = null;\n        /** Event emitted when the group value changes. */\n        this._change = new _angular_core.EventEmitter();\n        this.buttonToggleGroup = toggleGroup;\n        this.buttonToggleGroupMultiple = toggleGroupMultiple;\n        if (this.buttonToggleGroup) {\n            buttonToggleDispatcher.listen(function (id, name) {\n                if (id != _this.id && name == _this.name) {\n                    _this.checked = false;\n                }\n            });\n            this._type = 'radio';\n            this.name = this.buttonToggleGroup.name;\n            this._isSingleSelector = true;\n        }\n        else {\n            // Even if there is no group at all, treat the button toggle as a checkbox so it can be\n            // toggled on or off.\n            this._type = 'checkbox';\n            this._isSingleSelector = false;\n        }\n    }\n    Object.defineProperty(MdButtonToggle.prototype, \"change\", {\n        get: function () {\n            return this._change.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MdButtonToggle.prototype.ngOnInit = function () {\n        if (this.id == null) {\n            this.id = \"md-button-toggle-\" + _uniqueIdCounter++;\n        }\n        if (this.buttonToggleGroup && this._value == this.buttonToggleGroup.value) {\n            this._checked = true;\n        }\n    };\n    Object.defineProperty(MdButtonToggle.prototype, \"inputId\", {\n        get: function () {\n            return this.id + \"-input\";\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdButtonToggle.prototype, \"checked\", {\n        get: function () {\n            return this._checked;\n        },\n        set: function (newCheckedState) {\n            if (this._isSingleSelector) {\n                if (newCheckedState) {\n                    // Notify all button toggles with the same name (in the same group) to un-check.\n                    this.buttonToggleDispatcher.notify(this.id, this.name);\n                }\n            }\n            this._checked = newCheckedState;\n            if (newCheckedState && this._isSingleSelector && this.buttonToggleGroup.value != this.value) {\n                this.buttonToggleGroup.selected = this;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdButtonToggle.prototype, \"value\", {\n        /** MdButtonToggleGroup reads this to assign its own value. */\n        get: function () {\n            return this._value;\n        },\n        set: function (value) {\n            if (this._value != value) {\n                if (this.buttonToggleGroup != null && this.checked) {\n                    this.buttonToggleGroup.value = value;\n                }\n                this._value = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Dispatch change event with current value. */\n    MdButtonToggle.prototype._emitChangeEvent = function () {\n        var event = new MdButtonToggleChange();\n        event.source = this;\n        event.value = this._value;\n        this._change.emit(event);\n    };\n    Object.defineProperty(MdButtonToggle.prototype, \"disabled\", {\n        get: function () {\n            return this._disabled || (this.buttonToggleGroup != null && this.buttonToggleGroup.disabled) ||\n                (this.buttonToggleGroupMultiple != null && this.buttonToggleGroupMultiple.disabled);\n        },\n        set: function (value) {\n            this._disabled = (value != null && value !== false) ? true : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Toggle the state of the current button toggle. */\n    MdButtonToggle.prototype._toggle = function () {\n        this.checked = !this.checked;\n    };\n    /** Checks the button toggle due to an interaction with the underlying native input. */\n    MdButtonToggle.prototype._onInputChange = function (event) {\n        event.stopPropagation();\n        if (this._isSingleSelector) {\n            // Propagate the change one-way via the group, which will in turn mark this\n            // button toggle as checked.\n            this.checked = true;\n            this.buttonToggleGroup.selected = this;\n            this.buttonToggleGroup.onTouched();\n        }\n        else {\n            this._toggle();\n        }\n        // Emit a change event when the native input does.\n        this._emitChangeEvent();\n    };\n    /** TODO: internal */\n    MdButtonToggle.prototype._onInputClick = function (event) {\n        // We have to stop propagation for click events on the visual hidden input element.\n        // By default, when a user clicks on a label element, a generated click event will be\n        // dispatched on the associated input element. Since we are using a label element as our\n        // root container, the click event on the `slide-toggle` will be executed twice.\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\n        // This will lead to multiple click events.\n        // Preventing bubbling for the second event will solve that issue.\n        event.stopPropagation();\n    };\n    __decorate$16([\n        _angular_core.HostBinding(),\n        _angular_core.Input(), \n        __metadata$16('design:type', String)\n    ], MdButtonToggle.prototype, \"id\", void 0);\n    __decorate$16([\n        _angular_core.Input(), \n        __metadata$16('design:type', String)\n    ], MdButtonToggle.prototype, \"name\", void 0);\n    __decorate$16([\n        _angular_core.Output(), \n        __metadata$16('design:type', rxjs_Observable.Observable)\n    ], MdButtonToggle.prototype, \"change\", null);\n    __decorate$16([\n        _angular_core.HostBinding('class.md-button-toggle-checked'),\n        _angular_core.Input(), \n        __metadata$16('design:type', Boolean)\n    ], MdButtonToggle.prototype, \"checked\", null);\n    __decorate$16([\n        _angular_core.Input(), \n        __metadata$16('design:type', Object)\n    ], MdButtonToggle.prototype, \"value\", null);\n    __decorate$16([\n        _angular_core.HostBinding('class.md-button-toggle-disabled'),\n        _angular_core.Input(), \n        __metadata$16('design:type', Boolean)\n    ], MdButtonToggle.prototype, \"disabled\", null);\n    MdButtonToggle = __decorate$16([\n        _angular_core.Component({selector: 'md-button-toggle',\n            template: \"<label [attr.for]=\\\"inputId\\\" class=\\\"md-button-toggle-label\\\"> <input #input class=\\\"md-button-toggle-input md-visually-hidden\\\" [type]=\\\"_type\\\" [id]=\\\"inputId\\\" [checked]=\\\"checked\\\" [disabled]=\\\"disabled\\\" [name]=\\\"name\\\" (change)=\\\"_onInputChange($event)\\\" (click)=\\\"_onInputClick($event)\\\"> <div class=\\\"md-button-toggle-label-content\\\"> <ng-content></ng-content> </div> </label> \",\n            styles: [\"md-button-toggle-group { box-shadow: 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12); position: relative; display: inline-flex; border-radius: 3px; cursor: pointer; white-space: nowrap; } .md-button-toggle-disabled .md-button-toggle-label-content { cursor: default; } md-button-toggle { white-space: nowrap; } .md-button-toggle-label-content { display: inline-block; line-height: 36px; padding: 0 16px; cursor: pointer; } .md-button-toggle-label-content > * { vertical-align: middle; } /*# sourceMappingURL=button-toggle.css.map */ \"],\n            encapsulation: _angular_core.ViewEncapsulation.None,\n        }),\n        __param$1(0, _angular_core.Optional()),\n        __param$1(1, _angular_core.Optional()), \n        __metadata$16('design:paramtypes', [MdButtonToggleGroup, MdButtonToggleGroupMultiple, MdUniqueSelectionDispatcher])\n    ], MdButtonToggle);\n    return MdButtonToggle;\n}());\nvar MdButtonToggleModule = (function () {\n    function MdButtonToggleModule() {\n    }\n    MdButtonToggleModule.forRoot = function () {\n        return {\n            ngModule: MdButtonToggleModule,\n            providers: [MdUniqueSelectionDispatcher]\n        };\n    };\n    MdButtonToggleModule = __decorate$16([\n        _angular_core.NgModule({\n            imports: [_angular_forms.FormsModule],\n            exports: [MdButtonToggleGroup, MdButtonToggleGroupMultiple, MdButtonToggle],\n            declarations: [MdButtonToggleGroup, MdButtonToggleGroupMultiple, MdButtonToggle],\n        }), \n        __metadata$16('design:paramtypes', [])\n    ], MdButtonToggleModule);\n    return MdButtonToggleModule;\n}());\n\nvar __extends$6 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __decorate$17 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$17 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n// TODO(jelbourn): Make the `isMouseDown` stuff done with one global listener.\n// TODO(kara): Convert attribute selectors to classes when attr maps become available\nvar MdButton = (function () {\n    function MdButton(_elementRef, _renderer) {\n        this._elementRef = _elementRef;\n        this._renderer = _renderer;\n        /** Whether the button has focus from the keyboard (not the mouse). Used for class binding. */\n        this._isKeyboardFocused = false;\n        /** Whether a mousedown has occurred on this element in the last 100ms. */\n        this._isMouseDown = false;\n        /** Whether the ripple effect on click should be disabled. */\n        this.disableRipple = false;\n    }\n    Object.defineProperty(MdButton.prototype, \"color\", {\n        get: function () {\n            return this._color;\n        },\n        set: function (value) {\n            this._updateColor(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MdButton.prototype._setMousedown = function () {\n        var _this = this;\n        // We only *show* the focus style when focus has come to the button via the keyboard.\n        // The Material Design spec is silent on this topic, and without doing this, the\n        // button continues to look :active after clicking.\n        // @see http://marcysutton.com/button-focus-hell/\n        this._isMouseDown = true;\n        setTimeout(function () { _this._isMouseDown = false; }, 100);\n    };\n    MdButton.prototype._updateColor = function (newColor) {\n        this._setElementColor(this._color, false);\n        this._setElementColor(newColor, true);\n        this._color = newColor;\n    };\n    MdButton.prototype._setElementColor = function (color, isAdd) {\n        if (color != null && color != '') {\n            this._renderer.setElementClass(this._elementRef.nativeElement, \"md-\" + color, isAdd);\n        }\n    };\n    MdButton.prototype._setKeyboardFocus = function () {\n        this._isKeyboardFocused = !this._isMouseDown;\n    };\n    MdButton.prototype._removeKeyboardFocus = function () {\n        this._isKeyboardFocused = false;\n    };\n    /** TODO(hansl): e2e test this function. */\n    MdButton.prototype.focus = function () {\n        this._elementRef.nativeElement.focus();\n    };\n    MdButton.prototype.getHostElement = function () {\n        return this._elementRef.nativeElement;\n    };\n    MdButton.prototype.isRoundButton = function () {\n        var el = this._elementRef.nativeElement;\n        return el.hasAttribute('md-icon-button') ||\n            el.hasAttribute('md-fab') ||\n            el.hasAttribute('md-mini-fab');\n    };\n    MdButton.prototype.isRippleEnabled = function () {\n        return !this.disableRipple;\n    };\n    __decorate$17([\n        _angular_core.Input(),\n        BooleanFieldValue(), \n        __metadata$17('design:type', Boolean)\n    ], MdButton.prototype, \"disableRipple\", void 0);\n    __decorate$17([\n        _angular_core.Input(), \n        __metadata$17('design:type', String)\n    ], MdButton.prototype, \"color\", null);\n    MdButton = __decorate$17([\n        _angular_core.Component({selector: 'button[md-button], button[md-raised-button], button[md-icon-button], ' +\n                'button[md-fab], button[md-mini-fab]',\n            host: {\n                '[class.md-button-focus]': '_isKeyboardFocused',\n                '(mousedown)': '_setMousedown()',\n                '(focus)': '_setKeyboardFocus()',\n                '(blur)': '_removeKeyboardFocus()',\n            },\n            template: \"<span class=\\\"md-button-wrapper\\\"><ng-content></ng-content></span> <div md-ripple *ngIf=\\\"isRippleEnabled()\\\" class=\\\"md-button-ripple\\\" [class.md-button-ripple-round]=\\\"isRoundButton()\\\" [md-ripple-trigger]=\\\"getHostElement()\\\" [md-ripple-color]=\\\"isRoundButton() ? 'rgba(255, 255, 255, 0.2)' : ''\\\" md-ripple-background-color=\\\"rgba(0, 0, 0, 0)\\\"></div> \",\n            styles: [\"[md-raised-button], [md-fab], [md-mini-fab], [md-button], [md-icon-button] { box-sizing: border-box; position: relative; cursor: pointer; user-select: none; outline: none; border: none; display: inline-block; white-space: nowrap; text-decoration: none; vertical-align: baseline; font-size: 14px; font-family: Roboto, \\\"Helvetica Neue\\\", sans-serif; font-weight: 500; color: currentColor; text-align: center; margin: 0; min-width: 88px; line-height: 36px; padding: 0 16px; border-radius: 3px; } [disabled][md-raised-button], [disabled][md-fab], [disabled][md-mini-fab], [disabled][md-button], [disabled][md-icon-button] { cursor: default; } .md-button-focus[md-raised-button]::after, .md-button-focus[md-fab]::after, .md-button-focus[md-mini-fab]::after, .md-button-focus[md-button]::after, .md-button-focus[md-icon-button]::after { position: absolute; top: 0; left: 0; bottom: 0; right: 0; content: ''; background-color: rgba(0, 0, 0, 0.12); border-radius: inherit; pointer-events: none; } [md-raised-button], [md-fab], [md-mini-fab] { box-shadow: 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12); transform: translate3d(0, 0, 0); transition: background 400ms cubic-bezier(0.25, 0.8, 0.25, 1), box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1); } [md-raised-button]:active, [md-fab]:active, [md-mini-fab]:active { box-shadow: 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12); } [disabled][md-raised-button], [disabled][md-fab], [disabled][md-mini-fab] { box-shadow: none; } [md-button]:hover::after, [md-icon-button]:hover::after { position: absolute; top: 0; left: 0; bottom: 0; right: 0; content: ''; background-color: rgba(0, 0, 0, 0.12); border-radius: inherit; pointer-events: none; } [md-button][disabled]:hover.md-primary, [md-button][disabled]:hover.md-accent, [md-button][disabled]:hover.md-warn, [md-button][disabled]:hover::after, [md-icon-button][disabled]:hover.md-primary, [md-icon-button][disabled]:hover.md-accent, [md-icon-button][disabled]:hover.md-warn, [md-icon-button][disabled]:hover::after { background-color: transparent; } [md-fab] { min-width: 0; border-radius: 50%; width: 56px; height: 56px; padding: 0; } [md-fab] i, [md-fab] md-icon { padding: 16px 0; } [md-mini-fab] { min-width: 0; border-radius: 50%; width: 40px; height: 40px; padding: 0; } [md-mini-fab] i, [md-mini-fab] md-icon { padding: 8px 0; } [md-icon-button] { min-width: 0; padding: 0; width: 40px; height: 40px; line-height: 24px; border-radius: 50%; } [md-icon-button] .md-button-wrapper > * { vertical-align: middle; } .md-button-ripple { position: absolute; top: 0; left: 0; bottom: 0; right: 0; } .md-button-ripple-round { border-radius: 50%; z-index: 1; } @media screen and (-ms-high-contrast: active) { .md-raised-button, .md-fab, .md-mini-fab { border: 1px solid #fff; } } /*# sourceMappingURL=button.css.map */ \"],\n            encapsulation: _angular_core.ViewEncapsulation.None,\n            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,\n        }), \n        __metadata$17('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])\n    ], MdButton);\n    return MdButton;\n}());\nvar MdAnchor = (function (_super) {\n    __extends$6(MdAnchor, _super);\n    function MdAnchor(elementRef, renderer) {\n        _super.call(this, elementRef, renderer);\n        this._disabled = null;\n    }\n    Object.defineProperty(MdAnchor.prototype, \"tabIndex\", {\n        get: function () {\n            return this.disabled ? -1 : 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdAnchor.prototype, \"isAriaDisabled\", {\n        get: function () {\n            return this.disabled ? 'true' : 'false';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdAnchor.prototype, \"disabled\", {\n        get: function () { return this._disabled; },\n        set: function (value) {\n            // The presence of *any* disabled value makes the component disabled, *except* for false.\n            this._disabled = (value != null && value != false) ? true : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MdAnchor.prototype._haltDisabledEvents = function (event) {\n        // A disabled button shouldn't apply any actions\n        if (this.disabled) {\n            event.preventDefault();\n            event.stopImmediatePropagation();\n        }\n    };\n    __decorate$17([\n        _angular_core.HostBinding('tabIndex'), \n        __metadata$17('design:type', Number)\n    ], MdAnchor.prototype, \"tabIndex\", null);\n    __decorate$17([\n        _angular_core.HostBinding('attr.aria-disabled'), \n        __metadata$17('design:type', String)\n    ], MdAnchor.prototype, \"isAriaDisabled\", null);\n    __decorate$17([\n        _angular_core.HostBinding('attr.disabled'),\n        _angular_core.Input('disabled'), \n        __metadata$17('design:type', Object)\n    ], MdAnchor.prototype, \"disabled\", null);\n    MdAnchor = __decorate$17([\n        _angular_core.Component({selector: 'a[md-button], a[md-raised-button], a[md-icon-button], a[md-fab], a[md-mini-fab]',\n            inputs: ['color'],\n            host: {\n                '[class.md-button-focus]': '_isKeyboardFocused',\n                '(mousedown)': '_setMousedown()',\n                '(focus)': '_setKeyboardFocus()',\n                '(blur)': '_removeKeyboardFocus()',\n                '(click)': '_haltDisabledEvents($event)',\n            },\n            template: \"<span class=\\\"md-button-wrapper\\\"><ng-content></ng-content></span> <div md-ripple *ngIf=\\\"isRippleEnabled()\\\" class=\\\"md-button-ripple\\\" [class.md-button-ripple-round]=\\\"isRoundButton()\\\" [md-ripple-trigger]=\\\"getHostElement()\\\" [md-ripple-color]=\\\"isRoundButton() ? 'rgba(255, 255, 255, 0.2)' : ''\\\" md-ripple-background-color=\\\"rgba(0, 0, 0, 0)\\\"></div> \",\n            styles: [\"[md-raised-button], [md-fab], [md-mini-fab], [md-button], [md-icon-button] { box-sizing: border-box; position: relative; cursor: pointer; user-select: none; outline: none; border: none; display: inline-block; white-space: nowrap; text-decoration: none; vertical-align: baseline; font-size: 14px; font-family: Roboto, \\\"Helvetica Neue\\\", sans-serif; font-weight: 500; color: currentColor; text-align: center; margin: 0; min-width: 88px; line-height: 36px; padding: 0 16px; border-radius: 3px; } [disabled][md-raised-button], [disabled][md-fab], [disabled][md-mini-fab], [disabled][md-button], [disabled][md-icon-button] { cursor: default; } .md-button-focus[md-raised-button]::after, .md-button-focus[md-fab]::after, .md-button-focus[md-mini-fab]::after, .md-button-focus[md-button]::after, .md-button-focus[md-icon-button]::after { position: absolute; top: 0; left: 0; bottom: 0; right: 0; content: ''; background-color: rgba(0, 0, 0, 0.12); border-radius: inherit; pointer-events: none; } [md-raised-button], [md-fab], [md-mini-fab] { box-shadow: 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12); transform: translate3d(0, 0, 0); transition: background 400ms cubic-bezier(0.25, 0.8, 0.25, 1), box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1); } [md-raised-button]:active, [md-fab]:active, [md-mini-fab]:active { box-shadow: 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12); } [disabled][md-raised-button], [disabled][md-fab], [disabled][md-mini-fab] { box-shadow: none; } [md-button]:hover::after, [md-icon-button]:hover::after { position: absolute; top: 0; left: 0; bottom: 0; right: 0; content: ''; background-color: rgba(0, 0, 0, 0.12); border-radius: inherit; pointer-events: none; } [md-button][disabled]:hover.md-primary, [md-button][disabled]:hover.md-accent, [md-button][disabled]:hover.md-warn, [md-button][disabled]:hover::after, [md-icon-button][disabled]:hover.md-primary, [md-icon-button][disabled]:hover.md-accent, [md-icon-button][disabled]:hover.md-warn, [md-icon-button][disabled]:hover::after { background-color: transparent; } [md-fab] { min-width: 0; border-radius: 50%; width: 56px; height: 56px; padding: 0; } [md-fab] i, [md-fab] md-icon { padding: 16px 0; } [md-mini-fab] { min-width: 0; border-radius: 50%; width: 40px; height: 40px; padding: 0; } [md-mini-fab] i, [md-mini-fab] md-icon { padding: 8px 0; } [md-icon-button] { min-width: 0; padding: 0; width: 40px; height: 40px; line-height: 24px; border-radius: 50%; } [md-icon-button] .md-button-wrapper > * { vertical-align: middle; } .md-button-ripple { position: absolute; top: 0; left: 0; bottom: 0; right: 0; } .md-button-ripple-round { border-radius: 50%; z-index: 1; } @media screen and (-ms-high-contrast: active) { .md-raised-button, .md-fab, .md-mini-fab { border: 1px solid #fff; } } /*# sourceMappingURL=button.css.map */ \"],\n            encapsulation: _angular_core.ViewEncapsulation.None\n        }), \n        __metadata$17('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])\n    ], MdAnchor);\n    return MdAnchor;\n}(MdButton));\nvar MdButtonModule = (function () {\n    function MdButtonModule() {\n    }\n    MdButtonModule.forRoot = function () {\n        return {\n            ngModule: MdButtonModule,\n            providers: []\n        };\n    };\n    MdButtonModule = __decorate$17([\n        _angular_core.NgModule({\n            imports: [_angular_common.CommonModule, MdRippleModule],\n            exports: [MdButton, MdAnchor],\n            declarations: [MdButton, MdAnchor],\n        }), \n        __metadata$17('design:paramtypes', [])\n    ], MdButtonModule);\n    return MdButtonModule;\n}());\n\nvar __decorate$18 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$18 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/**\n * Monotonically increasing integer used to auto-generate unique ids for checkbox components.\n */\nvar nextId = 0;\n/**\n * Provider Expression that allows md-checkbox to register as a ControlValueAccessor. This allows it\n * to support [(ngModel)].\n */\nvar MD_CHECKBOX_CONTROL_VALUE_ACCESSOR = {\n    provide: _angular_forms.NG_VALUE_ACCESSOR,\n    useExisting: _angular_core.forwardRef(function () { return MdCheckbox; }),\n    multi: true\n};\n/**\n * Represents the different states that require custom transitions between them.\n */\n(function (TransitionCheckState) {\n    /** The initial state of the component before any user interaction. */\n    TransitionCheckState[TransitionCheckState[\"Init\"] = 0] = \"Init\";\n    /** The state representing the component when it's becoming checked. */\n    TransitionCheckState[TransitionCheckState[\"Checked\"] = 1] = \"Checked\";\n    /** The state representing the component when it's becoming unchecked. */\n    TransitionCheckState[TransitionCheckState[\"Unchecked\"] = 2] = \"Unchecked\";\n    /** The state representing the component when it's becoming indeterminate. */\n    TransitionCheckState[TransitionCheckState[\"Indeterminate\"] = 3] = \"Indeterminate\";\n})(exports.TransitionCheckState || (exports.TransitionCheckState = {}));\n// A simple change event emitted by the MdCheckbox component.\nvar MdCheckboxChange = (function () {\n    function MdCheckboxChange() {\n    }\n    return MdCheckboxChange;\n}());\n/**\n * A material design checkbox component. Supports all of the functionality of an HTML5 checkbox,\n * and exposes a similar API. An MdCheckbox can be either checked, unchecked, indeterminate, or\n * disabled. Note that all additional accessibility attributes are taken care of by the component,\n * so there is no need to provide them yourself. However, if you want to omit a label and still\n * have the checkbox be accessible, you may supply an [aria-label] input.\n * See: https://www.google.com/design/spec/components/selection-controls.html\n */\nvar MdCheckbox = (function () {\n    function MdCheckbox(_renderer, _elementRef) {\n        this._renderer = _renderer;\n        this._elementRef = _elementRef;\n        /**\n         * Attached to the aria-label attribute of the host element. In most cases, arial-labelledby will\n         * take precedence so this may be omitted.\n         */\n        this.ariaLabel = '';\n        /**\n         * Users can specify the `aria-labelledby` attribute which will be forwarded to the input element\n         */\n        this.ariaLabelledby = null;\n        /** A unique id for the checkbox. If one is not supplied, it is auto-generated. */\n        this.id = \"md-checkbox-\" + ++nextId;\n        /** Whether the checkbox is required or not. */\n        this.required = false;\n        /** Whether or not the checkbox should come before or after the label. */\n        this.align = 'start';\n        /**\n         * Whether the checkbox is disabled. When the checkbox is disabled it cannot be interacted with.\n         * The correct ARIA attributes are applied to denote this to assistive technology.\n         */\n        this.disabled = false;\n        /**\n         * The tabindex attribute for the checkbox. Note that when the checkbox is disabled, the attribute\n         * on the host element will be removed. It will be placed back when the checkbox is re-enabled.\n         */\n        this.tabindex = 0;\n        /** Name value will be applied to the input element if present */\n        this.name = null;\n        /** Event emitted when the checkbox's `checked` value changes. */\n        this.change = new _angular_core.EventEmitter();\n        /** Called when the checkbox is blurred. Needed to properly implement ControlValueAccessor. */\n        this.onTouched = function () { };\n        this._currentAnimationClass = '';\n        this._currentCheckState = exports.TransitionCheckState.Init;\n        this._checked = false;\n        this._indeterminate = false;\n        this._controlValueAccessorChangeFn = function (value) { };\n        this.hasFocus = false;\n    }\n    Object.defineProperty(MdCheckbox.prototype, \"inputId\", {\n        /** ID to be applied to the `input` element */\n        get: function () {\n            return \"input-\" + this.id;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdCheckbox.prototype, \"checked\", {\n        /**\n         * Whether the checkbox is checked. Note that setting `checked` will immediately set\n         * `indeterminate` to false.\n         */\n        get: function () {\n            return this._checked;\n        },\n        set: function (checked) {\n            if (checked != this.checked) {\n                this._indeterminate = false;\n                this._checked = checked;\n                this._transitionCheckState(this._checked ? exports.TransitionCheckState.Checked : exports.TransitionCheckState.Unchecked);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdCheckbox.prototype, \"indeterminate\", {\n        /**\n         * Whether the checkbox is indeterminate. This is also known as \"mixed\" mode and can be used to\n         * represent a checkbox with three states, e.g. a checkbox that represents a nested list of\n         * checkable items. Note that whenever `checked` is set, indeterminate is immediately set to\n         * false. This differs from the web platform in that indeterminate state on native\n         * checkboxes is only remove when the user manually checks the checkbox (rather than setting the\n         * `checked` property programmatically). However, we feel that this behavior is more accommodating\n         * to the way consumers would envision using this component.\n         */\n        get: function () {\n            return this._indeterminate;\n        },\n        set: function (indeterminate) {\n            this._indeterminate = indeterminate;\n            if (this._indeterminate) {\n                this._transitionCheckState(exports.TransitionCheckState.Indeterminate);\n            }\n            else {\n                this._transitionCheckState(this.checked ? exports.TransitionCheckState.Checked : exports.TransitionCheckState.Unchecked);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * TODO: internal\n     */\n    MdCheckbox.prototype.writeValue = function (value) {\n        this.checked = !!value;\n    };\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * TODO: internal\n     */\n    MdCheckbox.prototype.registerOnChange = function (fn) {\n        this._controlValueAccessorChangeFn = fn;\n    };\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * TODO: internal\n     */\n    MdCheckbox.prototype.registerOnTouched = function (fn) {\n        this.onTouched = fn;\n    };\n    MdCheckbox.prototype._transitionCheckState = function (newState) {\n        var oldState = this._currentCheckState;\n        var renderer = this._renderer;\n        var elementRef = this._elementRef;\n        if (oldState === newState) {\n            return;\n        }\n        if (this._currentAnimationClass.length > 0) {\n            renderer.setElementClass(elementRef.nativeElement, this._currentAnimationClass, false);\n        }\n        this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(oldState, newState);\n        this._currentCheckState = newState;\n        if (this._currentAnimationClass.length > 0) {\n            renderer.setElementClass(elementRef.nativeElement, this._currentAnimationClass, true);\n        }\n    };\n    MdCheckbox.prototype._emitChangeEvent = function () {\n        var event = new MdCheckboxChange();\n        event.source = this;\n        event.checked = this.checked;\n        this._controlValueAccessorChangeFn(this.checked);\n        this.change.emit(event);\n    };\n    /** Informs the component when the input has focus so that we can style accordingly */\n    MdCheckbox.prototype._onInputFocus = function () {\n        this.hasFocus = true;\n    };\n    /** Informs the component when we lose focus in order to style accordingly */\n    MdCheckbox.prototype._onInputBlur = function () {\n        this.hasFocus = false;\n        this.onTouched();\n    };\n    /**\n     * Toggles the `checked` value between true and false\n     */\n    MdCheckbox.prototype.toggle = function () {\n        this.checked = !this.checked;\n    };\n    /**\n     * Event handler for checkbox input element.\n     * Toggles checked state if element is not disabled.\n     * @param event\n     */\n    MdCheckbox.prototype._onInteractionEvent = function (event) {\n        // We always have to stop propagation on the change event.\n        // Otherwise the change event, from the input element, will bubble up and\n        // emit its event object to the `change` output.\n        event.stopPropagation();\n        if (!this.disabled) {\n            this.toggle();\n            // Emit our custom change event if the native input emitted one.\n            // It is important to only emit it, if the native input triggered one, because\n            // we don't want to trigger a change event, when the `checked` variable changes for example.\n            this._emitChangeEvent();\n        }\n    };\n    MdCheckbox.prototype._onInputClick = function (event) {\n        // We have to stop propagation for click events on the visual hidden input element.\n        // By default, when a user clicks on a label element, a generated click event will be\n        // dispatched on the associated input element. Since we are using a label element as our\n        // root container, the click event on the `checkbox` will be executed twice.\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\n        // This will lead to multiple click events.\n        // Preventing bubbling for the second event will solve that issue.\n        event.stopPropagation();\n    };\n    MdCheckbox.prototype._getAnimationClassForCheckStateTransition = function (oldState, newState) {\n        var animSuffix;\n        switch (oldState) {\n            case exports.TransitionCheckState.Init:\n                // Handle edge case where user interacts with checkbox that does not have [(ngModel)] or\n                // [checked] bound to it.\n                if (newState === exports.TransitionCheckState.Checked) {\n                    animSuffix = 'unchecked-checked';\n                }\n                else {\n                    return '';\n                }\n                break;\n            case exports.TransitionCheckState.Unchecked:\n                animSuffix = newState === exports.TransitionCheckState.Checked ?\n                    'unchecked-checked' : 'unchecked-indeterminate';\n                break;\n            case exports.TransitionCheckState.Checked:\n                animSuffix = newState === exports.TransitionCheckState.Unchecked ?\n                    'checked-unchecked' : 'checked-indeterminate';\n                break;\n            case exports.TransitionCheckState.Indeterminate:\n                animSuffix = newState === exports.TransitionCheckState.Checked ?\n                    'indeterminate-checked' : 'indeterminate-unchecked';\n        }\n        return \"md-checkbox-anim-\" + animSuffix;\n    };\n    __decorate$18([\n        _angular_core.Input('aria-label'), \n        __metadata$18('design:type', String)\n    ], MdCheckbox.prototype, \"ariaLabel\", void 0);\n    __decorate$18([\n        _angular_core.Input('aria-labelledby'), \n        __metadata$18('design:type', String)\n    ], MdCheckbox.prototype, \"ariaLabelledby\", void 0);\n    __decorate$18([\n        _angular_core.Input(), \n        __metadata$18('design:type', String)\n    ], MdCheckbox.prototype, \"id\", void 0);\n    __decorate$18([\n        _angular_core.Input(),\n        BooleanFieldValue(), \n        __metadata$18('design:type', Boolean)\n    ], MdCheckbox.prototype, \"required\", void 0);\n    __decorate$18([\n        _angular_core.Input(), \n        __metadata$18('design:type', Object)\n    ], MdCheckbox.prototype, \"align\", void 0);\n    __decorate$18([\n        _angular_core.Input(), \n        __metadata$18('design:type', Boolean)\n    ], MdCheckbox.prototype, \"disabled\", void 0);\n    __decorate$18([\n        _angular_core.Input(), \n        __metadata$18('design:type', Number)\n    ], MdCheckbox.prototype, \"tabindex\", void 0);\n    __decorate$18([\n        _angular_core.Input(), \n        __metadata$18('design:type', String)\n    ], MdCheckbox.prototype, \"name\", void 0);\n    __decorate$18([\n        _angular_core.Output(), \n        __metadata$18('design:type', _angular_core.EventEmitter)\n    ], MdCheckbox.prototype, \"change\", void 0);\n    __decorate$18([\n        _angular_core.Input(), \n        __metadata$18('design:type', Object)\n    ], MdCheckbox.prototype, \"checked\", null);\n    __decorate$18([\n        _angular_core.Input(), \n        __metadata$18('design:type', Object)\n    ], MdCheckbox.prototype, \"indeterminate\", null);\n    MdCheckbox = __decorate$18([\n        _angular_core.Component({selector: 'md-checkbox',\n            template: \"<label class=\\\"md-checkbox-layout\\\"> <div class=\\\"md-checkbox-inner-container\\\"> <input class=\\\"md-checkbox-input md-visually-hidden\\\" type=\\\"checkbox\\\" [id]=\\\"inputId\\\" [required]=\\\"required\\\" [checked]=\\\"checked\\\" [disabled]=\\\"disabled\\\" [name]=\\\"name\\\" [tabIndex]=\\\"tabindex\\\" [indeterminate]=\\\"indeterminate\\\" [attr.aria-label]=\\\"ariaLabel\\\" [attr.aria-labelledby]=\\\"ariaLabelledby\\\" (focus)=\\\"_onInputFocus()\\\" (blur)=\\\"_onInputBlur()\\\" (change)=\\\"_onInteractionEvent($event)\\\" (click)=\\\"_onInputClick($event)\\\"> <div class=\\\"md-ink-ripple\\\"></div> <div class=\\\"md-checkbox-frame\\\"></div> <div class=\\\"md-checkbox-background\\\"> <svg version=\\\"1.1\\\" class=\\\"md-checkbox-checkmark\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 24 24\\\" xml:space=\\\"preserve\\\"> <path class=\\\"md-checkbox-checkmark-path\\\" fill=\\\"none\\\" stroke=\\\"white\\\" d=\\\"M4.1,12.7 9,17.6 20.3,6.3\\\"/> </svg> <!-- Element for rendering the indeterminate state checkbox. --> <div class=\\\"md-checkbox-mixedmark\\\"></div> </div> </div> <span class=\\\"md-checkbox-label\\\"> <ng-content></ng-content> </span> </label> \",\n            styles: [\"@keyframes md-checkbox-fade-in-background { 0% { opacity: 0; } 50% { opacity: 1; } } @keyframes md-checkbox-fade-out-background { 0%, 50% { opacity: 1; } 100% { opacity: 0; } } @keyframes md-checkbox-unchecked-checked-checkmark-path { 0%, 50% { stroke-dashoffset: 22.91026; } 50% { animation-timing-function: cubic-bezier(0, 0, 0.2, 0.1); } 100% { stroke-dashoffset: 0; } } @keyframes md-checkbox-unchecked-indeterminate-mixedmark { 0%, 68.2% { transform: scaleX(0); } 68.2% { animation-timing-function: cubic-bezier(0, 0, 0, 1); } 100% { transform: scaleX(1); } } @keyframes md-checkbox-checked-unchecked-checkmark-path { from { animation-timing-function: cubic-bezier(0.4, 0, 1, 1); stroke-dashoffset: 0; } to { stroke-dashoffset: -22.91026; } } @keyframes md-checkbox-checked-indeterminate-checkmark { from { animation-timing-function: cubic-bezier(0, 0, 0.2, 0.1); opacity: 1; transform: rotate(0deg); } to { opacity: 0; transform: rotate(45deg); } } @keyframes md-checkbox-indeterminate-checked-checkmark { from { animation-timing-function: cubic-bezier(0.14, 0, 0, 1); opacity: 0; transform: rotate(45deg); } to { opacity: 1; transform: rotate(360deg); } } @keyframes md-checkbox-checked-indeterminate-mixedmark { from { animation-timing-function: cubic-bezier(0, 0, 0.2, 0.1); opacity: 0; transform: rotate(-45deg); } to { opacity: 1; transform: rotate(0deg); } } @keyframes md-checkbox-indeterminate-checked-mixedmark { from { animation-timing-function: cubic-bezier(0.14, 0, 0, 1); opacity: 1; transform: rotate(0deg); } to { opacity: 0; transform: rotate(315deg); } } @keyframes md-checkbox-indeterminate-unchecked-mixedmark { 0% { animation-timing-function: linear; opacity: 1; transform: scaleX(1); } 32.8%, 100% { opacity: 0; transform: scaleX(0); } } .md-checkbox-frame, .md-checkbox-background, .md-checkbox-checkmark { bottom: 0; left: 0; position: absolute; right: 0; top: 0; } .md-checkbox-checkmark, .md-checkbox-mixedmark { width: calc(100% - 4px); } .md-checkbox-frame, .md-checkbox-background { border-radius: 2px; box-sizing: border-box; pointer-events: none; } md-checkbox { cursor: pointer; } .md-checkbox-layout { cursor: inherit; align-items: baseline; display: inline-flex; } .md-checkbox-inner-container { display: inline-block; height: 20px; line-height: 0; margin: auto; margin-right: 8px; order: 0; position: relative; vertical-align: middle; white-space: nowrap; width: 20px; } [dir='rtl'] .md-checkbox-inner-container { margin-left: 8px; margin-right: auto; } .md-checkbox-layout .md-checkbox-label { line-height: 24px; } .md-checkbox-frame { background-color: transparent; border: 2px solid; transition: border-color 90ms cubic-bezier(0, 0, 0.2, 0.1); will-change: border-color; } .md-checkbox-background { align-items: center; display: inline-flex; justify-content: center; transition: background-color 90ms cubic-bezier(0, 0, 0.2, 0.1), opacity 90ms cubic-bezier(0, 0, 0.2, 0.1); will-change: background-color, opacity; } .md-checkbox-checkmark { width: 100%; } .md-checkbox-checkmark-path { stroke-dashoffset: 22.91026; stroke-dasharray: 22.91026; stroke-width: 2.66667px; } .md-checkbox-mixedmark { height: 2px; opacity: 0; transform: scaleX(0) rotate(0deg); } .md-checkbox-align-end .md-checkbox-inner-container { order: 1; margin-left: 8px; margin-right: auto; } [dir='rtl'] .md-checkbox-align-end .md-checkbox-inner-container { margin-left: auto; margin-right: 8px; } .md-checkbox-checked .md-checkbox-checkmark { opacity: 1; } .md-checkbox-checked .md-checkbox-checkmark-path { stroke-dashoffset: 0; } .md-checkbox-checked .md-checkbox-mixedmark { transform: scaleX(1) rotate(-45deg); } .md-checkbox-indeterminate .md-checkbox-checkmark { opacity: 0; transform: rotate(45deg); } .md-checkbox-indeterminate .md-checkbox-checkmark-path { stroke-dashoffset: 0; } .md-checkbox-indeterminate .md-checkbox-mixedmark { opacity: 1; transform: scaleX(1) rotate(0deg); } .md-checkbox-unchecked .md-checkbox-background { background-color: transparent; } .md-checkbox-disabled { cursor: default; } .md-checkbox-anim-unchecked-checked .md-checkbox-background { animation: 180ms linear 0ms md-checkbox-fade-in-background; } .md-checkbox-anim-unchecked-checked .md-checkbox-checkmark-path { animation: 180ms linear 0ms md-checkbox-unchecked-checked-checkmark-path; } .md-checkbox-anim-unchecked-indeterminate .md-checkbox-background { animation: 180ms linear 0ms md-checkbox-fade-in-background; } .md-checkbox-anim-unchecked-indeterminate .md-checkbox-mixedmark { animation: 90ms linear 0ms md-checkbox-unchecked-indeterminate-mixedmark; } .md-checkbox-anim-checked-unchecked .md-checkbox-background { animation: 180ms linear 0ms md-checkbox-fade-out-background; } .md-checkbox-anim-checked-unchecked .md-checkbox-checkmark-path { animation: 90ms linear 0ms md-checkbox-checked-unchecked-checkmark-path; } .md-checkbox-anim-checked-indeterminate .md-checkbox-checkmark { animation: 90ms linear 0ms md-checkbox-checked-indeterminate-checkmark; } .md-checkbox-anim-checked-indeterminate .md-checkbox-mixedmark { animation: 90ms linear 0ms md-checkbox-checked-indeterminate-mixedmark; } .md-checkbox-anim-indeterminate-checked .md-checkbox-checkmark { animation: 500ms linear 0ms md-checkbox-indeterminate-checked-checkmark; } .md-checkbox-anim-indeterminate-checked .md-checkbox-mixedmark { animation: 500ms linear 0ms md-checkbox-indeterminate-checked-mixedmark; } .md-checkbox-anim-indeterminate-unchecked .md-checkbox-background { animation: 180ms linear 0ms md-checkbox-fade-out-background; } .md-checkbox-anim-indeterminate-unchecked .md-checkbox-mixedmark { animation: 300ms linear 0ms md-checkbox-indeterminate-unchecked-mixedmark; } .md-checkbox-input { bottom: 0; left: 50%; } .md-ink-ripple { border-radius: 50%; opacity: 0; height: 48px; left: 50%; overflow: hidden; pointer-events: none; position: absolute; top: 50%; transform: translate(-50%, -50%); transition: opacity ease 280ms, background-color ease 280ms; width: 48px; } .md-checkbox-focused .md-ink-ripple { opacity: 1; } .md-checkbox-disabled .md-ink-ripple { background-color: #000; } /*# sourceMappingURL=checkbox.css.map */ \"],\n            host: {\n                '[class.md-checkbox-indeterminate]': 'indeterminate',\n                '[class.md-checkbox-checked]': 'checked',\n                '[class.md-checkbox-disabled]': 'disabled',\n                '[class.md-checkbox-align-end]': 'align == \"end\"',\n                '[class.md-checkbox-focused]': 'hasFocus',\n            },\n            providers: [MD_CHECKBOX_CONTROL_VALUE_ACCESSOR],\n            encapsulation: _angular_core.ViewEncapsulation.None,\n            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush\n        }), \n        __metadata$18('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])\n    ], MdCheckbox);\n    return MdCheckbox;\n}());\nvar MdCheckboxModule = (function () {\n    function MdCheckboxModule() {\n    }\n    MdCheckboxModule.forRoot = function () {\n        return {\n            ngModule: MdCheckboxModule,\n            providers: []\n        };\n    };\n    MdCheckboxModule = __decorate$18([\n        _angular_core.NgModule({\n            exports: [MdCheckbox],\n            declarations: [MdCheckbox],\n        }), \n        __metadata$18('design:paramtypes', [])\n    ], MdCheckboxModule);\n    return MdCheckboxModule;\n}());\n\nvar __decorate$19 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$19 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param$2 = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\n/**\n * Provider Expression that allows md-radio-group to register as a ControlValueAccessor. This\n * allows it to support [(ngModel)] and ngControl.\n */\nvar MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = {\n    provide: _angular_forms.NG_VALUE_ACCESSOR,\n    useExisting: _angular_core.forwardRef(function () { return MdRadioGroup; }),\n    multi: true\n};\n// TODO(mtlin):\n// Ink ripple is currently placeholder.\n// Determine motion spec for button transitions.\n// Design review.\n// RTL\n// Support forms API.\n// Use ChangeDetectionStrategy.OnPush\nvar _uniqueIdCounter$1 = 0;\n/** A simple change event emitted by either MdRadioButton or MdRadioGroup. */\nvar MdRadioChange = (function () {\n    function MdRadioChange() {\n    }\n    return MdRadioChange;\n}());\nvar MdRadioGroup = (function () {\n    function MdRadioGroup() {\n        /**\n         * Selected value for group. Should equal the value of the selected radio button if there *is*\n         * a corresponding radio button with a matching value. If there is *not* such a corresponding\n         * radio button, this value persists to be applied in case a new radio button is added with a\n         * matching value.\n         */\n        this._value = null;\n        /** The HTML name attribute applied to radio buttons in this group. */\n        this._name = \"md-radio-group-\" + _uniqueIdCounter$1++;\n        /** Disables all individual radio buttons assigned to this group. */\n        this._disabled = false;\n        /** The currently selected radio button. Should match value. */\n        this._selected = null;\n        /** Whether the `value` has been set to its initial value. */\n        this._isInitialized = false;\n        /** The method to be called in order to update ngModel */\n        this._controlValueAccessorChangeFn = function (value) { };\n        /** onTouch function registered via registerOnTouch (ControlValueAccessor). */\n        this.onTouched = function () { };\n        /** Event emitted when the group value changes. */\n        this.change = new _angular_core.EventEmitter();\n        /** Child radio buttons. */\n        this._radios = null;\n    }\n    Object.defineProperty(MdRadioGroup.prototype, \"name\", {\n        get: function () {\n            return this._name;\n        },\n        set: function (value) {\n            this._name = value;\n            this._updateRadioButtonNames();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdRadioGroup.prototype, \"disabled\", {\n        get: function () {\n            return this._disabled;\n        },\n        set: function (value) {\n            // The presence of *any* disabled value makes the component disabled, *except* for false.\n            this._disabled = (value != null && value !== false) ? true : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdRadioGroup.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        set: function (newValue) {\n            if (this._value != newValue) {\n                // Set this before proceeding to ensure no circular loop occurs with selection.\n                this._value = newValue;\n                this._updateSelectedRadioFromValue();\n                // Only fire a change event if this isn't the first time the value is ever set.\n                if (this._isInitialized) {\n                    this._emitChangeEvent();\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdRadioGroup.prototype, \"selected\", {\n        get: function () {\n            return this._selected;\n        },\n        set: function (selected) {\n            this._selected = selected;\n            this.value = selected ? selected.value : null;\n            if (selected && !selected.checked) {\n                selected.checked = true;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initialize properties once content children are available.\n     * This allows us to propagate relevant attributes to associated buttons.\n     * TODO: internal\n     */\n    MdRadioGroup.prototype.ngAfterContentInit = function () {\n        // Mark this component as initialized in AfterContentInit because the initial value can\n        // possibly be set by NgModel on MdRadioGroup, and it is possible that the OnInit of the\n        // NgModel occurs *after* the OnInit of the MdRadioGroup.\n        this._isInitialized = true;\n    };\n    /**\n     * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n     * radio buttons upon their blur.\n     */\n    MdRadioGroup.prototype._touch = function () {\n        if (this.onTouched) {\n            this.onTouched();\n        }\n    };\n    MdRadioGroup.prototype._updateRadioButtonNames = function () {\n        var _this = this;\n        if (this._radios) {\n            this._radios.forEach(function (radio) {\n                radio.name = _this.name;\n            });\n        }\n    };\n    /** Updates the `selected` radio button from the internal _value state. */\n    MdRadioGroup.prototype._updateSelectedRadioFromValue = function () {\n        var _this = this;\n        // If the value already matches the selected radio, do nothing.\n        var isAlreadySelected = this._selected != null && this._selected.value == this._value;\n        if (this._radios != null && !isAlreadySelected) {\n            var matchingRadio = this._radios.filter(function (radio) { return radio.value == _this._value; })[0];\n            if (matchingRadio) {\n                this.selected = matchingRadio;\n            }\n            else if (this.value == null) {\n                this.selected = null;\n                this._radios.forEach(function (radio) { radio.checked = false; });\n            }\n        }\n    };\n    /** Dispatch change event with current selection and group value. */\n    MdRadioGroup.prototype._emitChangeEvent = function () {\n        var event = new MdRadioChange();\n        event.source = this._selected;\n        event.value = this._value;\n        this._controlValueAccessorChangeFn(event.value);\n        this.change.emit(event);\n    };\n    /**\n      * Implemented as part of ControlValueAccessor.\n      * TODO: internal\n      */\n    MdRadioGroup.prototype.writeValue = function (value) {\n        this.value = value;\n    };\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * TODO: internal\n     */\n    MdRadioGroup.prototype.registerOnChange = function (fn) {\n        this._controlValueAccessorChangeFn = fn;\n    };\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * TODO: internal\n     */\n    MdRadioGroup.prototype.registerOnTouched = function (fn) {\n        this.onTouched = fn;\n    };\n    __decorate$19([\n        _angular_core.Output(), \n        __metadata$19('design:type', _angular_core.EventEmitter)\n    ], MdRadioGroup.prototype, \"change\", void 0);\n    __decorate$19([\n        _angular_core.ContentChildren(_angular_core.forwardRef(function () { return MdRadioButton; })), \n        __metadata$19('design:type', _angular_core.QueryList)\n    ], MdRadioGroup.prototype, \"_radios\", void 0);\n    __decorate$19([\n        _angular_core.Input(), \n        __metadata$19('design:type', String)\n    ], MdRadioGroup.prototype, \"name\", null);\n    __decorate$19([\n        _angular_core.Input(), \n        __metadata$19('design:type', Object)\n    ], MdRadioGroup.prototype, \"align\", void 0);\n    __decorate$19([\n        _angular_core.Input(), \n        __metadata$19('design:type', Boolean)\n    ], MdRadioGroup.prototype, \"disabled\", null);\n    __decorate$19([\n        _angular_core.Input(), \n        __metadata$19('design:type', Object)\n    ], MdRadioGroup.prototype, \"value\", null);\n    __decorate$19([\n        _angular_core.Input(), \n        __metadata$19('design:type', Object)\n    ], MdRadioGroup.prototype, \"selected\", null);\n    MdRadioGroup = __decorate$19([\n        _angular_core.Directive({\n            selector: 'md-radio-group',\n            providers: [MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR],\n            host: {\n                'role': 'radiogroup',\n            },\n        }), \n        __metadata$19('design:paramtypes', [])\n    ], MdRadioGroup);\n    return MdRadioGroup;\n}());\nvar MdRadioButton = (function () {\n    function MdRadioButton(radioGroup, radioDispatcher) {\n        // Assertions. Ideally these should be stripped out by the compiler.\n        // TODO(jelbourn): Assert that there's no name binding AND a parent radio group.\n        var _this = this;\n        this.radioDispatcher = radioDispatcher;\n        /** Whether this radio is checked. */\n        this._checked = false;\n        /** The unique ID for the radio button. */\n        this.id = \"md-radio-\" + _uniqueIdCounter$1++;\n        /** Value assigned to this radio.*/\n        this._value = null;\n        /** Event emitted when the group value changes. */\n        this.change = new _angular_core.EventEmitter();\n        this.radioGroup = radioGroup;\n        radioDispatcher.listen(function (id, name) {\n            if (id != _this.id && name == _this.name) {\n                _this.checked = false;\n            }\n        });\n    }\n    Object.defineProperty(MdRadioButton.prototype, \"inputId\", {\n        get: function () {\n            return this.id + \"-input\";\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdRadioButton.prototype, \"checked\", {\n        get: function () {\n            return this._checked;\n        },\n        set: function (newCheckedState) {\n            if (newCheckedState) {\n                // Notify all radio buttons with the same name to un-check.\n                this.radioDispatcher.notify(this.id, this.name);\n            }\n            this._checked = newCheckedState;\n            if (newCheckedState && this.radioGroup && this.radioGroup.value != this.value) {\n                this.radioGroup.selected = this;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdRadioButton.prototype, \"value\", {\n        /** MdRadioGroup reads this to assign its own value. */\n        get: function () {\n            return this._value;\n        },\n        set: function (value) {\n            if (this._value != value) {\n                if (this.radioGroup != null && this.checked) {\n                    this.radioGroup.value = value;\n                }\n                this._value = value;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdRadioButton.prototype, \"align\", {\n        get: function () {\n            return this._align || (this.radioGroup != null && this.radioGroup.align) || 'start';\n        },\n        set: function (value) {\n            this._align = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdRadioButton.prototype, \"disabled\", {\n        get: function () {\n            return this._disabled || (this.radioGroup != null && this.radioGroup.disabled);\n        },\n        set: function (value) {\n            // The presence of *any* disabled value makes the component disabled, *except* for false.\n            this._disabled = (value != null && value !== false) ? true : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** TODO: internal */\n    MdRadioButton.prototype.ngOnInit = function () {\n        if (this.radioGroup) {\n            // If the radio is inside a radio group, determine if it should be checked\n            this.checked = this.radioGroup.value === this._value;\n            // Copy name from parent radio group\n            this.name = this.radioGroup.name;\n        }\n    };\n    /** Dispatch change event with current value. */\n    MdRadioButton.prototype._emitChangeEvent = function () {\n        var event = new MdRadioChange();\n        event.source = this;\n        event.value = this._value;\n        this.change.emit(event);\n    };\n    /**\n     * We use a hidden native input field to handle changes to focus state via keyboard navigation,\n     * with visual rendering done separately. The native element is kept in sync with the overall\n     * state of the component.\n     */\n    MdRadioButton.prototype._onInputFocus = function () {\n        this._isFocused = true;\n    };\n    /** TODO: internal */\n    MdRadioButton.prototype._onInputBlur = function () {\n        this._isFocused = false;\n        if (this.radioGroup) {\n            this.radioGroup._touch();\n        }\n    };\n    /** TODO: internal */\n    MdRadioButton.prototype._onInputClick = function (event) {\n        // We have to stop propagation for click events on the visual hidden input element.\n        // By default, when a user clicks on a label element, a generated click event will be\n        // dispatched on the associated input element. Since we are using a label element as our\n        // root container, the click event on the `radio-button` will be executed twice.\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\n        // This will lead to multiple click events.\n        // Preventing bubbling for the second event will solve that issue.\n        event.stopPropagation();\n    };\n    /**\n     * Triggered when the radio button received a click or the input recognized any change.\n     * Clicking on a label element, will trigger a change event on the associated input.\n     * TODO: internal\n     */\n    MdRadioButton.prototype._onInputChange = function (event) {\n        // We always have to stop propagation on the change event.\n        // Otherwise the change event, from the input element, will bubble up and\n        // emit its event object to the `change` output.\n        event.stopPropagation();\n        this.checked = true;\n        this._emitChangeEvent();\n        if (this.radioGroup) {\n            this.radioGroup._touch();\n        }\n    };\n    __decorate$19([\n        _angular_core.HostBinding('class.md-radio-focused'), \n        __metadata$19('design:type', Boolean)\n    ], MdRadioButton.prototype, \"_isFocused\", void 0);\n    __decorate$19([\n        _angular_core.HostBinding('id'),\n        _angular_core.Input(), \n        __metadata$19('design:type', String)\n    ], MdRadioButton.prototype, \"id\", void 0);\n    __decorate$19([\n        _angular_core.Input(), \n        __metadata$19('design:type', String)\n    ], MdRadioButton.prototype, \"name\", void 0);\n    __decorate$19([\n        _angular_core.Input('aria-label'), \n        __metadata$19('design:type', String)\n    ], MdRadioButton.prototype, \"ariaLabel\", void 0);\n    __decorate$19([\n        _angular_core.Input('aria-labelledby'), \n        __metadata$19('design:type', String)\n    ], MdRadioButton.prototype, \"ariaLabelledby\", void 0);\n    __decorate$19([\n        _angular_core.Output(), \n        __metadata$19('design:type', _angular_core.EventEmitter)\n    ], MdRadioButton.prototype, \"change\", void 0);\n    __decorate$19([\n        _angular_core.HostBinding('class.md-radio-checked'),\n        _angular_core.Input(), \n        __metadata$19('design:type', Boolean)\n    ], MdRadioButton.prototype, \"checked\", null);\n    __decorate$19([\n        _angular_core.Input(), \n        __metadata$19('design:type', Object)\n    ], MdRadioButton.prototype, \"value\", null);\n    __decorate$19([\n        _angular_core.Input(), \n        __metadata$19('design:type', Object)\n    ], MdRadioButton.prototype, \"align\", null);\n    __decorate$19([\n        _angular_core.HostBinding('class.md-radio-disabled'),\n        _angular_core.Input(), \n        __metadata$19('design:type', Boolean)\n    ], MdRadioButton.prototype, \"disabled\", null);\n    MdRadioButton = __decorate$19([\n        _angular_core.Component({selector: 'md-radio-button',\n            template: \"<!-- TODO(jelbourn): render the radio on either side of the content --> <!-- TODO(mtlin): Evaluate trade-offs of using native radio vs. cost of additional bindings. --> <label [attr.for]=\\\"inputId\\\" class=\\\"md-radio-label\\\"> <!-- The actual 'radio' part of the control. --> <div class=\\\"md-radio-container\\\"> <div class=\\\"md-radio-outer-circle\\\"></div> <div class=\\\"md-radio-inner-circle\\\"></div> <div class=\\\"md-ink-ripple\\\"></div> </div> <input #input class=\\\"md-radio-input md-visually-hidden\\\" type=\\\"radio\\\" [id]=\\\"inputId\\\" [checked]=\\\"checked\\\" [disabled]=\\\"disabled\\\" [name]=\\\"name\\\" [attr.aria-label]=\\\"ariaLabel\\\" [attr.aria-labelledby]=\\\"ariaLabelledby\\\" (change)=\\\"_onInputChange($event)\\\" (focus)=\\\"_onInputFocus()\\\" (blur)=\\\"_onInputBlur()\\\" (click)=\\\"_onInputClick($event)\\\"> <!-- The label content for radio control. --> <div class=\\\"md-radio-label-content\\\" [class.md-radio-align-end]=\\\"align == 'end'\\\"> <ng-content></ng-content> </div> </label> \",\n            styles: [\"md-radio-button { display: inline-block; } .md-radio-label { cursor: pointer; display: inline-flex; align-items: baseline; white-space: nowrap; } .md-radio-container { box-sizing: border-box; display: inline-block; height: 20px; position: relative; width: 20px; top: 2px; } .md-radio-outer-circle { border: solid 2px; border-radius: 50%; box-sizing: border-box; height: 20px; left: 0; position: absolute; top: 0; transition: border-color ease 280ms; width: 20px; } .md-radio-inner-circle { border-radius: 50%; box-sizing: border-box; height: 20px; left: 0; position: absolute; top: 0; transition: transform ease 280ms, background-color ease 280ms; transform: scale(0); width: 20px; } .md-radio-checked .md-radio-inner-circle { transform: scale(0.5); } .md-radio-label-content { display: inline-block; order: 0; line-height: inherit; padding-left: 8px; padding-right: 0; } [dir='rtl'] .md-radio-label-content { padding-right: 8px; padding-left: 0; } .md-radio-label-content.md-radio-align-end { order: -1; padding-left: 0; padding-right: 8px; } [dir='rtl'] .md-radio-label-content.md-radio-align-end { padding-right: 0; padding-left: 8px; } .md-radio-disabled, .md-radio-disabled .md-radio-label { cursor: default; } .md-ink-ripple { border-radius: 50%; opacity: 0; height: 48px; left: 50%; overflow: hidden; pointer-events: none; position: absolute; top: 50%; transform: translate(-50%, -50%); transition: opacity ease 280ms, background-color ease 280ms; width: 48px; } .md-radio-focused .md-ink-ripple { opacity: 1; } .md-radio-disabled .md-ink-ripple { background-color: #000; } /*# sourceMappingURL=radio.css.map */ \"],\n            encapsulation: _angular_core.ViewEncapsulation.None\n        }),\n        __param$2(0, _angular_core.Optional()), \n        __metadata$19('design:paramtypes', [MdRadioGroup, MdUniqueSelectionDispatcher])\n    ], MdRadioButton);\n    return MdRadioButton;\n}());\nvar MdRadioModule = (function () {\n    function MdRadioModule() {\n    }\n    MdRadioModule.forRoot = function () {\n        return {\n            ngModule: MdRadioModule,\n            providers: [MdUniqueSelectionDispatcher],\n        };\n    };\n    MdRadioModule = __decorate$19([\n        _angular_core.NgModule({\n            exports: [MdRadioGroup, MdRadioButton],\n            declarations: [MdRadioGroup, MdRadioButton],\n        }), \n        __metadata$19('design:paramtypes', [])\n    ], MdRadioModule);\n    return MdRadioModule;\n}());\n\nvar __decorate$21 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$21 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar MdSelect = (function () {\n    function MdSelect() {\n    }\n    MdSelect = __decorate$21([\n        _angular_core.Component({selector: 'md-select',\n            template: \"I'm a select!\",\n            styles: [\" /*# sourceMappingURL=select.css.map */ \"],\n            encapsulation: _angular_core.ViewEncapsulation.None\n        }), \n        __metadata$21('design:paramtypes', [])\n    ], MdSelect);\n    return MdSelect;\n}());\n\nvar __decorate$20 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$20 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar MdSelectModule = (function () {\n    function MdSelectModule() {\n    }\n    MdSelectModule.forRoot = function () {\n        return {\n            ngModule: MdSelectModule,\n            providers: []\n        };\n    };\n    MdSelectModule = __decorate$20([\n        _angular_core.NgModule({\n            imports: [],\n            exports: [MdSelect],\n            declarations: [MdSelect],\n        }), \n        __metadata$20('design:paramtypes', [])\n    ], MdSelectModule);\n    return MdSelectModule;\n}());\n\nvar __decorate$22 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$22 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar MD_SLIDE_TOGGLE_VALUE_ACCESSOR = {\n    provide: _angular_forms.NG_VALUE_ACCESSOR,\n    useExisting: _angular_core.forwardRef(function () { return MdSlideToggle; }),\n    multi: true\n};\n// A simple change event emitted by the MdSlideToggle component.\nvar MdSlideToggleChange = (function () {\n    function MdSlideToggleChange() {\n    }\n    return MdSlideToggleChange;\n}());\n// Increasing integer for generating unique ids for slide-toggle components.\nvar nextId$1 = 0;\nvar MdSlideToggle = (function () {\n    function MdSlideToggle(_elementRef, _renderer) {\n        var _this = this;\n        this._elementRef = _elementRef;\n        this._renderer = _renderer;\n        this.onChange = function (_) { };\n        this.onTouched = function () { };\n        // A unique id for the slide-toggle. By default the id is auto-generated.\n        this._uniqueId = \"md-slide-toggle-\" + ++nextId$1;\n        this._checked = false;\n        this._hasFocus = false;\n        this._isMousedown = false;\n        this._slideRenderer = null;\n        this.disabled = false;\n        this.required = false;\n        this.name = null;\n        this.id = this._uniqueId;\n        this.tabIndex = 0;\n        this.ariaLabel = null;\n        this.ariaLabelledby = null;\n        this._change = new _angular_core.EventEmitter();\n        this.change = this._change.asObservable();\n        // Returns the unique id for the visual hidden input.\n        this.getInputId = function () { return ((_this.id || _this._uniqueId) + \"-input\"); };\n    }\n    /** TODO: internal */\n    MdSlideToggle.prototype.ngAfterContentInit = function () {\n        this._slideRenderer = new SlideToggleRenderer(this._elementRef);\n    };\n    /**\n     * The onChangeEvent method will be also called on click.\n     * This is because everything for the slide-toggle is wrapped inside of a label,\n     * which triggers a onChange event on click.\n     */\n    MdSlideToggle.prototype._onChangeEvent = function (event) {\n        // We always have to stop propagation on the change event.\n        // Otherwise the change event, from the input element, will bubble up and\n        // emit its event object to the component's `change` output.\n        event.stopPropagation();\n        // Once a drag is currently in progress, we do not want to toggle the slide-toggle on a click.\n        if (!this.disabled && !this._slideRenderer.isDragging()) {\n            this.toggle();\n            // Emit our custom change event if the native input emitted one.\n            // It is important to only emit it, if the native input triggered one, because\n            // we don't want to trigger a change event, when the `checked` variable changes for example.\n            this._emitChangeEvent();\n        }\n    };\n    MdSlideToggle.prototype._onInputClick = function (event) {\n        this.onTouched();\n        // We have to stop propagation for click events on the visual hidden input element.\n        // By default, when a user clicks on a label element, a generated click event will be\n        // dispatched on the associated input element. Since we are using a label element as our\n        // root container, the click event on the `slide-toggle` will be executed twice.\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\n        // This will lead to multiple click events.\n        // Preventing bubbling for the second event will solve that issue.\n        event.stopPropagation();\n    };\n    MdSlideToggle.prototype._setMousedown = function () {\n        var _this = this;\n        // We only *show* the focus style when focus has come to the button via the keyboard.\n        // The Material Design spec is silent on this topic, and without doing this, the\n        // button continues to look :active after clicking.\n        // @see http://marcysutton.com/button-focus-hell/\n        this._isMousedown = true;\n        setTimeout(function () { return _this._isMousedown = false; }, 100);\n    };\n    MdSlideToggle.prototype._onInputFocus = function () {\n        // Only show the focus / ripple indicator when the focus was not triggered by a mouse\n        // interaction on the component.\n        if (!this._isMousedown) {\n            this._hasFocus = true;\n        }\n    };\n    MdSlideToggle.prototype._onInputBlur = function () {\n        this._hasFocus = false;\n        this.onTouched();\n    };\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * TODO: internal\n     */\n    MdSlideToggle.prototype.writeValue = function (value) {\n        this.checked = value;\n    };\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * TODO: internal\n     */\n    MdSlideToggle.prototype.registerOnChange = function (fn) {\n        this.onChange = fn;\n    };\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * TODO: internal\n     */\n    MdSlideToggle.prototype.registerOnTouched = function (fn) {\n        this.onTouched = fn;\n    };\n    Object.defineProperty(MdSlideToggle.prototype, \"checked\", {\n        get: function () {\n            return !!this._checked;\n        },\n        set: function (value) {\n            if (this.checked !== !!value) {\n                this._checked = value;\n                this.onChange(this._checked);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdSlideToggle.prototype, \"color\", {\n        get: function () {\n            return this._color;\n        },\n        set: function (value) {\n            this._updateColor(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MdSlideToggle.prototype.toggle = function () {\n        this.checked = !this.checked;\n    };\n    MdSlideToggle.prototype._updateColor = function (newColor) {\n        this._setElementColor(this._color, false);\n        this._setElementColor(newColor, true);\n        this._color = newColor;\n    };\n    MdSlideToggle.prototype._setElementColor = function (color, isAdd) {\n        if (color != null && color != '') {\n            this._renderer.setElementClass(this._elementRef.nativeElement, \"md-\" + color, isAdd);\n        }\n    };\n    /** Emits the change event to the `change` output EventEmitter */\n    MdSlideToggle.prototype._emitChangeEvent = function () {\n        var event = new MdSlideToggleChange();\n        event.source = this;\n        event.checked = this.checked;\n        this._change.emit(event);\n    };\n    /** TODO: internal */\n    MdSlideToggle.prototype._onDragStart = function () {\n        this._slideRenderer.startThumbDrag(this.checked);\n    };\n    /** TODO: internal */\n    MdSlideToggle.prototype._onDrag = function (event) {\n        this._slideRenderer.updateThumbPosition(event.deltaX);\n    };\n    /** TODO: internal */\n    MdSlideToggle.prototype._onDragEnd = function () {\n        var _this = this;\n        // Notice that we have to stop outside of the current event handler,\n        // because otherwise the click event will be fired and will reset the new checked variable.\n        setTimeout(function () {\n            _this.checked = _this._slideRenderer.stopThumbDrag();\n        }, 0);\n    };\n    __decorate$22([\n        _angular_core.Input(),\n        BooleanFieldValue(), \n        __metadata$22('design:type', Boolean)\n    ], MdSlideToggle.prototype, \"disabled\", void 0);\n    __decorate$22([\n        _angular_core.Input(),\n        BooleanFieldValue(), \n        __metadata$22('design:type', Boolean)\n    ], MdSlideToggle.prototype, \"required\", void 0);\n    __decorate$22([\n        _angular_core.Input(), \n        __metadata$22('design:type', String)\n    ], MdSlideToggle.prototype, \"name\", void 0);\n    __decorate$22([\n        _angular_core.Input(), \n        __metadata$22('design:type', String)\n    ], MdSlideToggle.prototype, \"id\", void 0);\n    __decorate$22([\n        _angular_core.Input(), \n        __metadata$22('design:type', Number)\n    ], MdSlideToggle.prototype, \"tabIndex\", void 0);\n    __decorate$22([\n        _angular_core.Input(), \n        __metadata$22('design:type', String)\n    ], MdSlideToggle.prototype, \"ariaLabel\", void 0);\n    __decorate$22([\n        _angular_core.Input(), \n        __metadata$22('design:type', String)\n    ], MdSlideToggle.prototype, \"ariaLabelledby\", void 0);\n    __decorate$22([\n        _angular_core.Output(), \n        __metadata$22('design:type', rxjs_Observable.Observable)\n    ], MdSlideToggle.prototype, \"change\", void 0);\n    __decorate$22([\n        _angular_core.Input(), \n        __metadata$22('design:type', Object)\n    ], MdSlideToggle.prototype, \"checked\", null);\n    __decorate$22([\n        _angular_core.Input(), \n        __metadata$22('design:type', String)\n    ], MdSlideToggle.prototype, \"color\", null);\n    MdSlideToggle = __decorate$22([\n        _angular_core.Component({selector: 'md-slide-toggle',\n            host: {\n                '[class.md-checked]': 'checked',\n                '[class.md-disabled]': 'disabled',\n                // This md-slide-toggle prefix will change, once the temporary ripple is removed.\n                '[class.md-slide-toggle-focused]': '_hasFocus',\n                '(mousedown)': '_setMousedown()'\n            },\n            template: \"<label class=\\\"md-slide-toggle-label\\\"> <div class=\\\"md-slide-toggle-container\\\"> <div class=\\\"md-slide-toggle-bar\\\"></div> <div class=\\\"md-slide-toggle-thumb-container\\\" (slidestart)=\\\"_onDragStart()\\\" (slide)=\\\"_onDrag($event)\\\" (slideend)=\\\"_onDragEnd()\\\"> <div class=\\\"md-slide-toggle-thumb\\\"> <div class=\\\"md-ink-ripple\\\"></div> </div> </div> <input #input class=\\\"md-slide-toggle-input md-visually-hidden\\\" type=\\\"checkbox\\\" [id]=\\\"getInputId()\\\" [required]=\\\"required\\\" [tabIndex]=\\\"tabIndex\\\" [checked]=\\\"checked\\\" [disabled]=\\\"disabled\\\" [attr.name]=\\\"name\\\" [attr.aria-label]=\\\"ariaLabel\\\" [attr.aria-labelledby]=\\\"ariaLabelledby\\\" (blur)=\\\"_onInputBlur()\\\" (focus)=\\\"_onInputFocus()\\\" (change)=\\\"_onChangeEvent($event)\\\" (click)=\\\"_onInputClick($event)\\\"> </div> <span class=\\\"md-slide-toggle-content\\\"> <ng-content></ng-content> </span> </label> \",\n            styles: [\":host { display: flex; height: 24px; margin: 16px 0; line-height: 24px; white-space: nowrap; user-select: none; outline: none; } :host.md-checked .md-slide-toggle-thumb-container { transform: translate3d(100%, 0, 0); } :host .md-ink-ripple { border-radius: 50%; opacity: 0; height: 48px; left: 50%; overflow: hidden; pointer-events: none; position: absolute; top: 50%; transform: translate(-50%, -50%); transition: opacity ease 280ms, background-color ease 280ms; width: 48px; } :host.md-slide-toggle-focused .md-ink-ripple { opacity: 1; } :host.md-slide-toggle-disabled .md-ink-ripple { background-color: #000; } :host.md-disabled .md-slide-toggle-label, :host.md-disabled .md-slide-toggle-container { cursor: default; } .md-slide-toggle-content { font-size: 14px; font-family: Roboto, \\\"Helvetica Neue\\\", sans-serif; font-weight: 500; } .md-slide-toggle-label { display: flex; flex: 1; cursor: pointer; } .md-slide-toggle-container { cursor: grab; width: 36px; height: 24px; position: relative; user-select: none; margin-right: 8px; } .md-slide-toggle-thumb-container { position: absolute; top: 2px; left: 0; z-index: 1; width: 16px; transform: translate3d(0, 0, 0); transition: all 80ms linear; transition-property: transform; } .md-slide-toggle-thumb-container.md-dragging { transition-duration: 0ms; } .md-slide-toggle-thumb { position: absolute; margin: 0; left: 0; top: 0; height: 20px; width: 20px; border-radius: 50%; box-shadow: 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12); } .md-slide-toggle-bar { position: absolute; left: 1px; top: 5px; width: 34px; height: 14px; border-radius: 8px; } .md-slide-toggle-input { bottom: 0; left: 10px; } .md-slide-toggle-bar, .md-slide-toggle-thumb { transition: all 80ms linear; transition-property: background-color; transition-delay: 50ms; } /*# sourceMappingURL=slide-toggle.css.map */ \"],\n            providers: [MD_SLIDE_TOGGLE_VALUE_ACCESSOR],\n            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush\n        }), \n        __metadata$22('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])\n    ], MdSlideToggle);\n    return MdSlideToggle;\n}());\n/**\n * Renderer for the Slide Toggle component, which separates DOM modification in its own class\n */\nvar SlideToggleRenderer = (function () {\n    function SlideToggleRenderer(_elementRef) {\n        this._elementRef = _elementRef;\n        this._thumbEl = _elementRef.nativeElement.querySelector('.md-slide-toggle-thumb-container');\n        this._thumbBarEl = _elementRef.nativeElement.querySelector('.md-slide-toggle-bar');\n    }\n    /** Whether the slide-toggle is currently dragging. */\n    SlideToggleRenderer.prototype.isDragging = function () {\n        return !!this._thumbBarWidth;\n    };\n    /** Initializes the drag of the slide-toggle. */\n    SlideToggleRenderer.prototype.startThumbDrag = function (checked) {\n        if (!this._thumbBarWidth) {\n            this._thumbBarWidth = this._thumbBarEl.clientWidth - this._thumbEl.clientWidth;\n            this._checked = checked;\n            this._thumbEl.classList.add('md-dragging');\n        }\n    };\n    /** Stops the current drag and returns the new checked value. */\n    SlideToggleRenderer.prototype.stopThumbDrag = function () {\n        if (this._thumbBarWidth) {\n            this._thumbBarWidth = null;\n            this._thumbEl.classList.remove('md-dragging');\n            applyCssTransform(this._thumbEl, '');\n            return this._percentage > 50;\n        }\n    };\n    /** Updates the thumb containers position from the specified distance. */\n    SlideToggleRenderer.prototype.updateThumbPosition = function (distance) {\n        if (this._thumbBarWidth) {\n            this._percentage = this._getThumbPercentage(distance);\n            applyCssTransform(this._thumbEl, \"translate3d(\" + this._percentage + \"%, 0, 0)\");\n        }\n    };\n    /** Retrieves the percentage of thumb from the moved distance. */\n    SlideToggleRenderer.prototype._getThumbPercentage = function (distance) {\n        var percentage = (distance / this._thumbBarWidth) * 100;\n        // When the toggle was initially checked, then we have to start the drag at the end.\n        if (this._checked) {\n            percentage += 100;\n        }\n        return Math.max(0, Math.min(percentage, 100));\n    };\n    return SlideToggleRenderer;\n}());\nvar MdSlideToggleModule = (function () {\n    function MdSlideToggleModule() {\n    }\n    MdSlideToggleModule.forRoot = function () {\n        return {\n            ngModule: MdSlideToggleModule,\n            providers: [{ provide: _angular_platformBrowser.HAMMER_GESTURE_CONFIG, useClass: MdGestureConfig }]\n        };\n    };\n    MdSlideToggleModule = __decorate$22([\n        _angular_core.NgModule({\n            imports: [_angular_forms.FormsModule],\n            exports: [MdSlideToggle],\n            declarations: [MdSlideToggle],\n        }), \n        __metadata$22('design:paramtypes', [])\n    ], MdSlideToggleModule);\n    return MdSlideToggleModule;\n}());\n\nvar __decorate$23 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$23 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/**\n * Visually, a 30px separation between tick marks looks best. This is very subjective but it is\n * the default separation we chose.\n */\nvar MIN_AUTO_TICK_SEPARATION = 30;\n/**\n * Provider Expression that allows md-slider to register as a ControlValueAccessor.\n * This allows it to support [(ngModel)] and [formControl].\n */\nvar MD_SLIDER_VALUE_ACCESSOR = {\n    provide: _angular_forms.NG_VALUE_ACCESSOR,\n    useExisting: _angular_core.forwardRef(function () { return MdSlider; }),\n    multi: true\n};\nvar MdSlider = (function () {\n    function MdSlider(elementRef) {\n        /** A renderer to handle updating the slider's thumb and fill track. */\n        this._renderer = null;\n        /** The dimensions of the slider. */\n        this._sliderDimensions = null;\n        this.disabled = false;\n        /** Whether or not to show the thumb label. */\n        this.thumbLabel = false;\n        /** The miniumum value that the slider can have. */\n        this._min = 0;\n        /** The maximum value that the slider can have. */\n        this._max = 100;\n        /** The percentage of the slider that coincides with the value. */\n        this._percent = 0;\n        this._controlValueAccessorChangeFn = function (value) { };\n        /** onTouch function registered via registerOnTouch (ControlValueAccessor). */\n        this.onTouched = function () { };\n        /** The values at which the thumb will snap. */\n        this.step = 1;\n        /**\n         * Whether or not the thumb is sliding.\n         * Used to determine if there should be a transition for the thumb and fill track.\n         * TODO: internal\n         */\n        this.isSliding = false;\n        /**\n         * Whether or not the slider is active (clicked or sliding).\n         * Used to shrink and grow the thumb as according to the Material Design spec.\n         * TODO: internal\n         */\n        this.isActive = false;\n        /** Indicator for if the value has been set or not. */\n        this._isInitialized = false;\n        /** Value of the slider. */\n        this._value = 0;\n        this._renderer = new SliderRenderer(elementRef);\n    }\n    Object.defineProperty(MdSlider.prototype, \"min\", {\n        get: function () {\n            return this._min;\n        },\n        set: function (v) {\n            // This has to be forced as a number to handle the math later.\n            this._min = Number(v);\n            // If the value wasn't explicitly set by the user, set it to the min.\n            if (!this._isInitialized) {\n                this.value = this._min;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdSlider.prototype, \"max\", {\n        get: function () {\n            return this._max;\n        },\n        set: function (v) {\n            this._max = Number(v);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdSlider.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        set: function (v) {\n            // Only set the value to a valid number. v is casted to an any as we know it will come in as a\n            // string but it is labeled as a number which causes parseFloat to not accept it.\n            if (isNaN(parseFloat(v))) {\n                return;\n            }\n            this._value = Number(v);\n            this._isInitialized = true;\n            this._controlValueAccessorChangeFn(this._value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Once the slider has rendered, grab the dimensions and update the position of the thumb and\n     * fill track.\n     * TODO: internal\n     */\n    MdSlider.prototype.ngAfterContentInit = function () {\n        this._sliderDimensions = this._renderer.getSliderDimensions();\n        // This needs to be called after content init because the value can be set to the min if the\n        // value itself isn't set. If this happens, the control value accessor needs to be updated.\n        this._controlValueAccessorChangeFn(this.value);\n        this.snapThumbToValue();\n        this._updateTickSeparation();\n    };\n    /** TODO: internal */\n    MdSlider.prototype.onClick = function (event) {\n        if (this.disabled) {\n            return;\n        }\n        this.isActive = true;\n        this.isSliding = false;\n        this._renderer.addFocus();\n        this.updateValueFromPosition(event.clientX);\n        this.snapThumbToValue();\n    };\n    /** TODO: internal */\n    MdSlider.prototype.onSlide = function (event) {\n        if (this.disabled) {\n            return;\n        }\n        // Prevent the slide from selecting anything else.\n        event.preventDefault();\n        this.updateValueFromPosition(event.center.x);\n    };\n    /** TODO: internal */\n    MdSlider.prototype.onSlideStart = function (event) {\n        if (this.disabled) {\n            return;\n        }\n        event.preventDefault();\n        this.isSliding = true;\n        this.isActive = true;\n        this._renderer.addFocus();\n        this.updateValueFromPosition(event.center.x);\n    };\n    /** TODO: internal */\n    MdSlider.prototype.onSlideEnd = function () {\n        this.isSliding = false;\n        this.snapThumbToValue();\n    };\n    /** TODO: internal */\n    MdSlider.prototype.onResize = function () {\n        this.isSliding = true;\n        this._sliderDimensions = this._renderer.getSliderDimensions();\n        // Skip updating the value and position as there is no new placement.\n        this._renderer.updateThumbAndFillPosition(this._percent, this._sliderDimensions.width);\n    };\n    /** TODO: internal */\n    MdSlider.prototype.onBlur = function () {\n        this.isActive = false;\n        this.onTouched();\n    };\n    /**\n     * When the value changes without a physical position, the percentage needs to be recalculated\n     * independent of the physical location.\n     * This is also used to move the thumb to a snapped value once sliding is done.\n     */\n    MdSlider.prototype.updatePercentFromValue = function () {\n        this._percent = this.calculatePercentage(this.value);\n    };\n    /**\n     * Calculate the new value from the new physical location. The value will always be snapped.\n     */\n    MdSlider.prototype.updateValueFromPosition = function (pos) {\n        var offset = this._sliderDimensions.left;\n        var size = this._sliderDimensions.width;\n        // The exact value is calculated from the event and used to find the closest snap value.\n        this._percent = this.clamp((pos - offset) / size);\n        var exactValue = this.calculateValue(this._percent);\n        // This calculation finds the closest step by finding the closest whole number divisible by the\n        // step relative to the min.\n        var closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;\n        // The value needs to snap to the min and max.\n        this.value = this.clamp(closestValue, this.min, this.max);\n        this._renderer.updateThumbAndFillPosition(this._percent, this._sliderDimensions.width);\n    };\n    /**\n     * Snaps the thumb to the current value.\n     * Called after a click or drag event is over.\n     */\n    MdSlider.prototype.snapThumbToValue = function () {\n        this.updatePercentFromValue();\n        this._renderer.updateThumbAndFillPosition(this._percent, this._sliderDimensions.width);\n    };\n    /**\n     * Calculates the separation in pixels of tick marks. If there is no tick interval or the interval\n     * is set to something other than a number or 'auto', nothing happens.\n     */\n    MdSlider.prototype._updateTickSeparation = function () {\n        if (this._tickInterval == 'auto') {\n            this._updateAutoTickSeparation();\n        }\n        else if (Number(this._tickInterval)) {\n            this._updateTickSeparationFromInterval();\n        }\n    };\n    /**\n     * Calculates the optimal separation in pixels of tick marks based on the minimum auto tick\n     * separation constant.\n     */\n    MdSlider.prototype._updateAutoTickSeparation = function () {\n        // We're looking for the multiple of step for which the separation between is greater than the\n        // minimum tick separation.\n        var sliderWidth = this._sliderDimensions.width;\n        // This is the total \"width\" of the slider in terms of values.\n        var valueWidth = this.max - this.min;\n        // Calculate how many values exist within 1px on the slider.\n        var valuePerPixel = valueWidth / sliderWidth;\n        // Calculate how many values exist in the minimum tick separation (px).\n        var valuePerSeparation = valuePerPixel * MIN_AUTO_TICK_SEPARATION;\n        // Calculate how many steps exist in this separation. This will be the lowest value you can\n        // multiply step by to get a separation that is greater than or equal to the minimum tick\n        // separation.\n        var stepsPerSeparation = Math.ceil(valuePerSeparation / this.step);\n        // Get the percentage of the slider for which this tick would be located so we can then draw\n        // it on the slider.\n        var tickPercentage = this.calculatePercentage((this.step * stepsPerSeparation) + this.min);\n        // The pixel value of the tick is the percentage * the width of the slider. Use this to draw\n        // the ticks on the slider.\n        this._renderer.drawTicks(sliderWidth * tickPercentage);\n    };\n    /**\n     * Calculates the separation of tick marks by finding the pixel value of the tickInterval.\n     */\n    MdSlider.prototype._updateTickSeparationFromInterval = function () {\n        // Force tickInterval to be a number so it can be used in calculations.\n        var interval = this._tickInterval;\n        // Calculate the first value a tick will be located at by getting the step at which the interval\n        // lands and adding that to the min.\n        var tickValue = (this.step * interval) + this.min;\n        // The percentage of the step on the slider is needed in order to calculate the pixel offset\n        // from the beginning of the slider. This offset is the tick separation.\n        var tickPercentage = this.calculatePercentage(tickValue);\n        this._renderer.drawTicks(this._sliderDimensions.width * tickPercentage);\n    };\n    /**\n     * Calculates the percentage of the slider that a value is.\n     */\n    MdSlider.prototype.calculatePercentage = function (value) {\n        return (value - this.min) / (this.max - this.min);\n    };\n    /**\n     * Calculates the value a percentage of the slider corresponds to.\n     */\n    MdSlider.prototype.calculateValue = function (percentage) {\n        return this.min + (percentage * (this.max - this.min));\n    };\n    /**\n     * Return a number between two numbers.\n     */\n    MdSlider.prototype.clamp = function (value, min, max) {\n        if (min === void 0) { min = 0; }\n        if (max === void 0) { max = 1; }\n        return Math.max(min, Math.min(value, max));\n    };\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * TODO: internal\n     */\n    MdSlider.prototype.writeValue = function (value) {\n        this.value = value;\n        if (this._sliderDimensions) {\n            this.snapThumbToValue();\n        }\n    };\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * TODO: internal\n     */\n    MdSlider.prototype.registerOnChange = function (fn) {\n        this._controlValueAccessorChangeFn = fn;\n    };\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * TODO: internal\n     */\n    MdSlider.prototype.registerOnTouched = function (fn) {\n        this.onTouched = fn;\n    };\n    __decorate$23([\n        _angular_core.Input(),\n        BooleanFieldValue(),\n        _angular_core.HostBinding('class.md-slider-disabled'),\n        _angular_core.HostBinding('attr.aria-disabled'), \n        __metadata$23('design:type', Boolean)\n    ], MdSlider.prototype, \"disabled\", void 0);\n    __decorate$23([\n        _angular_core.Input('thumb-label'),\n        BooleanFieldValue(), \n        __metadata$23('design:type', Boolean)\n    ], MdSlider.prototype, \"thumbLabel\", void 0);\n    __decorate$23([\n        _angular_core.Input(), \n        __metadata$23('design:type', Number)\n    ], MdSlider.prototype, \"step\", void 0);\n    __decorate$23([\n        _angular_core.Input('tick-interval'), \n        __metadata$23('design:type', Object)\n    ], MdSlider.prototype, \"_tickInterval\", void 0);\n    __decorate$23([\n        _angular_core.Input(),\n        _angular_core.HostBinding('attr.aria-valuemin'), \n        __metadata$23('design:type', Object)\n    ], MdSlider.prototype, \"min\", null);\n    __decorate$23([\n        _angular_core.Input(),\n        _angular_core.HostBinding('attr.aria-valuemax'), \n        __metadata$23('design:type', Object)\n    ], MdSlider.prototype, \"max\", null);\n    __decorate$23([\n        _angular_core.Input(),\n        _angular_core.HostBinding('attr.aria-valuenow'), \n        __metadata$23('design:type', Object)\n    ], MdSlider.prototype, \"value\", null);\n    MdSlider = __decorate$23([\n        _angular_core.Component({selector: 'md-slider',\n            providers: [MD_SLIDER_VALUE_ACCESSOR],\n            host: {\n                'tabindex': '0',\n                '(click)': 'onClick($event)',\n                '(slide)': 'onSlide($event)',\n                '(slidestart)': 'onSlideStart($event)',\n                '(slideend)': 'onSlideEnd()',\n                '(window:resize)': 'onResize()',\n                '(blur)': 'onBlur()',\n            },\n            template: \"<div class=\\\"md-slider-wrapper\\\"> <div class=\\\"md-slider-container\\\" [class.md-slider-sliding]=\\\"isSliding\\\" [class.md-slider-active]=\\\"isActive\\\" [class.md-slider-thumb-label-showing]=\\\"thumbLabel\\\"> <div class=\\\"md-slider-track-container\\\"> <div class=\\\"md-slider-track\\\"></div> <div class=\\\"md-slider-track md-slider-track-fill\\\"></div> <div class=\\\"md-slider-tick-container\\\"></div> <div class=\\\"md-slider-last-tick-container\\\"></div> </div> <div class=\\\"md-slider-thumb-container\\\"> <div class=\\\"md-slider-thumb-position\\\"> <div class=\\\"md-slider-thumb\\\"></div> <div class=\\\"md-slider-thumb-label\\\"> <span class=\\\"md-slider-thumb-label-text\\\">{{value}}</span> </div> </div> </div> </div> </div> \",\n            styles: [\"md-slider { height: 48px; min-width: 128px; position: relative; padding: 0; display: inline-block; outline: none; vertical-align: middle; } md-slider *, md-slider *::after { box-sizing: border-box; } .md-slider-wrapper { width: 100%; height: 100%; padding-left: 8px; padding-right: 8px; } .md-slider-container { position: relative; } .md-slider-track-container { width: 100%; position: absolute; top: 23px; height: 2px; } .md-slider-track { position: absolute; left: 0; right: 0; height: 100%; } .md-slider-track-fill { transition-duration: 400ms; transition-timing-function: cubic-bezier(0.25, 0.8, 0.25, 1); transition-property: width, height; } .md-slider-tick-container, .md-slider-last-tick-container { position: absolute; left: 0; right: 0; height: 100%; } .md-slider-thumb-container { position: absolute; left: 0; top: 50%; transform: translate3d(-50%, -50%, 0); transition-duration: 400ms; transition-timing-function: cubic-bezier(0.25, 0.8, 0.25, 1); transition-property: left, bottom; } .md-slider-thumb-position { transition: transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1); } .md-slider-thumb { z-index: 1; position: absolute; top: 14px; left: -10px; width: 20px; height: 20px; border-radius: 20px; transform: scale(0.7); transition: transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1); } .md-slider-thumb::after { content: ''; position: absolute; width: 20px; height: 20px; border-radius: 20px; border-width: 3px; border-style: solid; transition: inherit; } .md-slider-thumb-label { display: flex; align-items: center; justify-content: center; position: absolute; left: -14px; top: -17px; width: 28px; height: 28px; border-radius: 50%; transform: scale(0.4) translate3d(0, 67.5px, 0) rotate(45deg); transition: 300ms cubic-bezier(0.35, 0, 0.25, 1); transition-property: transform, border-radius; } .md-slider-thumb-label-text { z-index: 1; font-size: 12px; font-weight: bold; opacity: 0; transform: rotate(-45deg); transition: opacity 300ms cubic-bezier(0.35, 0, 0.25, 1); } .md-slider-container:not(.md-slider-thumb-label-showing) .md-slider-thumb-label { display: none; } .md-slider-active.md-slider-thumb-label-showing .md-slider-thumb { transform: scale(0); } .md-slider-sliding .md-slider-thumb-position, .md-slider-sliding .md-slider-track-fill { transition: none; cursor: default; } .md-slider-active .md-slider-thumb { transform: scale(1); } .md-slider-active .md-slider-thumb-label { border-radius: 50% 50% 0; transform: rotate(45deg); } .md-slider-active .md-slider-thumb-label-text { opacity: 1; } /*# sourceMappingURL=slider.css.map */ \"],\n            encapsulation: _angular_core.ViewEncapsulation.None,\n        }), \n        __metadata$23('design:paramtypes', [_angular_core.ElementRef])\n    ], MdSlider);\n    return MdSlider;\n}());\n/**\n * Renderer class in order to keep all dom manipulation in one place and outside of the main class.\n */\nvar SliderRenderer = (function () {\n    function SliderRenderer(elementRef) {\n        this._sliderElement = elementRef.nativeElement;\n    }\n    /**\n     * Get the bounding client rect of the slider track element.\n     * The track is used rather than the native element to ignore the extra space that the thumb can\n     * take up.\n     */\n    SliderRenderer.prototype.getSliderDimensions = function () {\n        var trackElement = this._sliderElement.querySelector('.md-slider-track');\n        return trackElement.getBoundingClientRect();\n    };\n    /**\n     * Update the physical position of the thumb and fill track on the slider.\n     */\n    SliderRenderer.prototype.updateThumbAndFillPosition = function (percent, width) {\n        // A container element that is used to avoid overwriting the transform on the thumb itself.\n        var thumbPositionElement = this._sliderElement.querySelector('.md-slider-thumb-position');\n        var fillTrackElement = this._sliderElement.querySelector('.md-slider-track-fill');\n        var position = Math.round(percent * width);\n        fillTrackElement.style.width = position + \"px\";\n        applyCssTransform(thumbPositionElement, \"translateX(\" + position + \"px)\");\n    };\n    /**\n     * Focuses the native element.\n     * Currently only used to allow a blur event to fire but will be used with keyboard input later.\n     */\n    SliderRenderer.prototype.addFocus = function () {\n        this._sliderElement.focus();\n    };\n    /**\n     * Draws ticks onto the tick container.\n     */\n    SliderRenderer.prototype.drawTicks = function (tickSeparation) {\n        var tickContainer = this._sliderElement.querySelector('.md-slider-tick-container');\n        var tickContainerWidth = tickContainer.getBoundingClientRect().width;\n        // An extra element for the last tick is needed because the linear gradient cannot be told to\n        // always draw a tick at the end of the gradient. To get around this, there is a second\n        // container for ticks that has a single tick mark on the very right edge.\n        var lastTickContainer = this._sliderElement.querySelector('.md-slider-last-tick-container');\n        // Subtract 1 from the tick separation to center the tick.\n        // TODO: Evaluate the rendering performance of using repeating background gradients.\n        tickContainer.style.background = \"repeating-linear-gradient(to right, black, black 2px, \" +\n            (\"transparent 2px, transparent \" + (tickSeparation - 1) + \"px)\");\n        // Add a tick to the very end by starting on the right side and adding a 2px black line.\n        lastTickContainer.style.background = \"linear-gradient(to left, black, black 2px, transparent \" +\n            \"2px, transparent)\";\n        // If the second to last tick is too close (a separation of less than half the normal\n        // separation), don't show it by decreasing the width of the tick container element.\n        if (tickContainerWidth % tickSeparation < (tickSeparation / 2)) {\n            tickContainer.style.width = tickContainerWidth - tickSeparation + 'px';\n        }\n    };\n    return SliderRenderer;\n}());\nvar MdSliderModule = (function () {\n    function MdSliderModule() {\n    }\n    MdSliderModule.forRoot = function () {\n        return {\n            ngModule: MdSliderModule,\n            providers: [{ provide: _angular_platformBrowser.HAMMER_GESTURE_CONFIG, useClass: MdGestureConfig }]\n        };\n    };\n    MdSliderModule = __decorate$23([\n        _angular_core.NgModule({\n            imports: [_angular_forms.FormsModule],\n            exports: [MdSlider],\n            declarations: [MdSlider],\n            providers: [\n                { provide: _angular_platformBrowser.HAMMER_GESTURE_CONFIG, useClass: MdGestureConfig },\n            ],\n        }), \n        __metadata$23('design:paramtypes', [])\n    ], MdSliderModule);\n    return MdSliderModule;\n}());\n\nvar __extends$7 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __decorate$24 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$24 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param$3 = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\n/** Exception thrown when two MdSidenav are matching the same side. */\nvar MdDuplicatedSidenavError = (function (_super) {\n    __extends$7(MdDuplicatedSidenavError, _super);\n    function MdDuplicatedSidenavError(align) {\n        _super.call(this, \"A sidenav was already declared for 'align=\\\"\" + align + \"\\\"'\");\n    }\n    return MdDuplicatedSidenavError;\n}(MdError));\n/**\n * <md-sidenav> component.\n *\n * This component corresponds to the drawer of the sidenav.\n *\n * Please refer to README.md for examples on how to use it.\n */\nvar MdSidenav = (function () {\n    /**\n     * @param _elementRef The DOM element reference. Used for transition and width calculation.\n     *     If not available we do not hook on transitions.\n     */\n    function MdSidenav(_elementRef) {\n        this._elementRef = _elementRef;\n        /** Alignment of the sidenav (direction neutral); whether 'start' or 'end'. */\n        this.align = 'start';\n        /** Mode of the sidenav; whether 'over' or 'side'. */\n        this.mode = 'over';\n        /** Whether the sidenav is opened. */\n        this._opened = false;\n        /** Event emitted when the sidenav is being opened. Use this to synchronize animations. */\n        this.onOpenStart = new _angular_core.EventEmitter();\n        /** Event emitted when the sidenav is fully opened. */\n        this.onOpen = new _angular_core.EventEmitter();\n        /** Event emitted when the sidenav is being closed. Use this to synchronize animations. */\n        this.onCloseStart = new _angular_core.EventEmitter();\n        /** Event emitted when the sidenav is fully closed. */\n        this.onClose = new _angular_core.EventEmitter();\n        this._transition = false;\n    }\n    Object.defineProperty(MdSidenav.prototype, \"opened\", {\n        /**\n         * Whether the sidenav is opened. We overload this because we trigger an event when it\n         * starts or end.\n         */\n        get: function () { return this._opened; },\n        set: function (v) {\n            // TODO(jelbourn): this coercion goes away when BooleanFieldValue is removed.\n            var booleanValue = v != null && \"\" + v !== 'false';\n            this.toggle(booleanValue);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Open this sidenav, and return a Promise that will resolve when it's fully opened (or get\n     * rejected if it didn't). */\n    MdSidenav.prototype.open = function () {\n        return this.toggle(true);\n    };\n    /**\n     * Close this sidenav, and return a Promise that will resolve when it's fully closed (or get\n     * rejected if it didn't).\n     */\n    MdSidenav.prototype.close = function () {\n        return this.toggle(false);\n    };\n    /**\n     * Toggle this sidenav. This is equivalent to calling open() when it's already opened, or\n     * close() when it's closed.\n     * @param isOpen\n     */\n    MdSidenav.prototype.toggle = function (isOpen) {\n        var _this = this;\n        if (isOpen === void 0) { isOpen = !this.opened; }\n        // Shortcut it if we're already opened.\n        if (isOpen === this.opened) {\n            if (!this._transition) {\n                return Promise.resolve(null);\n            }\n            else {\n                return isOpen ? this._openPromise : this._closePromise;\n            }\n        }\n        this._opened = isOpen;\n        this._transition = true;\n        if (isOpen) {\n            this.onOpenStart.emit(null);\n        }\n        else {\n            this.onCloseStart.emit(null);\n        }\n        if (isOpen) {\n            if (this._openPromise == null) {\n                this._openPromise = new Promise(function (resolve, reject) {\n                    _this._openPromiseResolve = resolve;\n                    _this._openPromiseReject = reject;\n                });\n            }\n            return this._openPromise;\n        }\n        else {\n            if (this._closePromise == null) {\n                this._closePromise = new Promise(function (resolve, reject) {\n                    _this._closePromiseResolve = resolve;\n                    _this._closePromiseReject = reject;\n                });\n            }\n            return this._closePromise;\n        }\n    };\n    /**\n     * When transition has finished, set the internal state for classes and emit the proper event.\n     * The event passed is actually of type TransitionEvent, but that type is not available in\n     * Android so we use any.\n     */\n    MdSidenav.prototype._onTransitionEnd = function (transitionEvent) {\n        if (transitionEvent.target == this._elementRef.nativeElement\n            && transitionEvent.propertyName.endsWith('transform')) {\n            this._transition = false;\n            if (this._opened) {\n                if (this._openPromise != null) {\n                    this._openPromiseResolve();\n                }\n                if (this._closePromise != null) {\n                    this._closePromiseReject();\n                }\n                this.onOpen.emit(null);\n            }\n            else {\n                if (this._closePromise != null) {\n                    this._closePromiseResolve();\n                }\n                if (this._openPromise != null) {\n                    this._openPromiseReject();\n                }\n                this.onClose.emit(null);\n            }\n            this._openPromise = null;\n            this._closePromise = null;\n        }\n    };\n    Object.defineProperty(MdSidenav.prototype, \"_isClosing\", {\n        get: function () {\n            return !this._opened && this._transition;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdSidenav.prototype, \"_isOpening\", {\n        get: function () {\n            return this._opened && this._transition;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdSidenav.prototype, \"_isClosed\", {\n        get: function () {\n            return !this._opened && !this._transition;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdSidenav.prototype, \"_isOpened\", {\n        get: function () {\n            return this._opened && !this._transition;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdSidenav.prototype, \"_isEnd\", {\n        get: function () {\n            return this.align == 'end';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdSidenav.prototype, \"_modeSide\", {\n        get: function () {\n            return this.mode == 'side';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdSidenav.prototype, \"_modeOver\", {\n        get: function () {\n            return this.mode == 'over';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdSidenav.prototype, \"_modePush\", {\n        get: function () {\n            return this.mode == 'push';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdSidenav.prototype, \"_width\", {\n        /** TODO: internal (needed by MdSidenavLayout). */\n        get: function () {\n            if (this._elementRef.nativeElement) {\n                return this._elementRef.nativeElement.offsetWidth;\n            }\n            return 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    __decorate$24([\n        _angular_core.Input(), \n        __metadata$24('design:type', Object)\n    ], MdSidenav.prototype, \"align\", void 0);\n    __decorate$24([\n        _angular_core.Input(), \n        __metadata$24('design:type', Object)\n    ], MdSidenav.prototype, \"mode\", void 0);\n    __decorate$24([\n        _angular_core.Output('open-start'), \n        __metadata$24('design:type', Object)\n    ], MdSidenav.prototype, \"onOpenStart\", void 0);\n    __decorate$24([\n        _angular_core.Output('open'), \n        __metadata$24('design:type', Object)\n    ], MdSidenav.prototype, \"onOpen\", void 0);\n    __decorate$24([\n        _angular_core.Output('close-start'), \n        __metadata$24('design:type', Object)\n    ], MdSidenav.prototype, \"onCloseStart\", void 0);\n    __decorate$24([\n        _angular_core.Output('close'), \n        __metadata$24('design:type', Object)\n    ], MdSidenav.prototype, \"onClose\", void 0);\n    __decorate$24([\n        _angular_core.Input(), \n        __metadata$24('design:type', Boolean)\n    ], MdSidenav.prototype, \"opened\", null);\n    __decorate$24([\n        _angular_core.HostBinding('class.md-sidenav-closing'), \n        __metadata$24('design:type', Object)\n    ], MdSidenav.prototype, \"_isClosing\", null);\n    __decorate$24([\n        _angular_core.HostBinding('class.md-sidenav-opening'), \n        __metadata$24('design:type', Object)\n    ], MdSidenav.prototype, \"_isOpening\", null);\n    __decorate$24([\n        _angular_core.HostBinding('class.md-sidenav-closed'), \n        __metadata$24('design:type', Object)\n    ], MdSidenav.prototype, \"_isClosed\", null);\n    __decorate$24([\n        _angular_core.HostBinding('class.md-sidenav-opened'), \n        __metadata$24('design:type', Object)\n    ], MdSidenav.prototype, \"_isOpened\", null);\n    __decorate$24([\n        _angular_core.HostBinding('class.md-sidenav-end'), \n        __metadata$24('design:type', Object)\n    ], MdSidenav.prototype, \"_isEnd\", null);\n    __decorate$24([\n        _angular_core.HostBinding('class.md-sidenav-side'), \n        __metadata$24('design:type', Object)\n    ], MdSidenav.prototype, \"_modeSide\", null);\n    __decorate$24([\n        _angular_core.HostBinding('class.md-sidenav-over'), \n        __metadata$24('design:type', Object)\n    ], MdSidenav.prototype, \"_modeOver\", null);\n    __decorate$24([\n        _angular_core.HostBinding('class.md-sidenav-push'), \n        __metadata$24('design:type', Object)\n    ], MdSidenav.prototype, \"_modePush\", null);\n    MdSidenav = __decorate$24([\n        _angular_core.Component({selector: 'md-sidenav',\n            template: '<ng-content></ng-content>',\n            host: {\n                '(transitionend)': '_onTransitionEnd($event)',\n                // must prevent the browser from aligning text based on value\n                '[attr.align]': 'null'\n            },\n            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,\n            encapsulation: _angular_core.ViewEncapsulation.None,\n        }), \n        __metadata$24('design:paramtypes', [_angular_core.ElementRef])\n    ], MdSidenav);\n    return MdSidenav;\n}());\n/**\n * <md-sidenav-layout> component.\n *\n * This is the parent component to one or two <md-sidenav>s that validates the state internally\n * and coordinate the backdrop and content styling.\n */\nvar MdSidenavLayout = (function () {\n    function MdSidenavLayout(_dir, _element, _renderer) {\n        var _this = this;\n        this._dir = _dir;\n        this._element = _element;\n        this._renderer = _renderer;\n        // If a `Dir` directive exists up the tree, listen direction changes and update the left/right\n        // properties to point to the proper start/end.\n        if (_dir != null) {\n            _dir.dirChange.subscribe(function () { return _this._validateDrawers(); });\n        }\n    }\n    Object.defineProperty(MdSidenavLayout.prototype, \"start\", {\n        get: function () { return this._start; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdSidenavLayout.prototype, \"end\", {\n        get: function () { return this._end; },\n        enumerable: true,\n        configurable: true\n    });\n    /** TODO: internal */\n    MdSidenavLayout.prototype.ngAfterContentInit = function () {\n        var _this = this;\n        // On changes, assert on consistency.\n        this._sidenavs.changes.subscribe(function () { return _this._validateDrawers(); });\n        this._sidenavs.forEach(function (sidenav) { return _this._watchSidenavToggle(sidenav); });\n        this._validateDrawers();\n    };\n    /*\n    * Subscribes to sidenav events in order to set a class on the main layout element when the sidenav\n    * is open and the backdrop is visible. This ensures any overflow on the layout element is properly\n    * hidden.\n    */\n    MdSidenavLayout.prototype._watchSidenavToggle = function (sidenav) {\n        var _this = this;\n        if (!sidenav || sidenav.mode === 'side') {\n            return;\n        }\n        sidenav.onOpen.subscribe(function () { return _this._setLayoutClass(sidenav, true); });\n        sidenav.onClose.subscribe(function () { return _this._setLayoutClass(sidenav, false); });\n    };\n    /* Toggles the 'md-sidenav-opened' class on the main 'md-sidenav-layout' element. */\n    MdSidenavLayout.prototype._setLayoutClass = function (sidenav, bool) {\n        this._renderer.setElementClass(this._element.nativeElement, 'md-sidenav-opened', bool);\n    };\n    /** Validate the state of the sidenav children components. */\n    MdSidenavLayout.prototype._validateDrawers = function () {\n        var _this = this;\n        this._start = this._end = null;\n        // Ensure that we have at most one start and one end sidenav.\n        this._sidenavs.forEach(function (sidenav) {\n            if (sidenav.align == 'end') {\n                if (_this._end != null) {\n                    throw new MdDuplicatedSidenavError('end');\n                }\n                _this._end = sidenav;\n            }\n            else {\n                if (_this._start != null) {\n                    throw new MdDuplicatedSidenavError('start');\n                }\n                _this._start = sidenav;\n            }\n        });\n        this._right = this._left = null;\n        // Detect if we're LTR or RTL.\n        if (this._dir == null || this._dir.value == 'ltr') {\n            this._left = this._start;\n            this._right = this._end;\n        }\n        else {\n            this._left = this._end;\n            this._right = this._start;\n        }\n    };\n    MdSidenavLayout.prototype._closeModalSidenav = function () {\n        if (this._start != null && this._start.mode != 'side') {\n            this._start.close();\n        }\n        if (this._end != null && this._end.mode != 'side') {\n            this._end.close();\n        }\n    };\n    MdSidenavLayout.prototype._isShowingBackdrop = function () {\n        return (this._isSidenavOpen(this._start) && this._start.mode != 'side')\n            || (this._isSidenavOpen(this._end) && this._end.mode != 'side');\n    };\n    MdSidenavLayout.prototype._isSidenavOpen = function (side) {\n        return side != null && side.opened;\n    };\n    /**\n     * Return the width of the sidenav, if it's in the proper mode and opened.\n     * This may relayout the view, so do not call this often.\n     * @param sidenav\n     * @param mode\n     */\n    MdSidenavLayout.prototype._getSidenavEffectiveWidth = function (sidenav, mode) {\n        return (this._isSidenavOpen(sidenav) && sidenav.mode == mode) ? sidenav._width : 0;\n    };\n    MdSidenavLayout.prototype._getMarginLeft = function () {\n        return this._getSidenavEffectiveWidth(this._left, 'side');\n    };\n    MdSidenavLayout.prototype._getMarginRight = function () {\n        return this._getSidenavEffectiveWidth(this._right, 'side');\n    };\n    MdSidenavLayout.prototype._getPositionLeft = function () {\n        return this._getSidenavEffectiveWidth(this._left, 'push');\n    };\n    MdSidenavLayout.prototype._getPositionRight = function () {\n        return this._getSidenavEffectiveWidth(this._right, 'push');\n    };\n    /**\n     * Returns the horizontal offset for the content area.  There should never be a value for both\n     * left and right, so by subtracting the right value from the left value, we should always get\n     * the appropriate offset.\n     */\n    MdSidenavLayout.prototype._getPositionOffset = function () {\n        return this._getPositionLeft() - this._getPositionRight();\n    };\n    /**\n     * This is using [ngStyle] rather than separate [style...] properties because [style.transform]\n     * doesn't seem to work right now.\n     */\n    MdSidenavLayout.prototype._getStyles = function () {\n        return {\n            marginLeft: this._getMarginLeft() + \"px\",\n            marginRight: this._getMarginRight() + \"px\",\n            transform: \"translate3d(\" + this._getPositionOffset() + \"px, 0, 0)\"\n        };\n    };\n    __decorate$24([\n        _angular_core.ContentChildren(MdSidenav), \n        __metadata$24('design:type', _angular_core.QueryList)\n    ], MdSidenavLayout.prototype, \"_sidenavs\", void 0);\n    MdSidenavLayout = __decorate$24([\n        _angular_core.Component({selector: 'md-sidenav-layout',\n            // Do not use ChangeDetectionStrategy.OnPush. It does not work for this component because\n            // technically it is a sibling of MdSidenav (on the content tree) and isn't updated when MdSidenav\n            // changes its state.\n            template: \"<div class=\\\"md-sidenav-backdrop\\\" (click)=\\\"_closeModalSidenav()\\\" [class.md-sidenav-shown]=\\\"_isShowingBackdrop()\\\"></div> <ng-content select=\\\"md-sidenav\\\"></ng-content> <div class=\\\"md-sidenav-content\\\" [ngStyle]=\\\"_getStyles()\\\"> <ng-content></ng-content> </div> \",\n            styles: [\"md-sidenav-layout { position: relative; transform: translate3d(0, 0, 0); box-sizing: border-box; -webkit-overflow-scrolling: touch; display: block; overflow: hidden; } md-sidenav-layout[fullscreen] { position: fixed; top: 0; left: 0; right: 0; bottom: 0; } md-sidenav-layout[fullscreen].md-sidenav-opened { overflow: hidden; } .md-sidenav-backdrop { position: fixed; top: 0; left: 0; right: 0; bottom: 0; display: block; z-index: 2; visibility: hidden; } .md-sidenav-backdrop.md-sidenav-shown { visibility: visible; } .md-sidenav-content { position: relative; transform: translate3d(0, 0, 0); display: block; height: 100%; overflow: auto; } md-sidenav { position: relative; transform: translate3d(0, 0, 0); display: block; position: absolute; top: 0; bottom: 0; z-index: 3; min-width: 5%; overflow-y: auto; transform: translate3d(-100%, 0, 0); } md-sidenav.md-sidenav-closed { visibility: hidden; } md-sidenav.md-sidenav-closing { transform: translate3d(-100%, 0, 0); will-change: transform; } md-sidenav.md-sidenav-opening { box-shadow: 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12); visibility: visible; transform: translate3d(0, 0, 0); will-change: transform; } md-sidenav.md-sidenav-opened { box-shadow: 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12); transform: translate3d(0, 0, 0); } md-sidenav.md-sidenav-side { z-index: 1; } md-sidenav.md-sidenav-end { right: 0; transform: translate3d(100%, 0, 0); } md-sidenav.md-sidenav-end.md-sidenav-closed { visibility: hidden; } md-sidenav.md-sidenav-end.md-sidenav-closing { transform: translate3d(100%, 0, 0); will-change: transform; } md-sidenav.md-sidenav-end.md-sidenav-opening { box-shadow: 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12); visibility: visible; transform: translate3d(0, 0, 0); will-change: transform; } md-sidenav.md-sidenav-end.md-sidenav-opened { box-shadow: 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12); transform: translate3d(0, 0, 0); } [dir='rtl'] md-sidenav { transform: translate3d(100%, 0, 0); } [dir='rtl'] md-sidenav.md-sidenav-closed { visibility: hidden; } [dir='rtl'] md-sidenav.md-sidenav-closing { transform: translate3d(100%, 0, 0); will-change: transform; } [dir='rtl'] md-sidenav.md-sidenav-opening { box-shadow: 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12); visibility: visible; transform: translate3d(0, 0, 0); will-change: transform; } [dir='rtl'] md-sidenav.md-sidenav-opened { box-shadow: 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12); transform: translate3d(0, 0, 0); } [dir='rtl'] md-sidenav.md-sidenav-end { left: 0; right: auto; transform: translate3d(-100%, 0, 0); } [dir='rtl'] md-sidenav.md-sidenav-end.md-sidenav-closed { visibility: hidden; } [dir='rtl'] md-sidenav.md-sidenav-end.md-sidenav-closing { transform: translate3d(-100%, 0, 0); will-change: transform; } [dir='rtl'] md-sidenav.md-sidenav-end.md-sidenav-opening { box-shadow: 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12); visibility: visible; transform: translate3d(0, 0, 0); will-change: transform; } [dir='rtl'] md-sidenav.md-sidenav-end.md-sidenav-opened { box-shadow: 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12); transform: translate3d(0, 0, 0); } /*# sourceMappingURL=sidenav.css.map */ \",\n\"md-sidenav { transition: transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1); } .md-sidenav-content { transition: transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1); } .md-sidenav-backdrop.md-sidenav-shown { transition: background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1); } /*# sourceMappingURL=sidenav-transitions.css.map */ \"],\n            encapsulation: _angular_core.ViewEncapsulation.None,\n        }),\n        __param$3(0, _angular_core.Optional()), \n        __metadata$24('design:paramtypes', [Dir, _angular_core.ElementRef, _angular_core.Renderer])\n    ], MdSidenavLayout);\n    return MdSidenavLayout;\n}());\nvar MdSidenavModule = (function () {\n    function MdSidenavModule() {\n    }\n    MdSidenavModule.forRoot = function () {\n        return {\n            ngModule: MdSidenavModule,\n            providers: []\n        };\n    };\n    MdSidenavModule = __decorate$24([\n        _angular_core.NgModule({\n            imports: [_angular_common.CommonModule],\n            exports: [MdSidenavLayout, MdSidenav],\n            declarations: [MdSidenavLayout, MdSidenav],\n        }), \n        __metadata$24('design:paramtypes', [])\n    ], MdSidenavModule);\n    return MdSidenavModule;\n}());\n\nvar __decorate$25 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$25 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar MdListDivider = (function () {\n    function MdListDivider() {\n    }\n    MdListDivider = __decorate$25([\n        _angular_core.Directive({\n            selector: 'md-divider'\n        }), \n        __metadata$25('design:paramtypes', [])\n    ], MdListDivider);\n    return MdListDivider;\n}());\nvar MdList = (function () {\n    function MdList() {\n    }\n    MdList = __decorate$25([\n        _angular_core.Component({selector: 'md-list, md-nav-list',\n            host: { 'role': 'list' },\n            template: '<ng-content></ng-content>',\n            styles: [\"md-list, md-nav-list { padding-top: 8px; display: block; } md-list [md-subheader], md-nav-list [md-subheader] { display: block; box-sizing: border-box; height: 48px; padding: 16px; margin: 0; font-size: 14px; font-weight: 500; } md-list [md-subheader]:first-child, md-nav-list [md-subheader]:first-child { margin-top: -8px; } md-list md-list-item .md-list-item, md-list a[md-list-item] .md-list-item, md-nav-list md-list-item .md-list-item, md-nav-list a[md-list-item] .md-list-item { display: flex; flex-direction: row; align-items: center; font-family: Roboto, \\\"Helvetica Neue\\\", sans-serif; box-sizing: border-box; font-size: 16px; height: 48px; padding: 0 16px; } md-list md-list-item.md-list-avatar .md-list-item, md-list a[md-list-item].md-list-avatar .md-list-item, md-nav-list md-list-item.md-list-avatar .md-list-item, md-nav-list a[md-list-item].md-list-avatar .md-list-item { height: 56px; } md-list md-list-item.md-2-line .md-list-item, md-list a[md-list-item].md-2-line .md-list-item, md-nav-list md-list-item.md-2-line .md-list-item, md-nav-list a[md-list-item].md-2-line .md-list-item { height: 72px; } md-list md-list-item.md-3-line .md-list-item, md-list a[md-list-item].md-3-line .md-list-item, md-nav-list md-list-item.md-3-line .md-list-item, md-nav-list a[md-list-item].md-3-line .md-list-item { height: 88px; } md-list md-list-item .md-list-text, md-list a[md-list-item] .md-list-text, md-nav-list md-list-item .md-list-text, md-nav-list a[md-list-item] .md-list-text { display: flex; flex-direction: column; width: 100%; box-sizing: border-box; overflow: hidden; padding: 0 16px; } md-list md-list-item .md-list-text > *, md-list a[md-list-item] .md-list-text > *, md-nav-list md-list-item .md-list-text > *, md-nav-list a[md-list-item] .md-list-text > * { margin: 0; padding: 0; font-weight: normal; font-size: inherit; } md-list md-list-item .md-list-text:empty, md-list a[md-list-item] .md-list-text:empty, md-nav-list md-list-item .md-list-text:empty, md-nav-list a[md-list-item] .md-list-text:empty { display: none; } md-list md-list-item .md-list-text:first-child, md-list a[md-list-item] .md-list-text:first-child, md-nav-list md-list-item .md-list-text:first-child, md-nav-list a[md-list-item] .md-list-text:first-child { padding: 0; } md-list md-list-item [md-list-avatar], md-list a[md-list-item] [md-list-avatar], md-nav-list md-list-item [md-list-avatar], md-nav-list a[md-list-item] [md-list-avatar] { width: 40px; height: 40px; border-radius: 50%; } md-list md-list-item [md-list-icon], md-list a[md-list-item] [md-list-icon], md-nav-list md-list-item [md-list-icon], md-nav-list a[md-list-item] [md-list-icon] { width: 24px; height: 24px; border-radius: 50%; padding: 4px; } md-list md-list-item [md-line], md-list a[md-list-item] [md-line], md-nav-list md-list-item [md-line], md-nav-list a[md-list-item] [md-line] { white-space: nowrap; overflow-x: hidden; text-overflow: ellipsis; display: block; box-sizing: border-box; } md-list md-list-item [md-line]:nth-child(n+2), md-list a[md-list-item] [md-line]:nth-child(n+2), md-nav-list md-list-item [md-line]:nth-child(n+2), md-nav-list a[md-list-item] [md-line]:nth-child(n+2) { font-size: 14px; } md-list[dense], md-nav-list[dense] { padding-top: 4px; display: block; } md-list[dense] [md-subheader], md-nav-list[dense] [md-subheader] { display: block; box-sizing: border-box; height: 40px; padding: 16px; margin: 0; font-size: 13px; font-weight: 500; } md-list[dense] [md-subheader]:first-child, md-nav-list[dense] [md-subheader]:first-child { margin-top: -4px; } md-list[dense] md-list-item .md-list-item, md-list[dense] a[md-list-item] .md-list-item, md-nav-list[dense] md-list-item .md-list-item, md-nav-list[dense] a[md-list-item] .md-list-item { display: flex; flex-direction: row; align-items: center; font-family: Roboto, \\\"Helvetica Neue\\\", sans-serif; box-sizing: border-box; font-size: 13px; height: 40px; padding: 0 16px; } md-list[dense] md-list-item.md-list-avatar .md-list-item, md-list[dense] a[md-list-item].md-list-avatar .md-list-item, md-nav-list[dense] md-list-item.md-list-avatar .md-list-item, md-nav-list[dense] a[md-list-item].md-list-avatar .md-list-item { height: 48px; } md-list[dense] md-list-item.md-2-line .md-list-item, md-list[dense] a[md-list-item].md-2-line .md-list-item, md-nav-list[dense] md-list-item.md-2-line .md-list-item, md-nav-list[dense] a[md-list-item].md-2-line .md-list-item { height: 60px; } md-list[dense] md-list-item.md-3-line .md-list-item, md-list[dense] a[md-list-item].md-3-line .md-list-item, md-nav-list[dense] md-list-item.md-3-line .md-list-item, md-nav-list[dense] a[md-list-item].md-3-line .md-list-item { height: 76px; } md-list[dense] md-list-item .md-list-text, md-list[dense] a[md-list-item] .md-list-text, md-nav-list[dense] md-list-item .md-list-text, md-nav-list[dense] a[md-list-item] .md-list-text { display: flex; flex-direction: column; width: 100%; box-sizing: border-box; overflow: hidden; padding: 0 16px; } md-list[dense] md-list-item .md-list-text > *, md-list[dense] a[md-list-item] .md-list-text > *, md-nav-list[dense] md-list-item .md-list-text > *, md-nav-list[dense] a[md-list-item] .md-list-text > * { margin: 0; padding: 0; font-weight: normal; font-size: inherit; } md-list[dense] md-list-item .md-list-text:empty, md-list[dense] a[md-list-item] .md-list-text:empty, md-nav-list[dense] md-list-item .md-list-text:empty, md-nav-list[dense] a[md-list-item] .md-list-text:empty { display: none; } md-list[dense] md-list-item .md-list-text:first-child, md-list[dense] a[md-list-item] .md-list-text:first-child, md-nav-list[dense] md-list-item .md-list-text:first-child, md-nav-list[dense] a[md-list-item] .md-list-text:first-child { padding: 0; } md-list[dense] md-list-item [md-list-avatar], md-list[dense] a[md-list-item] [md-list-avatar], md-nav-list[dense] md-list-item [md-list-avatar], md-nav-list[dense] a[md-list-item] [md-list-avatar] { width: 40px; height: 40px; border-radius: 50%; } md-list[dense] md-list-item [md-list-icon], md-list[dense] a[md-list-item] [md-list-icon], md-nav-list[dense] md-list-item [md-list-icon], md-nav-list[dense] a[md-list-item] [md-list-icon] { width: 24px; height: 24px; border-radius: 50%; padding: 4px; } md-list[dense] md-list-item [md-line], md-list[dense] a[md-list-item] [md-line], md-nav-list[dense] md-list-item [md-line], md-nav-list[dense] a[md-list-item] [md-line] { white-space: nowrap; overflow-x: hidden; text-overflow: ellipsis; display: block; box-sizing: border-box; } md-list[dense] md-list-item [md-line]:nth-child(n+2), md-list[dense] a[md-list-item] [md-line]:nth-child(n+2), md-nav-list[dense] md-list-item [md-line]:nth-child(n+2), md-nav-list[dense] a[md-list-item] [md-line]:nth-child(n+2) { font-size: 13px; } md-divider { display: block; border-top: 1px solid; margin: 0; } md-nav-list a { text-decoration: none; color: inherit; } md-nav-list .md-list-item { cursor: pointer; } md-nav-list .md-list-item:hover, md-nav-list .md-list-item.md-list-item-focus { outline: none; } /*# sourceMappingURL=list.css.map */ \"],\n            encapsulation: _angular_core.ViewEncapsulation.None\n        }), \n        __metadata$25('design:paramtypes', [])\n    ], MdList);\n    return MdList;\n}());\n/* Need directive for a ContentChild query in list-item */\nvar MdListAvatar = (function () {\n    function MdListAvatar() {\n    }\n    MdListAvatar = __decorate$25([\n        _angular_core.Directive({ selector: '[md-list-avatar]' }), \n        __metadata$25('design:paramtypes', [])\n    ], MdListAvatar);\n    return MdListAvatar;\n}());\nvar MdListItem = (function () {\n    function MdListItem(_renderer, _element) {\n        this._renderer = _renderer;\n        this._element = _element;\n        this._hasFocus = false;\n    }\n    Object.defineProperty(MdListItem.prototype, \"_hasAvatar\", {\n        set: function (avatar) {\n            this._renderer.setElementClass(this._element.nativeElement, 'md-list-avatar', avatar != null);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** TODO: internal */\n    MdListItem.prototype.ngAfterContentInit = function () {\n        this._lineSetter = new MdLineSetter(this._lines, this._renderer, this._element);\n    };\n    MdListItem.prototype._handleFocus = function () {\n        this._hasFocus = true;\n    };\n    MdListItem.prototype._handleBlur = function () {\n        this._hasFocus = false;\n    };\n    __decorate$25([\n        _angular_core.ContentChildren(MdLine), \n        __metadata$25('design:type', _angular_core.QueryList)\n    ], MdListItem.prototype, \"_lines\", void 0);\n    __decorate$25([\n        _angular_core.ContentChild(MdListAvatar), \n        __metadata$25('design:type', MdListAvatar), \n        __metadata$25('design:paramtypes', [MdListAvatar])\n    ], MdListItem.prototype, \"_hasAvatar\", null);\n    MdListItem = __decorate$25([\n        _angular_core.Component({selector: 'md-list-item, a[md-list-item]',\n            host: {\n                'role': 'listitem',\n                '(focus)': '_handleFocus()',\n                '(blur)': '_handleBlur()',\n            },\n            template: \"<div class=\\\"md-list-item\\\" [class.md-list-item-focus]=\\\"_hasFocus\\\"> <ng-content select=\\\"[md-list-avatar],[md-list-icon]\\\"></ng-content> <div class=\\\"md-list-text\\\"><ng-content select=\\\"[md-line]\\\"></ng-content></div> <ng-content></ng-content> </div> \",\n            encapsulation: _angular_core.ViewEncapsulation.None\n        }), \n        __metadata$25('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])\n    ], MdListItem);\n    return MdListItem;\n}());\nvar MdListModule = (function () {\n    function MdListModule() {\n    }\n    MdListModule.forRoot = function () {\n        return {\n            ngModule: MdListModule,\n            providers: []\n        };\n    };\n    MdListModule = __decorate$25([\n        _angular_core.NgModule({\n            imports: [MdLineModule],\n            exports: [MdList, MdListItem, MdListDivider, MdListAvatar, MdLineModule],\n            declarations: [MdList, MdListItem, MdListDivider, MdListAvatar],\n        }), \n        __metadata$25('design:paramtypes', [])\n    ], MdListModule);\n    return MdListModule;\n}());\n\n/**\n * Converts values into strings. Falsy values become empty strings.\n * TODO: internal\n */\nfunction coerceToString(value) {\n    return \"\" + (value || '');\n}\n/**\n * Converts a value that might be a string into a number.\n * TODO: internal\n */\nfunction coerceToNumber(value) {\n    return typeof value === 'string' ? parseInt(value, 10) : value;\n}\n\nvar __decorate$27 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$27 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar MdGridTile = (function () {\n    function MdGridTile(_renderer, _element) {\n        this._renderer = _renderer;\n        this._element = _element;\n        this._rowspan = 1;\n        this._colspan = 1;\n    }\n    Object.defineProperty(MdGridTile.prototype, \"rowspan\", {\n        get: function () {\n            return this._rowspan;\n        },\n        set: function (value) {\n            this._rowspan = coerceToNumber(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdGridTile.prototype, \"colspan\", {\n        get: function () {\n            return this._colspan;\n        },\n        set: function (value) {\n            this._colspan = coerceToNumber(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets the style of the grid-tile element.  Needs to be set manually to avoid\n     * \"Changed after checked\" errors that would occur with HostBinding.\n     */\n    MdGridTile.prototype._setStyle = function (property, value) {\n        this._renderer.setElementStyle(this._element.nativeElement, property, value);\n    };\n    __decorate$27([\n        _angular_core.Input(), \n        __metadata$27('design:type', Object)\n    ], MdGridTile.prototype, \"rowspan\", null);\n    __decorate$27([\n        _angular_core.Input(), \n        __metadata$27('design:type', Object)\n    ], MdGridTile.prototype, \"colspan\", null);\n    MdGridTile = __decorate$27([\n        _angular_core.Component({selector: 'md-grid-tile',\n            host: { 'role': 'listitem' },\n            template: \"<!-- TODO(kara): Revisit why this is a figure.--> <figure> <ng-content></ng-content> </figure>\",\n            styles: [\"md-grid-list { display: block; position: relative; } md-grid-tile { display: block; position: absolute; overflow: hidden; } md-grid-tile figure { display: flex; position: absolute; align-items: center; justify-content: center; height: 100%; top: 0; right: 0; bottom: 0; left: 0; padding: 0; margin: 0; } md-grid-tile md-grid-tile-header, md-grid-tile md-grid-tile-footer { display: flex; align-items: center; height: 48px; color: #fff; background: rgba(0, 0, 0, 0.38); overflow: hidden; padding: 0 16px; font-size: 16px; position: absolute; left: 0; right: 0; } md-grid-tile md-grid-tile-header [md-line], md-grid-tile md-grid-tile-footer [md-line] { white-space: nowrap; overflow-x: hidden; text-overflow: ellipsis; display: block; box-sizing: border-box; } md-grid-tile md-grid-tile-header [md-line]:nth-child(n+2), md-grid-tile md-grid-tile-footer [md-line]:nth-child(n+2) { font-size: 12px; } md-grid-tile md-grid-tile-header > *, md-grid-tile md-grid-tile-footer > * { margin: 0; padding: 0; font-weight: normal; font-size: inherit; } md-grid-tile md-grid-tile-header.md-2-line, md-grid-tile md-grid-tile-footer.md-2-line { height: 68px; } md-grid-tile .md-grid-list-text { display: flex; flex-direction: column; width: 100%; box-sizing: border-box; overflow: hidden; } md-grid-tile .md-grid-list-text > * { margin: 0; padding: 0; font-weight: normal; font-size: inherit; } md-grid-tile .md-grid-list-text:empty { display: none; } md-grid-tile md-grid-tile-header { top: 0; } md-grid-tile md-grid-tile-footer { bottom: 0; } md-grid-tile [md-grid-avatar] { padding-right: 16px; } [dir='rtl'] md-grid-tile [md-grid-avatar] { padding-right: 0; padding-left: 16px; } md-grid-tile [md-grid-avatar]:empty { display: none; } /*# sourceMappingURL=grid-list.css.map */ \"],\n            encapsulation: _angular_core.ViewEncapsulation.None,\n        }), \n        __metadata$27('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])\n    ], MdGridTile);\n    return MdGridTile;\n}());\nvar MdGridTileText = (function () {\n    function MdGridTileText(_renderer, _element) {\n        this._renderer = _renderer;\n        this._element = _element;\n    }\n    MdGridTileText.prototype.ngAfterContentInit = function () {\n        this._lineSetter = new MdLineSetter(this._lines, this._renderer, this._element);\n    };\n    __decorate$27([\n        _angular_core.ContentChildren(MdLine), \n        __metadata$27('design:type', _angular_core.QueryList)\n    ], MdGridTileText.prototype, \"_lines\", void 0);\n    MdGridTileText = __decorate$27([\n        _angular_core.Component({selector: 'md-grid-tile-header, md-grid-tile-footer',\n            template: \"<ng-content select=\\\"[md-grid-avatar]\\\"></ng-content> <div class=\\\"md-grid-list-text\\\"><ng-content select=\\\"[md-line]\\\"></ng-content></div> <ng-content></ng-content>\"\n        }), \n        __metadata$27('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])\n    ], MdGridTileText);\n    return MdGridTileText;\n}());\n\nvar __extends$8 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * Exception thrown when cols property is missing from grid-list\n */\nvar MdGridListColsError = (function (_super) {\n    __extends$8(MdGridListColsError, _super);\n    function MdGridListColsError() {\n        _super.call(this, \"md-grid-list: must pass in number of columns. Example: <md-grid-list cols=\\\"3\\\">\");\n    }\n    return MdGridListColsError;\n}(MdError));\n/**\n * Exception thrown when a tile's colspan is longer than the number of cols in list\n */\nvar MdGridTileTooWideError = (function (_super) {\n    __extends$8(MdGridTileTooWideError, _super);\n    function MdGridTileTooWideError(cols, listLength) {\n        _super.call(this, \"md-grid-list: tile with colspan \" + cols + \" is wider than grid with cols=\\\"\" + listLength + \"\\\".\");\n    }\n    return MdGridTileTooWideError;\n}(MdError));\n/**\n * Exception thrown when an invalid ratio is passed in as a rowHeight\n */\nvar MdGridListBadRatioError = (function (_super) {\n    __extends$8(MdGridListBadRatioError, _super);\n    function MdGridListBadRatioError(value) {\n        _super.call(this, \"md-grid-list: invalid ratio given for row-height: \\\"\" + value + \"\\\"\");\n    }\n    return MdGridListBadRatioError;\n}(MdError));\n\n/**\n * Class for determining, from a list of tiles, the (row, col) position of each of those tiles\n * in the grid. This is necessary (rather than just rendering the tiles in normal document flow)\n * because the tiles can have a rowspan.\n *\n * The positioning algorithm greedily places each tile as soon as it encounters a gap in the grid\n * large enough to accommodate it so that the tiles still render in the same order in which they\n * are given.\n *\n * The basis of the algorithm is the use of an array to track the already placed tiles. Each\n * element of the array corresponds to a column, and the value indicates how many cells in that\n * column are already occupied; zero indicates an empty cell. Moving \"down\" to the next row\n * decrements each value in the tracking array (indicating that the column is one cell closer to\n * being free).\n */\nvar TileCoordinator = (function () {\n    function TileCoordinator(numColumns, tiles) {\n        var _this = this;\n        /** Index at which the search for the next gap will start. */\n        this.columnIndex = 0;\n        /** The current row index. */\n        this.rowIndex = 0;\n        this.tracker = new Array(numColumns);\n        this.tracker.fill(0, 0, this.tracker.length);\n        this.positions = tiles.map(function (tile) { return _this._trackTile(tile); });\n    }\n    Object.defineProperty(TileCoordinator.prototype, \"rowCount\", {\n        /** Gets the total number of rows occupied by tiles */\n        get: function () { return this.rowIndex + 1; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TileCoordinator.prototype, \"rowspan\", {\n        /** Gets the total span of rows occupied by tiles.\n         * Ex: A list with 1 row that contains a tile with rowspan 2 will have a total rowspan of 2. */\n        get: function () {\n            var lastRowMax = Math.max.apply(Math, this.tracker);\n            // if any of the tiles has a rowspan that pushes it beyond the total row count,\n            // add the difference to the rowcount\n            return lastRowMax > 1 ? this.rowCount + lastRowMax - 1 : this.rowCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Calculates the row and col position of a tile. */\n    TileCoordinator.prototype._trackTile = function (tile) {\n        // Find a gap large enough for this tile.\n        var gapStartIndex = this._findMatchingGap(tile.colspan);\n        // Place tile in the resulting gap.\n        this._markTilePosition(gapStartIndex, tile);\n        // The next time we look for a gap, the search will start at columnIndex, which should be\n        // immediately after the tile that has just been placed.\n        this.columnIndex = gapStartIndex + tile.colspan;\n        return new TilePosition(this.rowIndex, gapStartIndex);\n    };\n    /** Finds the next available space large enough to fit the tile. */\n    TileCoordinator.prototype._findMatchingGap = function (tileCols) {\n        if (tileCols > this.tracker.length) {\n            throw new MdGridTileTooWideError(tileCols, this.tracker.length);\n        }\n        // Start index is inclusive, end index is exclusive.\n        var gapStartIndex = -1;\n        var gapEndIndex = -1;\n        // Look for a gap large enough to fit the given tile. Empty spaces are marked with a zero.\n        do {\n            // If we've reached the end of the row, go to the next row.\n            if (this.columnIndex + tileCols > this.tracker.length) {\n                this._nextRow();\n                continue;\n            }\n            gapStartIndex = this.tracker.indexOf(0, this.columnIndex);\n            // If there are no more empty spaces in this row at all, move on to the next row.\n            if (gapStartIndex == -1) {\n                this._nextRow();\n                continue;\n            }\n            gapEndIndex = this._findGapEndIndex(gapStartIndex);\n            // If a gap large enough isn't found, we want to start looking immediately after the current\n            // gap on the next iteration.\n            this.columnIndex = gapStartIndex + 1;\n        } while (gapEndIndex - gapStartIndex < tileCols);\n        return gapStartIndex;\n    };\n    /** Move \"down\" to the next row. */\n    TileCoordinator.prototype._nextRow = function () {\n        this.columnIndex = 0;\n        this.rowIndex++;\n        // Decrement all spaces by one to reflect moving down one row.\n        for (var i = 0; i < this.tracker.length; i++) {\n            this.tracker[i] = Math.max(0, this.tracker[i] - 1);\n        }\n    };\n    /**\n     * Finds the end index (exclusive) of a gap given the index from which to start looking.\n     * The gap ends when a non-zero value is found.\n     */\n    TileCoordinator.prototype._findGapEndIndex = function (gapStartIndex) {\n        for (var i = gapStartIndex + 1; i < this.tracker.length; i++) {\n            if (this.tracker[i] != 0) {\n                return i;\n            }\n        }\n        // The gap ends with the end of the row.\n        return this.tracker.length;\n    };\n    /** Update the tile tracker to account for the given tile in the given space. */\n    TileCoordinator.prototype._markTilePosition = function (start, tile) {\n        for (var i = 0; i < tile.colspan; i++) {\n            this.tracker[start + i] = tile.rowspan;\n        }\n    };\n    return TileCoordinator;\n}());\n/** Simple data structure for tile position (row, col). */\nvar TilePosition = (function () {\n    function TilePosition(row, col) {\n        this.row = row;\n        this.col = col;\n    }\n    return TilePosition;\n}());\n\nvar __extends$9 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * Sets the style properties for an individual tile, given the position calculated by the\n * Tile Coordinator.\n * TODO: internal\n */\nvar TileStyler = (function () {\n    function TileStyler() {\n        this._rows = 0;\n        this._rowspan = 0;\n    }\n    /**\n     * Adds grid-list layout info once it is available. Cannot be processed in the constructor\n     * because these properties haven't been calculated by that point.\n     */\n    TileStyler.prototype.init = function (_gutterSize, tracker, cols, direction) {\n        this._gutterSize = normalizeUnits(_gutterSize);\n        this._rows = tracker.rowCount;\n        this._rowspan = tracker.rowspan;\n        this._cols = cols;\n        this._direction = direction;\n    };\n    /**\n     * Computes the amount of space a single 1x1 tile would take up (width or height).\n     * Used as a basis for other calculations.\n     * @param sizePercent Percent of the total grid-list space that one 1x1 tile would take up.\n     * @param gutterFraction Fraction of the gutter size taken up by one 1x1 tile.\n     * @return The size of a 1x1 tile as an expression that can be evaluated via CSS calc().\n     */\n    TileStyler.prototype.getBaseTileSize = function (sizePercent, gutterFraction) {\n        // Take the base size percent (as would be if evenly dividing the size between cells),\n        // and then subtracting the size of one gutter. However, since there are no gutters on the\n        // edges, each tile only uses a fraction (gutterShare = numGutters / numCells) of the gutter\n        // size. (Imagine having one gutter per tile, and then breaking up the extra gutter on the\n        // edge evenly among the cells).\n        return \"(\" + sizePercent + \"% - ( \" + this._gutterSize + \" * \" + gutterFraction + \" ))\";\n    };\n    /**\n     * Gets The horizontal or vertical position of a tile, e.g., the 'top' or 'left' property value.\n     * @param offset Number of tiles that have already been rendered in the row/column.\n     * @param baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).\n     * @return Position of the tile as a CSS calc() expression.\n     */\n    TileStyler.prototype.getTilePosition = function (baseSize, offset) {\n        // The position comes the size of a 1x1 tile plus gutter for each previous tile in the\n        // row/column (offset).\n        return calc(\"(\" + baseSize + \" + \" + this._gutterSize + \") * \" + offset);\n    };\n    /**\n     * Gets the actual size of a tile, e.g., width or height, taking rowspan or colspan into account.\n     * @param baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).\n     * @param span The tile's rowspan or colspan.\n     * @return Size of the tile as a CSS calc() expression.\n     */\n    TileStyler.prototype.getTileSize = function (baseSize, span) {\n        return \"(\" + baseSize + \" * \" + span + \") + (\" + (span - 1) + \" * \" + this._gutterSize + \")\";\n    };\n    /** Gets the style properties to be applied to a tile for the given row and column index. */\n    TileStyler.prototype.setStyle = function (tile, rowIndex, colIndex) {\n        // Percent of the available horizontal space that one column takes up.\n        var percentWidthPerTile = 100 / this._cols;\n        // Fraction of the vertical gutter size that each column takes up.\n        // For example, if there are 5 columns, each column uses 4/5 = 0.8 times the gutter width.\n        var gutterWidthFractionPerTile = (this._cols - 1) / this._cols;\n        this.setColStyles(tile, colIndex, percentWidthPerTile, gutterWidthFractionPerTile);\n        this.setRowStyles(tile, rowIndex, percentWidthPerTile, gutterWidthFractionPerTile);\n    };\n    /** Sets the horizontal placement of the tile in the list. */\n    TileStyler.prototype.setColStyles = function (tile, colIndex, percentWidth, gutterWidth) {\n        // Base horizontal size of a column.\n        var baseTileWidth = this.getBaseTileSize(percentWidth, gutterWidth);\n        // The width and horizontal position of each tile is always calculated the same way, but the\n        // height and vertical position depends on the rowMode.\n        var side = this._direction === 'ltr' ? 'left' : 'right';\n        tile._setStyle(side, this.getTilePosition(baseTileWidth, colIndex));\n        tile._setStyle('width', calc(this.getTileSize(baseTileWidth, tile.colspan)));\n    };\n    /** Calculates the total size taken up by gutters across one axis of a list. */\n    TileStyler.prototype.getGutterSpan = function () {\n        return this._gutterSize + \" * (\" + this._rowspan + \" - 1)\";\n    };\n    /** Calculates the total size taken up by tiles across one axis of a list. */\n    TileStyler.prototype.getTileSpan = function (tileHeight) {\n        return this._rowspan + \" * \" + this.getTileSize(tileHeight, 1);\n    };\n    /**\n     * Sets the vertical placement of the tile in the list.\n     * This method will be implemented by each type of TileStyler.\n     */\n    TileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) { };\n    /**\n     * Calculates the computed height and returns the correct style property to set.\n     * This method will be implemented by each type of TileStyler.\n     */\n    TileStyler.prototype.getComputedHeight = function () { return null; };\n    return TileStyler;\n}());\n/**\n * This type of styler is instantiated when the user passes in a fixed row height.\n * Example <md-grid-list cols=\"3\" rowHeight=\"100px\">\n * TODO: internal\n */\nvar FixedTileStyler = (function (_super) {\n    __extends$9(FixedTileStyler, _super);\n    function FixedTileStyler(fixedRowHeight) {\n        _super.call(this);\n        this.fixedRowHeight = fixedRowHeight;\n    }\n    FixedTileStyler.prototype.init = function (gutterSize, tracker, cols, direction) {\n        _super.prototype.init.call(this, gutterSize, tracker, cols, direction);\n        this.fixedRowHeight = normalizeUnits(this.fixedRowHeight);\n    };\n    FixedTileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) {\n        tile._setStyle('top', this.getTilePosition(this.fixedRowHeight, rowIndex));\n        tile._setStyle('height', calc(this.getTileSize(this.fixedRowHeight, tile.rowspan)));\n    };\n    FixedTileStyler.prototype.getComputedHeight = function () {\n        return [\n            'height', calc(this.getTileSpan(this.fixedRowHeight) + \" + \" + this.getGutterSpan())\n        ];\n    };\n    return FixedTileStyler;\n}(TileStyler));\n/**\n * This type of styler is instantiated when the user passes in a width:height ratio\n * for the row height.  Example <md-grid-list cols=\"3\" rowHeight=\"3:1\">\n * TODO: internal\n */\nvar RatioTileStyler = (function (_super) {\n    __extends$9(RatioTileStyler, _super);\n    function RatioTileStyler(value) {\n        _super.call(this);\n        this._parseRatio(value);\n    }\n    RatioTileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) {\n        var percentHeightPerTile = percentWidth / this.rowHeightRatio;\n        this.baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterWidth);\n        // Use paddingTop and marginTop to maintain the given aspect ratio, as\n        // a percentage-based value for these properties is applied versus the *width* of the\n        // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties\n        tile._setStyle('marginTop', this.getTilePosition(this.baseTileHeight, rowIndex));\n        tile._setStyle('paddingTop', calc(this.getTileSize(this.baseTileHeight, tile.rowspan)));\n    };\n    RatioTileStyler.prototype.getComputedHeight = function () {\n        return [\n            'paddingBottom', calc(this.getTileSpan(this.baseTileHeight) + \" + \" + this.getGutterSpan())\n        ];\n    };\n    RatioTileStyler.prototype._parseRatio = function (value) {\n        var ratioParts = value.split(':');\n        if (ratioParts.length !== 2) {\n            throw new MdGridListBadRatioError(value);\n        }\n        this.rowHeightRatio = parseFloat(ratioParts[0]) / parseFloat(ratioParts[1]);\n    };\n    return RatioTileStyler;\n}(TileStyler));\n/*  This type of styler is instantiated when the user selects a \"fit\" row height mode.\n *  In other words, the row height will reflect the total height of the container divided\n *  by the number of rows.  Example <md-grid-list cols=\"3\" rowHeight=\"fit\"> */\nvar FitTileStyler = (function (_super) {\n    __extends$9(FitTileStyler, _super);\n    function FitTileStyler() {\n        _super.apply(this, arguments);\n    }\n    FitTileStyler.prototype.setRowStyles = function (tile, rowIndex, percentWidth, gutterWidth) {\n        // Percent of the available vertical space that one row takes up.\n        var percentHeightPerTile = 100 / this._rowspan;\n        // Fraction of the horizontal gutter size that each column takes up.\n        var gutterHeightPerTile = (this._rows - 1) / this._rows;\n        // Base vertical size of a column.\n        var baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterHeightPerTile);\n        tile._setStyle('top', this.getTilePosition(baseTileHeight, rowIndex));\n        tile._setStyle('height', calc(this.getTileSize(baseTileHeight, tile.rowspan)));\n    };\n    return FitTileStyler;\n}(TileStyler));\n/** Wraps a CSS string in a calc function */\nfunction calc(exp) { return \"calc(\" + exp + \")\"; }\n/** Appends pixels to a CSS string if no units are given. */\nfunction normalizeUnits(value) {\n    return (value.match(/px|em|rem/)) ? value : value + 'px';\n}\n\nvar __decorate$26 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$26 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param$4 = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\n// TODO(kara): Conditional (responsive) column count / row size.\n// TODO(kara): Re-layout on window resize / media change (debounced).\n// TODO(kara): gridTileHeader and gridTileFooter.\nvar MD_FIT_MODE = 'fit';\nvar MdGridList = (function () {\n    function MdGridList(_renderer, _element, _dir) {\n        this._renderer = _renderer;\n        this._element = _element;\n        this._dir = _dir;\n        /** The amount of space between tiles. This will be something like '5px' or '2em'. */\n        this._gutter = '1px';\n    }\n    Object.defineProperty(MdGridList.prototype, \"cols\", {\n        get: function () {\n            return this._cols;\n        },\n        set: function (value) {\n            this._cols = coerceToNumber(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdGridList.prototype, \"gutterSize\", {\n        get: function () {\n            return this._gutter;\n        },\n        set: function (value) {\n            this._gutter = coerceToString(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdGridList.prototype, \"rowHeight\", {\n        /** Set internal representation of row height from the user-provided value. */\n        set: function (value) {\n            this._rowHeight = coerceToString(value);\n            this._setTileStyler();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** TODO: internal */\n    MdGridList.prototype.ngOnInit = function () {\n        this._checkCols();\n        this._checkRowHeight();\n    };\n    /**\n     * The layout calculation is fairly cheap if nothing changes, so there's little cost\n     * to run it frequently.\n     * TODO: internal\n     */\n    MdGridList.prototype.ngAfterContentChecked = function () {\n        this._layoutTiles();\n    };\n    /** Throw a friendly error if cols property is missing */\n    MdGridList.prototype._checkCols = function () {\n        if (!this.cols) {\n            throw new MdGridListColsError();\n        }\n    };\n    /** Default to equal width:height if rowHeight property is missing */\n    MdGridList.prototype._checkRowHeight = function () {\n        if (!this._rowHeight) {\n            this._tileStyler = new RatioTileStyler('1:1');\n        }\n    };\n    /** Creates correct Tile Styler subtype based on rowHeight passed in by user */\n    MdGridList.prototype._setTileStyler = function () {\n        if (this._rowHeight === MD_FIT_MODE) {\n            this._tileStyler = new FitTileStyler();\n        }\n        else if (this._rowHeight && this._rowHeight.match(/:/g)) {\n            this._tileStyler = new RatioTileStyler(this._rowHeight);\n        }\n        else {\n            this._tileStyler = new FixedTileStyler(this._rowHeight);\n        }\n    };\n    /** Computes and applies the size and position for all children grid tiles. */\n    MdGridList.prototype._layoutTiles = function () {\n        var tiles = this._tiles.toArray();\n        var tracker = new TileCoordinator(this.cols, tiles);\n        var direction = this._dir ? this._dir.value : 'ltr';\n        this._tileStyler.init(this.gutterSize, tracker, this.cols, direction);\n        for (var i = 0; i < tiles.length; i++) {\n            var pos = tracker.positions[i];\n            var tile = tiles[i];\n            this._tileStyler.setStyle(tile, pos.row, pos.col);\n        }\n        this._setListStyle(this._tileStyler.getComputedHeight());\n    };\n    /** Sets style on the main grid-list element, given the style name and value. */\n    MdGridList.prototype._setListStyle = function (style) {\n        if (style) {\n            this._renderer.setElementStyle(this._element.nativeElement, style[0], style[1]);\n        }\n    };\n    __decorate$26([\n        _angular_core.ContentChildren(MdGridTile), \n        __metadata$26('design:type', _angular_core.QueryList)\n    ], MdGridList.prototype, \"_tiles\", void 0);\n    __decorate$26([\n        _angular_core.Input(), \n        __metadata$26('design:type', Object)\n    ], MdGridList.prototype, \"cols\", null);\n    __decorate$26([\n        _angular_core.Input('gutterSize'), \n        __metadata$26('design:type', Object)\n    ], MdGridList.prototype, \"gutterSize\", null);\n    __decorate$26([\n        _angular_core.Input(), \n        __metadata$26('design:type', Object), \n        __metadata$26('design:paramtypes', [Object])\n    ], MdGridList.prototype, \"rowHeight\", null);\n    MdGridList = __decorate$26([\n        _angular_core.Component({selector: 'md-grid-list',\n            template: \"<div class=\\\"md-grid-list\\\"> <ng-content></ng-content> </div>\",\n            styles: [\"md-grid-list { display: block; position: relative; } md-grid-tile { display: block; position: absolute; overflow: hidden; } md-grid-tile figure { display: flex; position: absolute; align-items: center; justify-content: center; height: 100%; top: 0; right: 0; bottom: 0; left: 0; padding: 0; margin: 0; } md-grid-tile md-grid-tile-header, md-grid-tile md-grid-tile-footer { display: flex; align-items: center; height: 48px; color: #fff; background: rgba(0, 0, 0, 0.38); overflow: hidden; padding: 0 16px; font-size: 16px; position: absolute; left: 0; right: 0; } md-grid-tile md-grid-tile-header [md-line], md-grid-tile md-grid-tile-footer [md-line] { white-space: nowrap; overflow-x: hidden; text-overflow: ellipsis; display: block; box-sizing: border-box; } md-grid-tile md-grid-tile-header [md-line]:nth-child(n+2), md-grid-tile md-grid-tile-footer [md-line]:nth-child(n+2) { font-size: 12px; } md-grid-tile md-grid-tile-header > *, md-grid-tile md-grid-tile-footer > * { margin: 0; padding: 0; font-weight: normal; font-size: inherit; } md-grid-tile md-grid-tile-header.md-2-line, md-grid-tile md-grid-tile-footer.md-2-line { height: 68px; } md-grid-tile .md-grid-list-text { display: flex; flex-direction: column; width: 100%; box-sizing: border-box; overflow: hidden; } md-grid-tile .md-grid-list-text > * { margin: 0; padding: 0; font-weight: normal; font-size: inherit; } md-grid-tile .md-grid-list-text:empty { display: none; } md-grid-tile md-grid-tile-header { top: 0; } md-grid-tile md-grid-tile-footer { bottom: 0; } md-grid-tile [md-grid-avatar] { padding-right: 16px; } [dir='rtl'] md-grid-tile [md-grid-avatar] { padding-right: 0; padding-left: 16px; } md-grid-tile [md-grid-avatar]:empty { display: none; } /*# sourceMappingURL=grid-list.css.map */ \"],\n            encapsulation: _angular_core.ViewEncapsulation.None,\n        }),\n        __param$4(2, _angular_core.Optional()), \n        __metadata$26('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef, Dir])\n    ], MdGridList);\n    return MdGridList;\n}());\nvar MdGridListModule = (function () {\n    function MdGridListModule() {\n    }\n    MdGridListModule.forRoot = function () {\n        return {\n            ngModule: MdGridListModule,\n            providers: []\n        };\n    };\n    MdGridListModule = __decorate$26([\n        _angular_core.NgModule({\n            imports: [MdLineModule],\n            exports: [MdGridList, MdGridTile, MdGridTileText, MdLineModule],\n            declarations: [MdGridList, MdGridTile, MdGridTileText],\n        }), \n        __metadata$26('design:paramtypes', [])\n    ], MdGridListModule);\n    return MdGridListModule;\n}());\n\nvar __decorate$28 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$28 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/**\n * Content of a card, needed as it's used as a selector in the API.\n */\nvar MdCardContent = (function () {\n    function MdCardContent() {\n    }\n    MdCardContent = __decorate$28([\n        _angular_core.Directive({\n            selector: 'md-card-content'\n        }), \n        __metadata$28('design:paramtypes', [])\n    ], MdCardContent);\n    return MdCardContent;\n}());\n/**\n * Title of a card, needed as it's used as a selector in the API.\n */\nvar MdCardTitle = (function () {\n    function MdCardTitle() {\n    }\n    MdCardTitle = __decorate$28([\n        _angular_core.Directive({\n            selector: 'md-card-title'\n        }), \n        __metadata$28('design:paramtypes', [])\n    ], MdCardTitle);\n    return MdCardTitle;\n}());\n/**\n * Sub-title of a card, needed as it's used as a selector in the API.\n */\nvar MdCardSubtitle = (function () {\n    function MdCardSubtitle() {\n    }\n    MdCardSubtitle = __decorate$28([\n        _angular_core.Directive({\n            selector: 'md-card-subtitle'\n        }), \n        __metadata$28('design:paramtypes', [])\n    ], MdCardSubtitle);\n    return MdCardSubtitle;\n}());\n/**\n * Action section of a card, needed as it's used as a selector in the API.\n */\nvar MdCardActions = (function () {\n    function MdCardActions() {\n    }\n    MdCardActions = __decorate$28([\n        _angular_core.Directive({\n            selector: 'md-card-actions'\n        }), \n        __metadata$28('design:paramtypes', [])\n    ], MdCardActions);\n    return MdCardActions;\n}());\n/**\n * Footer of a card, needed as it's used as a selector in the API.\n */\nvar MdCardFooter = (function () {\n    function MdCardFooter() {\n    }\n    MdCardFooter = __decorate$28([\n        _angular_core.Directive({\n            selector: 'md-card-footer'\n        }), \n        __metadata$28('design:paramtypes', [])\n    ], MdCardFooter);\n    return MdCardFooter;\n}());\n/*\n\n<md-card> is a basic content container component that adds the styles of a material design card.\n\nWhile you can use this component alone,\nit also provides a number of preset styles for common card sections, including:\n - md-card-title\n - md-card-subtitle\n - md-card-content\n - md-card-actions\n - md-card-footer\n\n You can see some examples of cards here:\n http://embed.plnkr.co/s5O4YcyvbLhIApSrIhtj/\n\n TODO(kara): update link to demo site when it exists\n\n*/\nvar MdCard = (function () {\n    function MdCard() {\n    }\n    MdCard = __decorate$28([\n        _angular_core.Component({selector: 'md-card',\n            template: \"<ng-content></ng-content> \",\n            styles: [\"md-card { box-shadow: 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12); transition: box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1); will-change: box-shadow; display: block; position: relative; padding: 24px; border-radius: 2px; font-family: Roboto, \\\"Helvetica Neue\\\", sans-serif; } md-card:hover { box-shadow: 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12); } .md-card-flat { box-shadow: none; } md-card-title, md-card-subtitle, md-card-content, md-card-actions { display: block; margin-bottom: 16px; } md-card-title { font-size: 24px; font-weight: 400; } md-card-subtitle { font-size: 14px; } md-card-content { font-size: 14px; } md-card-actions { margin-left: -16px; margin-right: -16px; padding: 8px 0; } md-card-actions[align='end'] { display: flex; justify-content: flex-end; } [md-card-image] { width: calc(100% + 48px); margin: 0 -24px 16px -24px; } [md-card-xl-image] { width: 240px; height: 240px; margin: -8px; } md-card-footer { position: absolute; width: 100%; min-height: 5px; bottom: 0; left: 0; } md-card-actions [md-button], md-card-actions [md-raised-button] { margin: 0 4px; } md-card-header { display: flex; flex-direction: row; height: 40px; margin: -8px 0 16px 0; } .md-card-header-text { height: 40px; margin: 0 8px; } [md-card-avatar] { height: 40px; width: 40px; border-radius: 50%; } md-card-header md-card-title { font-size: 14px; } [md-card-sm-image], [md-card-md-image], [md-card-lg-image] { margin: -8px 0; } md-card-title-group { display: flex; justify-content: space-between; margin: 0 -8px; } [md-card-sm-image] { width: 80px; height: 80px; } [md-card-md-image] { width: 112px; height: 112px; } [md-card-lg-image] { width: 152px; height: 152px; } @media (max-width: 600px) { md-card { padding: 24px 16px; } [md-card-image] { width: calc(100% + 32px); margin: 16px -16px; } md-card-title-group { margin: 0; } [md-card-xl-image] { margin-left: 0; margin-right: 0; } md-card-header { margin: -8px 0 0 0; } } md-card > :first-child, md-card-content > :first-child { margin-top: 0; } md-card > :last-child, md-card-content > :last-child { margin-bottom: 0; } [md-card-image]:first-child { margin-top: -24px; } md-card > md-card-actions:last-child { margin-bottom: -16px; padding-bottom: 0; } md-card-actions [md-button]:first-child, md-card-actions [md-raised-button]:first-child { margin-left: 0; margin-right: 0; } md-card-title:not(:first-child), md-card-subtitle:not(:first-child) { margin-top: -4px; } md-card-header md-card-subtitle:not(:first-child) { margin-top: -8px; } md-card > [md-card-xl-image]:first-child { margin-top: -8px; } md-card > [md-card-xl-image]:last-child { margin-bottom: -8px; } /*# sourceMappingURL=card.css.map */ \"],\n            encapsulation: _angular_core.ViewEncapsulation.None,\n            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,\n        }), \n        __metadata$28('design:paramtypes', [])\n    ], MdCard);\n    return MdCard;\n}());\n/*  The following components don't have any behavior.\n They simply use content projection to wrap user content\n for flex layout purposes in <md-card> (and thus allow a cleaner, boilerplate-free API).\n\n\n<md-card-header> is a component intended to be used within the <md-card> component.\nIt adds styles for a preset header section (i.e. a title, subtitle, and avatar layout).\n\nYou can see an example of a card with a header here:\nhttp://embed.plnkr.co/tvJl19z3gZTQd6WmwkIa/\n\nTODO(kara): update link to demo site when it exists\n*/\nvar MdCardHeader = (function () {\n    function MdCardHeader() {\n    }\n    MdCardHeader = __decorate$28([\n        _angular_core.Component({selector: 'md-card-header',\n            template: \"<ng-content select=\\\"[md-card-avatar]\\\"></ng-content> <div class=\\\"md-card-header-text\\\"> <ng-content select=\\\"md-card-title, md-card-subtitle\\\"></ng-content> </div> <ng-content></ng-content> \",\n            encapsulation: _angular_core.ViewEncapsulation.None,\n            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,\n        }), \n        __metadata$28('design:paramtypes', [])\n    ], MdCardHeader);\n    return MdCardHeader;\n}());\n/*\n\n<md-card-title-group> is a component intended to be used within the <md-card> component.\nIt adds styles for a preset layout that groups an image with a title section.\n\nYou can see an example of a card with a title-group section here:\nhttp://embed.plnkr.co/EDfgCF9eKcXjini1WODm/\n\nTODO(kara): update link to demo site when it exists\n*/\nvar MdCardTitleGroup = (function () {\n    function MdCardTitleGroup() {\n    }\n    MdCardTitleGroup = __decorate$28([\n        _angular_core.Component({selector: 'md-card-title-group',\n            template: \"<div> <ng-content select=\\\"md-card-title, md-card-subtitle\\\"></ng-content> </div> <ng-content select=\\\"img\\\"></ng-content> <ng-content></ng-content> \",\n            encapsulation: _angular_core.ViewEncapsulation.None,\n            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,\n        }), \n        __metadata$28('design:paramtypes', [])\n    ], MdCardTitleGroup);\n    return MdCardTitleGroup;\n}());\nvar MdCardModule = (function () {\n    function MdCardModule() {\n    }\n    MdCardModule.forRoot = function () {\n        return {\n            ngModule: MdCardModule,\n            providers: []\n        };\n    };\n    MdCardModule = __decorate$28([\n        _angular_core.NgModule({\n            exports: [\n                MdCard, MdCardHeader, MdCardTitleGroup, MdCardContent, MdCardTitle, MdCardSubtitle,\n                MdCardActions, MdCardFooter\n            ],\n            declarations: [\n                MdCard, MdCardHeader, MdCardTitleGroup, MdCardContent, MdCardTitle, MdCardSubtitle,\n                MdCardActions, MdCardFooter\n            ],\n        }), \n        __metadata$28('design:paramtypes', [])\n    ], MdCardModule);\n    return MdCardModule;\n}());\n\nvar __extends$11 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __decorate$30 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$30 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/** Exception thrown when attempting to load an icon with a name that cannot be found. */\nvar MdIconNameNotFoundError = (function (_super) {\n    __extends$11(MdIconNameNotFoundError, _super);\n    function MdIconNameNotFoundError(iconName) {\n        _super.call(this, \"Unable to find icon with the name \\\"\" + iconName + \"\\\"\");\n    }\n    return MdIconNameNotFoundError;\n}(MdError));\n/**\n * Exception thrown when attempting to load SVG content that does not contain the expected\n * <svg> tag.\n */\nvar MdIconSvgTagNotFoundError = (function (_super) {\n    __extends$11(MdIconSvgTagNotFoundError, _super);\n    function MdIconSvgTagNotFoundError() {\n        _super.call(this, '<svg> tag not found');\n    }\n    return MdIconSvgTagNotFoundError;\n}(MdError));\n/** Configuration for an icon, including the URL and possibly the cached SVG element. */\nvar SvgIconConfig = (function () {\n    function SvgIconConfig(url) {\n        this.url = url;\n        this.svgElement = null;\n    }\n    return SvgIconConfig;\n}());\n/** Returns the cache key to use for an icon namespace and name. */\nvar iconKey = function (namespace, name) { return namespace + ':' + name; };\n/**\n * Service to register and display icons used by the <md-icon> component.\n * - Registers icon URLs by namespace and name.\n * - Registers icon set URLs by namespace.\n * - Registers aliases for CSS classes, for use with icon fonts.\n * - Loads icons from URLs and extracts individual icons from icon sets.\n */\nvar MdIconRegistry = (function () {\n    function MdIconRegistry(_http) {\n        this._http = _http;\n        /**\n         * URLs and cached SVG elements for individual icons. Keys are of the format \"[namespace]:[icon]\".\n         */\n        this._svgIconConfigs = new Map();\n        /**\n         * SvgIconConfig objects and cached SVG elements for icon sets, keyed by namespace.\n         * Multiple icon sets can be registered under the same namespace.\n         */\n        this._iconSetConfigs = new Map();\n        /** Cache for icons loaded by direct URLs. */\n        this._cachedIconsByUrl = new Map();\n        /** In-progress icon fetches. Used to coalesce multiple requests to the same URL. */\n        this._inProgressUrlFetches = new Map();\n        /** Map from font identifiers to their CSS class names. Used for icon fonts. */\n        this._fontCssClassesByAlias = new Map();\n        /**\n         * The CSS class to apply when an <md-icon> component has no icon name, url, or font specified.\n         * The default 'material-icons' value assumes that the material icon font has been loaded as\n         * described at http://google.github.io/material-design-icons/#icon-font-for-the-web\n         */\n        this._defaultFontSetClass = 'material-icons';\n    }\n    /** Registers an icon by URL in the default namespace. */\n    MdIconRegistry.prototype.addSvgIcon = function (iconName, url) {\n        return this.addSvgIconInNamespace('', iconName, url);\n    };\n    /** Registers an icon by URL in the specified namespace. */\n    MdIconRegistry.prototype.addSvgIconInNamespace = function (namespace, iconName, url) {\n        var key = iconKey(namespace, iconName);\n        this._svgIconConfigs.set(key, new SvgIconConfig(url));\n        return this;\n    };\n    /** Registers an icon set by URL in the default namespace. */\n    MdIconRegistry.prototype.addSvgIconSet = function (url) {\n        return this.addSvgIconSetInNamespace('', url);\n    };\n    /** Registers an icon set by URL in the specified namespace. */\n    MdIconRegistry.prototype.addSvgIconSetInNamespace = function (namespace, url) {\n        var config = new SvgIconConfig(url);\n        if (this._iconSetConfigs.has(namespace)) {\n            this._iconSetConfigs.get(namespace).push(config);\n        }\n        else {\n            this._iconSetConfigs.set(namespace, [config]);\n        }\n        return this;\n    };\n    /**\n     * Defines an alias for a CSS class name to be used for icon fonts. Creating an mdIcon\n     * component with the alias as the fontSet input will cause the class name to be applied\n     * to the <md-icon> element.\n     */\n    MdIconRegistry.prototype.registerFontClassAlias = function (alias, className) {\n        if (className === void 0) { className = alias; }\n        this._fontCssClassesByAlias.set(alias, className);\n        return this;\n    };\n    /**\n     * Returns the CSS class name associated with the alias by a previous call to\n     * registerFontClassAlias. If no CSS class has been associated, returns the alias unmodified.\n     */\n    MdIconRegistry.prototype.classNameForFontAlias = function (alias) {\n        return this._fontCssClassesByAlias.get(alias) || alias;\n    };\n    /**\n     * Sets the CSS class name to be used for icon fonts when an <md-icon> component does not\n     * have a fontSet input value, and is not loading an icon by name or URL.\n     */\n    MdIconRegistry.prototype.setDefaultFontSetClass = function (className) {\n        this._defaultFontSetClass = className;\n        return this;\n    };\n    /**\n     * Returns the CSS class name to be used for icon fonts when an <md-icon> component does not\n     * have a fontSet input value, and is not loading an icon by name or URL.\n     */\n    MdIconRegistry.prototype.getDefaultFontSetClass = function () {\n        return this._defaultFontSetClass;\n    };\n    /**\n     * Returns an Observable that produces the icon (as an <svg> DOM element) from the given URL.\n     * The response from the URL may be cached so this will not always cause an HTTP request, but\n     * the produced element will always be a new copy of the originally fetched icon. (That is,\n     * it will not contain any modifications made to elements previously returned).\n     */\n    MdIconRegistry.prototype.getSvgIconFromUrl = function (url) {\n        var _this = this;\n        if (this._cachedIconsByUrl.has(url)) {\n            return rxjs_Observable.Observable.of(cloneSvg(this._cachedIconsByUrl.get(url)));\n        }\n        return this._loadSvgIconFromConfig(new SvgIconConfig(url))\n            .do(function (svg) { return _this._cachedIconsByUrl.set(url, svg); })\n            .map(function (svg) { return cloneSvg(svg); });\n    };\n    /**\n     * Returns an Observable that produces the icon (as an <svg> DOM element) with the given name\n     * and namespace. The icon must have been previously registered with addIcon or addIconSet;\n     * if not, the Observable will throw an MdIconNameNotFoundError.\n     */\n    MdIconRegistry.prototype.getNamedSvgIcon = function (name, namespace) {\n        if (namespace === void 0) { namespace = ''; }\n        // Return (copy of) cached icon if possible.\n        var key = iconKey(namespace, name);\n        if (this._svgIconConfigs.has(key)) {\n            return this._getSvgFromConfig(this._svgIconConfigs.get(key));\n        }\n        // See if we have any icon sets registered for the namespace.\n        var iconSetConfigs = this._iconSetConfigs.get(namespace);\n        if (iconSetConfigs) {\n            return this._getSvgFromIconSetConfigs(name, iconSetConfigs);\n        }\n        return rxjs_Observable.Observable.throw(new MdIconNameNotFoundError(key));\n    };\n    /**\n     * Returns the cached icon for a SvgIconConfig if available, or fetches it from its URL if not.\n     */\n    MdIconRegistry.prototype._getSvgFromConfig = function (config) {\n        if (config.svgElement) {\n            // We already have the SVG element for this icon, return a copy.\n            return rxjs_Observable.Observable.of(cloneSvg(config.svgElement));\n        }\n        else {\n            // Fetch the icon from the config's URL, cache it, and return a copy.\n            return this._loadSvgIconFromConfig(config)\n                .do(function (svg) { return config.svgElement = svg; })\n                .map(function (svg) { return cloneSvg(svg); });\n        }\n    };\n    /**\n     * Attempts to find an icon with the specified name in any of the SVG icon sets.\n     * First searches the available cached icons for a nested element with a matching name, and\n     * if found copies the element to a new <svg> element. If not found, fetches all icon sets\n     * that have not been cached, and searches again after all fetches are completed.\n     * The returned Observable produces the SVG element if possible, and throws\n     * MdIconNameNotFoundError if no icon with the specified name can be found.\n     */\n    MdIconRegistry.prototype._getSvgFromIconSetConfigs = function (name, iconSetConfigs) {\n        var _this = this;\n        // For all the icon set SVG elements we've fetched, see if any contain an icon with the\n        // requested name.\n        var namedIcon = this._extractIconWithNameFromAnySet(name, iconSetConfigs);\n        if (namedIcon) {\n            // We could cache namedIcon in _svgIconConfigs, but since we have to make a copy every\n            // time anyway, there's probably not much advantage compared to just always extracting\n            // it from the icon set.\n            return rxjs_Observable.Observable.of(namedIcon);\n        }\n        // Not found in any cached icon sets. If there are icon sets with URLs that we haven't\n        // fetched, fetch them now and look for iconName in the results.\n        var iconSetFetchRequests = iconSetConfigs\n            .filter(function (iconSetConfig) { return !iconSetConfig.svgElement; })\n            .map(function (iconSetConfig) {\n            return _this._loadSvgIconSetFromConfig(iconSetConfig)\n                .catch(function (err, caught) {\n                // Swallow errors fetching individual URLs so the combined Observable won't\n                // necessarily fail.\n                console.log(\"Loading icon set URL: \" + iconSetConfig.url + \" failed: \" + err);\n                return rxjs_Observable.Observable.of(null);\n            })\n                .do(function (svg) {\n                // Cache SVG element.\n                if (svg) {\n                    iconSetConfig.svgElement = svg;\n                }\n            });\n        });\n        // Fetch all the icon set URLs. When the requests complete, every IconSet should have a\n        // cached SVG element (unless the request failed), and we can check again for the icon.\n        return rxjs_Observable.Observable.forkJoin(iconSetFetchRequests)\n            .map(function (ignoredResults) {\n            var foundIcon = _this._extractIconWithNameFromAnySet(name, iconSetConfigs);\n            if (!foundIcon) {\n                throw new MdIconNameNotFoundError(name);\n            }\n            return foundIcon;\n        });\n    };\n    /**\n     * Searches the cached SVG elements for the given icon sets for a nested icon element whose \"id\"\n     * tag matches the specified name. If found, copies the nested element to a new SVG element and\n     * returns it. Returns null if no matching element is found.\n     */\n    MdIconRegistry.prototype._extractIconWithNameFromAnySet = function (iconName, iconSetConfigs) {\n        // Iterate backwards, so icon sets added later have precedence.\n        for (var i = iconSetConfigs.length - 1; i >= 0; i--) {\n            var config = iconSetConfigs[i];\n            if (config.svgElement) {\n                var foundIcon = this._extractSvgIconFromSet(config.svgElement, iconName, config);\n                if (foundIcon) {\n                    return foundIcon;\n                }\n            }\n        }\n        return null;\n    };\n    /**\n     * Loads the content of the icon URL specified in the SvgIconConfig and creates an SVG element\n     * from it.\n     */\n    MdIconRegistry.prototype._loadSvgIconFromConfig = function (config) {\n        var _this = this;\n        return this._fetchUrl(config.url)\n            .map(function (svgText) { return _this._createSvgElementForSingleIcon(svgText, config); });\n    };\n    /**\n     * Loads the content of the icon set URL specified in the SvgIconConfig and creates an SVG element\n     * from it.\n     */\n    MdIconRegistry.prototype._loadSvgIconSetFromConfig = function (config) {\n        var _this = this;\n        // TODO: Document that icons should only be loaded from trusted sources.\n        return this._fetchUrl(config.url)\n            .map(function (svgText) { return _this._svgElementFromString(svgText); });\n    };\n    /**\n     * Creates a DOM element from the given SVG string, and adds default attributes.\n     */\n    MdIconRegistry.prototype._createSvgElementForSingleIcon = function (responseText, config) {\n        var svg = this._svgElementFromString(responseText);\n        this._setSvgAttributes(svg, config);\n        return svg;\n    };\n    /**\n     * Searches the cached element of the given SvgIconConfig for a nested icon element whose \"id\"\n     * tag matches the specified name. If found, copies the nested element to a new SVG element and\n     * returns it. Returns null if no matching element is found.\n     */\n    MdIconRegistry.prototype._extractSvgIconFromSet = function (iconSet, iconName, config) {\n        var iconNode = iconSet.querySelector('#' + iconName);\n        if (!iconNode) {\n            return null;\n        }\n        // If the icon node is itself an <svg> node, clone and return it directly. If not, set it as\n        // the content of a new <svg> node.\n        if (iconNode.tagName.toLowerCase() == 'svg') {\n            return this._setSvgAttributes(iconNode.cloneNode(true), config);\n        }\n        // createElement('SVG') doesn't work as expected; the DOM ends up with\n        // the correct nodes, but the SVG content doesn't render. Instead we\n        // have to create an empty SVG node using innerHTML and append its content.\n        // Elements created using DOMParser.parseFromString have the same problem.\n        // http://stackoverflow.com/questions/23003278/svg-innerhtml-in-firefox-can-not-display\n        var svg = this._svgElementFromString('<svg></svg>');\n        // Clone the node so we don't remove it from the parent icon set element.\n        svg.appendChild(iconNode.cloneNode(true));\n        return this._setSvgAttributes(svg, config);\n    };\n    /**\n     * Creates a DOM element from the given SVG string.\n     */\n    MdIconRegistry.prototype._svgElementFromString = function (str) {\n        // TODO: Is there a better way than innerHTML? Renderer doesn't appear to have a method for\n        // creating an element from an HTML string.\n        var div = document.createElement('DIV');\n        div.innerHTML = str;\n        var svg = div.querySelector('svg');\n        if (!svg) {\n            throw new MdIconSvgTagNotFoundError();\n        }\n        return svg;\n    };\n    /**\n     * Sets the default attributes for an SVG element to be used as an icon.\n     */\n    MdIconRegistry.prototype._setSvgAttributes = function (svg, config) {\n        if (!svg.getAttribute('xmlns')) {\n            svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n        }\n        svg.setAttribute('fit', '');\n        svg.setAttribute('height', '100%');\n        svg.setAttribute('width', '100%');\n        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n        svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.\n        return svg;\n    };\n    /**\n     * Returns an Observable which produces the string contents of the given URL. Results may be\n     * cached, so future calls with the same URL may not cause another HTTP request.\n     */\n    MdIconRegistry.prototype._fetchUrl = function (url) {\n        var _this = this;\n        // Store in-progress fetches to avoid sending a duplicate request for a URL when there is\n        // already a request in progress for that URL. It's necessary to call share() on the\n        // Observable returned by http.get() so that multiple subscribers don't cause multiple XHRs.\n        if (this._inProgressUrlFetches.has(url)) {\n            return this._inProgressUrlFetches.get(url);\n        }\n        // TODO(jelbourn): for some reason, the `finally` operator \"loses\" the generic type on the\n        // Observable. Figure out why and fix it.\n        var req = this._http.get(url)\n            .map(function (response) { return response.text(); })\n            .finally(function () {\n            _this._inProgressUrlFetches.delete(url);\n        })\n            .share();\n        this._inProgressUrlFetches.set(url, req);\n        return req;\n    };\n    MdIconRegistry = __decorate$30([\n        _angular_core.Injectable(), \n        __metadata$30('design:paramtypes', [_angular_http.Http])\n    ], MdIconRegistry);\n    return MdIconRegistry;\n}());\n/** Clones an SVGElement while preserving type information. */\nfunction cloneSvg(svg) {\n    return svg.cloneNode(true);\n}\n\nvar __extends$10 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __decorate$29 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$29 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/** Exception thrown when an invalid icon name is passed to an md-icon component. */\nvar MdIconInvalidNameError = (function (_super) {\n    __extends$10(MdIconInvalidNameError, _super);\n    function MdIconInvalidNameError(iconName) {\n        _super.call(this, \"Invalid icon name: \\\"\" + iconName + \"\\\"\");\n    }\n    return MdIconInvalidNameError;\n}(MdError));\n/**\n * Component to display an icon. It can be used in the following ways:\n * - Specify the svgSrc input to load an SVG icon from a URL. The SVG content is directly inlined\n *   as a child of the <md-icon> component, so that CSS styles can easily be applied to it.\n *   The URL is loaded via an XMLHttpRequest, so it must be on the same domain as the page or its\n *   server must be configured to allow cross-domain requests.\n *   Example:\n *     <md-icon svgSrc=\"assets/arrow.svg\"></md-icon>\n *\n * - Specify the svgIcon input to load an SVG icon from a URL previously registered with the\n *   addSvgIcon, addSvgIconInNamespace, addSvgIconSet, or addSvgIconSetInNamespace methods of\n *   MdIconRegistry. If the svgIcon value contains a colon it is assumed to be in the format\n *   \"[namespace]:[name]\", if not the value will be the name of an icon in the default namespace.\n *   Examples:\n *     <md-icon svgIcon=\"left-arrow\"></md-icon>\n *     <md-icon svgIcon=\"animals:cat\"></md-icon>\n *\n * - Use a font ligature as an icon by putting the ligature text in the content of the <md-icon>\n *   component. By default the Material icons font is used as described at\n *   http://google.github.io/material-design-icons/#icon-font-for-the-web. You can specify an\n *   alternate font by setting the fontSet input to either the CSS class to apply to use the\n *   desired font, or to an alias previously registered with MdIconRegistry.registerFontClassAlias.\n *   Examples:\n *     <md-icon>home</md-icon>\n *     <md-icon fontSet=\"myfont\">sun</md-icon>\n *\n * - Specify a font glyph to be included via CSS rules by setting the fontSet input to specify the\n *   font, and the fontIcon input to specify the icon. Typically the fontIcon will specify a\n *   CSS class which causes the glyph to be displayed via a :before selector, as in\n *   https://fortawesome.github.io/Font-Awesome/examples/\n *   Example:\n *     <md-icon fontSet=\"fa\" fontIcon=\"alarm\"></md-icon>\n */\nvar MdIcon = (function () {\n    function MdIcon(_element, _renderer, _mdIconRegistry) {\n        this._element = _element;\n        this._renderer = _renderer;\n        this._mdIconRegistry = _mdIconRegistry;\n        this.hostAriaLabel = '';\n    }\n    /**\n     * Splits an svgIcon binding value into its icon set and icon name components.\n     * Returns a 2-element array of [(icon set), (icon name)].\n     * The separator for the two fields is ':'. If there is no separator, an empty\n     * string is returned for the icon set and the entire value is returned for\n     * the icon name. If the argument is falsy, returns an array of two empty strings.\n     * Throws a MdIconInvalidNameError if the name contains two or more ':' separators.\n     * Examples:\n     *   'social:cake' -> ['social', 'cake']\n     *   'penguin' -> ['', 'penguin']\n     *   null -> ['', '']\n     *   'a:b:c' -> (throws MdIconInvalidNameError)\n     */\n    MdIcon.prototype._splitIconName = function (iconName) {\n        if (!iconName) {\n            return ['', ''];\n        }\n        var parts = iconName.split(':');\n        switch (parts.length) {\n            case 1:\n                // Use default namespace.\n                return ['', parts[0]];\n            case 2:\n                return parts;\n            default:\n                throw new MdIconInvalidNameError(iconName);\n        }\n    };\n    /** TODO: internal */\n    MdIcon.prototype.ngOnChanges = function (changes) {\n        var _this = this;\n        var changedInputs = Object.keys(changes);\n        // Only update the inline SVG icon if the inputs changed, to avoid unnecessary DOM operations.\n        if (changedInputs.indexOf('svgIcon') != -1 || changedInputs.indexOf('svgSrc') != -1) {\n            if (this.svgIcon) {\n                var _a = this._splitIconName(this.svgIcon), namespace = _a[0], iconName = _a[1];\n                this._mdIconRegistry.getNamedSvgIcon(iconName, namespace).subscribe(function (svg) { return _this._setSvgElement(svg); }, function (err) { return console.log(\"Error retrieving icon: \" + err); });\n            }\n            else if (this.svgSrc) {\n                this._mdIconRegistry.getSvgIconFromUrl(this.svgSrc).subscribe(function (svg) { return _this._setSvgElement(svg); }, function (err) { return console.log(\"Error retrieving icon: \" + err); });\n            }\n        }\n        if (this._usingFontIcon()) {\n            this._updateFontIconClasses();\n        }\n        this._updateAriaLabel();\n    };\n    /** TODO: internal */\n    MdIcon.prototype.ngOnInit = function () {\n        // Update font classes because ngOnChanges won't be called if none of the inputs are present,\n        // e.g. <md-icon>arrow</md-icon>. In this case we need to add a CSS class for the default font.\n        if (this._usingFontIcon()) {\n            this._updateFontIconClasses();\n        }\n    };\n    /** TODO: internal */\n    MdIcon.prototype.ngAfterViewChecked = function () {\n        // Update aria label here because it may depend on the projected text content.\n        // (e.g. <md-icon>home</md-icon> should use 'home').\n        this._updateAriaLabel();\n    };\n    MdIcon.prototype._updateAriaLabel = function () {\n        var ariaLabel = this._getAriaLabel();\n        if (ariaLabel) {\n            this._renderer.setElementAttribute(this._element.nativeElement, 'aria-label', ariaLabel);\n        }\n    };\n    MdIcon.prototype._getAriaLabel = function () {\n        // If the parent provided an aria-label attribute value, use it as-is. Otherwise look for a\n        // reasonable value from the alt attribute, font icon name, SVG icon name, or (for ligatures)\n        // the text content of the directive.\n        var label = this.hostAriaLabel ||\n            this.alt ||\n            this.fontIcon ||\n            this._splitIconName(this.svgIcon)[1];\n        if (label) {\n            return label;\n        }\n        // The \"content\" of an SVG icon is not a useful label.\n        if (this._usingFontIcon()) {\n            var text = this._element.nativeElement.textContent;\n            if (text) {\n                return text;\n            }\n        }\n        // TODO: Warn here in dev mode.\n        return null;\n    };\n    MdIcon.prototype._usingFontIcon = function () {\n        return !(this.svgIcon || this.svgSrc);\n    };\n    MdIcon.prototype._setSvgElement = function (svg) {\n        var layoutElement = this._element.nativeElement;\n        // Remove existing child nodes and add the new SVG element.\n        // We would use renderer.detachView(Array.from(layoutElement.childNodes)) here,\n        // but it fails in IE11: https://github.com/angular/angular/issues/6327\n        layoutElement.innerHTML = '';\n        this._renderer.projectNodes(layoutElement, [svg]);\n    };\n    MdIcon.prototype._updateFontIconClasses = function () {\n        if (!this._usingFontIcon()) {\n            return;\n        }\n        var elem = this._element.nativeElement;\n        var fontSetClass = this.fontSet ?\n            this._mdIconRegistry.classNameForFontAlias(this.fontSet) :\n            this._mdIconRegistry.getDefaultFontSetClass();\n        if (fontSetClass != this._previousFontSetClass) {\n            if (this._previousFontSetClass) {\n                this._renderer.setElementClass(elem, this._previousFontSetClass, false);\n            }\n            if (fontSetClass) {\n                this._renderer.setElementClass(elem, fontSetClass, true);\n            }\n            this._previousFontSetClass = fontSetClass;\n        }\n        if (this.fontIcon != this._previousFontIconClass) {\n            if (this._previousFontIconClass) {\n                this._renderer.setElementClass(elem, this._previousFontIconClass, false);\n            }\n            if (this.fontIcon) {\n                this._renderer.setElementClass(elem, this.fontIcon, true);\n            }\n            this._previousFontIconClass = this.fontIcon;\n        }\n    };\n    __decorate$29([\n        _angular_core.Input(), \n        __metadata$29('design:type', String)\n    ], MdIcon.prototype, \"svgSrc\", void 0);\n    __decorate$29([\n        _angular_core.Input(), \n        __metadata$29('design:type', String)\n    ], MdIcon.prototype, \"svgIcon\", void 0);\n    __decorate$29([\n        _angular_core.Input(), \n        __metadata$29('design:type', String)\n    ], MdIcon.prototype, \"fontSet\", void 0);\n    __decorate$29([\n        _angular_core.Input(), \n        __metadata$29('design:type', String)\n    ], MdIcon.prototype, \"fontIcon\", void 0);\n    __decorate$29([\n        _angular_core.Input(), \n        __metadata$29('design:type', String)\n    ], MdIcon.prototype, \"alt\", void 0);\n    __decorate$29([\n        _angular_core.Input('aria-label'), \n        __metadata$29('design:type', String)\n    ], MdIcon.prototype, \"hostAriaLabel\", void 0);\n    MdIcon = __decorate$29([\n        _angular_core.Component({template: '<ng-content></ng-content>',\n            selector: 'md-icon',\n            styles: [\"md-icon { background-repeat: no-repeat; display: inline-block; fill: currentColor; height: 24px; width: 24px; } /*# sourceMappingURL=icon.css.map */ \"],\n            host: {\n                'role': 'img',\n            },\n            encapsulation: _angular_core.ViewEncapsulation.None,\n            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,\n        }), \n        __metadata$29('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer, MdIconRegistry])\n    ], MdIcon);\n    return MdIcon;\n}());\nvar MdIconModule = (function () {\n    function MdIconModule() {\n    }\n    MdIconModule.forRoot = function () {\n        return {\n            ngModule: MdIconModule,\n            providers: [MdIconRegistry],\n        };\n    };\n    MdIconModule = __decorate$29([\n        _angular_core.NgModule({\n            imports: [_angular_http.HttpModule],\n            exports: [MdIcon],\n            declarations: [MdIcon],\n        }), \n        __metadata$29('design:paramtypes', [])\n    ], MdIconModule);\n    return MdIconModule;\n}());\n\nvar __extends$12 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __decorate$31 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$31 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n// TODO(josephperrott): Benchpress tests.\n/** A single degree in radians. */\nvar DEGREE_IN_RADIANS = Math.PI / 180;\n/** Duration of the indeterminate animation. */\nvar DURATION_INDETERMINATE = 667;\n/** Duration of the indeterminate animation. */\nvar DURATION_DETERMINATE = 225;\n/** Start animation value of the indeterminate animation */\nvar startIndeterminate = 3;\n/** End animation value of the indeterminate animation */\nvar endIndeterminate = 80;\n/**\n * <md-progress-circle> component.\n */\nvar MdProgressCircle = (function () {\n    function MdProgressCircle(_changeDetectorRef) {\n        this._changeDetectorRef = _changeDetectorRef;\n        /** The id of the last requested animation. */\n        this._lastAnimationId = 0;\n        this._mode = 'determinate';\n    }\n    Object.defineProperty(MdProgressCircle.prototype, \"_ariaValueMin\", {\n        /**\n         * Values for aria max and min are only defined as numbers when in a determinate mode.  We do this\n         * because voiceover does not report the progress indicator as indeterminate if the aria min\n         * and/or max value are number values.\n         */\n        get: function () {\n            return this.mode == 'determinate' ? 0 : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdProgressCircle.prototype, \"_ariaValueMax\", {\n        get: function () {\n            return this.mode == 'determinate' ? 100 : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdProgressCircle.prototype, \"interdeterminateInterval\", {\n        /** TODO: internal */\n        get: function () {\n            return this._interdeterminateInterval;\n        },\n        /** TODO: internal */\n        set: function (interval) {\n            clearInterval(this._interdeterminateInterval);\n            this._interdeterminateInterval = interval;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdProgressCircle.prototype, \"currentPath\", {\n        /** TODO: internal */\n        get: function () {\n            return this._currentPath;\n        },\n        set: function (path) {\n            this._currentPath = path;\n            // Mark for check as our ChangeDetectionStrategy is OnPush, when changes come from within the\n            // component, change detection must be called for.\n            this._changeDetectorRef.markForCheck();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Clean up any animations that were running. */\n    MdProgressCircle.prototype.ngOnDestroy = function () {\n        this._cleanupIndeterminateAnimation();\n    };\n    Object.defineProperty(MdProgressCircle.prototype, \"value\", {\n        get: function () {\n            if (this.mode == 'determinate') {\n                return this._value;\n            }\n        },\n        set: function (v) {\n            if (v && this.mode == 'determinate') {\n                var newValue = clamp(v);\n                this._animateCircle((this.value || 0), newValue, linearEase, DURATION_DETERMINATE, 0);\n                this._value = newValue;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdProgressCircle.prototype, \"mode\", {\n        /**\n         * Mode of the progress circle\n         *\n         * Input must be one of the values from ProgressMode, defaults to 'determinate'.\n         * mode is bound to the host as the attribute host.\n         */\n        get: function () {\n            return this._mode;\n        },\n        set: function (m) {\n            if (m == 'indeterminate') {\n                this._startIndeterminateAnimation();\n            }\n            else {\n                this._cleanupIndeterminateAnimation();\n            }\n            this._mode = m;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Animates the circle from one percentage value to another.\n     *\n     * @param animateFrom The percentage of the circle filled starting the animation.\n     * @param animateTo The percentage of the circle filled ending the animation.\n     * @param ease The easing function to manage the pace of change in the animation.\n     * @param duration The length of time to show the animation, in milliseconds.\n     * @param rotation The starting angle of the circle fill, with 0 represented at the top center\n     *    of the circle.\n     */\n    MdProgressCircle.prototype._animateCircle = function (animateFrom, animateTo, ease, duration, rotation) {\n        var _this = this;\n        var id = ++this._lastAnimationId;\n        var startTime = Date.now();\n        var changeInValue = animateTo - animateFrom;\n        // No need to animate it if the values are the same\n        if (animateTo === animateFrom) {\n            this.currentPath = getSvgArc(animateTo, rotation);\n        }\n        else {\n            var animation_1 = function () {\n                var elapsedTime = Math.max(0, Math.min(Date.now() - startTime, duration));\n                _this.currentPath = getSvgArc(ease(elapsedTime, animateFrom, changeInValue, duration), rotation);\n                // Prevent overlapping animations by checking if a new animation has been called for and\n                // if the animation has lasted long than the animation duration.\n                if (id === _this._lastAnimationId && elapsedTime < duration) {\n                    requestAnimationFrame(animation_1);\n                }\n            };\n            requestAnimationFrame(animation_1);\n        }\n    };\n    /**\n     * Starts the indeterminate animation interval, if it is not already running.\n     */\n    MdProgressCircle.prototype._startIndeterminateAnimation = function () {\n        var _this = this;\n        var rotationStartPoint = 0;\n        var start = startIndeterminate;\n        var end = endIndeterminate;\n        var duration = DURATION_INDETERMINATE;\n        var animate = function () {\n            _this._animateCircle(start, end, materialEase, duration, rotationStartPoint);\n            // Prevent rotation from reaching Number.MAX_SAFE_INTEGER.\n            rotationStartPoint = (rotationStartPoint + end) % 100;\n            var temp = start;\n            start = -end;\n            end = -temp;\n        };\n        if (!this.interdeterminateInterval) {\n            this.interdeterminateInterval = setInterval(animate, duration + 50, 0, false);\n            animate();\n        }\n    };\n    /**\n     * Removes interval, ending the animation.\n     */\n    MdProgressCircle.prototype._cleanupIndeterminateAnimation = function () {\n        this.interdeterminateInterval = null;\n    };\n    __decorate$31([\n        _angular_core.Input(),\n        _angular_core.HostBinding('attr.aria-valuenow'), \n        __metadata$31('design:type', Object)\n    ], MdProgressCircle.prototype, \"value\", null);\n    __decorate$31([\n        _angular_core.HostBinding('attr.mode'),\n        _angular_core.Input(), \n        __metadata$31('design:type', Object)\n    ], MdProgressCircle.prototype, \"mode\", null);\n    MdProgressCircle = __decorate$31([\n        _angular_core.Component({selector: 'md-progress-circle',\n            host: {\n                'role': 'progressbar',\n                '[attr.aria-valuemin]': '_ariaValueMin',\n                '[attr.aria-valuemax]': '_ariaValueMax',\n            },\n            template: \"<!-- preserveAspectRatio of xMidYMid meet as the center of the viewport is the circle's center.  The center of the circle with remain at the center of the md-progress-circle element containing the SVG. --> <svg viewBox=\\\"0 0 100 100\\\" preserveAspectRatio=\\\"xMidYMid meet\\\"> <path [attr.d]=\\\"currentPath\\\"></path> </svg> \",\n            styles: [\":host { display: block; height: 100px; width: 100px; } :host svg { height: 100%; width: 100%; transform-origin: center; } :host path { fill: transparent; stroke-width: 10px; } :host[mode='indeterminate'] { animation-duration: 5250ms, 2887.5ms; animation-name: md-progress-circle-sporadic-rotate, md-progress-circle-linear-rotate; animation-timing-function: cubic-bezier(0.35, 0, 0.25, 1), linear; animation-iteration-count: infinite; transition: none; } @keyframes md-progress-circle-linear-rotate { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } @keyframes md-progress-circle-sporadic-rotate { 12.5% { transform: rotate(135deg); } 25% { transform: rotate(270deg); } 37.5% { transform: rotate(405deg); } 50% { transform: rotate(540deg); } 62.5% { transform: rotate(675deg); } 75% { transform: rotate(810deg); } 87.5% { transform: rotate(945deg); } 100% { transform: rotate(1080deg); } } /*# sourceMappingURL=progress-circle.css.map */ \"],\n            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,\n        }), \n        __metadata$31('design:paramtypes', [_angular_core.ChangeDetectorRef])\n    ], MdProgressCircle);\n    return MdProgressCircle;\n}());\n/**\n * <md-spinner> component.\n *\n * This is a component definition to be used as a convenience reference to create an\n * indeterminate <md-progress-circle> instance.\n */\nvar MdSpinner = (function (_super) {\n    __extends$12(MdSpinner, _super);\n    function MdSpinner(changeDetectorRef) {\n        _super.call(this, changeDetectorRef);\n        this.mode = 'indeterminate';\n    }\n    MdSpinner = __decorate$31([\n        _angular_core.Component({selector: 'md-spinner',\n            host: {\n                'role': 'progressbar',\n                'mode': 'indeterminate',\n            },\n            template: \"<!-- preserveAspectRatio of xMidYMid meet as the center of the viewport is the circle's center.  The center of the circle with remain at the center of the md-progress-circle element containing the SVG. --> <svg viewBox=\\\"0 0 100 100\\\" preserveAspectRatio=\\\"xMidYMid meet\\\"> <path [attr.d]=\\\"currentPath\\\"></path> </svg> \",\n            styles: [\":host { display: block; height: 100px; width: 100px; } :host svg { height: 100%; width: 100%; transform-origin: center; } :host path { fill: transparent; stroke-width: 10px; } :host[mode='indeterminate'] { animation-duration: 5250ms, 2887.5ms; animation-name: md-progress-circle-sporadic-rotate, md-progress-circle-linear-rotate; animation-timing-function: cubic-bezier(0.35, 0, 0.25, 1), linear; animation-iteration-count: infinite; transition: none; } @keyframes md-progress-circle-linear-rotate { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } @keyframes md-progress-circle-sporadic-rotate { 12.5% { transform: rotate(135deg); } 25% { transform: rotate(270deg); } 37.5% { transform: rotate(405deg); } 50% { transform: rotate(540deg); } 62.5% { transform: rotate(675deg); } 75% { transform: rotate(810deg); } 87.5% { transform: rotate(945deg); } 100% { transform: rotate(1080deg); } } /*# sourceMappingURL=progress-circle.css.map */ \"],\n        }), \n        __metadata$31('design:paramtypes', [_angular_core.ChangeDetectorRef])\n    ], MdSpinner);\n    return MdSpinner;\n}(MdProgressCircle));\n/**\n * Module functions.\n */\n/** Clamps a value to be between 0 and 100. */\nfunction clamp(v) {\n    return Math.max(0, Math.min(100, v));\n}\n/**\n * Converts Polar coordinates to Cartesian.\n */\nfunction polarToCartesian(radius, pathRadius, angleInDegrees) {\n    var angleInRadians = (angleInDegrees - 90) * DEGREE_IN_RADIANS;\n    return (radius + (pathRadius * Math.cos(angleInRadians))) +\n        ',' + (radius + (pathRadius * Math.sin(angleInRadians)));\n}\n/**\n * Easing function for linear animation.\n */\nfunction linearEase(currentTime, startValue, changeInValue, duration) {\n    return changeInValue * currentTime / duration + startValue;\n}\n/**\n * Easing function to match material design indeterminate animation.\n */\nfunction materialEase(currentTime, startValue, changeInValue, duration) {\n    var time = currentTime / duration;\n    var timeCubed = Math.pow(time, 3);\n    var timeQuad = Math.pow(time, 4);\n    var timeQuint = Math.pow(time, 5);\n    return startValue + changeInValue * ((6 * timeQuint) + (-15 * timeQuad) + (10 * timeCubed));\n}\n/**\n * Determines the path value to define the arc.  Converting percentage values to to polar\n * coordinates on the circle, and then to cartesian coordinates in the viewport.\n *\n * @param currentValue The current percentage value of the progress circle, the percentage of the\n *    circle to fill.\n * @param rotation The starting point of the circle with 0 being the 0 degree point.\n * @return A string for an SVG path representing a circle filled from the starting point to the\n *    percentage value provided.\n */\nfunction getSvgArc(currentValue, rotation) {\n    // The angle can't be exactly 360, because the arc becomes hidden.\n    var maximumAngle = 359.99 / 100;\n    var startPoint = rotation || 0;\n    var radius = 50;\n    var pathRadius = 40;\n    var startAngle = startPoint * maximumAngle;\n    var endAngle = currentValue * maximumAngle;\n    var start = polarToCartesian(radius, pathRadius, startAngle);\n    var end = polarToCartesian(radius, pathRadius, endAngle + startAngle);\n    var arcSweep = endAngle < 0 ? 0 : 1;\n    var largeArcFlag;\n    if (endAngle < 0) {\n        largeArcFlag = endAngle >= -180 ? 0 : 1;\n    }\n    else {\n        largeArcFlag = endAngle <= 180 ? 0 : 1;\n    }\n    return \"M\" + start + \"A\" + pathRadius + \",\" + pathRadius + \" 0 \" + largeArcFlag + \",\" + arcSweep + \" \" + end;\n}\nvar MdProgressCircleModule = (function () {\n    function MdProgressCircleModule() {\n    }\n    MdProgressCircleModule.forRoot = function () {\n        return {\n            ngModule: MdProgressCircleModule,\n            providers: []\n        };\n    };\n    MdProgressCircleModule = __decorate$31([\n        _angular_core.NgModule({\n            exports: [MdProgressCircle, MdSpinner],\n            declarations: [MdProgressCircle, MdSpinner],\n        }), \n        __metadata$31('design:paramtypes', [])\n    ], MdProgressCircleModule);\n    return MdProgressCircleModule;\n}());\n\nvar __decorate$32 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$32 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n// TODO(josephperrott): Benchpress tests.\n// TODO(josephperrott): Add ARIA attributes for progressbar \"for\".\n/**\n * <md-progress-bar> component.\n */\nvar MdProgressBar = (function () {\n    function MdProgressBar() {\n        /** Value of the progressbar. Defaults to zero. Mirrored to aria-valuenow. */\n        this._value = 0;\n        /** Buffer value of the progress bar. Defaults to zero. */\n        this._bufferValue = 0;\n        /**\n         * Mode of the progress bar.\n         *\n         * Input must be one of these values: determinate, indeterminate, buffer, query, defaults to\n         * 'determinate'.\n         * Mirrored to mode attribute.\n         */\n        this.mode = 'determinate';\n    }\n    Object.defineProperty(MdProgressBar.prototype, \"value\", {\n        get: function () {\n            return this._value;\n        },\n        set: function (v) {\n            this._value = clamp$1(v || 0);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdProgressBar.prototype, \"bufferValue\", {\n        get: function () {\n            return this._bufferValue;\n        },\n        set: function (v) {\n            this._bufferValue = clamp$1(v || 0);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Gets the current transform value for the progress bar's primary indicator. */\n    MdProgressBar.prototype._primaryTransform = function () {\n        var scale = this.value / 100;\n        return { transform: \"scaleX(\" + scale + \")\" };\n    };\n    /**\n     * Gets the current transform value for the progress bar's buffer indicator.  Only used if the\n     * progress mode is set to buffer, otherwise returns an undefined, causing no transformation.\n     */\n    MdProgressBar.prototype._bufferTransform = function () {\n        if (this.mode == 'buffer') {\n            var scale = this.bufferValue / 100;\n            return { transform: \"scaleX(\" + scale + \")\" };\n        }\n    };\n    __decorate$32([\n        _angular_core.Input(),\n        _angular_core.HostBinding('attr.aria-valuenow'), \n        __metadata$32('design:type', Object)\n    ], MdProgressBar.prototype, \"value\", null);\n    __decorate$32([\n        _angular_core.Input(), \n        __metadata$32('design:type', Object)\n    ], MdProgressBar.prototype, \"bufferValue\", null);\n    __decorate$32([\n        _angular_core.Input(),\n        _angular_core.HostBinding('attr.mode'), \n        __metadata$32('design:type', Object)\n    ], MdProgressBar.prototype, \"mode\", void 0);\n    MdProgressBar = __decorate$32([\n        _angular_core.Component({selector: 'md-progress-bar',\n            host: {\n                'role': 'progressbar',\n                'aria-valuemin': '0',\n                'aria-valuemax': '100',\n            },\n            template: \"<!-- The background div is named as such because it appears below the other divs and is not sized based on values. --> <div class=\\\"md-progress-bar-background\\\"></div> <div class=\\\"md-progress-bar-buffer\\\" [ngStyle]=\\\"_bufferTransform()\\\"></div> <div class=\\\"md-progress-bar-primary md-progress-bar-fill\\\" [ngStyle]=\\\"_primaryTransform()\\\"></div> <div class=\\\"md-progress-bar-secondary md-progress-bar-fill\\\"></div> \",\n            styles: [\":host { display: block; height: 5px; overflow: hidden; position: relative; transform: translateZ(0); transition: opacity 250ms linear; width: 100%; } :host .md-progress-bar-background { background-repeat: repeat-x; background-size: 10px 4px; height: 100%; position: absolute; visibility: hidden; width: 100%; } :host .md-progress-bar-buffer { height: 100%; position: absolute; transform-origin: top left; transition: transform 250ms ease; width: 100%; } :host .md-progress-bar-secondary { visibility: hidden; } :host .md-progress-bar-fill { animation: none; height: 100%; position: absolute; transform-origin: top left; transition: transform 250ms ease; width: 100%; } :host .md-progress-bar-fill::after { animation: none; content: ''; display: inline-block; height: 100%; position: absolute; width: 100%; } :host[mode='query'] { transform: rotateZ(180deg); } :host[mode='indeterminate'] .md-progress-bar-fill, :host[mode='query'] .md-progress-bar-fill { transition: none; } :host[mode='indeterminate'] .md-progress-bar-primary, :host[mode='query'] .md-progress-bar-primary { animation: md-progress-bar-primary-indeterminate-translate 2000ms infinite linear; left: -145.166611%; } :host[mode='indeterminate'] .md-progress-bar-primary.md-progress-bar-fill::after, :host[mode='query'] .md-progress-bar-primary.md-progress-bar-fill::after { animation: md-progress-bar-primary-indeterminate-scale 2000ms infinite linear; } :host[mode='indeterminate'] .md-progress-bar-secondary, :host[mode='query'] .md-progress-bar-secondary { animation: md-progress-bar-secondary-indeterminate-translate 2000ms infinite linear; left: -54.888891%; visibility: visible; } :host[mode='indeterminate'] .md-progress-bar-secondary.md-progress-bar-fill::after, :host[mode='query'] .md-progress-bar-secondary.md-progress-bar-fill::after { animation: md-progress-bar-secondary-indeterminate-scale 2000ms infinite linear; } :host[mode='buffer'] .md-progress-bar-background { animation: md-progress-bar-background-scroll 250ms infinite linear; visibility: visible; } :host-context([dir='rtl']) { transform: rotateY(180deg); } @keyframes md-progress-bar-primary-indeterminate-translate { 0% { transform: translateX(0); } 20% { animation-timing-function: cubic-bezier(0.5, 0, 0.70173, 0.49582); transform: translateX(0); } 59.15% { animation-timing-function: cubic-bezier(0.30244, 0.38135, 0.55, 0.95635); transform: translateX(83.67142%); } 100% { transform: translateX(200.61106%); } } @keyframes md-progress-bar-primary-indeterminate-scale { 0% { transform: scaleX(0.08); } 36.65% { animation-timing-function: cubic-bezier(0.33473, 0.12482, 0.78584, 1); transform: scaleX(0.08); } 69.15% { animation-timing-function: cubic-bezier(0.06, 0.11, 0.6, 1); transform: scaleX(0.66148); } 100% { transform: scaleX(0.08); } } @keyframes md-progress-bar-secondary-indeterminate-translate { 0% { animation-timing-function: cubic-bezier(0.15, 0, 0.51506, 0.40969); transform: translateX(0); } 25% { animation-timing-function: cubic-bezier(0.31033, 0.28406, 0.8, 0.73371); transform: translateX(37.65191%); } 48.35% { animation-timing-function: cubic-bezier(0.4, 0.62704, 0.6, 0.90203); transform: translateX(84.38617%); } 100% { transform: translateX(160.27778%); } } @keyframes md-progress-bar-secondary-indeterminate-scale { 0% { animation-timing-function: cubic-bezier(0.15, 0, 0.51506, 0.40969); transform: scaleX(0.08); } 19.15% { animation-timing-function: cubic-bezier(0.31033, 0.28406, 0.8, 0.73371); transform: scaleX(0.4571); } 44.15% { animation-timing-function: cubic-bezier(0.4, 0.62704, 0.6, 0.90203); transform: scaleX(0.72796); } 100% { transform: scaleX(0.08); } } @keyframes md-progress-bar-background-scroll { to { transform: translateX(-10px); } } /*# sourceMappingURL=progress-bar.css.map */ \"],\n            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,\n        }), \n        __metadata$32('design:paramtypes', [])\n    ], MdProgressBar);\n    return MdProgressBar;\n}());\n/** Clamps a value to be between two numbers, by default 0 and 100. */\nfunction clamp$1(v, min, max) {\n    if (min === void 0) { min = 0; }\n    if (max === void 0) { max = 100; }\n    return Math.max(min, Math.min(max, v));\n}\nvar MdProgressBarModule = (function () {\n    function MdProgressBarModule() {\n    }\n    MdProgressBarModule.forRoot = function () {\n        return {\n            ngModule: MdProgressBarModule,\n            providers: []\n        };\n    };\n    MdProgressBarModule = __decorate$32([\n        _angular_core.NgModule({\n            imports: [_angular_common.CommonModule],\n            exports: [MdProgressBar],\n            declarations: [MdProgressBar],\n        }), \n        __metadata$32('design:paramtypes', [])\n    ], MdProgressBarModule);\n    return MdProgressBarModule;\n}());\n\nvar __extends$13 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __decorate$33 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$33 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar noop = function () { };\nvar MD_INPUT_CONTROL_VALUE_ACCESSOR = {\n    provide: _angular_forms.NG_VALUE_ACCESSOR,\n    useExisting: _angular_core.forwardRef(function () { return MdInput; }),\n    multi: true\n};\n// Invalid input type. Using one of these will throw an MdInputUnsupportedTypeError.\nvar MD_INPUT_INVALID_INPUT_TYPE = [\n    'file',\n    'radio',\n    'checkbox',\n];\nvar nextUniqueId$1 = 0;\nvar MdInputPlaceholderConflictError = (function (_super) {\n    __extends$13(MdInputPlaceholderConflictError, _super);\n    function MdInputPlaceholderConflictError() {\n        _super.call(this, 'Placeholder attribute and child element were both specified.');\n    }\n    return MdInputPlaceholderConflictError;\n}(MdError));\nvar MdInputUnsupportedTypeError = (function (_super) {\n    __extends$13(MdInputUnsupportedTypeError, _super);\n    function MdInputUnsupportedTypeError(type) {\n        _super.call(this, \"Input type \\\"\" + type + \"\\\" isn't supported by md-input.\");\n    }\n    return MdInputUnsupportedTypeError;\n}(MdError));\nvar MdInputDuplicatedHintError = (function (_super) {\n    __extends$13(MdInputDuplicatedHintError, _super);\n    function MdInputDuplicatedHintError(align) {\n        _super.call(this, \"A hint was already declared for 'align=\\\"\" + align + \"\\\"'.\");\n    }\n    return MdInputDuplicatedHintError;\n}(MdError));\n/**\n * The placeholder directive. The content can declare this to implement more\n * complex placeholders.\n */\nvar MdPlaceholder = (function () {\n    function MdPlaceholder() {\n    }\n    MdPlaceholder = __decorate$33([\n        _angular_core.Directive({\n            selector: 'md-placeholder'\n        }), \n        __metadata$33('design:paramtypes', [])\n    ], MdPlaceholder);\n    return MdPlaceholder;\n}());\n/** The hint directive, used to tag content as hint labels (going under the input). */\nvar MdHint = (function () {\n    function MdHint() {\n        // Whether to align the hint label at the start or end of the line.\n        this.align = 'start';\n    }\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', Object)\n    ], MdHint.prototype, \"align\", void 0);\n    MdHint = __decorate$33([\n        _angular_core.Directive({\n            selector: 'md-hint',\n            host: {\n                '[class.md-right]': 'align == \"end\"',\n                '[class.md-hint]': 'true'\n            }\n        }), \n        __metadata$33('design:paramtypes', [])\n    ], MdHint);\n    return MdHint;\n}());\n/**\n * Component that represents a text input. It encapsulates the <input> HTMLElement and\n * improve on its behaviour, along with styling it according to the Material Design.\n */\nvar MdInput = (function () {\n    function MdInput() {\n        this._focused = false;\n        this._value = '';\n        /** Callback registered via registerOnTouched (ControlValueAccessor) */\n        this._onTouchedCallback = noop;\n        /** Callback registered via registerOnChange (ControlValueAccessor) */\n        this._onChangeCallback = noop;\n        /**\n         * Bindings.\n         */\n        this.align = 'start';\n        this.dividerColor = 'primary';\n        this.floatingPlaceholder = true;\n        this.hintLabel = '';\n        this.autofocus = false;\n        this.disabled = false;\n        this.id = \"md-input-\" + nextUniqueId$1++;\n        this.list = null;\n        this.max = null;\n        this.maxlength = null;\n        this.min = null;\n        this.minlength = null;\n        this.placeholder = null;\n        this.readonly = false;\n        this.required = false;\n        this.spellcheck = false;\n        this.step = null;\n        this.tabindex = null;\n        this.type = 'text';\n        this.name = null;\n        this._blurEmitter = new _angular_core.EventEmitter();\n        this._focusEmitter = new _angular_core.EventEmitter();\n    }\n    Object.defineProperty(MdInput.prototype, \"focused\", {\n        /** Readonly properties. */\n        get: function () { return this._focused; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdInput.prototype, \"empty\", {\n        get: function () { return (this._value == null || this._value === '') && this.type !== 'date'; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdInput.prototype, \"characterCount\", {\n        get: function () {\n            return this.empty ? 0 : ('' + this._value).length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdInput.prototype, \"inputId\", {\n        get: function () { return this.id + \"-input\"; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdInput.prototype, \"onBlur\", {\n        get: function () {\n            return this._blurEmitter.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdInput.prototype, \"onFocus\", {\n        get: function () {\n            return this._focusEmitter.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdInput.prototype, \"value\", {\n        get: function () { return this._value; },\n        set: function (v) {\n            v = this._convertValueForInputType(v);\n            if (v !== this._value) {\n                this._value = v;\n                this._onChangeCallback(v);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ;\n    Object.defineProperty(MdInput.prototype, \"_align\", {\n        // This is to remove the `align` property of the `md-input` itself. Otherwise HTML5\n        // might place it as RTL when we don't want to. We still want to use `align` as an\n        // Input though, so we use HostBinding.\n        get: function () { return null; },\n        enumerable: true,\n        configurable: true\n    });\n    /** Set focus on input */\n    MdInput.prototype.focus = function () {\n        this._inputElement.nativeElement.focus();\n    };\n    MdInput.prototype._handleFocus = function (event) {\n        this._focused = true;\n        this._focusEmitter.emit(event);\n    };\n    MdInput.prototype._handleBlur = function (event) {\n        this._focused = false;\n        this._onTouchedCallback();\n        this._blurEmitter.emit(event);\n    };\n    MdInput.prototype._handleChange = function (event) {\n        this.value = event.target.value;\n        this._onTouchedCallback();\n    };\n    MdInput.prototype._hasPlaceholder = function () {\n        return !!this.placeholder || this._placeholderChild != null;\n    };\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * TODO: internal\n     */\n    MdInput.prototype.writeValue = function (value) {\n        this._value = value;\n    };\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * TODO: internal\n     */\n    MdInput.prototype.registerOnChange = function (fn) {\n        this._onChangeCallback = fn;\n    };\n    /**\n     * Implemented as part of ControlValueAccessor.\n     * TODO: internal\n     */\n    MdInput.prototype.registerOnTouched = function (fn) {\n        this._onTouchedCallback = fn;\n    };\n    /** TODO: internal */\n    MdInput.prototype.ngAfterContentInit = function () {\n        var _this = this;\n        this._validateConstraints();\n        // Trigger validation when the hint children change.\n        this._hintChildren.changes.subscribe(function () {\n            _this._validateConstraints();\n        });\n    };\n    /** TODO: internal */\n    MdInput.prototype.ngOnChanges = function (changes) {\n        this._validateConstraints();\n    };\n    /**\n     * Convert the value passed in to a value that is expected from the type of the md-input.\n     * This is normally performed by the *_VALUE_ACCESSOR in forms, but since the type is bound\n     * on our internal input it won't work locally.\n     * @private\n     */\n    MdInput.prototype._convertValueForInputType = function (v) {\n        switch (this.type) {\n            case 'number': return parseFloat(v);\n            default: return v;\n        }\n    };\n    /**\n     * Ensure that all constraints defined by the API are validated, or throw errors otherwise.\n     * Constraints for now:\n     *   - placeholder attribute and <md-placeholder> are mutually exclusive.\n     *   - type attribute is not one of the forbidden types (see constant at the top).\n     *   - Maximum one of each `<md-hint>` alignment specified, with the attribute being\n     *     considered as align=\"start\".\n     * @private\n     */\n    MdInput.prototype._validateConstraints = function () {\n        var _this = this;\n        if (this.placeholder != '' && this.placeholder != null && this._placeholderChild != null) {\n            throw new MdInputPlaceholderConflictError();\n        }\n        if (MD_INPUT_INVALID_INPUT_TYPE.indexOf(this.type) != -1) {\n            throw new MdInputUnsupportedTypeError(this.type);\n        }\n        if (this._hintChildren) {\n            // Validate the hint labels.\n            var startHint_1 = null;\n            var endHint_1 = null;\n            this._hintChildren.forEach(function (hint) {\n                if (hint.align == 'start') {\n                    if (startHint_1 || _this.hintLabel) {\n                        throw new MdInputDuplicatedHintError('start');\n                    }\n                    startHint_1 = hint;\n                }\n                else if (hint.align == 'end') {\n                    if (endHint_1) {\n                        throw new MdInputDuplicatedHintError('end');\n                    }\n                    endHint_1 = hint;\n                }\n            });\n        }\n    };\n    __decorate$33([\n        _angular_core.Input('aria-label'), \n        __metadata$33('design:type', String)\n    ], MdInput.prototype, \"ariaLabel\", void 0);\n    __decorate$33([\n        _angular_core.Input('aria-labelledby'), \n        __metadata$33('design:type', String)\n    ], MdInput.prototype, \"ariaLabelledBy\", void 0);\n    __decorate$33([\n        _angular_core.Input('aria-disabled'),\n        BooleanFieldValue(), \n        __metadata$33('design:type', Boolean)\n    ], MdInput.prototype, \"ariaDisabled\", void 0);\n    __decorate$33([\n        _angular_core.Input('aria-required'),\n        BooleanFieldValue(), \n        __metadata$33('design:type', Boolean)\n    ], MdInput.prototype, \"ariaRequired\", void 0);\n    __decorate$33([\n        _angular_core.Input('aria-invalid'),\n        BooleanFieldValue(), \n        __metadata$33('design:type', Boolean)\n    ], MdInput.prototype, \"ariaInvalid\", void 0);\n    __decorate$33([\n        _angular_core.ContentChild(MdPlaceholder), \n        __metadata$33('design:type', MdPlaceholder)\n    ], MdInput.prototype, \"_placeholderChild\", void 0);\n    __decorate$33([\n        _angular_core.ContentChildren(MdHint), \n        __metadata$33('design:type', _angular_core.QueryList)\n    ], MdInput.prototype, \"_hintChildren\", void 0);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', Object)\n    ], MdInput.prototype, \"align\", void 0);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', Object)\n    ], MdInput.prototype, \"dividerColor\", void 0);\n    __decorate$33([\n        _angular_core.Input(),\n        BooleanFieldValue(), \n        __metadata$33('design:type', Boolean)\n    ], MdInput.prototype, \"floatingPlaceholder\", void 0);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', String)\n    ], MdInput.prototype, \"hintLabel\", void 0);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', String)\n    ], MdInput.prototype, \"autocomplete\", void 0);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', String)\n    ], MdInput.prototype, \"autocorrect\", void 0);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', String)\n    ], MdInput.prototype, \"autocapitalize\", void 0);\n    __decorate$33([\n        _angular_core.Input(),\n        BooleanFieldValue(), \n        __metadata$33('design:type', Boolean)\n    ], MdInput.prototype, \"autofocus\", void 0);\n    __decorate$33([\n        _angular_core.Input(),\n        BooleanFieldValue(), \n        __metadata$33('design:type', Boolean)\n    ], MdInput.prototype, \"disabled\", void 0);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', String)\n    ], MdInput.prototype, \"id\", void 0);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', String)\n    ], MdInput.prototype, \"list\", void 0);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', Object)\n    ], MdInput.prototype, \"max\", void 0);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', Number)\n    ], MdInput.prototype, \"maxlength\", void 0);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', Object)\n    ], MdInput.prototype, \"min\", void 0);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', Number)\n    ], MdInput.prototype, \"minlength\", void 0);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', String)\n    ], MdInput.prototype, \"placeholder\", void 0);\n    __decorate$33([\n        _angular_core.Input(),\n        BooleanFieldValue(), \n        __metadata$33('design:type', Boolean)\n    ], MdInput.prototype, \"readonly\", void 0);\n    __decorate$33([\n        _angular_core.Input(),\n        BooleanFieldValue(), \n        __metadata$33('design:type', Boolean)\n    ], MdInput.prototype, \"required\", void 0);\n    __decorate$33([\n        _angular_core.Input(),\n        BooleanFieldValue(), \n        __metadata$33('design:type', Boolean)\n    ], MdInput.prototype, \"spellcheck\", void 0);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', Number)\n    ], MdInput.prototype, \"step\", void 0);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', Number)\n    ], MdInput.prototype, \"tabindex\", void 0);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', String)\n    ], MdInput.prototype, \"type\", void 0);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', String)\n    ], MdInput.prototype, \"name\", void 0);\n    __decorate$33([\n        _angular_core.Output('blur'), \n        __metadata$33('design:type', rxjs_Observable.Observable)\n    ], MdInput.prototype, \"onBlur\", null);\n    __decorate$33([\n        _angular_core.Output('focus'), \n        __metadata$33('design:type', rxjs_Observable.Observable)\n    ], MdInput.prototype, \"onFocus\", null);\n    __decorate$33([\n        _angular_core.Input(), \n        __metadata$33('design:type', Object)\n    ], MdInput.prototype, \"value\", null);\n    __decorate$33([\n        _angular_core.HostBinding('attr.align'), \n        __metadata$33('design:type', Object)\n    ], MdInput.prototype, \"_align\", null);\n    __decorate$33([\n        _angular_core.ViewChild('input'), \n        __metadata$33('design:type', _angular_core.ElementRef)\n    ], MdInput.prototype, \"_inputElement\", void 0);\n    MdInput = __decorate$33([\n        _angular_core.Component({selector: 'md-input',\n            template: \"<div class=\\\"md-input-wrapper\\\"> <div class=\\\"md-input-table\\\"> <div class=\\\"md-input-prefix\\\"><ng-content select=\\\"[md-prefix]\\\"></ng-content></div> <div class=\\\"md-input-infix\\\"> <input #input aria-target class=\\\"md-input-element\\\" [class.md-end]=\\\"align == 'end'\\\" [attr.aria-label]=\\\"ariaLabel\\\" [attr.aria-labelledby]=\\\"ariaLabelledBy\\\" [attr.aria-disabled]=\\\"ariaDisabled\\\" [attr.aria-required]=\\\"ariaRequired\\\" [attr.aria-invalid]=\\\"ariaInvalid\\\" [attr.autocomplete]=\\\"autocomplete\\\" [attr.autocorrect]=\\\"autocorrect\\\" [attr.autocapitalize]=\\\"autocapitalize\\\" [autofocus]=\\\"autofocus\\\" [disabled]=\\\"disabled\\\" [id]=\\\"inputId\\\" [attr.list]=\\\"list\\\" [attr.max]=\\\"max\\\" [attr.maxlength]=\\\"maxlength\\\" [attr.min]=\\\"min\\\" [attr.minlength]=\\\"minlength\\\" [readonly]=\\\"readonly\\\" [required]=\\\"required\\\" [spellcheck]=\\\"spellcheck\\\" [attr.step]=\\\"step\\\" [attr.tabindex]=\\\"tabindex\\\" [type]=\\\"type\\\" [attr.name]=\\\"name\\\" (focus)=\\\"_handleFocus($event)\\\" (blur)=\\\"_handleBlur($event)\\\" [(ngModel)]=\\\"value\\\" (change)=\\\"_handleChange($event)\\\"> <label class=\\\"md-input-placeholder\\\" [attr.for]=\\\"inputId\\\" [class.md-empty]=\\\"empty\\\" [class.md-focused]=\\\"focused\\\" [class.md-float]=\\\"floatingPlaceholder\\\" [class.md-accent]=\\\"dividerColor == 'accent'\\\" [class.md-warn]=\\\"dividerColor == 'warn'\\\" *ngIf=\\\"_hasPlaceholder()\\\"> <ng-content select=\\\"md-placeholder\\\"></ng-content> {{placeholder}} <span class=\\\"md-placeholder-required\\\" *ngIf=\\\"required\\\">*</span> </label> </div> <div class=\\\"md-input-suffix\\\"><ng-content select=\\\"[md-suffix]\\\"></ng-content></div> </div> <div class=\\\"md-input-underline\\\" [class.md-disabled]=\\\"disabled\\\"> <span class=\\\"md-input-ripple\\\" [class.md-focused]=\\\"focused\\\" [class.md-accent]=\\\"dividerColor == 'accent'\\\" [class.md-warn]=\\\"dividerColor == 'warn'\\\"></span> </div> <div *ngIf=\\\"hintLabel != ''\\\" class=\\\"md-hint\\\">{{hintLabel}}</div> <ng-content select=\\\"md-hint\\\"></ng-content> </div> \",\n            styles: [\"md-input { display: inline-block; position: relative; font-family: Roboto, \\\"Helvetica Neue\\\", sans-serif; text-align: left; } [dir='rtl'] md-input { text-align: right; } .md-input-wrapper { margin: 16px 0; } .md-input-table { display: inline-table; flex-flow: column; vertical-align: bottom; width: 100%; } .md-input-table > * { display: table-cell; } .md-input-infix { position: relative; } .md-input-element { font: inherit; background: transparent; color: currentColor; border: none; outline: none; padding: 0; width: 100%; } .md-input-element.md-end { text-align: right; } [dir='rtl'] .md-input-element.md-end { text-align: left; } .md-input-element:-moz-ui-invalid { box-shadow: none; } .md-input-element:-webkit-autofill + .md-input-placeholder { display: block; padding-bottom: 5px; transform: translateY(-100%) scale(0.75); width: 133.33333%; } .md-input-placeholder { position: absolute; left: 0; top: 0; font-size: 100%; pointer-events: none; z-index: 1; width: 100%; display: none; white-space: nowrap; text-overflow: ellipsis; overflow-x: hidden; transform: translateY(0); transform-origin: bottom left; transition: transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1), scale 400ms cubic-bezier(0.25, 0.8, 0.25, 1), color 400ms cubic-bezier(0.25, 0.8, 0.25, 1), width 400ms cubic-bezier(0.25, 0.8, 0.25, 1); } .md-input-placeholder.md-empty { display: block; cursor: text; } .md-input-placeholder.md-float:not(.md-empty), .md-input-placeholder.md-float.md-focused { display: block; padding-bottom: 5px; transform: translateY(-100%) scale(0.75); width: 133.33333%; } [dir='rtl'] .md-input-placeholder { transform-origin: bottom right; } .md-input-underline { position: absolute; height: 1px; width: 100%; margin-top: 4px; border-top-width: 1px; border-top-style: solid; } .md-input-underline.md-disabled { border-top: 0; background-image: linear-gradient(to right, rgba(0, 0, 0, 0.26) 0%, rgba(0, 0, 0, 0.26) 33%, transparent 0%); background-position: 0; background-size: 4px 1px; background-repeat: repeat-x; } .md-input-underline .md-input-ripple { position: absolute; height: 2px; z-index: 1; top: -1px; width: 100%; transform-origin: top; opacity: 0; transform: scaleY(0); transition: transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1), opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1); } .md-input-underline .md-input-ripple.md-focused { opacity: 1; transform: scaleY(1); } .md-hint { position: absolute; font-size: 75%; bottom: -0.5em; } .md-hint.md-right { right: 0; } [dir='rtl'] .md-hint { right: 0; left: auto; } [dir='rtl'] .md-hint.md-right { right: auto; left: 0; } /*# sourceMappingURL=input.css.map */ \"],\n            providers: [MD_INPUT_CONTROL_VALUE_ACCESSOR],\n            host: { '(click)': 'focus()' },\n            encapsulation: _angular_core.ViewEncapsulation.None,\n        }), \n        __metadata$33('design:paramtypes', [])\n    ], MdInput);\n    return MdInput;\n}());\nvar MdInputModule = (function () {\n    function MdInputModule() {\n    }\n    MdInputModule.forRoot = function () {\n        return {\n            ngModule: MdInputModule,\n            providers: []\n        };\n    };\n    MdInputModule = __decorate$33([\n        _angular_core.NgModule({\n            declarations: [MdPlaceholder, MdInput, MdHint],\n            imports: [_angular_common.CommonModule, _angular_forms.FormsModule],\n            exports: [MdPlaceholder, MdInput, MdHint],\n        }), \n        __metadata$33('design:paramtypes', [])\n    ], MdInputModule);\n    return MdInputModule;\n}());\n\n// TODO(josephperrott): Implement onAction observable.\n/**\n * Reference to a snack bar dispatched from the snack bar service.\n */\nvar MdSnackBarRef = (function () {\n    function MdSnackBarRef(instance, _overlayRef) {\n        this._overlayRef = _overlayRef;\n        /** Subject for notifying the user that the snack bar has closed. */\n        this._afterClosed = new rxjs_Subject.Subject();\n        // Sets the readonly instance of the snack bar content component.\n        this.instance = instance;\n    }\n    /** Dismisses the snack bar. */\n    MdSnackBarRef.prototype.dismiss = function () {\n        if (!this._afterClosed.closed) {\n            this._overlayRef.dispose();\n            this._afterClosed.complete();\n        }\n    };\n    /** Gets an observable that is notified when the snack bar is finished closing. */\n    MdSnackBarRef.prototype.afterDismissed = function () {\n        return this._afterClosed.asObservable();\n    };\n    return MdSnackBarRef;\n}());\n\nvar __extends$15 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar MdSnackBarContentAlreadyAttached = (function (_super) {\n    __extends$15(MdSnackBarContentAlreadyAttached, _super);\n    function MdSnackBarContentAlreadyAttached() {\n        _super.call(this, 'Attempting to attach snack bar content after content is already attached');\n    }\n    return MdSnackBarContentAlreadyAttached;\n}(MdError));\n\nvar __extends$14 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __decorate$35 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$35 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/**\n * Internal component that wraps user-provided snack bar content.\n */\nvar MdSnackBarContainer = (function (_super) {\n    __extends$14(MdSnackBarContainer, _super);\n    function MdSnackBarContainer() {\n        _super.apply(this, arguments);\n    }\n    /** Attach a portal as content to this snack bar container. */\n    MdSnackBarContainer.prototype.attachComponentPortal = function (portal) {\n        if (this._portalHost.hasAttached()) {\n            throw new MdSnackBarContentAlreadyAttached();\n        }\n        return this._portalHost.attachComponentPortal(portal);\n    };\n    MdSnackBarContainer.prototype.attachTemplatePortal = function (portal) {\n        throw Error('Not yet implemented');\n    };\n    __decorate$35([\n        _angular_core.ViewChild(PortalHostDirective), \n        __metadata$35('design:type', PortalHostDirective)\n    ], MdSnackBarContainer.prototype, \"_portalHost\", void 0);\n    MdSnackBarContainer = __decorate$35([\n        _angular_core.Component({selector: 'snack-bar-container',\n            template: \"<template portalHost></template>\",\n            styles: [\":host { box-shadow: 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12); background: #323232; border-radius: 2px; display: block; height: 20px; max-width: 568px; min-width: 288px; overflow: hidden; padding: 14px 24px; } /*# sourceMappingURL=snack-bar-container.css.map */ \"],\n            host: {\n                'role': 'alert'\n            }\n        }), \n        __metadata$35('design:paramtypes', [])\n    ], MdSnackBarContainer);\n    return MdSnackBarContainer;\n}(BasePortalHost));\n\nvar __decorate$36 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$36 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/**\n * A component used to open as the default snack bar, matching material spec.\n * This should only be used internally by the snack bar service.\n */\nvar SimpleSnackBar = (function () {\n    function SimpleSnackBar() {\n    }\n    /** Dismisses the snack bar. */\n    SimpleSnackBar.prototype.dismiss = function () {\n        this.snackBarRef.dismiss();\n    };\n    Object.defineProperty(SimpleSnackBar.prototype, \"hasAction\", {\n        /** If the action button should be shown. */\n        get: function () { return !!this.action; },\n        enumerable: true,\n        configurable: true\n    });\n    SimpleSnackBar = __decorate$36([\n        _angular_core.Component({selector: 'simple-snack-bar',\n            template: \"<span class=\\\"md-simple-snackbar-message\\\">{{message}}</span> <button md-button class=\\\"md-simple-snackbar-action\\\" *ngIf=\\\"hasAction\\\" (click)=\\\"dismiss()\\\">{{action}}</button>\",\n            styles: [\"md-simple-snackbar { display: flex; justify-content: space-between; } .md-simple-snackbar-message { box-sizing: border-box; border: none; color: white; font-family: Roboto, 'Helvetica Neue', sans-serif; font-size: 14px; line-height: 20px; outline: none; text-decoration: none; word-break: break-all; } .md-simple-snackbar-action { box-sizing: border-box; color: white; float: right; font-weight: 600; line-height: 20px; margin: -5px 0 0 48px; min-width: initial; padding: 5px; text-transform: uppercase; } /*# sourceMappingURL=simple-snack-bar.css.map */ \"],\n        }), \n        __metadata$36('design:paramtypes', [])\n    ], SimpleSnackBar);\n    return SimpleSnackBar;\n}());\n\nvar MdSnackBarConfig = (function () {\n    function MdSnackBarConfig(viewContainerRef) {\n        /** The politeness level for the MdAriaLiveAnnouncer announcement. */\n        this.politeness = 'assertive';\n        this.viewContainerRef = viewContainerRef;\n    }\n    return MdSnackBarConfig;\n}());\n\nvar __decorate$34 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$34 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n// TODO(josephperrott): Animate entrance and exit of snack bars.\n// TODO(josephperrott): Automate dismiss after timeout.\n/**\n * Service to dispatch Material Design snack bar messages.\n */\nvar MdSnackBar = (function () {\n    function MdSnackBar(_overlay, _live) {\n        this._overlay = _overlay;\n        this._live = _live;\n    }\n    /**\n     * Creates and dispatches a snack bar with a custom component for the content, removing any\n     * currently opened snack bars.\n     */\n    MdSnackBar.prototype.openFromComponent = function (component, config) {\n        if (this._snackBarRef) {\n            this._snackBarRef.dismiss();\n        }\n        var overlayRef = this._createOverlay();\n        var snackBarContainer = this._attachSnackBarContainer(overlayRef, config);\n        var mdSnackBarRef = this._attachSnackbarContent(component, snackBarContainer, overlayRef);\n        this._live.announce(config.announcementMessage, config.politeness);\n        return mdSnackBarRef;\n    };\n    /**\n     * Creates and dispatches a snack bar.\n     */\n    MdSnackBar.prototype.open = function (message, actionLabel, config) {\n        config.announcementMessage = message;\n        var simpleSnackBarRef = this.openFromComponent(SimpleSnackBar, config);\n        simpleSnackBarRef.instance.snackBarRef = simpleSnackBarRef;\n        simpleSnackBarRef.instance.message = message;\n        simpleSnackBarRef.instance.action = actionLabel;\n        return simpleSnackBarRef;\n    };\n    /**\n     * Attaches the snack bar container component to the overlay.\n     */\n    MdSnackBar.prototype._attachSnackBarContainer = function (overlayRef, config) {\n        var containerPortal = new ComponentPortal(MdSnackBarContainer, config.viewContainerRef);\n        var containerRef = overlayRef.attach(containerPortal);\n        containerRef.instance.snackBarConfig = config;\n        return containerRef.instance;\n    };\n    /**\n     * Places a new component as the content of the snack bar container.\n     */\n    MdSnackBar.prototype._attachSnackbarContent = function (component, container, overlayRef) {\n        var portal = new ComponentPortal(component);\n        var contentRef = container.attachComponentPortal(portal);\n        var snackBarRef = new MdSnackBarRef(contentRef.instance, overlayRef);\n        this._snackBarRef = snackBarRef;\n        return snackBarRef;\n    };\n    /**\n     * Creates a new overlay and places it in the correct location.\n     */\n    MdSnackBar.prototype._createOverlay = function () {\n        var state = new OverlayState();\n        state.positionStrategy = this._overlay.position().global()\n            .fixed()\n            .centerHorizontally()\n            .bottom('0');\n        return this._overlay.create(state);\n    };\n    MdSnackBar = __decorate$34([\n        _angular_core.Injectable(), \n        __metadata$34('design:paramtypes', [Overlay, MdLiveAnnouncer])\n    ], MdSnackBar);\n    return MdSnackBar;\n}());\nvar MdSnackBarModule = (function () {\n    function MdSnackBarModule() {\n    }\n    MdSnackBarModule.forRoot = function () {\n        return {\n            ngModule: MdSnackBarModule,\n            providers: [MdSnackBar, OVERLAY_PROVIDERS, MdLiveAnnouncer]\n        };\n    };\n    MdSnackBarModule = __decorate$34([\n        _angular_core.NgModule({\n            imports: [OverlayModule, PortalModule, _angular_common.CommonModule],\n            exports: [MdSnackBarContainer],\n            declarations: [MdSnackBarContainer, SimpleSnackBar],\n            entryComponents: [MdSnackBarContainer, SimpleSnackBar],\n        }), \n        __metadata$34('design:paramtypes', [])\n    ], MdSnackBarModule);\n    return MdSnackBarModule;\n}());\n\nvar __extends$16 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __decorate$38 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$38 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/** Used to flag tab labels for use with the portal directive */\nvar MdTabLabel = (function (_super) {\n    __extends$16(MdTabLabel, _super);\n    function MdTabLabel(templateRef, viewContainerRef) {\n        _super.call(this, templateRef, viewContainerRef);\n    }\n    MdTabLabel = __decorate$38([\n        _angular_core.Directive({\n            selector: '[md-tab-label]',\n        }), \n        __metadata$38('design:paramtypes', [_angular_core.TemplateRef, _angular_core.ViewContainerRef])\n    ], MdTabLabel);\n    return MdTabLabel;\n}(TemplatePortalDirective));\n\nvar __extends$17 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __decorate$39 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$39 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/** Used to flag tab contents for use with the portal directive */\nvar MdTabContent = (function (_super) {\n    __extends$17(MdTabContent, _super);\n    function MdTabContent(templateRef, viewContainerRef) {\n        _super.call(this, templateRef, viewContainerRef);\n    }\n    MdTabContent = __decorate$39([\n        _angular_core.Directive({\n            selector: '[md-tab-content]'\n        }), \n        __metadata$39('design:paramtypes', [_angular_core.TemplateRef, _angular_core.ViewContainerRef])\n    ], MdTabContent);\n    return MdTabContent;\n}(TemplatePortalDirective));\n\nvar __decorate$40 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$40 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/** Used in the `md-tab-group` view to display tab labels */\nvar MdTabLabelWrapper = (function () {\n    function MdTabLabelWrapper(elementRef) {\n        this.elementRef = elementRef;\n    }\n    /**\n     * Sets focus on the wrapper element\n     */\n    MdTabLabelWrapper.prototype.focus = function () {\n        this.elementRef.nativeElement.focus();\n    };\n    MdTabLabelWrapper = __decorate$40([\n        _angular_core.Directive({\n            selector: '[md-tab-label-wrapper]'\n        }), \n        __metadata$40('design:paramtypes', [_angular_core.ElementRef])\n    ], MdTabLabelWrapper);\n    return MdTabLabelWrapper;\n}());\n\nvar __decorate$41 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$41 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/** The ink-bar is used to display and animate the line underneath the current active tab label. */\nvar MdInkBar = (function () {\n    function MdInkBar(_renderer, _elementRef) {\n        this._renderer = _renderer;\n        this._elementRef = _elementRef;\n    }\n    /**\n     * Calculates the styles from the provided element in order to align the ink-bar to that element.\n     * @param element\n     */\n    MdInkBar.prototype.alignToElement = function (element) {\n        this._renderer.setElementStyle(this._elementRef.nativeElement, 'left', this._getLeftPosition(element));\n        this._renderer.setElementStyle(this._elementRef.nativeElement, 'width', this._getElementWidth(element));\n    };\n    /**\n     * Generates the pixel distance from the left based on the provided element in string format.\n     * @param element\n     * @returns {string}\n     */\n    MdInkBar.prototype._getLeftPosition = function (element) {\n        return element ? element.offsetLeft + 'px' : '0';\n    };\n    /**\n     * Generates the pixel width from the provided element in string format.\n     * @param element\n     * @returns {string}\n     */\n    MdInkBar.prototype._getElementWidth = function (element) {\n        return element ? element.offsetWidth + 'px' : '0';\n    };\n    MdInkBar = __decorate$41([\n        _angular_core.Directive({\n            selector: 'md-ink-bar',\n        }), \n        __metadata$41('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])\n    ], MdInkBar);\n    return MdInkBar;\n}());\n\nvar __decorate$37 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$37 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/** Used to generate unique ID's for each tab component */\nvar nextId$2 = 0;\n/** A simple change event emitted on focus or selection changes. */\nvar MdTabChangeEvent = (function () {\n    function MdTabChangeEvent() {\n    }\n    return MdTabChangeEvent;\n}());\nvar MdTab = (function () {\n    function MdTab() {\n        // TODO: Replace this when BooleanFieldValue is removed.\n        this._disabled = false;\n    }\n    Object.defineProperty(MdTab.prototype, \"disabled\", {\n        get: function () {\n            return this._disabled;\n        },\n        set: function (value) {\n            this._disabled = (value != null && \"\" + value !== 'false');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    __decorate$37([\n        _angular_core.ContentChild(MdTabLabel), \n        __metadata$37('design:type', MdTabLabel)\n    ], MdTab.prototype, \"label\", void 0);\n    __decorate$37([\n        _angular_core.ContentChild(MdTabContent), \n        __metadata$37('design:type', MdTabContent)\n    ], MdTab.prototype, \"content\", void 0);\n    __decorate$37([\n        _angular_core.Input('disabled'), \n        __metadata$37('design:type', Boolean), \n        __metadata$37('design:paramtypes', [Boolean])\n    ], MdTab.prototype, \"disabled\", null);\n    MdTab = __decorate$37([\n        _angular_core.Directive({\n            selector: 'md-tab'\n        }), \n        __metadata$37('design:paramtypes', [])\n    ], MdTab);\n    return MdTab;\n}());\n/**\n * Material design tab-group component.  Supports basic tab pairs (label + content) and includes\n * animated ink-bar, keyboard navigation, and screen reader.\n * See: https://www.google.com/design/spec/components/tabs.html\n */\nvar MdTabGroup = (function () {\n    function MdTabGroup(_zone) {\n        this._zone = _zone;\n        this._isInitialized = false;\n        this._selectedIndex = 0;\n        this._onFocusChange = new _angular_core.EventEmitter();\n        this._onSelectChange = new _angular_core.EventEmitter();\n        this._focusIndex = 0;\n        this._groupId = nextId$2++;\n    }\n    Object.defineProperty(MdTabGroup.prototype, \"selectedIndex\", {\n        get: function () {\n            return this._selectedIndex;\n        },\n        set: function (value) {\n            if (value != this._selectedIndex && this.isValidIndex(value)) {\n                this._selectedIndex = value;\n                if (this._isInitialized) {\n                    this._onSelectChange.emit(this._createChangeEvent(value));\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n     * providing a valid index and return true.\n     */\n    MdTabGroup.prototype.isValidIndex = function (index) {\n        if (this._tabs) {\n            var tab = this._tabs.toArray()[index];\n            return tab && !tab.disabled;\n        }\n        else {\n            return true;\n        }\n    };\n    Object.defineProperty(MdTabGroup.prototype, \"_selectedIndexChange\", {\n        /** Output to enable support for two-way binding on `selectedIndex`. */\n        get: function () {\n            return this.selectChange.map(function (event) { return event.index; });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdTabGroup.prototype, \"focusChange\", {\n        get: function () {\n            return this._onFocusChange.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdTabGroup.prototype, \"selectChange\", {\n        get: function () {\n            return this._onSelectChange.asObservable();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Waits one frame for the view to update, then upates the ink bar\n     * Note: This must be run outside of the zone or it will create an infinite change detection loop\n     * TODO: internal\n     */\n    MdTabGroup.prototype.ngAfterViewChecked = function () {\n        var _this = this;\n        this._zone.runOutsideAngular(function () {\n            window.requestAnimationFrame(function () {\n                _this._updateInkBar();\n            });\n        });\n        this._isInitialized = true;\n    };\n    /** Tells the ink-bar to align itself to the current label wrapper */\n    MdTabGroup.prototype._updateInkBar = function () {\n        this._inkBar.toArray()[0].alignToElement(this._currentLabelWrapper);\n    };\n    Object.defineProperty(MdTabGroup.prototype, \"_currentLabelWrapper\", {\n        /**\n         * Reference to the current label wrapper; defaults to null for initial render before the\n         * ViewChildren references are ready.\n         */\n        get: function () {\n            return this._labelWrappers && this._labelWrappers.length\n                ? this._labelWrappers.toArray()[this.selectedIndex].elementRef.nativeElement\n                : null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdTabGroup.prototype, \"focusIndex\", {\n        /** Tracks which element has focus; used for keyboard navigation */\n        get: function () {\n            return this._focusIndex;\n        },\n        /** When the focus index is set, we must manually send focus to the correct label */\n        set: function (value) {\n            if (this.isValidIndex(value)) {\n                this._focusIndex = value;\n                if (this._isInitialized) {\n                    this._onFocusChange.emit(this._createChangeEvent(value));\n                }\n                if (this._labelWrappers && this._labelWrappers.length) {\n                    this._labelWrappers.toArray()[value].focus();\n                }\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MdTabGroup.prototype._createChangeEvent = function (index) {\n        var event = new MdTabChangeEvent;\n        event.index = index;\n        if (this._tabs && this._tabs.length) {\n            event.tab = this._tabs.toArray()[index];\n        }\n        return event;\n    };\n    /** Returns a unique id for each tab label element */\n    MdTabGroup.prototype._getTabLabelId = function (i) {\n        return \"md-tab-label-\" + this._groupId + \"-\" + i;\n    };\n    /** Returns a unique id for each tab content element */\n    MdTabGroup.prototype._getTabContentId = function (i) {\n        return \"md-tab-content-\" + this._groupId + \"-\" + i;\n    };\n    MdTabGroup.prototype.handleKeydown = function (event) {\n        switch (event.keyCode) {\n            case RIGHT_ARROW:\n                this.focusNextTab();\n                break;\n            case LEFT_ARROW:\n                this.focusPreviousTab();\n                break;\n            case ENTER:\n                this.selectedIndex = this.focusIndex;\n                break;\n        }\n    };\n    /**\n     * Moves the focus left or right depending on the offset provided.  Valid offsets are 1 and -1.\n     */\n    MdTabGroup.prototype.moveFocus = function (offset) {\n        if (this._labelWrappers) {\n            var tabs = this._tabs.toArray();\n            for (var i = this.focusIndex + offset; i < tabs.length && i >= 0; i += offset) {\n                if (this.isValidIndex(i)) {\n                    this.focusIndex = i;\n                    return;\n                }\n            }\n        }\n    };\n    /** Increment the focus index by 1 until a valid tab is found. */\n    MdTabGroup.prototype.focusNextTab = function () {\n        this.moveFocus(1);\n    };\n    /** Decrement the focus index by 1 until a valid tab is found. */\n    MdTabGroup.prototype.focusPreviousTab = function () {\n        this.moveFocus(-1);\n    };\n    __decorate$37([\n        _angular_core.ContentChildren(MdTab), \n        __metadata$37('design:type', _angular_core.QueryList)\n    ], MdTabGroup.prototype, \"_tabs\", void 0);\n    __decorate$37([\n        _angular_core.ViewChildren(MdTabLabelWrapper), \n        __metadata$37('design:type', _angular_core.QueryList)\n    ], MdTabGroup.prototype, \"_labelWrappers\", void 0);\n    __decorate$37([\n        _angular_core.ViewChildren(MdInkBar), \n        __metadata$37('design:type', _angular_core.QueryList)\n    ], MdTabGroup.prototype, \"_inkBar\", void 0);\n    __decorate$37([\n        _angular_core.Input(), \n        __metadata$37('design:type', Number), \n        __metadata$37('design:paramtypes', [Number])\n    ], MdTabGroup.prototype, \"selectedIndex\", null);\n    __decorate$37([\n        _angular_core.Output('selectedIndexChange'), \n        __metadata$37('design:type', rxjs_Observable.Observable)\n    ], MdTabGroup.prototype, \"_selectedIndexChange\", null);\n    __decorate$37([\n        _angular_core.Output('focusChange'), \n        __metadata$37('design:type', rxjs_Observable.Observable)\n    ], MdTabGroup.prototype, \"focusChange\", null);\n    __decorate$37([\n        _angular_core.Output('selectChange'), \n        __metadata$37('design:type', rxjs_Observable.Observable)\n    ], MdTabGroup.prototype, \"selectChange\", null);\n    MdTabGroup = __decorate$37([\n        _angular_core.Component({selector: 'md-tab-group',\n            template: \"<div class=\\\"md-tab-header\\\" role=\\\"tablist\\\" (keydown)=\\\"handleKeydown($event)\\\"> <div class=\\\"md-tab-label\\\" role=\\\"tab\\\" md-tab-label-wrapper *ngFor=\\\"let tab of _tabs; let i = index\\\" [id]=\\\"_getTabLabelId(i)\\\" [tabIndex]=\\\"selectedIndex == i ? 0 : -1\\\" [attr.aria-controls]=\\\"_getTabContentId(i)\\\" [attr.aria-selected]=\\\"selectedIndex == i\\\" [class.md-tab-active]=\\\"selectedIndex == i\\\" [class.md-tab-disabled]=\\\"tab.disabled\\\" (click)=\\\"focusIndex = selectedIndex = i\\\"> <template [portalHost]=\\\"tab.label\\\"></template> </div> <md-ink-bar></md-ink-bar> </div> <div class=\\\"md-tab-body-wrapper\\\"> <div class=\\\"md-tab-body\\\" role=\\\"tabpanel\\\" *ngFor=\\\"let tab of _tabs; let i = index\\\" [id]=\\\"_getTabContentId(i)\\\" [class.md-tab-active]=\\\"selectedIndex == i\\\" [attr.aria-labelledby]=\\\"_getTabLabelId(i)\\\"> <template [ngIf]=\\\"selectedIndex == i\\\"> <template [portalHost]=\\\"tab.content\\\"></template> </template> </div> </div> \",\n            styles: [\":host { display: flex; flex-direction: column; font-family: Roboto, \\\"Helvetica Neue\\\", sans-serif; } .md-tab-header { overflow: hidden; position: relative; display: flex; flex-direction: row; flex-shrink: 0; } .md-tab-label { line-height: 48px; height: 48px; padding: 0 12px; font-size: 14px; font-family: Roboto, \\\"Helvetica Neue\\\", sans-serif; font-weight: 500; cursor: pointer; box-sizing: border-box; color: currentColor; opacity: 0.6; min-width: 160px; text-align: center; } .md-tab-label:focus { outline: none; opacity: 1; } .md-tab-disabled { cursor: default; pointer-events: none; } .md-tab-body-wrapper { position: relative; overflow: hidden; flex-grow: 1; display: flex; } .md-tab-body { display: none; overflow: auto; box-sizing: border-box; flex-grow: 1; flex-shrink: 1; } .md-tab-body.md-tab-active { display: block; } md-ink-bar { position: absolute; bottom: 0; height: 2px; transition: 350ms ease-out; } /*# sourceMappingURL=tab-group.css.map */ \"],\n        }), \n        __metadata$37('design:paramtypes', [_angular_core.NgZone])\n    ], MdTabGroup);\n    return MdTabGroup;\n}());\nvar MdTabsModule = (function () {\n    function MdTabsModule() {\n    }\n    MdTabsModule.forRoot = function () {\n        return {\n            ngModule: MdTabsModule,\n            providers: []\n        };\n    };\n    MdTabsModule = __decorate$37([\n        _angular_core.NgModule({\n            imports: [_angular_common.CommonModule, PortalModule],\n            // Don't export MdInkBar or MdTabLabelWrapper, as they are internal implementatino details.\n            exports: [MdTabGroup, MdTabLabel, MdTabContent, MdTab],\n            declarations: [MdTabGroup, MdTabLabel, MdTabContent, MdTab, MdInkBar, MdTabLabelWrapper],\n        }), \n        __metadata$37('design:paramtypes', [])\n    ], MdTabsModule);\n    return MdTabsModule;\n}());\n\nvar __decorate$42 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$42 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar MdToolbarRow = (function () {\n    function MdToolbarRow() {\n    }\n    MdToolbarRow = __decorate$42([\n        _angular_core.Directive({\n            selector: 'md-toolbar-row'\n        }), \n        __metadata$42('design:paramtypes', [])\n    ], MdToolbarRow);\n    return MdToolbarRow;\n}());\nvar MdToolbar = (function () {\n    function MdToolbar(elementRef, renderer) {\n        this.elementRef = elementRef;\n        this.renderer = renderer;\n    }\n    Object.defineProperty(MdToolbar.prototype, \"color\", {\n        get: function () {\n            return this._color;\n        },\n        set: function (value) {\n            this._updateColor(value);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MdToolbar.prototype._updateColor = function (newColor) {\n        this._setElementColor(this._color, false);\n        this._setElementColor(newColor, true);\n        this._color = newColor;\n    };\n    MdToolbar.prototype._setElementColor = function (color, isAdd) {\n        if (color != null && color != '') {\n            this.renderer.setElementClass(this.elementRef.nativeElement, \"md-\" + color, isAdd);\n        }\n    };\n    __decorate$42([\n        _angular_core.Input(), \n        __metadata$42('design:type', String)\n    ], MdToolbar.prototype, \"color\", null);\n    MdToolbar = __decorate$42([\n        _angular_core.Component({selector: 'md-toolbar',\n            template: \"<div class=\\\"md-toolbar-layout\\\"> <md-toolbar-row> <ng-content></ng-content> </md-toolbar-row> <ng-content select=\\\"md-toolbar-row\\\"></ng-content> </div>\",\n            styles: [\"md-toolbar { display: flex; box-sizing: border-box; width: 100%; min-height: 64px; font-size: 20px; font-weight: 400; font-family: Roboto, \\\"Helvetica Neue\\\", sans-serif; padding: 0 16px; flex-direction: column; } md-toolbar md-toolbar-row { display: flex; box-sizing: border-box; width: 100%; height: 64px; flex-direction: row; align-items: center; } /*# sourceMappingURL=toolbar.css.map */ \"],\n            changeDetection: _angular_core.ChangeDetectionStrategy.OnPush,\n            encapsulation: _angular_core.ViewEncapsulation.None\n        }), \n        __metadata$42('design:paramtypes', [_angular_core.ElementRef, _angular_core.Renderer])\n    ], MdToolbar);\n    return MdToolbar;\n}());\nvar MdToolbarModule = (function () {\n    function MdToolbarModule() {\n    }\n    MdToolbarModule.forRoot = function () {\n        return {\n            ngModule: MdToolbarModule,\n            providers: []\n        };\n    };\n    MdToolbarModule = __decorate$42([\n        _angular_core.NgModule({\n            exports: [MdToolbar, MdToolbarRow],\n            declarations: [MdToolbar, MdToolbarRow],\n        }), \n        __metadata$42('design:paramtypes', [])\n    ], MdToolbarModule);\n    return MdToolbarModule;\n}());\n\nvar __decorate$43 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$43 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar MdTooltip = (function () {\n    function MdTooltip(_overlay, _elementRef, _viewContainerRef, _changeDetectionRef) {\n        this._overlay = _overlay;\n        this._elementRef = _elementRef;\n        this._viewContainerRef = _viewContainerRef;\n        this._changeDetectionRef = _changeDetectionRef;\n        this.visible = false;\n        /** Allows the user to define the position of the tooltip relative to the parent element */\n        this._position = 'below';\n    }\n    Object.defineProperty(MdTooltip.prototype, \"position\", {\n        get: function () {\n            return this._position;\n        },\n        set: function (value) {\n            if (value !== this._position) {\n                this._position = value;\n                this._createOverlay();\n                this._updatePosition();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdTooltip.prototype, \"message\", {\n        get: function () {\n            return this._message;\n        },\n        set: function (value) {\n            this._message = value;\n            this._updatePosition();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Create overlay on init\n     * TODO: internal\n     */\n    MdTooltip.prototype.ngOnInit = function () {\n        this._createOverlay();\n    };\n    /**\n     * Create the overlay config and position strategy\n     */\n    MdTooltip.prototype._createOverlay = function () {\n        if (this._overlayRef) {\n            if (this.visible) {\n                // if visible, hide before destroying\n                this.hide();\n                this._createOverlay();\n            }\n            else {\n                // if not visible, dispose and recreate\n                this._overlayRef.dispose();\n                this._overlayRef = null;\n                this._createOverlay();\n            }\n        }\n        else {\n            var origin = this._getOrigin();\n            var position = this._getOverlayPosition();\n            var strategy = this._overlay.position().connectedTo(this._elementRef, origin, position);\n            var config = new OverlayState();\n            config.positionStrategy = strategy;\n            this._overlayRef = this._overlay.create(config);\n        }\n    };\n    /**\n     * Returns the origin position based on the user's position preference\n     */\n    MdTooltip.prototype._getOrigin = function () {\n        switch (this.position) {\n            case 'before': return { originX: 'start', originY: 'center' };\n            case 'after': return { originX: 'end', originY: 'center' };\n            case 'above': return { originX: 'center', originY: 'top' };\n            case 'below': return { originX: 'center', originY: 'bottom' };\n        }\n    };\n    /**\n     * Returns the overlay position based on the user's preference\n     */\n    MdTooltip.prototype._getOverlayPosition = function () {\n        switch (this.position) {\n            case 'before': return { overlayX: 'end', overlayY: 'center' };\n            case 'after': return { overlayX: 'start', overlayY: 'center' };\n            case 'above': return { overlayX: 'center', overlayY: 'bottom' };\n            case 'below': return { overlayX: 'center', overlayY: 'top' };\n        }\n    };\n    /**\n     * Shows the tooltip on mouse enter\n     * @param event\n     */\n    MdTooltip.prototype._handleMouseEnter = function (event) {\n        this.show();\n    };\n    /**\n     * Hides the tooltip on mouse leave\n     * @param event\n     */\n    MdTooltip.prototype._handleMouseLeave = function (event) {\n        this.hide();\n    };\n    /**\n     * Shows the tooltip and returns a promise that will resolve when the tooltip is visible\n     */\n    MdTooltip.prototype.show = function () {\n        if (!this.visible && this._overlayRef && !this._overlayRef.hasAttached()) {\n            this.visible = true;\n            var portal = new ComponentPortal(TooltipComponent, this._viewContainerRef);\n            var tooltipRef = this._overlayRef.attach(portal);\n            tooltipRef.instance.message = this.message;\n            this._updatePosition();\n        }\n    };\n    /**\n     * Hides the tooltip and returns a promise that will resolve when the tooltip is hidden\n     */\n    MdTooltip.prototype.hide = function () {\n        if (this.visible && this._overlayRef && this._overlayRef.hasAttached()) {\n            this.visible = false;\n            this._overlayRef.detach();\n        }\n    };\n    /**\n     * Shows/hides the tooltip and returns a promise that will resolve when it is done\n     */\n    MdTooltip.prototype.toggle = function () {\n        if (this.visible) {\n            this.hide();\n        }\n        else {\n            this.show();\n        }\n    };\n    /**\n     * Updates the tooltip's position\n     */\n    MdTooltip.prototype._updatePosition = function () {\n        if (this._overlayRef) {\n            this._changeDetectionRef.detectChanges();\n            this._overlayRef.updatePosition();\n        }\n    };\n    __decorate$43([\n        _angular_core.Input('tooltip-position'), \n        __metadata$43('design:type', String)\n    ], MdTooltip.prototype, \"position\", null);\n    __decorate$43([\n        _angular_core.Input('md-tooltip'), \n        __metadata$43('design:type', Object)\n    ], MdTooltip.prototype, \"message\", null);\n    MdTooltip = __decorate$43([\n        _angular_core.Directive({\n            selector: '[md-tooltip]',\n            host: {\n                '(mouseenter)': '_handleMouseEnter($event)',\n                '(mouseleave)': '_handleMouseLeave($event)',\n            }\n        }), \n        __metadata$43('design:paramtypes', [Overlay, _angular_core.ElementRef, _angular_core.ViewContainerRef, _angular_core.ChangeDetectorRef])\n    ], MdTooltip);\n    return MdTooltip;\n}());\nvar TooltipComponent = (function () {\n    function TooltipComponent() {\n    }\n    TooltipComponent = __decorate$43([\n        _angular_core.Component({selector: 'md-tooltip-component',\n            template: \"<div class=\\\"md-tooltip\\\">{{message}}</div>\",\n            styles: [\":host { pointer-events: none; } .md-tooltip { color: white; padding: 0 8px; border-radius: 2px; font-family: Roboto, \\\"Helvetica Neue\\\", sans-serif; font-size: 10px; margin: 14px; height: 22px; line-height: 22px; } /*# sourceMappingURL=tooltip.css.map */ \"],\n        }), \n        __metadata$43('design:paramtypes', [])\n    ], TooltipComponent);\n    return TooltipComponent;\n}());\nvar MdTooltipModule = (function () {\n    function MdTooltipModule() {\n    }\n    MdTooltipModule.forRoot = function () {\n        return {\n            ngModule: MdTooltipModule,\n            providers: OVERLAY_PROVIDERS,\n        };\n    };\n    MdTooltipModule = __decorate$43([\n        _angular_core.NgModule({\n            imports: [OverlayModule],\n            exports: [MdTooltip, TooltipComponent],\n            declarations: [MdTooltip, TooltipComponent],\n            entryComponents: [TooltipComponent],\n        }), \n        __metadata$43('design:paramtypes', [])\n    ], MdTooltipModule);\n    return MdTooltipModule;\n}());\n\nvar __extends$18 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/**\n * Exception thrown when menu trigger doesn't have a valid md-menu instance\n */\nvar MdMenuMissingError = (function (_super) {\n    __extends$18(MdMenuMissingError, _super);\n    function MdMenuMissingError() {\n        _super.call(this, \"md-menu-trigger: must pass in an md-menu instance.\\n\\n    Example:\\n      <md-menu #menu=\\\"mdMenu\\\"></md-menu>\\n      <button [md-menu-trigger-for]=\\\"menu\\\"></button>\\n    \");\n    }\n    return MdMenuMissingError;\n}(MdError));\n/**\n * Exception thrown when menu's x-position value isn't valid.\n * In other words, it doesn't match 'before' or 'after'.\n */\nvar MdMenuInvalidPositionX = (function (_super) {\n    __extends$18(MdMenuInvalidPositionX, _super);\n    function MdMenuInvalidPositionX() {\n        _super.call(this, \"x-position value must be either 'before' or after'.\\n      Example: <md-menu x-position=\\\"before\\\" #menu=\\\"mdMenu\\\"></md-menu>\\n    \");\n    }\n    return MdMenuInvalidPositionX;\n}(MdError));\n/**\n * Exception thrown when menu's y-position value isn't valid.\n * In other words, it doesn't match 'above' or 'below'.\n */\nvar MdMenuInvalidPositionY = (function (_super) {\n    __extends$18(MdMenuInvalidPositionY, _super);\n    function MdMenuInvalidPositionY() {\n        _super.call(this, \"y-position value must be either 'above' or below'.\\n      Example: <md-menu y-position=\\\"above\\\" #menu=\\\"mdMenu\\\"></md-menu>\\n    \");\n    }\n    return MdMenuInvalidPositionY;\n}(MdError));\n\nvar __decorate$46 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$46 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/**\n * This directive is intended to be used inside an md-menu tag.\n * It exists mostly to set the role attribute.\n */\nvar MdMenuItem = (function () {\n    function MdMenuItem(_renderer, _elementRef) {\n        this._renderer = _renderer;\n        this._elementRef = _elementRef;\n    }\n    MdMenuItem.prototype.focus = function () {\n        this._renderer.invokeElementMethod(this._elementRef.nativeElement, 'focus');\n    };\n    Object.defineProperty(MdMenuItem.prototype, \"disabled\", {\n        // this is necessary to support anchors\n        get: function () {\n            return this._disabled;\n        },\n        set: function (value) {\n            this._disabled = (value === false || value === undefined) ? null : true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MdMenuItem.prototype, \"isAriaDisabled\", {\n        get: function () {\n            return String(this.disabled);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * TODO: internal\n     */\n    MdMenuItem.prototype._checkDisabled = function (event) {\n        if (this.disabled) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    };\n    __decorate$46([\n        _angular_core.HostBinding('attr.disabled'),\n        _angular_core.Input(), \n        __metadata$46('design:type', Boolean)\n    ], MdMenuItem.prototype, \"disabled\", null);\n    __decorate$46([\n        _angular_core.HostBinding('attr.aria-disabled'), \n        __metadata$46('design:type', String)\n    ], MdMenuItem.prototype, \"isAriaDisabled\", null);\n    MdMenuItem = __decorate$46([\n        _angular_core.Directive({\n            selector: '[md-menu-item]',\n            host: {\n                'role': 'menuitem',\n                '(click)': '_checkDisabled($event)',\n                'tabindex': '-1'\n            },\n            exportAs: 'mdMenuItem'\n        }), \n        __metadata$46('design:paramtypes', [_angular_core.Renderer, _angular_core.ElementRef])\n    ], MdMenuItem);\n    return MdMenuItem;\n}());\n\n// TODO(kara): prevent-close functionality\nvar __decorate$45 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$45 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __param$5 = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar MdMenu = (function () {\n    function MdMenu(posX, posY) {\n        this._showClickCatcher = false;\n        this._focusedItemIndex = 0;\n        this.positionX = 'after';\n        this.positionY = 'below';\n        this.close = new _angular_core.EventEmitter;\n        if (posX) {\n            this._setPositionX(posX);\n        }\n        if (posY) {\n            this._setPositionY(posY);\n        }\n    }\n    Object.defineProperty(MdMenu.prototype, \"classList\", {\n        /**\n         * This method takes classes set on the host md-menu element and applies them on the\n         * menu template that displays in the overlay container.  Otherwise, it's difficult\n         * to style the containing menu from outside the component.\n         * @param classes list of class names\n         */\n        set: function (classes) {\n            this._classList = classes.split(' ').reduce(function (obj, className) {\n                obj[className] = true;\n                return obj;\n            }, {});\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * This function toggles the display of the menu's click catcher element.\n     * This element covers the viewport when the menu is open to detect clicks outside the menu.\n     * TODO: internal\n     */\n    MdMenu.prototype._setClickCatcher = function (bool) {\n        this._showClickCatcher = bool;\n    };\n    /**\n     * Focus the first item in the menu. This method is used by the menu trigger\n     * to focus the first item when the menu is opened by the ENTER key.\n     * TODO: internal\n     */\n    MdMenu.prototype._focusFirstItem = function () {\n        this.items.first.focus();\n    };\n    // TODO(kara): update this when (keydown.downArrow) testability is fixed\n    // TODO: internal\n    MdMenu.prototype._handleKeydown = function (event) {\n        if (event.keyCode === DOWN_ARROW) {\n            this._focusNextItem();\n        }\n        else if (event.keyCode === UP_ARROW) {\n            this._focusPreviousItem();\n        }\n        else if (event.keyCode === TAB) {\n            this._emitCloseEvent();\n        }\n    };\n    /**\n     * This emits a close event to which the trigger is subscribed. When emitted, the\n     * trigger will close the menu.\n     */\n    MdMenu.prototype._emitCloseEvent = function () {\n        this._focusedItemIndex = 0;\n        this.close.emit(null);\n    };\n    MdMenu.prototype._focusNextItem = function () {\n        this._updateFocusedItemIndex(1);\n        this.items.toArray()[this._focusedItemIndex].focus();\n    };\n    MdMenu.prototype._focusPreviousItem = function () {\n        this._updateFocusedItemIndex(-1);\n        this.items.toArray()[this._focusedItemIndex].focus();\n    };\n    /**\n     * This method sets focus to the correct menu item, given a list of menu items and the delta\n     * between the currently focused menu item and the new menu item to be focused. It will\n     * continue to move down the list until it finds an item that is not disabled, and it will wrap\n     * if it encounters either end of the menu.\n     *\n     * @param delta the desired change in focus index\n     * @param menuItems the menu items that should be focused\n     * @private\n       */\n    MdMenu.prototype._updateFocusedItemIndex = function (delta, menuItems) {\n        if (menuItems === void 0) { menuItems = this.items.toArray(); }\n        // when focus would leave menu, wrap to beginning or end\n        this._focusedItemIndex = (this._focusedItemIndex + delta + this.items.length)\n            % this.items.length;\n        // skip all disabled menu items recursively until an active one\n        // is reached or the menu closes for overreaching bounds\n        while (menuItems[this._focusedItemIndex].disabled) {\n            this._updateFocusedItemIndex(delta, menuItems);\n        }\n    };\n    MdMenu.prototype._setPositionX = function (pos) {\n        if (pos !== 'before' && pos !== 'after') {\n            throw new MdMenuInvalidPositionX();\n        }\n        this.positionX = pos;\n    };\n    MdMenu.prototype._setPositionY = function (pos) {\n        if (pos !== 'above' && pos !== 'below') {\n            throw new MdMenuInvalidPositionY();\n        }\n        this.positionY = pos;\n    };\n    __decorate$45([\n        _angular_core.ViewChild(_angular_core.TemplateRef), \n        __metadata$45('design:type', _angular_core.TemplateRef)\n    ], MdMenu.prototype, \"templateRef\", void 0);\n    __decorate$45([\n        _angular_core.ContentChildren(MdMenuItem), \n        __metadata$45('design:type', _angular_core.QueryList)\n    ], MdMenu.prototype, \"items\", void 0);\n    __decorate$45([\n        _angular_core.Input('class'), \n        __metadata$45('design:type', String), \n        __metadata$45('design:paramtypes', [String])\n    ], MdMenu.prototype, \"classList\", null);\n    __decorate$45([\n        _angular_core.Output(), \n        __metadata$45('design:type', Object)\n    ], MdMenu.prototype, \"close\", void 0);\n    MdMenu = __decorate$45([\n        _angular_core.Component({selector: 'md-menu',\n            host: { 'role': 'menu' },\n            template: \"<template> <div class=\\\"md-menu\\\" [ngClass]=\\\"_classList\\\" (click)=\\\"_emitCloseEvent()\\\" (keydown)=\\\"_handleKeydown($event)\\\"> <ng-content></ng-content> </div> </template> <div class=\\\"md-menu-click-catcher\\\" *ngIf=\\\"_showClickCatcher\\\" (click)=\\\"_emitCloseEvent()\\\"></div>\",\n            styles: [\".md-menu { box-shadow: 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12); min-width: 112px; max-width: 280px; max-height: calc(100vh + 48px); overflow: auto; -webkit-overflow-scrolling: touch; padding-top: 8px; padding-bottom: 8px; } [md-menu-item] { cursor: pointer; user-select: none; outline: none; border: none; white-space: nowrap; overflow-x: hidden; text-overflow: ellipsis; display: flex; flex-direction: row; align-items: center; height: 48px; padding: 0 16px; font-size: 16px; font-family: Roboto, \\\"Helvetica Neue\\\", sans-serif; text-align: start; text-decoration: none; } [md-menu-item][disabled] { cursor: default; } button[md-menu-item] { width: 100%; } .md-menu-click-catcher { position: fixed; top: 0; left: 0; right: 0; bottom: 0; } /*# sourceMappingURL=menu.css.map */ \"],\n            encapsulation: _angular_core.ViewEncapsulation.None,\n            exportAs: 'mdMenu'\n        }),\n        __param$5(0, _angular_core.Attribute('x-position')),\n        __param$5(1, _angular_core.Attribute('y-position')), \n        __metadata$45('design:paramtypes', [String, String])\n    ], MdMenu);\n    return MdMenu;\n}());\n\nvar __decorate$47 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$47 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/**\n * This directive is intended to be used in conjunction with an md-menu tag.  It is\n * responsible for toggling the display of the provided menu instance.\n */\nvar MdMenuTrigger = (function () {\n    function MdMenuTrigger(_overlay, _element, _viewContainerRef, _renderer) {\n        this._overlay = _overlay;\n        this._element = _element;\n        this._viewContainerRef = _viewContainerRef;\n        this._renderer = _renderer;\n        this._menuOpen = false;\n        // tracking input type is necessary so it's possible to only auto-focus\n        // the first item of the list when the menu is opened via the keyboard\n        this._openedFromKeyboard = false;\n        this.onMenuOpen = new _angular_core.EventEmitter();\n        this.onMenuClose = new _angular_core.EventEmitter();\n    }\n    MdMenuTrigger.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        this._checkMenu();\n        this.menu.close.subscribe(function () { return _this.closeMenu(); });\n    };\n    MdMenuTrigger.prototype.ngOnDestroy = function () { this.destroyMenu(); };\n    Object.defineProperty(MdMenuTrigger.prototype, \"menuOpen\", {\n        get: function () { return this._menuOpen; },\n        enumerable: true,\n        configurable: true\n    });\n    MdMenuTrigger.prototype.toggleMenu = function () {\n        return this._menuOpen ? this.closeMenu() : this.openMenu();\n    };\n    MdMenuTrigger.prototype.openMenu = function () {\n        this._createOverlay();\n        this._overlayRef.attach(this._portal);\n        this._initMenu();\n    };\n    MdMenuTrigger.prototype.closeMenu = function () {\n        if (this._overlayRef) {\n            this._overlayRef.detach();\n            this._resetMenu();\n        }\n    };\n    MdMenuTrigger.prototype.destroyMenu = function () {\n        if (this._overlayRef) {\n            this._overlayRef.dispose();\n            this._overlayRef = null;\n        }\n    };\n    MdMenuTrigger.prototype.focus = function () {\n        this._renderer.invokeElementMethod(this._element.nativeElement, 'focus');\n    };\n    /**\n     * This method sets the menu state to open and focuses the first item if\n     * the menu was opened via the keyboard.\n     */\n    MdMenuTrigger.prototype._initMenu = function () {\n        this._setIsMenuOpen(true);\n        if (this._openedFromKeyboard) {\n            this.menu._focusFirstItem();\n        }\n    };\n    ;\n    /**\n     * This method resets the menu when it's closed, most importantly restoring\n     * focus to the menu trigger if the menu was opened via the keyboard.\n     */\n    MdMenuTrigger.prototype._resetMenu = function () {\n        this._setIsMenuOpen(false);\n        if (this._openedFromKeyboard) {\n            this.focus();\n            this._openedFromKeyboard = false;\n        }\n    };\n    // set state rather than toggle to support triggers sharing a menu\n    MdMenuTrigger.prototype._setIsMenuOpen = function (isOpen) {\n        this._menuOpen = isOpen;\n        this.menu._setClickCatcher(isOpen);\n        this._menuOpen ? this.onMenuOpen.emit(null) : this.onMenuClose.emit(null);\n    };\n    /**\n     *  This method checks that a valid instance of MdMenu has been passed into\n     *  md-menu-trigger-for.  If not, an exception is thrown.\n     */\n    MdMenuTrigger.prototype._checkMenu = function () {\n        if (!this.menu || !(this.menu instanceof MdMenu)) {\n            throw new MdMenuMissingError();\n        }\n    };\n    /**\n     *  This method creates the overlay from the provided menu's template and saves its\n     *  OverlayRef so that it can be attached to the DOM when openMenu is called.\n     */\n    MdMenuTrigger.prototype._createOverlay = function () {\n        if (!this._overlayRef) {\n            this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);\n            this._overlayRef = this._overlay.create(this._getOverlayConfig());\n        }\n    };\n    /**\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\n     * @returns OverlayState\n     */\n    MdMenuTrigger.prototype._getOverlayConfig = function () {\n        var overlayState = new OverlayState();\n        overlayState.positionStrategy = this._getPosition();\n        return overlayState;\n    };\n    /**\n     * This method builds the position strategy for the overlay, so the menu is properly connected\n     * to the trigger.\n     * @returns ConnectedPositionStrategy\n     */\n    MdMenuTrigger.prototype._getPosition = function () {\n        var positionX = this.menu.positionX === 'before' ? 'end' : 'start';\n        var positionY = this.menu.positionY === 'above' ? 'bottom' : 'top';\n        return this._overlay.position().connectedTo(this._element, { originX: positionX, originY: positionY }, { overlayX: positionX, overlayY: positionY });\n    };\n    // TODO: internal\n    MdMenuTrigger.prototype._handleKeydown = function (event) {\n        if (event.keyCode === ENTER) {\n            this._openedFromKeyboard = true;\n        }\n    };\n    __decorate$47([\n        _angular_core.Input('md-menu-trigger-for'), \n        __metadata$47('design:type', MdMenu)\n    ], MdMenuTrigger.prototype, \"menu\", void 0);\n    __decorate$47([\n        _angular_core.Output(), \n        __metadata$47('design:type', Object)\n    ], MdMenuTrigger.prototype, \"onMenuOpen\", void 0);\n    __decorate$47([\n        _angular_core.Output(), \n        __metadata$47('design:type', Object)\n    ], MdMenuTrigger.prototype, \"onMenuClose\", void 0);\n    __decorate$47([\n        _angular_core.HostListener('click'), \n        __metadata$47('design:type', Function), \n        __metadata$47('design:paramtypes', []), \n        __metadata$47('design:returntype', void 0)\n    ], MdMenuTrigger.prototype, \"toggleMenu\", null);\n    MdMenuTrigger = __decorate$47([\n        _angular_core.Directive({\n            selector: '[md-menu-trigger-for]',\n            host: {\n                'aria-haspopup': 'true',\n                '(keydown)': '_handleKeydown($event)'\n            },\n            exportAs: 'mdMenuTrigger'\n        }), \n        __metadata$47('design:paramtypes', [Overlay, _angular_core.ElementRef, _angular_core.ViewContainerRef, _angular_core.Renderer])\n    ], MdMenuTrigger);\n    return MdMenuTrigger;\n}());\n\nvar __decorate$44 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$44 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar MdMenuModule = (function () {\n    function MdMenuModule() {\n    }\n    MdMenuModule.forRoot = function () {\n        return {\n            ngModule: MdMenuModule,\n            providers: OVERLAY_PROVIDERS,\n        };\n    };\n    MdMenuModule = __decorate$44([\n        _angular_core.NgModule({\n            imports: [OverlayModule, _angular_common.CommonModule],\n            exports: [MdMenu, MdMenuItem, MdMenuTrigger],\n            declarations: [MdMenu, MdMenuItem, MdMenuTrigger],\n        }), \n        __metadata$44('design:paramtypes', [])\n    ], MdMenuModule);\n    return MdMenuModule;\n}());\n\n// TODO(jelbourn): resizing\n// TODO(jelbourn): afterOpen and beforeClose\n/**\n * Reference to a dialog opened via the MdDialog service.\n */\nvar MdDialogRef = (function () {\n    function MdDialogRef(_overlayRef) {\n        this._overlayRef = _overlayRef;\n        /** Subject for notifying the user that the dialog has finished closing. */\n        this._afterClosed = new rxjs_Subject.Subject();\n    }\n    /**\n     * Close the dialog.\n     * @param dialogResult Optional result to return to the dialog opener.\n     */\n    MdDialogRef.prototype.close = function (dialogResult) {\n        this._overlayRef.dispose();\n        this._afterClosed.next(dialogResult);\n        this._afterClosed.complete();\n    };\n    /** Gets an observable that is notified when the dialog is finished closing. */\n    MdDialogRef.prototype.afterClosed = function () {\n        return this._afterClosed.asObservable();\n    };\n    return MdDialogRef;\n}());\n\n/** Custom injector type specifically for instantiating components with a dialog. */\nvar DialogInjector = (function () {\n    function DialogInjector(_dialogRef, _parentInjector) {\n        this._dialogRef = _dialogRef;\n        this._parentInjector = _parentInjector;\n    }\n    DialogInjector.prototype.get = function (token, notFoundValue) {\n        if (token === MdDialogRef) {\n            return this._dialogRef;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    };\n    return DialogInjector;\n}());\n\nvar __extends$20 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/** Exception thrown when a ComponentPortal is attached to a DomPortalHost without an origin. */\nvar MdDialogContentAlreadyAttachedError = (function (_super) {\n    __extends$20(MdDialogContentAlreadyAttachedError, _super);\n    function MdDialogContentAlreadyAttachedError() {\n        _super.call(this, 'Attempting to attach dialog content after content is already attached');\n    }\n    return MdDialogContentAlreadyAttachedError;\n}(MdError));\n\nvar __extends$19 = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar __decorate$49 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$49 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n/**\n * Internal component that wraps user-provided dialog content.\n */\nvar MdDialogContainer = (function (_super) {\n    __extends$19(MdDialogContainer, _super);\n    function MdDialogContainer(_ngZone) {\n        _super.call(this);\n        this._ngZone = _ngZone;\n        /** Element that was focused before the dialog was opened. Save this to restore upon close. */\n        this._elementFocusedBeforeDialogWasOpened = null;\n    }\n    /** Attach a portal as content to this dialog container. */\n    MdDialogContainer.prototype.attachComponentPortal = function (portal) {\n        var _this = this;\n        if (this._portalHost.hasAttached()) {\n            throw new MdDialogContentAlreadyAttachedError();\n        }\n        var attachResult = this._portalHost.attachComponentPortal(portal);\n        // If were to attempt to focus immediately, then the content of the dialog would not yet be\n        // ready in instances where change detection has to run first. To deal with this, we simply\n        // wait for the microtask queue to be empty.\n        this._ngZone.onMicrotaskEmpty.first().subscribe(function () {\n            _this._elementFocusedBeforeDialogWasOpened = document.activeElement;\n            _this._focusTrap.focusFirstTabbableElement();\n        });\n        return attachResult;\n    };\n    MdDialogContainer.prototype.attachTemplatePortal = function (portal) {\n        throw Error('Not yet implemented');\n    };\n    /** Handles the user pressing the Escape key. */\n    MdDialogContainer.prototype.handleEscapeKey = function () {\n        // TODO(jelbourn): add MdDialogConfig option to disable this behavior.\n        this.dialogRef.close();\n    };\n    MdDialogContainer.prototype.ngOnDestroy = function () {\n        var _this = this;\n        // When the dialog is destroyed, return focus to the element that originally had it before\n        // the dialog was opened. Wait for the DOM to finish settling before changing the focus so\n        // that it doesn't end up back on the <body>.\n        this._ngZone.onMicrotaskEmpty.first().subscribe(function () {\n            _this._elementFocusedBeforeDialogWasOpened.focus();\n        });\n    };\n    __decorate$49([\n        _angular_core.ViewChild(PortalHostDirective), \n        __metadata$49('design:type', PortalHostDirective)\n    ], MdDialogContainer.prototype, \"_portalHost\", void 0);\n    __decorate$49([\n        _angular_core.ViewChild(FocusTrap), \n        __metadata$49('design:type', FocusTrap)\n    ], MdDialogContainer.prototype, \"_focusTrap\", void 0);\n    MdDialogContainer = __decorate$49([\n        _angular_core.Component({selector: 'md-dialog-container',\n            template: \"<focus-trap> <template portalHost></template> </focus-trap> \",\n            styles: [\"md-dialog-container { box-shadow: 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12); display: block; overflow: hidden; padding: 24px; } /*# sourceMappingURL=dialog-container.css.map */ \"],\n            host: {\n                'class': 'md-dialog-container',\n                '[attr.role]': 'dialogConfig?.role',\n                '(keydown.escape)': 'handleEscapeKey()',\n            },\n            encapsulation: _angular_core.ViewEncapsulation.None,\n        }), \n        __metadata$49('design:paramtypes', [_angular_core.NgZone])\n    ], MdDialogContainer);\n    return MdDialogContainer;\n}(BasePortalHost));\n\n/**\n * Configuration for opening a modal dialog with the MdDialog service.\n */\nvar MdDialogConfig = (function () {\n    function MdDialogConfig() {\n        /** The ARIA role of the dialog element. */\n        this.role = 'dialog';\n    }\n    return MdDialogConfig;\n}());\n\nvar __decorate$48 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$48 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n// TODO(jelbourn): add support for opening with a TemplateRef\n// TODO(jelbourn): add `closeAll` method\n// TODO(jelbourn): default dialog config\n// TODO(jelbourn): escape key closes dialog\n// TODO(jelbourn): dialog content directives (e.g., md-dialog-header)\n// TODO(jelbourn): animations\n/**\n * Service to open Material Design modal dialogs.\n */\nvar MdDialog = (function () {\n    function MdDialog(_overlay, _injector) {\n        this._overlay = _overlay;\n        this._injector = _injector;\n    }\n    /**\n     * Opens a modal dialog containing the given component.\n     * @param component Type of the component to load into the load.\n     * @param config\n     */\n    MdDialog.prototype.open = function (component, config) {\n        var overlayRef = this._createOverlay(config);\n        var dialogContainer = this._attachDialogContainer(overlayRef, config);\n        return this._attachDialogContent(component, dialogContainer, overlayRef);\n    };\n    /**\n     * Creates the overlay into which the dialog will be loaded.\n     * @param dialogConfig The dialog configuration.\n     * @returns A promise resolving to the OverlayRef for the created overlay.\n     */\n    MdDialog.prototype._createOverlay = function (dialogConfig) {\n        var overlayState = this._getOverlayState(dialogConfig);\n        return this._overlay.create(overlayState);\n    };\n    /**\n     * Attaches an MdDialogContainer to a dialog's already-created overlay.\n     * @param overlay Reference to the dialog's underlying overlay.\n     * @param config The dialog configuration.\n     * @returns A promise resolving to a ComponentRef for the attached container.\n     */\n    MdDialog.prototype._attachDialogContainer = function (overlay, config) {\n        var containerPortal = new ComponentPortal(MdDialogContainer, config.viewContainerRef);\n        var containerRef = overlay.attach(containerPortal);\n        containerRef.instance.dialogConfig = config;\n        return containerRef.instance;\n    };\n    /**\n     * Attaches the user-provided component to the already-created MdDialogContainer.\n     * @param component The type of component being loaded into the dialog.\n     * @param dialogContainer Reference to the wrapping MdDialogContainer.\n     * @param overlayRef Reference to the overlay in which the dialog resides.\n     * @returns A promise resolving to the MdDialogRef that should be returned to the user.\n     */\n    MdDialog.prototype._attachDialogContent = function (component, dialogContainer, overlayRef) {\n        // Create a reference to the dialog we're creating in order to give the user a handle\n        // to modify and close it.\n        var dialogRef = new MdDialogRef(overlayRef);\n        // When the dialog backdrop is clicked, we want to close it.\n        overlayRef.backdropClick().subscribe(function () { return dialogRef.close(); });\n        // Set the dialogRef to the container so that it can use the ref to close the dialog.\n        dialogContainer.dialogRef = dialogRef;\n        // We create an injector specifically for the component we're instantiating so that it can\n        // inject the MdDialogRef. This allows a component loaded inside of a dialog to close itself\n        // and, optionally, to return a value.\n        var dialogInjector = new DialogInjector(dialogRef, this._injector);\n        var contentPortal = new ComponentPortal(component, null, dialogInjector);\n        var contentRef = dialogContainer.attachComponentPortal(contentPortal);\n        dialogRef.componentInstance = contentRef.instance;\n        return dialogRef;\n    };\n    /**\n     * Creates an overlay state from a dialog config.\n     * @param dialogConfig The dialog configuration.\n     * @returns The overlay configuration.\n     */\n    MdDialog.prototype._getOverlayState = function (dialogConfig) {\n        var state = new OverlayState();\n        state.hasBackdrop = true;\n        state.positionStrategy = this._overlay.position()\n            .global()\n            .centerHorizontally()\n            .centerVertically();\n        return state;\n    };\n    MdDialog = __decorate$48([\n        _angular_core.Injectable(), \n        __metadata$48('design:paramtypes', [Overlay, _angular_core.Injector])\n    ], MdDialog);\n    return MdDialog;\n}());\nvar MdDialogModule = (function () {\n    function MdDialogModule() {\n    }\n    MdDialogModule.forRoot = function () {\n        return {\n            ngModule: MdDialogModule,\n            providers: [MdDialog, OVERLAY_PROVIDERS, InteractivityChecker],\n        };\n    };\n    MdDialogModule = __decorate$48([\n        _angular_core.NgModule({\n            imports: [OverlayModule, PortalModule, A11yModule],\n            exports: [MdDialogContainer],\n            declarations: [MdDialogContainer],\n            entryComponents: [MdDialogContainer],\n        }), \n        __metadata$48('design:paramtypes', [])\n    ], MdDialogModule);\n    return MdDialogModule;\n}());\n\nvar __decorate$15 = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata$15 = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar MATERIAL_MODULES = [\n    MdButtonModule,\n    MdButtonToggleModule,\n    MdCardModule,\n    MdCheckboxModule,\n    MdDialogModule,\n    MdGridListModule,\n    MdIconModule,\n    MdInputModule,\n    MdListModule,\n    MdMenuModule,\n    MdProgressBarModule,\n    MdProgressCircleModule,\n    MdRadioModule,\n    MdRippleModule,\n    MdSelectModule,\n    MdSidenavModule,\n    MdSliderModule,\n    MdSlideToggleModule,\n    MdSnackBarModule,\n    MdTabsModule,\n    MdToolbarModule,\n    MdTooltipModule,\n    OverlayModule,\n    PortalModule,\n    RtlModule,\n    A11yModule,\n];\nvar MaterialRootModule = (function () {\n    function MaterialRootModule() {\n    }\n    MaterialRootModule = __decorate$15([\n        _angular_core.NgModule({\n            imports: [\n                MdButtonModule.forRoot(),\n                MdCardModule.forRoot(),\n                MdCheckboxModule.forRoot(),\n                MdGridListModule.forRoot(),\n                MdInputModule.forRoot(),\n                MdListModule.forRoot(),\n                MdProgressBarModule.forRoot(),\n                MdProgressCircleModule.forRoot(),\n                MdRippleModule.forRoot(),\n                MdSelectModule.forRoot(),\n                MdSidenavModule.forRoot(),\n                MdTabsModule.forRoot(),\n                MdToolbarModule.forRoot(),\n                PortalModule.forRoot(),\n                RtlModule.forRoot(),\n                // These modules include providers.\n                A11yModule.forRoot(),\n                MdButtonToggleModule.forRoot(),\n                MdDialogModule.forRoot(),\n                MdIconModule.forRoot(),\n                MdMenuModule.forRoot(),\n                MdRadioModule.forRoot(),\n                MdSliderModule.forRoot(),\n                MdSlideToggleModule.forRoot(),\n                MdSnackBarModule.forRoot(),\n                MdTooltipModule.forRoot(),\n                OverlayModule.forRoot(),\n            ],\n            exports: MATERIAL_MODULES,\n        }), \n        __metadata$15('design:paramtypes', [])\n    ], MaterialRootModule);\n    return MaterialRootModule;\n}());\nvar MaterialModule = (function () {\n    function MaterialModule() {\n    }\n    MaterialModule.forRoot = function () {\n        return { ngModule: MaterialRootModule };\n    };\n    MaterialModule = __decorate$15([\n        _angular_core.NgModule({\n            imports: MATERIAL_MODULES,\n            exports: MATERIAL_MODULES,\n        }), \n        __metadata$15('design:paramtypes', [])\n    ], MaterialModule);\n    return MaterialModule;\n}());\n\nexports.MdCoreModule = MdCoreModule;\nexports.Dir = Dir;\nexports.RtlModule = RtlModule;\nexports.Portal = Portal;\nexports.BasePortalHost = BasePortalHost;\nexports.ComponentPortal = ComponentPortal;\nexports.TemplatePortal = TemplatePortal;\nexports.PortalHostDirective = PortalHostDirective;\nexports.TemplatePortalDirective = TemplatePortalDirective;\nexports.PortalModule = PortalModule;\nexports.DomPortalHost = DomPortalHost;\nexports.Overlay = Overlay;\nexports.OVERLAY_PROVIDERS = OVERLAY_PROVIDERS;\nexports.OverlayContainer = OverlayContainer;\nexports.OverlayRef = OverlayRef;\nexports.OverlayState = OverlayState;\nexports.ConnectedOverlayDirective = ConnectedOverlayDirective;\nexports.OverlayOrigin = OverlayOrigin;\nexports.OverlayModule = OverlayModule;\nexports.MdGestureConfig = MdGestureConfig;\nexports.MdRipple = MdRipple;\nexports.MdRippleModule = MdRippleModule;\nexports.MdLiveAnnouncer = MdLiveAnnouncer;\nexports.LIVE_ANNOUNCER_ELEMENT_TOKEN = LIVE_ANNOUNCER_ELEMENT_TOKEN;\nexports.FocusTrap = FocusTrap;\nexports.InteractivityChecker = InteractivityChecker;\nexports.A11yModule = A11yModule;\nexports.MdUniqueSelectionDispatcher = MdUniqueSelectionDispatcher;\nexports.MdLineModule = MdLineModule;\nexports.MdLine = MdLine;\nexports.MdLineSetter = MdLineSetter;\nexports.applyCssTransform = applyCssTransform;\nexports.MdError = MdError;\nexports.BooleanFieldValue = BooleanFieldValue;\nexports.ConnectedPositionStrategy = ConnectedPositionStrategy;\nexports.ConnectionPositionPair = ConnectionPositionPair;\nexports.UP_ARROW = UP_ARROW;\nexports.DOWN_ARROW = DOWN_ARROW;\nexports.RIGHT_ARROW = RIGHT_ARROW;\nexports.LEFT_ARROW = LEFT_ARROW;\nexports.ENTER = ENTER;\nexports.TAB = TAB;\nexports.MaterialRootModule = MaterialRootModule;\nexports.MaterialModule = MaterialModule;\nexports.MdButton = MdButton;\nexports.MdAnchor = MdAnchor;\nexports.MdButtonModule = MdButtonModule;\nexports.MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR = MD_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR;\nexports.MdButtonToggleChange = MdButtonToggleChange;\nexports.MdButtonToggleGroup = MdButtonToggleGroup;\nexports.MdButtonToggleGroupMultiple = MdButtonToggleGroupMultiple;\nexports.MdButtonToggle = MdButtonToggle;\nexports.MdButtonToggleModule = MdButtonToggleModule;\nexports.MdCardContent = MdCardContent;\nexports.MdCardTitle = MdCardTitle;\nexports.MdCardSubtitle = MdCardSubtitle;\nexports.MdCardActions = MdCardActions;\nexports.MdCardFooter = MdCardFooter;\nexports.MdCard = MdCard;\nexports.MdCardHeader = MdCardHeader;\nexports.MdCardTitleGroup = MdCardTitleGroup;\nexports.MdCardModule = MdCardModule;\nexports.MD_CHECKBOX_CONTROL_VALUE_ACCESSOR = MD_CHECKBOX_CONTROL_VALUE_ACCESSOR;\nexports.MdCheckboxChange = MdCheckboxChange;\nexports.MdCheckbox = MdCheckbox;\nexports.MdCheckboxModule = MdCheckboxModule;\nexports.MdDialog = MdDialog;\nexports.MdDialogModule = MdDialogModule;\nexports.MdDialogConfig = MdDialogConfig;\nexports.MdDialogRef = MdDialogRef;\nexports.MdDialogContainer = MdDialogContainer;\nexports.MdGridList = MdGridList;\nexports.MdGridListModule = MdGridListModule;\nexports.MdIconInvalidNameError = MdIconInvalidNameError;\nexports.MdIcon = MdIcon;\nexports.MdIconModule = MdIconModule;\nexports.MdIconRegistry = MdIconRegistry;\nexports.MD_INPUT_CONTROL_VALUE_ACCESSOR = MD_INPUT_CONTROL_VALUE_ACCESSOR;\nexports.MdInputPlaceholderConflictError = MdInputPlaceholderConflictError;\nexports.MdInputUnsupportedTypeError = MdInputUnsupportedTypeError;\nexports.MdInputDuplicatedHintError = MdInputDuplicatedHintError;\nexports.MdPlaceholder = MdPlaceholder;\nexports.MdHint = MdHint;\nexports.MdInput = MdInput;\nexports.MdInputModule = MdInputModule;\nexports.MdListDivider = MdListDivider;\nexports.MdList = MdList;\nexports.MdListAvatar = MdListAvatar;\nexports.MdListItem = MdListItem;\nexports.MdListModule = MdListModule;\nexports.MdMenuModule = MdMenuModule;\nexports.MdMenu = MdMenu;\nexports.MdMenuItem = MdMenuItem;\nexports.MdMenuTrigger = MdMenuTrigger;\nexports.MdProgressBar = MdProgressBar;\nexports.MdProgressBarModule = MdProgressBarModule;\nexports.MdProgressCircle = MdProgressCircle;\nexports.MdSpinner = MdSpinner;\nexports.MdProgressCircleModule = MdProgressCircleModule;\nexports.MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR = MD_RADIO_GROUP_CONTROL_VALUE_ACCESSOR;\nexports.MdRadioChange = MdRadioChange;\nexports.MdRadioGroup = MdRadioGroup;\nexports.MdRadioButton = MdRadioButton;\nexports.MdRadioModule = MdRadioModule;\nexports.MdSelectModule = MdSelectModule;\nexports.MdSelect = MdSelect;\nexports.MdDuplicatedSidenavError = MdDuplicatedSidenavError;\nexports.MdSidenav = MdSidenav;\nexports.MdSidenavLayout = MdSidenavLayout;\nexports.MdSidenavModule = MdSidenavModule;\nexports.MD_SLIDER_VALUE_ACCESSOR = MD_SLIDER_VALUE_ACCESSOR;\nexports.MdSlider = MdSlider;\nexports.SliderRenderer = SliderRenderer;\nexports.MdSliderModule = MdSliderModule;\nexports.MD_SLIDE_TOGGLE_VALUE_ACCESSOR = MD_SLIDE_TOGGLE_VALUE_ACCESSOR;\nexports.MdSlideToggleChange = MdSlideToggleChange;\nexports.MdSlideToggle = MdSlideToggle;\nexports.MdSlideToggleModule = MdSlideToggleModule;\nexports.MdSnackBar = MdSnackBar;\nexports.MdSnackBarModule = MdSnackBarModule;\nexports.MdSnackBarRef = MdSnackBarRef;\nexports.MdSnackBarConfig = MdSnackBarConfig;\nexports.MdSnackBarContainer = MdSnackBarContainer;\nexports.MdTabChangeEvent = MdTabChangeEvent;\nexports.MdTab = MdTab;\nexports.MdTabGroup = MdTabGroup;\nexports.MdTabsModule = MdTabsModule;\nexports.MdToolbarRow = MdToolbarRow;\nexports.MdToolbar = MdToolbar;\nexports.MdToolbarModule = MdToolbarModule;\nexports.MdTooltip = MdTooltip;\nexports.TooltipComponent = TooltipComponent;\nexports.MdTooltipModule = MdTooltipModule;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n//# sourceMappingURL=./material.umd.js.map\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(312)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vfi9AYW5ndWxhci9tYXRlcmlhbC9tYXRlcmlhbC51bWQuanM/ODQzMCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpLCByZXF1aXJlKCdyeGpzL1N1YmplY3QnKSwgcmVxdWlyZSgnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlcicpLCByZXF1aXJlKCdAYW5ndWxhci9mb3JtcycpLCByZXF1aXJlKCdyeGpzL09ic2VydmFibGUnKSwgcmVxdWlyZSgnQGFuZ3VsYXIvY29tbW9uJyksIHJlcXVpcmUoJ0Bhbmd1bGFyL2h0dHAnKSwgcmVxdWlyZSgncnhqcy9hZGQvb2JzZXJ2YWJsZS9mb3JrSm9pbicpLCByZXF1aXJlKCdyeGpzL2FkZC9vYnNlcnZhYmxlL29mJyksIHJlcXVpcmUoJ3J4anMvYWRkL29wZXJhdG9yL21hcCcpLCByZXF1aXJlKCdyeGpzL2FkZC9vcGVyYXRvci9maWx0ZXInKSwgcmVxdWlyZSgncnhqcy9hZGQvb3BlcmF0b3IvZG8nKSwgcmVxdWlyZSgncnhqcy9hZGQvb3BlcmF0b3Ivc2hhcmUnKSwgcmVxdWlyZSgncnhqcy9hZGQvb3BlcmF0b3IvZmluYWxseScpLCByZXF1aXJlKCdyeGpzL2FkZC9vcGVyYXRvci9jYXRjaCcpLCByZXF1aXJlKCdyeGpzL2FkZC9vcGVyYXRvci9maXJzdCcpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAYW5ndWxhci9jb3JlJywgJ3J4anMvU3ViamVjdCcsICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJywgJ0Bhbmd1bGFyL2Zvcm1zJywgJ3J4anMvT2JzZXJ2YWJsZScsICdAYW5ndWxhci9jb21tb24nLCAnQGFuZ3VsYXIvaHR0cCcsICdyeGpzL2FkZC9vYnNlcnZhYmxlL2ZvcmtKb2luJywgJ3J4anMvYWRkL29ic2VydmFibGUvb2YnLCAncnhqcy9hZGQvb3BlcmF0b3IvbWFwJywgJ3J4anMvYWRkL29wZXJhdG9yL2ZpbHRlcicsICdyeGpzL2FkZC9vcGVyYXRvci9kbycsICdyeGpzL2FkZC9vcGVyYXRvci9zaGFyZScsICdyeGpzL2FkZC9vcGVyYXRvci9maW5hbGx5JywgJ3J4anMvYWRkL29wZXJhdG9yL2NhdGNoJywgJ3J4anMvYWRkL29wZXJhdG9yL2ZpcnN0J10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsLm5nID0gZ2xvYmFsLm5nIHx8IHt9LCBnbG9iYWwubmcubWF0ZXJpYWwgPSBnbG9iYWwubmcubWF0ZXJpYWwgfHwge30pLGdsb2JhbC5uZy5jb3JlLGdsb2JhbC5SeCxnbG9iYWwubmcucGxhdGZvcm1Ccm93c2VyLGdsb2JhbC5uZy5mb3JtcyxnbG9iYWwuUngsZ2xvYmFsLm5nLmNvbW1vbixnbG9iYWwubmcuaHR0cCxnbG9iYWwuUnguT2JzZXJ2YWJsZSxnbG9iYWwuUnguT2JzZXJ2YWJsZSxnbG9iYWwuUnguT2JzZXJ2YWJsZS5wcm90b3R5cGUsZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwuUnguT2JzZXJ2YWJsZS5wcm90b3R5cGUsZ2xvYmFsLlJ4Lk9ic2VydmFibGUucHJvdG90eXBlLGdsb2JhbC5SeC5PYnNlcnZhYmxlLnByb3RvdHlwZSxnbG9iYWwucnhqc19hZGRfb3BlcmF0b3JfZmlyc3QpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLF9hbmd1bGFyX2NvcmUscnhqc19TdWJqZWN0LF9hbmd1bGFyX3BsYXRmb3JtQnJvd3NlcixfYW5ndWxhcl9mb3JtcyxyeGpzX09ic2VydmFibGUsX2FuZ3VsYXJfY29tbW9uLF9hbmd1bGFyX2h0dHAscnhqc19hZGRfb2JzZXJ2YWJsZV9mb3JrSm9pbixyeGpzX2FkZF9vYnNlcnZhYmxlX29mLHJ4anNfYWRkX29wZXJhdG9yX21hcCxyeGpzX2FkZF9vcGVyYXRvcl9maWx0ZXIscnhqc19hZGRfb3BlcmF0b3JfZG8scnhqc19hZGRfb3BlcmF0b3Jfc2hhcmUscnhqc19hZGRfb3BlcmF0b3JfZmluYWxseSxyeGpzX2FkZF9vcGVyYXRvcl9jYXRjaCxyeGpzX2FkZF9vcGVyYXRvcl9maXJzdCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBfX2RlY29yYXRlJDEgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBTaGFyZWQgZGlyZWN0aXZlIHRvIGNvdW50IGxpbmVzIGluc2lkZSBhIHRleHQgYXJlYSwgc3VjaCBhcyBhIGxpc3QgaXRlbS5cbiAqIExpbmUgZWxlbWVudHMgY2FuIGJlIGV4dHJhY3RlZCB3aXRoIGEgQENvbnRlbnRDaGlsZHJlbihNZExpbmUpIHF1ZXJ5LCB0aGVuXG4gKiBjb3VudGVkIGJ5IGNoZWNraW5nIHRoZSBxdWVyeSBsaXN0J3MgbGVuZ3RoLlxuICovXG52YXIgTWRMaW5lID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZExpbmUoKSB7XG4gICAgfVxuICAgIE1kTGluZSA9IF9fZGVjb3JhdGUkMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbWQtbGluZV0nIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQxKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kTGluZSk7XG4gICAgcmV0dXJuIE1kTGluZTtcbn0oKSk7XG4vKiBIZWxwZXIgdGhhdCB0YWtlcyBhIHF1ZXJ5IGxpc3Qgb2YgbGluZXMgYW5kIHNldHMgdGhlIGNvcnJlY3QgY2xhc3Mgb24gdGhlIGhvc3QgKi9cbnZhciBNZExpbmVTZXR0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGluZVNldHRlcihfbGluZXMsIF9yZW5kZXJlciwgX2VsZW1lbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fbGluZXMgPSBfbGluZXM7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3NldExpbmVDbGFzcyh0aGlzLl9saW5lcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLl9saW5lcy5jaGFuZ2VzLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fc2V0TGluZUNsYXNzKF90aGlzLl9saW5lcy5sZW5ndGgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgTWRMaW5lU2V0dGVyLnByb3RvdHlwZS5fc2V0TGluZUNsYXNzID0gZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0Q2xhc3NlcygpO1xuICAgICAgICBpZiAoY291bnQgPT09IDIgfHwgY291bnQgPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldENsYXNzKFwibWQtXCIgKyBjb3VudCArIFwiLWxpbmVcIiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kTGluZVNldHRlci5wcm90b3R5cGUuX3Jlc2V0Q2xhc3NlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2V0Q2xhc3MoJ21kLTItbGluZScsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc2V0Q2xhc3MoJ21kLTMtbGluZScsIGZhbHNlKTtcbiAgICB9O1xuICAgIE1kTGluZVNldHRlci5wcm90b3R5cGUuX3NldENsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgYm9vbCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCBjbGFzc05hbWUsIGJvb2wpO1xuICAgIH07XG4gICAgcmV0dXJuIE1kTGluZVNldHRlcjtcbn0oKSk7XG52YXIgTWRMaW5lTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZExpbmVNb2R1bGUoKSB7XG4gICAgfVxuICAgIE1kTGluZU1vZHVsZSA9IF9fZGVjb3JhdGUkMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgZXhwb3J0czogW01kTGluZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZExpbmVdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZExpbmVNb2R1bGUpO1xuICAgIHJldHVybiBNZExpbmVNb2R1bGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDIgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogRGlyZWN0aXZlIHRvIGxpc3RlbiB0byBjaGFuZ2VzIG9mIGRpcmVjdGlvbiBvZiBwYXJ0IG9mIHRoZSBET00uXG4gKlxuICogQXBwbGljYXRpb25zIHNob3VsZCB1c2UgdGhpcyBkaXJlY3RpdmUgaW5zdGVhZCBvZiB0aGUgbmF0aXZlIGF0dHJpYnV0ZSBzbyB0aGF0IE1hdGVyaWFsXG4gKiBjb21wb25lbnRzIGNhbiBsaXN0ZW4gb24gY2hhbmdlcyBvZiBkaXJlY3Rpb24uXG4gKi9cbnZhciBEaXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpcigpIHtcbiAgICAgICAgdGhpcy5fZGlyID0gJ2x0cic7XG4gICAgICAgIHRoaXMuZGlyQ2hhbmdlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaXIucHJvdG90eXBlLCBcImRpclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFyIG9sZCA9IHRoaXMuX2RpcjtcbiAgICAgICAgICAgIHRoaXMuX2RpciA9IHY7XG4gICAgICAgICAgICBpZiAob2xkICE9IHRoaXMuX2Rpcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlyQ2hhbmdlLmVtaXQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEaXIucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRpcjsgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikgeyB0aGlzLmRpciA9IHY7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIF9fZGVjb3JhdGUkMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2RpcicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyKCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBEaXIucHJvdG90eXBlLCBcIl9kaXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBEaXIucHJvdG90eXBlLCBcImRpckNoYW5nZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2F0dHIuZGlyJyksIFxuICAgICAgICBfX21ldGFkYXRhJDIoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIERpci5wcm90b3R5cGUsIFwiZGlyXCIsIG51bGwpO1xuICAgIERpciA9IF9fZGVjb3JhdGUkMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Rpcl0nLFxuICAgICAgICAgICAgLy8gVE9ETyhoYW5zbCk6IG1heWJlIGAkaW1wbGljaXRgIGlzbid0IHRoZSBiZXN0IG9wdGlvbiBoZXJlLCBidXQgZm9yIG5vdyB0aGF0J3MgdGhlIGJlc3Qgd2UgZ290LlxuICAgICAgICAgICAgZXhwb3J0QXM6ICckaW1wbGljaXQnXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQyKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIERpcik7XG4gICAgcmV0dXJuIERpcjtcbn0oKSk7XG52YXIgUnRsTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSdGxNb2R1bGUoKSB7XG4gICAgfVxuICAgIFJ0bE1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IFJ0bE1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFJ0bE1vZHVsZSA9IF9fZGVjb3JhdGUkMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgZXhwb3J0czogW0Rpcl0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtEaXJdXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQyKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIFJ0bE1vZHVsZSk7XG4gICAgcmV0dXJuIFJ0bE1vZHVsZTtcbn0oKSk7XG5cbi8qKiBUT0RPOiBpbnRlcm5hbCAqL1xudmFyIEZvcmVncm91bmRSaXBwbGVTdGF0ZTtcbihmdW5jdGlvbiAoRm9yZWdyb3VuZFJpcHBsZVN0YXRlKSB7XG4gICAgRm9yZWdyb3VuZFJpcHBsZVN0YXRlW0ZvcmVncm91bmRSaXBwbGVTdGF0ZVtcIk5FV1wiXSA9IDBdID0gXCJORVdcIjtcbiAgICBGb3JlZ3JvdW5kUmlwcGxlU3RhdGVbRm9yZWdyb3VuZFJpcHBsZVN0YXRlW1wiRVhQQU5ESU5HXCJdID0gMV0gPSBcIkVYUEFORElOR1wiO1xuICAgIEZvcmVncm91bmRSaXBwbGVTdGF0ZVtGb3JlZ3JvdW5kUmlwcGxlU3RhdGVbXCJGQURJTkdfT1VUXCJdID0gMl0gPSBcIkZBRElOR19PVVRcIjtcbn0pKEZvcmVncm91bmRSaXBwbGVTdGF0ZSB8fCAoRm9yZWdyb3VuZFJpcHBsZVN0YXRlID0ge30pKTtcbi8qKlxuICogV3JhcHBlciBmb3IgYSBmb3JlZ3JvdW5kIHJpcHBsZSBET00gZWxlbWVudCBhbmQgaXRzIGFuaW1hdGlvbiBzdGF0ZS5cbiAqIFRPRE86IGludGVybmFsXG4gKi9cbnZhciBGb3JlZ3JvdW5kUmlwcGxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGb3JlZ3JvdW5kUmlwcGxlKHJpcHBsZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5yaXBwbGVFbGVtZW50ID0gcmlwcGxlRWxlbWVudDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IEZvcmVncm91bmRSaXBwbGVTdGF0ZS5ORVc7XG4gICAgfVxuICAgIHJldHVybiBGb3JlZ3JvdW5kUmlwcGxlO1xufSgpKTtcbnZhciBSSVBQTEVfU1BFRURfUFhfUEVSX1NFQ09ORCA9IDEwMDA7XG52YXIgTUlOX1JJUFBMRV9GSUxMX1RJTUVfU0VDT05EUyA9IDAuMTtcbnZhciBNQVhfUklQUExFX0ZJTExfVElNRV9TRUNPTkRTID0gMC4zO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBwb2ludCAoeCwgeSkgdG8gdGhlIGZ1cnRoZXN0IGNvcm5lciBvZiBhIHJlY3RhbmdsZS5cbiAqL1xudmFyIGRpc3RhbmNlVG9GdXJ0aGVzdENvcm5lciA9IGZ1bmN0aW9uICh4LCB5LCByZWN0KSB7XG4gICAgdmFyIGRpc3RYID0gTWF0aC5tYXgoTWF0aC5hYnMoeCAtIHJlY3QubGVmdCksIE1hdGguYWJzKHggLSByZWN0LnJpZ2h0KSk7XG4gICAgdmFyIGRpc3RZID0gTWF0aC5tYXgoTWF0aC5hYnMoeSAtIHJlY3QudG9wKSwgTWF0aC5hYnMoeSAtIHJlY3QuYm90dG9tKSk7XG4gICAgcmV0dXJuIE1hdGguc3FydChkaXN0WCAqIGRpc3RYICsgZGlzdFkgKiBkaXN0WSk7XG59O1xuLyoqXG4gKiBIZWxwZXIgc2VydmljZSB0aGF0IHBlcmZvcm1zIERPTSBtYW5pcHVsYXRpb25zLiBOb3QgaW50ZW5kZWQgdG8gYmUgdXNlZCBvdXRzaWRlIHRoaXMgbW9kdWxlLlxuICogVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEgcmVmZXJlbmNlIHRvIHRoZSByaXBwbGUgZGlyZWN0aXZlJ3MgaG9zdCBlbGVtZW50IGFuZCBhIG1hcCBvZiBET01cbiAqIGV2ZW50IGhhbmRsZXJzIHRvIGJlIGluc3RhbGxlZCBvbiB0aGUgZWxlbWVudCB0aGF0IHRyaWdnZXJzIHJpcHBsZSBhbmltYXRpb25zLlxuICogVGhpcyB3aWxsIGV2ZW50dWFsbHkgYmVjb21lIGEgY3VzdG9tIHJlbmRlcmVyIG9uY2UgQW5ndWxhciBzdXBwb3J0IGV4aXN0cy5cbiAqIFRPRE86IGludGVybmFsXG4gKi9cbnZhciBSaXBwbGVSZW5kZXJlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmlwcGxlUmVuZGVyZXIoX2VsZW1lbnRSZWYsIF9ldmVudEhhbmRsZXJzKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcnMgPSBfZXZlbnRIYW5kbGVycztcbiAgICAgICAgdGhpcy5fcmlwcGxlRWxlbWVudCA9IF9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIC8vIEl0IG1pZ2h0IGJlIG5pY2UgdG8gZGVsYXkgY3JlYXRpbmcgdGhlIGJhY2tncm91bmQgdW50aWwgaXQncyBuZWVkZWQsIGJ1dCBkb2luZyB0aGlzIGluXG4gICAgICAgIC8vIGZhZGVJblJpcHBsZUJhY2tncm91bmQgY2F1c2VzIHRoZSBmaXJzdCBjbGljayBldmVudCB0byBub3QgYmUgaGFuZGxlZCByZWxpYWJseS5cbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kRGl2LmNsYXNzTGlzdC5hZGQoJ21kLXJpcHBsZS1iYWNrZ3JvdW5kJyk7XG4gICAgICAgIHRoaXMuX3JpcHBsZUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fYmFja2dyb3VuZERpdik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc3RhbGxzIGV2ZW50IGhhbmRsZXJzIG9uIHRoZSBnaXZlbiB0cmlnZ2VyIGVsZW1lbnQsIGFuZCByZW1vdmVzIGV2ZW50IGhhbmRsZXJzIGZyb20gdGhlXG4gICAgICogcHJldmlvdXMgdHJpZ2dlciBpZiBuZWVkZWQuXG4gICAgICovXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLnNldFRyaWdnZXJFbGVtZW50ID0gZnVuY3Rpb24gKG5ld1RyaWdnZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJFbGVtZW50ICE9PSBuZXdUcmlnZ2VyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHJpZ2dlckVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50SGFuZGxlciwgZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJFbGVtZW50ID0gbmV3VHJpZ2dlcjtcbiAgICAgICAgICAgIGlmICh0aGlzLl90cmlnZ2VyRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRIYW5kbGVyLCBldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnN0YWxscyBldmVudCBoYW5kbGVycyBvbiB0aGUgaG9zdCBlbGVtZW50IG9mIHRoZSBtZC1yaXBwbGUgZGlyZWN0aXZlLlxuICAgICAqL1xuICAgIFJpcHBsZVJlbmRlcmVyLnByb3RvdHlwZS5zZXRUcmlnZ2VyRWxlbWVudFRvSG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRUcmlnZ2VyRWxlbWVudCh0aGlzLl9yaXBwbGVFbGVtZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZXZlbnQgaGFuZGxlcnMgZnJvbSB0aGUgY3VycmVudCB0cmlnZ2VyIGVsZW1lbnQgaWYgbmVlZGVkLlxuICAgICAqL1xuICAgIFJpcHBsZVJlbmRlcmVyLnByb3RvdHlwZS5jbGVhclRyaWdnZXJFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldFRyaWdnZXJFbGVtZW50KG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZvcmVncm91bmQgcmlwcGxlIGFuZCBzZXRzIGl0cyBhbmltYXRpb24gdG8gZXhwYW5kIGFuZCBmYWRlIGluIGZyb20gdGhlIHBvc2l0aW9uXG4gICAgICogZ2l2ZW4gYnkgcmlwcGxlT3JpZ2luTGVmdCBhbmQgcmlwcGxlT3JpZ2luVG9wIChvciBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIDxtZC1yaXBwbGU+XG4gICAgICogYm91bmRpbmcgcmVjdCBpZiBjZW50ZXJlZCBpcyB0cnVlKS5cbiAgICAgKi9cbiAgICBSaXBwbGVSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlRm9yZWdyb3VuZFJpcHBsZSA9IGZ1bmN0aW9uIChyaXBwbGVPcmlnaW5MZWZ0LCByaXBwbGVPcmlnaW5Ub3AsIGNvbG9yLCBjZW50ZXJlZCwgcmFkaXVzLCBzcGVlZEZhY3RvciwgdHJhbnNpdGlvbkVuZENhbGxiYWNrKSB7XG4gICAgICAgIHZhciBwYXJlbnRSZWN0ID0gdGhpcy5fcmlwcGxlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgZm9yZWdyb3VuZCByaXBwbGUgZGl2IHdpdGggdGhlIHNpemUgYW5kIHBvc2l0aW9uIG9mIHRoZSBmdWxseSBleHBhbmRlZCByaXBwbGUuXG4gICAgICAgIC8vIFdoZW4gdGhlIGRpdiBpcyBjcmVhdGVkLCBpdCdzIGdpdmVuIGEgdHJhbnNmb3JtIHN0eWxlIHRoYXQgY2F1c2VzIHRoZSByaXBwbGUgdG8gYmUgZGlzcGxheWVkXG4gICAgICAgIC8vIHNtYWxsIGFuZCBjZW50ZXJlZCBvbiB0aGUgZXZlbnQgbG9jYXRpb24gKG9yIHRoZSBjZW50ZXIgb2YgdGhlIGJvdW5kaW5nIHJlY3QgaWYgdGhlIGNlbnRlcmVkXG4gICAgICAgIC8vIGFyZ3VtZW50IGlzIHRydWUpLiBSZW1vdmluZyB0aGF0IHRyYW5zZm9ybSBjYXVzZXMgdGhlIHJpcHBsZSB0byBhbmltYXRlIHRvIGl0cyBuYXR1cmFsIHNpemUuXG4gICAgICAgIHZhciBzdGFydFggPSBjZW50ZXJlZCA/IChwYXJlbnRSZWN0LmxlZnQgKyBwYXJlbnRSZWN0LndpZHRoIC8gMikgOiByaXBwbGVPcmlnaW5MZWZ0O1xuICAgICAgICB2YXIgc3RhcnRZID0gY2VudGVyZWQgPyAocGFyZW50UmVjdC50b3AgKyBwYXJlbnRSZWN0LmhlaWdodCAvIDIpIDogcmlwcGxlT3JpZ2luVG9wO1xuICAgICAgICB2YXIgb2Zmc2V0WCA9IHN0YXJ0WCAtIHBhcmVudFJlY3QubGVmdDtcbiAgICAgICAgdmFyIG9mZnNldFkgPSBzdGFydFkgLSBwYXJlbnRSZWN0LnRvcDtcbiAgICAgICAgdmFyIG1heFJhZGl1cyA9IHJhZGl1cyA+IDAgPyByYWRpdXMgOiBkaXN0YW5jZVRvRnVydGhlc3RDb3JuZXIoc3RhcnRYLCBzdGFydFksIHBhcmVudFJlY3QpO1xuICAgICAgICB2YXIgcmlwcGxlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX3JpcHBsZUVsZW1lbnQuYXBwZW5kQ2hpbGQocmlwcGxlRGl2KTtcbiAgICAgICAgcmlwcGxlRGl2LmNsYXNzTGlzdC5hZGQoJ21kLXJpcHBsZS1mb3JlZ3JvdW5kJyk7XG4gICAgICAgIHJpcHBsZURpdi5zdHlsZS5sZWZ0ID0gKG9mZnNldFggLSBtYXhSYWRpdXMpICsgXCJweFwiO1xuICAgICAgICByaXBwbGVEaXYuc3R5bGUudG9wID0gKG9mZnNldFkgLSBtYXhSYWRpdXMpICsgXCJweFwiO1xuICAgICAgICByaXBwbGVEaXYuc3R5bGUud2lkdGggPSAyICogbWF4UmFkaXVzICsgXCJweFwiO1xuICAgICAgICByaXBwbGVEaXYuc3R5bGUuaGVpZ2h0ID0gcmlwcGxlRGl2LnN0eWxlLndpZHRoO1xuICAgICAgICAvLyBJZiBjb2xvciBpbnB1dCBpcyBub3Qgc2V0LCB0aGlzIHdpbGwgZGVmYXVsdCB0byB0aGUgYmFja2dyb3VuZCBjb2xvciBkZWZpbmVkIGluIENTUy5cbiAgICAgICAgcmlwcGxlRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgICAgICAvLyBTdGFydCB0aGUgcmlwcGxlIHRpbnkuXG4gICAgICAgIHJpcHBsZURpdi5zdHlsZS50cmFuc2Zvcm0gPSBcInNjYWxlKDAuMDAxKVwiO1xuICAgICAgICB2YXIgZmFkZUluU2Vjb25kcyA9ICgxIC8gKHNwZWVkRmFjdG9yIHx8IDEpKSAqIE1hdGgubWF4KE1JTl9SSVBQTEVfRklMTF9USU1FX1NFQ09ORFMsIE1hdGgubWluKE1BWF9SSVBQTEVfRklMTF9USU1FX1NFQ09ORFMsIG1heFJhZGl1cyAvIFJJUFBMRV9TUEVFRF9QWF9QRVJfU0VDT05EKSk7XG4gICAgICAgIHJpcHBsZURpdi5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBmYWRlSW5TZWNvbmRzICsgXCJzXCI7XG4gICAgICAgIC8vIGh0dHBzOi8vdGltdGF1YmVydC5kZS9ibG9nLzIwMTIvMDkvY3NzLXRyYW5zaXRpb25zLWZvci1keW5hbWljYWxseS1jcmVhdGVkLWRvbS1lbGVtZW50cy9cbiAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUocmlwcGxlRGl2KS5vcGFjaXR5O1xuICAgICAgICByaXBwbGVEaXYuY2xhc3NMaXN0LmFkZCgnbWQtcmlwcGxlLWZhZGUtaW4nKTtcbiAgICAgICAgLy8gQ2xlYXJpbmcgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSBjYXVzZXMgdGhlIHJpcHBsZSB0byBhbmltYXRlIHRvIGl0cyBmdWxsIHNpemUuXG4gICAgICAgIHJpcHBsZURpdi5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgICAgICAgdmFyIHJpcHBsZSA9IG5ldyBGb3JlZ3JvdW5kUmlwcGxlKHJpcHBsZURpdik7XG4gICAgICAgIHJpcHBsZS5zdGF0ZSA9IEZvcmVncm91bmRSaXBwbGVTdGF0ZS5FWFBBTkRJTkc7XG4gICAgICAgIHJpcHBsZURpdi5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiB0cmFuc2l0aW9uRW5kQ2FsbGJhY2socmlwcGxlLCBldmVudCk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmFkZXMgb3V0IGEgZm9yZWdyb3VuZCByaXBwbGUgYWZ0ZXIgaXQgaGFzIGZ1bGx5IGV4cGFuZGVkIGFuZCBmYWRlZCBpbi5cbiAgICAgKi9cbiAgICBSaXBwbGVSZW5kZXJlci5wcm90b3R5cGUuZmFkZU91dEZvcmVncm91bmRSaXBwbGUgPSBmdW5jdGlvbiAocmlwcGxlKSB7XG4gICAgICAgIHJpcHBsZS5jbGFzc0xpc3QucmVtb3ZlKCdtZC1yaXBwbGUtZmFkZS1pbicpO1xuICAgICAgICByaXBwbGUuY2xhc3NMaXN0LmFkZCgnbWQtcmlwcGxlLWZhZGUtb3V0Jyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgZm9yZWdyb3VuZCByaXBwbGUgZnJvbSB0aGUgRE9NIGFmdGVyIGl0IGhhcyBmYWRlZCBvdXQuXG4gICAgICovXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLnJlbW92ZVJpcHBsZUZyb21Eb20gPSBmdW5jdGlvbiAocmlwcGxlKSB7XG4gICAgICAgIHJpcHBsZS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHJpcHBsZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGYWRlcyBpbiB0aGUgcmlwcGxlIGJhY2tncm91bmQuXG4gICAgICovXG4gICAgUmlwcGxlUmVuZGVyZXIucHJvdG90eXBlLmZhZGVJblJpcHBsZUJhY2tncm91bmQgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZERpdi5jbGFzc0xpc3QuYWRkKCdtZC1yaXBwbGUtYWN0aXZlJyk7XG4gICAgICAgIC8vIElmIGNvbG9yIGlzIG5vdCBzZXQsIHRoaXMgd2lsbCBkZWZhdWx0IHRvIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIGRlZmluZWQgaW4gQ1NTLlxuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmFkZXMgb3V0IHRoZSByaXBwbGUgYmFja2dyb3VuZC5cbiAgICAgKi9cbiAgICBSaXBwbGVSZW5kZXJlci5wcm90b3R5cGUuZmFkZU91dFJpcHBsZUJhY2tncm91bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9iYWNrZ3JvdW5kRGl2KSB7XG4gICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kRGl2LmNsYXNzTGlzdC5yZW1vdmUoJ21kLXJpcHBsZS1hY3RpdmUnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJpcHBsZVJlbmRlcmVyO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQzID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTWRSaXBwbGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUmlwcGxlKF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQsIHRoZSByYWRpdXMgaW4gcGl4ZWxzIG9mIGZvcmVncm91bmQgcmlwcGxlcyB3aGVuIGZ1bGx5IGV4cGFuZGVkLiBJZiB1bnNldCwgdGhlIHJhZGl1c1xuICAgICAgICAgKiB3aWxsIGJlIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIHJpcHBsZSB0byB0aGUgZnVydGhlc3QgY29ybmVyIG9mIHRoZSBob3N0IGVsZW1lbnQnc1xuICAgICAgICAgKiBib3VuZGluZyByZWN0YW5nbGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1heFJhZGl1cyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBzZXQsIHRoZSBub3JtYWwgZHVyYXRpb24gb2YgcmlwcGxlIGFuaW1hdGlvbnMgaXMgZGl2aWRlZCBieSB0aGlzIHZhbHVlLiBGb3IgZXhhbXBsZSxcbiAgICAgICAgICogc2V0dGluZyBpdCB0byAwLjUgd2lsbCBjYXVzZSB0aGUgYW5pbWF0aW9ucyB0byB0YWtlIHR3aWNlIGFzIGxvbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNwZWVkRmFjdG9yID0gMTtcbiAgICAgICAgLy8gVGhlc2UgZXZlbnQgaGFuZGxlcnMgYXJlIGF0dGFjaGVkIHRvIHRoZSBlbGVtZW50IHRoYXQgdHJpZ2dlcnMgdGhlIHJpcHBsZSBhbmltYXRpb25zLlxuICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZXZlbnRIYW5kbGVycy5zZXQoJ21vdXNlZG93bicsIGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gX3RoaXMuX21vdXNlRG93bihldmVudCk7IH0pO1xuICAgICAgICBldmVudEhhbmRsZXJzLnNldCgnY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLl9jbGljayhldmVudCk7IH0pO1xuICAgICAgICBldmVudEhhbmRsZXJzLnNldCgnbW91c2VsZWF2ZScsIGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gX3RoaXMuX21vdXNlTGVhdmUoZXZlbnQpOyB9KTtcbiAgICAgICAgdGhpcy5fcmlwcGxlUmVuZGVyZXIgPSBuZXcgUmlwcGxlUmVuZGVyZXIoX2VsZW1lbnRSZWYsIGV2ZW50SGFuZGxlcnMpO1xuICAgIH1cbiAgICAvKiogVE9ETzogaW50ZXJuYWwgKi9cbiAgICBNZFJpcHBsZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElmIG5vIHRyaWdnZXIgZWxlbWVudCB3YXMgZXhwbGljaXR5IHNldCwgdXNlIHRoZSBob3N0IGVsZW1lbnRcbiAgICAgICAgaWYgKCF0aGlzLnRyaWdnZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JpcHBsZVJlbmRlcmVyLnNldFRyaWdnZXJFbGVtZW50VG9Ib3N0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBUT0RPOiBpbnRlcm5hbCAqL1xuICAgIE1kUmlwcGxlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgdHJpZ2dlciBlbGVtZW50LlxuICAgICAgICB0aGlzLl9yaXBwbGVSZW5kZXJlci5jbGVhclRyaWdnZXJFbGVtZW50KCk7XG4gICAgfTtcbiAgICAvKiogVE9ETzogaW50ZXJuYWwgKi9cbiAgICBNZFJpcHBsZS5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICAvLyBJZiB0aGUgdHJpZ2dlciBlbGVtZW50IGNoYW5nZWQgKG9yIGlzIGJlaW5nIGluaXRpYWxseSBzZXQpLCBhZGQgZXZlbnQgbGlzdGVuZXJzIHRvIGl0LlxuICAgICAgICB2YXIgY2hhbmdlZElucHV0cyA9IE9iamVjdC5rZXlzKGNoYW5nZXMpO1xuICAgICAgICBpZiAoY2hhbmdlZElucHV0cy5pbmRleE9mKCd0cmlnZ2VyJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9yaXBwbGVSZW5kZXJlci5zZXRUcmlnZ2VyRWxlbWVudCh0aGlzLnRyaWdnZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNwb25kcyB0byB0aGUgc3RhcnQgb2YgYSByaXBwbGUgYW5pbWF0aW9uIHRyaWdnZXIgYnkgZmFkaW5nIHRoZSBiYWNrZ3JvdW5kIGluLlxuICAgICAqL1xuICAgIE1kUmlwcGxlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmlwcGxlUmVuZGVyZXIuZmFkZUluUmlwcGxlQmFja2dyb3VuZCh0aGlzLmJhY2tncm91bmRDb2xvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNwb25kcyB0byB0aGUgZW5kIG9mIGEgcmlwcGxlIGFuaW1hdGlvbiB0cmlnZ2VyIGJ5IGZhZGluZyB0aGUgYmFja2dyb3VuZCBvdXQsIGFuZCBjcmVhdGluZyBhXG4gICAgICogZm9yZWdyb3VuZCByaXBwbGUgdGhhdCBleHBhbmRzIGZyb20gdGhlIGV2ZW50IGxvY2F0aW9uIChvciBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGVsZW1lbnQgaWZcbiAgICAgKiB0aGUgXCJjZW50ZXJlZFwiIHByb3BlcnR5IGlzIHNldCBvciBmb3JjZUNlbnRlciBpcyB0cnVlKS5cbiAgICAgKi9cbiAgICBNZFJpcHBsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGxlZnQsIHRvcCwgZm9yY2VDZW50ZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGZvcmNlQ2VudGVyID09PSB2b2lkIDApIHsgZm9yY2VDZW50ZXIgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMuX3JpcHBsZVJlbmRlcmVyLmNyZWF0ZUZvcmVncm91bmRSaXBwbGUobGVmdCwgdG9wLCB0aGlzLmNvbG9yLCB0aGlzLmNlbnRlcmVkIHx8IGZvcmNlQ2VudGVyLCB0aGlzLm1heFJhZGl1cywgdGhpcy5zcGVlZEZhY3RvciwgZnVuY3Rpb24gKHJpcHBsZSwgZSkgeyByZXR1cm4gX3RoaXMuX3JpcHBsZVRyYW5zaXRpb25FbmRlZChyaXBwbGUsIGUpOyB9KTtcbiAgICAgICAgdGhpcy5fcmlwcGxlUmVuZGVyZXIuZmFkZU91dFJpcHBsZUJhY2tncm91bmQoKTtcbiAgICB9O1xuICAgIE1kUmlwcGxlLnByb3RvdHlwZS5fcmlwcGxlVHJhbnNpdGlvbkVuZGVkID0gZnVuY3Rpb24gKHJpcHBsZSwgZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnByb3BlcnR5TmFtZSA9PT0gJ29wYWNpdHknKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcmlwcGxlIGZpbmlzaGVkIGV4cGFuZGluZywgc3RhcnQgZmFkaW5nIGl0IG91dC4gSWYgaXQgZmluaXNoZWQgZmFkaW5nIG91dCxcbiAgICAgICAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIHRoZSBET00uXG4gICAgICAgICAgICBzd2l0Y2ggKHJpcHBsZS5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgRm9yZWdyb3VuZFJpcHBsZVN0YXRlLkVYUEFORElORzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmlwcGxlUmVuZGVyZXIuZmFkZU91dEZvcmVncm91bmRSaXBwbGUocmlwcGxlLnJpcHBsZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICByaXBwbGUuc3RhdGUgPSBGb3JlZ3JvdW5kUmlwcGxlU3RhdGUuRkFESU5HX09VVDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBGb3JlZ3JvdW5kUmlwcGxlU3RhdGUuRkFESU5HX09VVDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmlwcGxlUmVuZGVyZXIucmVtb3ZlUmlwcGxlRnJvbURvbShyaXBwbGUucmlwcGxlRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgdHJpZ2dlciBlbGVtZW50IHJlY2VpdmVzIGEgbW91c2Vkb3duIGV2ZW50LiBTdGFydHMgdGhlIHJpcHBsZSBhbmltYXRpb24gYnlcbiAgICAgKiBmYWRpbmcgaW4gdGhlIGJhY2tncm91bmQuXG4gICAgICovXG4gICAgTWRSaXBwbGUucHJvdG90eXBlLl9tb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkICYmIGV2ZW50LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgdHJpZ2dlciBlbGVtZW50IHJlY2VpdmVzIGEgY2xpY2sgZXZlbnQuIENyZWF0ZXMgYSBmb3JlZ3JvdW5kIHJpcHBsZSBhbmRcbiAgICAgKiBydW5zIGl0cyBhbmltYXRpb24uXG4gICAgICovXG4gICAgTWRSaXBwbGUucHJvdG90eXBlLl9jbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgZXZlbnQuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgICAvLyBJZiBzY3JlZW4gYW5kIHBhZ2UgcG9zaXRpb25zIGFyZSBhbGwgMCwgdGhpcyB3YXMgcHJvYmFibHkgdHJpZ2dlcmVkIGJ5IGEga2V5cHJlc3MuXG4gICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHVzZSB0aGUgY2VudGVyIG9mIHRoZSBib3VuZGluZyByZWN0IGFzIHRoZSByaXBwbGUgb3JpZ2luLlxuICAgICAgICAgICAgLy8gRklYTUU6IFRoaXMgZmFpbHMgb24gSUUxMSwgd2hpY2ggc3RpbGwgc2V0cyBwYWdlWC9ZIGFuZCBzY3JlZW5YL1kgb24ga2V5Ym9hcmQgY2xpY2tzLlxuICAgICAgICAgICAgdmFyIGlzS2V5RXZlbnQgPSAoZXZlbnQuc2NyZWVuWCA9PT0gMCAmJiBldmVudC5zY3JlZW5ZID09PSAwICYmIGV2ZW50LnBhZ2VYID09PSAwICYmIGV2ZW50LnBhZ2VZID09PSAwKTtcbiAgICAgICAgICAgIHRoaXMuZW5kKGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSwgaXNLZXlFdmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSB0cmlnZ2VyIGVsZW1lbnQgcmVjZWl2ZXMgYSBtb3VzZWxlYXZlIGV2ZW50LiBGYWRlcyBvdXQgdGhlIGJhY2tncm91bmQuXG4gICAgICovXG4gICAgTWRSaXBwbGUucHJvdG90eXBlLl9tb3VzZUxlYXZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFdlIGNhbiBhbHdheXMgZmFkZSBvdXQgdGhlIGJhY2tncm91bmQgaGVyZTsgSXQncyBhIG5vLW9wIGlmIGl0IHdhcyBhbHJlYWR5IGluYWN0aXZlLlxuICAgICAgICB0aGlzLl9yaXBwbGVSZW5kZXJlci5mYWRlT3V0UmlwcGxlQmFja2dyb3VuZCgpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWQtcmlwcGxlLXRyaWdnZXInKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMygnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRSaXBwbGUucHJvdG90eXBlLCBcInRyaWdnZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdtZC1yaXBwbGUtY2VudGVyZWQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMygnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kUmlwcGxlLnByb3RvdHlwZSwgXCJjZW50ZXJlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ21kLXJpcHBsZS1kaXNhYmxlZCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzKCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRSaXBwbGUucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWQtcmlwcGxlLW1heC1yYWRpdXMnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMygnZGVzaWduOnR5cGUnLCBOdW1iZXIpXG4gICAgXSwgTWRSaXBwbGUucHJvdG90eXBlLCBcIm1heFJhZGl1c1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ21kLXJpcHBsZS1zcGVlZC1mYWN0b3InKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMygnZGVzaWduOnR5cGUnLCBOdW1iZXIpXG4gICAgXSwgTWRSaXBwbGUucHJvdG90eXBlLCBcInNwZWVkRmFjdG9yXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWQtcmlwcGxlLWNvbG9yJyksIFxuICAgICAgICBfX21ldGFkYXRhJDMoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kUmlwcGxlLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ21kLXJpcHBsZS1iYWNrZ3JvdW5kLWNvbG9yJyksIFxuICAgICAgICBfX21ldGFkYXRhJDMoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kUmlwcGxlLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKCdjbGFzcy5tZC1yaXBwbGUtZm9jdXNlZCcpLFxuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdtZC1yaXBwbGUtZm9jdXNlZCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzKCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRSaXBwbGUucHJvdG90eXBlLCBcImZvY3VzZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKCdjbGFzcy5tZC1yaXBwbGUtdW5ib3VuZGVkJyksXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ21kLXJpcHBsZS11bmJvdW5kZWQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMygnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kUmlwcGxlLnByb3RvdHlwZSwgXCJ1bmJvdW5kZWRcIiwgdm9pZCAwKTtcbiAgICBNZFJpcHBsZSA9IF9fZGVjb3JhdGUkMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLXJpcHBsZV0nLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMygnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmXSlcbiAgICBdLCBNZFJpcHBsZSk7XG4gICAgcmV0dXJuIE1kUmlwcGxlO1xufSgpKTtcbnZhciBNZFJpcHBsZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRSaXBwbGVNb2R1bGUoKSB7XG4gICAgfVxuICAgIE1kUmlwcGxlTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRSaXBwbGVNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZFJpcHBsZU1vZHVsZSA9IF9fZGVjb3JhdGUkMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgZXhwb3J0czogW01kUmlwcGxlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kUmlwcGxlXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRSaXBwbGVNb2R1bGUpO1xuICAgIHJldHVybiBNZFJpcHBsZU1vZHVsZTtcbn0oKSk7XG5cbi8vIFRPRE8oa2FyYSk6IFJldmlzaXQgd2h5IGVycm9yIG1lc3NhZ2VzIGFyZSBub3QgYmVpbmcgcHJvcGVybHkgc2V0LlxudmFyIF9fZXh0ZW5kcyQzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogV3JhcHBlciBhcm91bmQgRXJyb3IgdGhhdCBzZXRzIHRoZSBlcnJvciBtZXNzYWdlLlxuICovXG52YXIgTWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDMoTWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZEVycm9yKHZhbHVlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE1kRXJyb3I7XG59KEVycm9yKSk7XG5cbnZhciBfX2V4dGVuZHMkMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKiogRXhjZXB0aW9uIHRocm93biB3aGVuIGEgQ29tcG9uZW50UG9ydGFsIGlzIGF0dGFjaGVkIHRvIGEgRG9tUG9ydGFsSG9zdCB3aXRob3V0IGFuIG9yaWdpbi4gKi9cbnZhciBNZENvbXBvbmVudFBvcnRhbEF0dGFjaGVkVG9Eb21XaXRob3V0T3JpZ2luRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQyKE1kQ29tcG9uZW50UG9ydGFsQXR0YWNoZWRUb0RvbVdpdGhvdXRPcmlnaW5FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZENvbXBvbmVudFBvcnRhbEF0dGFjaGVkVG9Eb21XaXRob3V0T3JpZ2luRXJyb3IoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdBIENvbXBvbmVudFBvcnRhbCBtdXN0IGhhdmUgYW4gb3JpZ2luIHNldCB3aGVuIGF0dGFjaGVkIHRvIGEgRG9tUG9ydGFsSG9zdCAnICtcbiAgICAgICAgICAgICdiZWNhdXNlIHRoZSBET00gZWxlbWVudCBpcyBub3QgcGFydCBvZiB0aGUgQW5ndWxhciBhcHBsaWNhdGlvbiBjb250ZXh0LicpO1xuICAgIH1cbiAgICByZXR1cm4gTWRDb21wb25lbnRQb3J0YWxBdHRhY2hlZFRvRG9tV2l0aG91dE9yaWdpbkVycm9yO1xufShNZEVycm9yKSk7XG4vKiogRXhjZXB0aW9uIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gYXR0YWNoIGEgbnVsbCBwb3J0YWwgdG8gYSBob3N0LiAqL1xudmFyIE1kTnVsbFBvcnRhbEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMihNZE51bGxQb3J0YWxFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZE51bGxQb3J0YWxFcnJvcigpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ011c3QgcHJvdmlkZSBhIHBvcnRhbCB0byBhdHRhY2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIE1kTnVsbFBvcnRhbEVycm9yO1xufShNZEVycm9yKSk7XG4vKiogRXhjZXB0aW9uIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gYXR0YWNoIGEgcG9ydGFsIHRvIGEgaG9zdCB0aGF0IGlzIGFscmVhZHkgYXR0YWNoZWQuICovXG52YXIgTWRQb3J0YWxBbHJlYWR5QXR0YWNoZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDIoTWRQb3J0YWxBbHJlYWR5QXR0YWNoZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZFBvcnRhbEFscmVhZHlBdHRhY2hlZEVycm9yKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnSG9zdCBhbHJlYWR5IGhhcyBhIHBvcnRhbCBhdHRhY2hlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gTWRQb3J0YWxBbHJlYWR5QXR0YWNoZWRFcnJvcjtcbn0oTWRFcnJvcikpO1xuLyoqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBhdHRlbXB0aW5nIHRvIGF0dGFjaCBhIHBvcnRhbCB0byBhbiBhbHJlYWR5LWRpc3Bvc2VkIGhvc3QuICovXG52YXIgTWRQb3J0YWxIb3N0QWxyZWFkeURpc3Bvc2VkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQyKE1kUG9ydGFsSG9zdEFscmVhZHlEaXNwb3NlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kUG9ydGFsSG9zdEFscmVhZHlEaXNwb3NlZEVycm9yKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnVGhpcyBQb3J0YWxIb3N0IGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIE1kUG9ydGFsSG9zdEFscmVhZHlEaXNwb3NlZEVycm9yO1xufShNZEVycm9yKSk7XG4vKiogRXhjZXB0aW9uIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gYXR0YWNoIGFuIHVua25vd24gcG9ydGFsIHR5cGUuICovXG52YXIgTWRVbmtub3duUG9ydGFsVHlwZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMihNZFVua25vd25Qb3J0YWxUeXBlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRVbmtub3duUG9ydGFsVHlwZUVycm9yKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnQXR0ZW1wdGluZyB0byBhdHRhY2ggYW4gdW5rbm93biBQb3J0YWwgdHlwZS4gJyArXG4gICAgICAgICAgICAnQmFzZVBvcnRhbEhvc3QgYWNjZXB0cyBlaXRoZXIgYSBDb21wb25lbnRQb3J0YWwgb3IgYSBUZW1wbGF0ZVBvcnRhbC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIE1kVW5rbm93blBvcnRhbFR5cGVFcnJvcjtcbn0oTWRFcnJvcikpO1xuLyoqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBhdHRlbXB0aW5nIHRvIGF0dGFjaCBhIHBvcnRhbCB0byBhIG51bGwgaG9zdC4gKi9cbnZhciBNZE51bGxQb3J0YWxIb3N0RXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQyKE1kTnVsbFBvcnRhbEhvc3RFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZE51bGxQb3J0YWxIb3N0RXJyb3IoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdBdHRlbXB0aW5nIHRvIGF0dGFjaCBhIHBvcnRhbCB0byBhIG51bGwgUG9ydGFsSG9zdCcpO1xuICAgIH1cbiAgICByZXR1cm4gTWROdWxsUG9ydGFsSG9zdEVycm9yO1xufShNZEVycm9yKSk7XG4vKiogRXhjZXB0aW9uIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gZGV0YWNoIGEgcG9ydGFsIHRoYXQgaXMgbm90IGF0dGFjaGVkLiAqL1xudmFyIE1kTm9Qb3J0YWxBdHRhY2hlZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMihNZE5vUG9ydGFsQXR0YWNoZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZE5vUG9ydGFsQXR0YWNoZWRFcnJvcigpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ0F0dGVtcHRpbmcgdG8gZGV0YWNoIGEgcG9ydGFsIHRoYXQgaXMgbm90IGF0dGFjaGVkIHRvIGEgaG9zdCcpO1xuICAgIH1cbiAgICByZXR1cm4gTWROb1BvcnRhbEF0dGFjaGVkRXJyb3I7XG59KE1kRXJyb3IpKTtcblxudmFyIF9fZXh0ZW5kcyQxID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQSBgUG9ydGFsYCBpcyBzb21ldGhpbmcgdGhhdCB5b3Ugd2FudCB0byByZW5kZXIgc29tZXdoZXJlIGVsc2UuXG4gKiBJdCBjYW4gYmUgYXR0YWNoIHRvIC8gZGV0YWNoZWQgZnJvbSBhIGBQb3J0YWxIb3N0YC5cbiAqL1xudmFyIFBvcnRhbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9ydGFsKCkge1xuICAgIH1cbiAgICAvKiogQXR0YWNoIHRoaXMgcG9ydGFsIHRvIGEgaG9zdC4gKi9cbiAgICBQb3J0YWwucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChob3N0KSB7XG4gICAgICAgIGlmIChob3N0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZE51bGxQb3J0YWxIb3N0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9zdC5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWRQb3J0YWxBbHJlYWR5QXR0YWNoZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2F0dGFjaGVkSG9zdCA9IGhvc3Q7XG4gICAgICAgIHJldHVybiBob3N0LmF0dGFjaCh0aGlzKTtcbiAgICB9O1xuICAgIC8qKiBEZXRhY2ggdGhpcyBwb3J0YWwgZnJvbSBpdHMgaG9zdCAqL1xuICAgIFBvcnRhbC5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaG9zdCA9IHRoaXMuX2F0dGFjaGVkSG9zdDtcbiAgICAgICAgaWYgKGhvc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1kTm9Qb3J0YWxBdHRhY2hlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXR0YWNoZWRIb3N0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGhvc3QuZGV0YWNoKCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9ydGFsLnByb3RvdHlwZSwgXCJpc0F0dGFjaGVkXCIsIHtcbiAgICAgICAgLyoqIFdoZXRoZXIgdGhpcyBwb3J0YWwgaXMgYXR0YWNoZWQgdG8gYSBob3N0LiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdHRhY2hlZEhvc3QgIT0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgUG9ydGFsSG9zdCByZWZlcmVuY2Ugd2l0aG91dCBwZXJmb3JtaW5nIGBhdHRhY2goKWAuIFRoaXMgaXMgdXNlZCBkaXJlY3RseSBieVxuICAgICAqIHRoZSBQb3J0YWxIb3N0IHdoZW4gaXQgaXMgcGVyZm9ybWluZyBhbiBgYXR0YWNoKClgIG9yIGBkZXRhdGNoKClgLlxuICAgICAqL1xuICAgIFBvcnRhbC5wcm90b3R5cGUuc2V0QXR0YWNoZWRIb3N0ID0gZnVuY3Rpb24gKGhvc3QpIHtcbiAgICAgICAgdGhpcy5fYXR0YWNoZWRIb3N0ID0gaG9zdDtcbiAgICB9O1xuICAgIHJldHVybiBQb3J0YWw7XG59KCkpO1xuLyoqXG4gKiBBIGBDb21wb25lbnRQb3J0YWxgIGlzIGEgcG9ydGFsIHRoYXQgaW5zdGFudGlhdGVzIHNvbWUgQ29tcG9uZW50IHVwb24gYXR0YWNobWVudC5cbiAqL1xudmFyIENvbXBvbmVudFBvcnRhbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoQ29tcG9uZW50UG9ydGFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbXBvbmVudFBvcnRhbChjb21wb25lbnQsIHZpZXdDb250YWluZXJSZWYsIGluamVjdG9yKSB7XG4gICAgICAgIGlmICh2aWV3Q29udGFpbmVyUmVmID09PSB2b2lkIDApIHsgdmlld0NvbnRhaW5lclJlZiA9IG51bGw7IH1cbiAgICAgICAgaWYgKGluamVjdG9yID09PSB2b2lkIDApIHsgaW5qZWN0b3IgPSBudWxsOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyUmVmID0gdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gQ29tcG9uZW50UG9ydGFsO1xufShQb3J0YWwpKTtcbi8qKlxuICogQSBgVGVtcGxhdGVQb3J0YWxgIGlzIGEgcG9ydGFsIHRoYXQgcmVwcmVzZW50cyBzb21lIGVtYmVkZGVkIHRlbXBsYXRlIChUZW1wbGF0ZVJlZikuXG4gKi9cbnZhciBUZW1wbGF0ZVBvcnRhbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEoVGVtcGxhdGVQb3J0YWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGVtcGxhdGVQb3J0YWwodGVtcGxhdGUsIHZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRpdGlvbmFsIGxvY2FscyBmb3IgdGhlIGluc3RhbnRpYXRlZCBlbWJlZGRlZCB2aWV3LlxuICAgICAgICAgKiBUaGVzZSBsb2NhbHMgY2FuIGJlIHNlZW4gYXMgXCJleHBvcnRzXCIgZm9yIHRoZSB0ZW1wbGF0ZSwgc3VjaCBhcyBob3cgbmdGb3IgaGFzXG4gICAgICAgICAqIGluZGV4IC8gZXZlbnQgLyBvZGQuXG4gICAgICAgICAqIFNlZSBodHRwczovL2FuZ3VsYXIuaW8vZG9jcy90cy9sYXRlc3QvYXBpL2NvcmUvRW1iZWRkZWRWaWV3UmVmLWNsYXNzLmh0bWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9jYWxzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lclJlZiA9IHZpZXdDb250YWluZXJSZWY7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZW1wbGF0ZVBvcnRhbC5wcm90b3R5cGUsIFwib3JpZ2luXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZVJlZi5lbGVtZW50UmVmO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUZW1wbGF0ZVBvcnRhbC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKGhvc3QsIGxvY2Fscykge1xuICAgICAgICB0aGlzLmxvY2FscyA9IGxvY2FscyA9PSBudWxsID8gbmV3IE1hcCgpIDogbG9jYWxzO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5hdHRhY2guY2FsbCh0aGlzLCBob3N0KTtcbiAgICB9O1xuICAgIFRlbXBsYXRlUG9ydGFsLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9jYWxzID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5kZXRhY2guY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBUZW1wbGF0ZVBvcnRhbDtcbn0oUG9ydGFsKSk7XG4vKipcbiAqIFBhcnRpYWwgaW1wbGVtZW50YXRpb24gb2YgUG9ydGFsSG9zdCB0aGF0IG9ubHkgZGVhbHMgd2l0aCBhdHRhY2hpbmcgZWl0aGVyIGFcbiAqIENvbXBvbmVudFBvcnRhbCBvciBhIFRlbXBsYXRlUG9ydGFsLlxuICovXG52YXIgQmFzZVBvcnRhbEhvc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2VQb3J0YWxIb3N0KCkge1xuICAgICAgICAvKiogV2hldGhlciB0aGlzIGhvc3QgaGFzIGFscmVhZHkgYmVlbiBwZXJtYW5lbnRseSBkaXNwb3NlZC4gKi9cbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKiogV2hldGhlciB0aGlzIGhvc3QgaGFzIGFuIGF0dGFjaGVkIHBvcnRhbC4gKi9cbiAgICBCYXNlUG9ydGFsSG9zdC5wcm90b3R5cGUuaGFzQXR0YWNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdHRhY2hlZFBvcnRhbCAhPSBudWxsO1xuICAgIH07XG4gICAgQmFzZVBvcnRhbEhvc3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uIChwb3J0YWwpIHtcbiAgICAgICAgaWYgKHBvcnRhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWROdWxsUG9ydGFsRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWRQb3J0YWxBbHJlYWR5QXR0YWNoZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWRQb3J0YWxIb3N0QWxyZWFkeURpc3Bvc2VkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9ydGFsIGluc3RhbmNlb2YgQ29tcG9uZW50UG9ydGFsKSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hlZFBvcnRhbCA9IHBvcnRhbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dGFjaENvbXBvbmVudFBvcnRhbChwb3J0YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcnRhbCBpbnN0YW5jZW9mIFRlbXBsYXRlUG9ydGFsKSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hlZFBvcnRhbCA9IHBvcnRhbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dGFjaFRlbXBsYXRlUG9ydGFsKHBvcnRhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE1kVW5rbm93blBvcnRhbFR5cGVFcnJvcigpO1xuICAgIH07XG4gICAgQmFzZVBvcnRhbEhvc3QucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2F0dGFjaGVkUG9ydGFsKSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hlZFBvcnRhbC5zZXRBdHRhY2hlZEhvc3QobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXR0YWNoZWRQb3J0YWwgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fZGlzcG9zZUZuICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VGbigpO1xuICAgICAgICAgICAgdGhpcy5fZGlzcG9zZUZuID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmFzZVBvcnRhbEhvc3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgfTtcbiAgICBCYXNlUG9ydGFsSG9zdC5wcm90b3R5cGUuc2V0RGlzcG9zZUZuID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VGbiA9IGZuO1xuICAgIH07XG4gICAgcmV0dXJuIEJhc2VQb3J0YWxIb3N0O1xufSgpKTtcblxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQ0ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogRGlyZWN0aXZlIHZlcnNpb24gb2YgYSBgVGVtcGxhdGVQb3J0YWxgLiBCZWNhdXNlIHRoZSBkaXJlY3RpdmUgKmlzKiBhIFRlbXBsYXRlUG9ydGFsLFxuICogdGhlIGRpcmVjdGl2ZSBpbnN0YW5jZSBpdHNlbGYgY2FuIGJlIGF0dGFjaGVkIHRvIGEgaG9zdCwgZW5hYmxpbmcgZGVjbGFyYXRpdmUgdXNlIG9mIHBvcnRhbHMuXG4gKlxuICogVXNhZ2U6XG4gKiA8dGVtcGxhdGUgcG9ydGFsICNncmVldGluZz5cbiAqICAgPHA+IEhlbGxvIHt7bmFtZX19IDwvcD5cbiAqIDwvdGVtcGxhdGU+XG4gKi9cbnZhciBUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRlbXBsYXRlUG9ydGFsRGlyZWN0aXZlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRlbXBsYXRlUG9ydGFsRGlyZWN0aXZlKHRlbXBsYXRlUmVmLCB2aWV3Q29udGFpbmVyUmVmKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHRlbXBsYXRlUmVmLCB2aWV3Q29udGFpbmVyUmVmKTtcbiAgICB9XG4gICAgVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmUgPSBfX2RlY29yYXRlJDQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1twb3J0YWxdJyxcbiAgICAgICAgICAgIGV4cG9ydEFzOiAncG9ydGFsJyxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuVGVtcGxhdGVSZWYsIF9hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZl0pXG4gICAgXSwgVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmUpO1xuICAgIHJldHVybiBUZW1wbGF0ZVBvcnRhbERpcmVjdGl2ZTtcbn0oVGVtcGxhdGVQb3J0YWwpKTtcbi8qKlxuICogRGlyZWN0aXZlIHZlcnNpb24gb2YgYSBQb3J0YWxIb3N0LiBCZWNhdXNlIHRoZSBkaXJlY3RpdmUgKmlzKiBhIFBvcnRhbEhvc3QsIHBvcnRhbHMgY2FuIGJlXG4gKiBkaXJlY3RseSBhdHRhY2hlZCB0byBpdCwgZW5hYmxpbmcgZGVjbGFyYXRpdmUgdXNlLlxuICpcbiAqIFVzYWdlOlxuICogPHRlbXBsYXRlIFtwb3J0YWxIb3N0XT1cImdyZWV0aW5nXCI+PC90ZW1wbGF0ZT5cbiAqL1xudmFyIFBvcnRhbEhvc3REaXJlY3RpdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQb3J0YWxIb3N0RGlyZWN0aXZlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBvcnRhbEhvc3REaXJlY3RpdmUoX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgX3ZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYgPSBfdmlld0NvbnRhaW5lclJlZjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFBvcnRhbEhvc3REaXJlY3RpdmUucHJvdG90eXBlLCBcInBvcnRhbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvcnRhbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgdGhpcy5fcmVwbGFjZUF0dGFjaGVkUG9ydGFsKHApO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogQXR0YWNoIHRoZSBnaXZlbiBDb21wb25lbnRQb3J0YWwgdG8gdGhpcyBQb3J0bEhvc3QgdXNpbmcgdGhlIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlci4gKi9cbiAgICBQb3J0YWxIb3N0RGlyZWN0aXZlLnByb3RvdHlwZS5hdHRhY2hDb21wb25lbnRQb3J0YWwgPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIHBvcnRhbC5zZXRBdHRhY2hlZEhvc3QodGhpcyk7XG4gICAgICAgIC8vIElmIHRoZSBwb3J0YWwgc3BlY2lmaWVzIGFuIG9yaWdpbiwgdXNlIHRoYXQgYXMgdGhlIGxvZ2ljYWwgbG9jYXRpb24gb2YgdGhlIGNvbXBvbmVudFxuICAgICAgICAvLyBpbiB0aGUgYXBwbGljYXRpb24gdHJlZS4gT3RoZXJ3aXNlIHVzZSB0aGUgbG9jYXRpb24gb2YgdGhpcyBQb3J0YWxIb3N0LlxuICAgICAgICB2YXIgdmlld0NvbnRhaW5lclJlZiA9IHBvcnRhbC52aWV3Q29udGFpbmVyUmVmICE9IG51bGwgP1xuICAgICAgICAgICAgcG9ydGFsLnZpZXdDb250YWluZXJSZWYgOlxuICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZjtcbiAgICAgICAgdmFyIGNvbXBvbmVudEZhY3RvcnkgPSB0aGlzLl9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkocG9ydGFsLmNvbXBvbmVudCk7XG4gICAgICAgIHZhciByZWYgPSB2aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudChjb21wb25lbnRGYWN0b3J5LCB2aWV3Q29udGFpbmVyUmVmLmxlbmd0aCwgcG9ydGFsLmluamVjdG9yIHx8IHZpZXdDb250YWluZXJSZWYucGFyZW50SW5qZWN0b3IpO1xuICAgICAgICB0aGlzLnNldERpc3Bvc2VGbihmdW5jdGlvbiAoKSB7IHJldHVybiByZWYuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICB9O1xuICAgIC8qKiBBdHRhY2ggdGhlIGdpdmVuIFRlbXBsYXRlUG9ydGFsIHRvIHRoaXMgUG9ydGxIb3N0IGFzIGFuIGVtYmVkZGVkIFZpZXcuICovXG4gICAgUG9ydGFsSG9zdERpcmVjdGl2ZS5wcm90b3R5cGUuYXR0YWNoVGVtcGxhdGVQb3J0YWwgPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHBvcnRhbC5zZXRBdHRhY2hlZEhvc3QodGhpcyk7XG4gICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXJSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KHBvcnRhbC50ZW1wbGF0ZVJlZik7XG4gICAgICAgIHRoaXMuc2V0RGlzcG9zZUZuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl92aWV3Q29udGFpbmVyUmVmLmNsZWFyKCk7IH0pO1xuICAgICAgICAvLyBUT0RPKGplbGJvdXJuKTogcmV0dXJuIGxvY2FscyBmcm9tIHZpZXdcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoKTtcbiAgICB9O1xuICAgIC8qKiBEZXRhdGNoZXMgdGhlIGN1cnJlbnRseSBhdHRhY2hlZCBQb3J0YWwgKGlmIHRoZXJlIGlzIG9uZSkgYW5kIGF0dGFjaGVzIHRoZSBnaXZlbiBQb3J0YWwuICovXG4gICAgUG9ydGFsSG9zdERpcmVjdGl2ZS5wcm90b3R5cGUuX3JlcGxhY2VBdHRhY2hlZFBvcnRhbCA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoKHApO1xuICAgICAgICAgICAgdGhpcy5fcG9ydGFsID0gcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9ydGFsSG9zdERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUkNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW3BvcnRhbEhvc3RdJyxcbiAgICAgICAgICAgIGlucHV0czogWydwb3J0YWw6IHBvcnRhbEhvc3QnXVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5Db21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIF9hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZl0pXG4gICAgXSwgUG9ydGFsSG9zdERpcmVjdGl2ZSk7XG4gICAgcmV0dXJuIFBvcnRhbEhvc3REaXJlY3RpdmU7XG59KEJhc2VQb3J0YWxIb3N0KSk7XG52YXIgUG9ydGFsTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb3J0YWxNb2R1bGUoKSB7XG4gICAgfVxuICAgIFBvcnRhbE1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IFBvcnRhbE1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFBvcnRhbE1vZHVsZSA9IF9fZGVjb3JhdGUkNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgZXhwb3J0czogW1RlbXBsYXRlUG9ydGFsRGlyZWN0aXZlLCBQb3J0YWxIb3N0RGlyZWN0aXZlXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1RlbXBsYXRlUG9ydGFsRGlyZWN0aXZlLCBQb3J0YWxIb3N0RGlyZWN0aXZlXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgUG9ydGFsTW9kdWxlKTtcbiAgICByZXR1cm4gUG9ydGFsTW9kdWxlO1xufSgpKTtcblxuLyoqXG4gKiBPdmVybGF5U3RhdGUgaXMgYSBiYWcgb2YgdmFsdWVzIGZvciBlaXRoZXIgdGhlIGluaXRpYWwgY29uZmlndXJhdGlvbiBvciBjdXJyZW50IHN0YXRlIG9mIGFuXG4gKiBvdmVybGF5LlxuICovXG52YXIgT3ZlcmxheVN0YXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPdmVybGF5U3RhdGUoKSB7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBvdmVybGF5IGhhcyBhIGJhY2tkcm9wLiAqL1xuICAgICAgICB0aGlzLmhhc0JhY2tkcm9wID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBPdmVybGF5U3RhdGU7XG59KCkpO1xuXG52YXIgX19leHRlbmRzJDQgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBIFBvcnRhbEhvc3QgZm9yIGF0dGFjaGluZyBwb3J0YWxzIHRvIGFuIGFyYml0cmFyeSBET00gZWxlbWVudCBvdXRzaWRlIG9mIHRoZSBBbmd1bGFyXG4gKiBhcHBsaWNhdGlvbiBjb250ZXh0LlxuICpcbiAqIFRoaXMgaXMgdGhlIG9ubHkgcGFydCBvZiB0aGUgcG9ydGFsIGNvcmUgdGhhdCBkaXJlY3RseSB0b3VjaGVzIHRoZSBET00uXG4gKi9cbnZhciBEb21Qb3J0YWxIb3N0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkNChEb21Qb3J0YWxIb3N0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERvbVBvcnRhbEhvc3QoX2hvc3REb21FbGVtZW50LCBfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9ob3N0RG9tRWxlbWVudCA9IF9ob3N0RG9tRWxlbWVudDtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICB9XG4gICAgLyoqIEF0dGFjaCB0aGUgZ2l2ZW4gQ29tcG9uZW50UG9ydGFsIHRvIERPTSBlbGVtZW50IHVzaW5nIHRoZSBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIuICovXG4gICAgRG9tUG9ydGFsSG9zdC5wcm90b3R5cGUuYXR0YWNoQ29tcG9uZW50UG9ydGFsID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICBpZiAocG9ydGFsLnZpZXdDb250YWluZXJSZWYgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1kQ29tcG9uZW50UG9ydGFsQXR0YWNoZWRUb0RvbVdpdGhvdXRPcmlnaW5FcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wb25lbnRGYWN0b3J5ID0gdGhpcy5fY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KHBvcnRhbC5jb21wb25lbnQpO1xuICAgICAgICB2YXIgcmVmID0gcG9ydGFsLnZpZXdDb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KGNvbXBvbmVudEZhY3RvcnksIHBvcnRhbC52aWV3Q29udGFpbmVyUmVmLmxlbmd0aCwgcG9ydGFsLmluamVjdG9yIHx8IHBvcnRhbC52aWV3Q29udGFpbmVyUmVmLnBhcmVudEluamVjdG9yKTtcbiAgICAgICAgdmFyIGhvc3RWaWV3ID0gcmVmLmhvc3RWaWV3O1xuICAgICAgICB0aGlzLl9ob3N0RG9tRWxlbWVudC5hcHBlbmRDaGlsZChob3N0Vmlldy5yb290Tm9kZXNbMF0pO1xuICAgICAgICB0aGlzLnNldERpc3Bvc2VGbihmdW5jdGlvbiAoKSB7IHJldHVybiByZWYuZGVzdHJveSgpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICB9O1xuICAgIERvbVBvcnRhbEhvc3QucHJvdG90eXBlLmF0dGFjaFRlbXBsYXRlUG9ydGFsID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdmlld0NvbnRhaW5lciA9IHBvcnRhbC52aWV3Q29udGFpbmVyUmVmO1xuICAgICAgICB2YXIgdmlld1JlZiA9IHZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHBvcnRhbC50ZW1wbGF0ZVJlZik7XG4gICAgICAgIHZpZXdSZWYucm9vdE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHJvb3ROb2RlKSB7IHJldHVybiBfdGhpcy5faG9zdERvbUVsZW1lbnQuYXBwZW5kQ2hpbGQocm9vdE5vZGUpOyB9KTtcbiAgICAgICAgdGhpcy5zZXREaXNwb3NlRm4oKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHZpZXdDb250YWluZXIuaW5kZXhPZih2aWV3UmVmKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgICAgIHZpZXdDb250YWluZXIucmVtb3ZlKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBUT0RPKGplbGJvdXJuKTogUmV0dXJuIGxvY2FscyBmcm9tIHZpZXcuXG4gICAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgfTtcbiAgICBEb21Qb3J0YWxIb3N0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2hvc3REb21FbGVtZW50LnBhcmVudE5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5faG9zdERvbUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9ob3N0RG9tRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEb21Qb3J0YWxIb3N0O1xufShCYXNlUG9ydGFsSG9zdCkpO1xuXG4vKipcbiAqIFJlZmVyZW5jZSB0byBhbiBvdmVybGF5IHRoYXQgaGFzIGJlZW4gY3JlYXRlZCB3aXRoIHRoZSBPdmVybGF5IHNlcnZpY2UuXG4gKiBVc2VkIHRvIG1hbmlwdWxhdGUgb3IgZGlzcG9zZSBvZiBzYWlkIG92ZXJsYXkuXG4gKi9cbnZhciBPdmVybGF5UmVmID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPdmVybGF5UmVmKF9wb3J0YWxIb3N0LCBfcGFuZSwgX3N0YXRlKSB7XG4gICAgICAgIHRoaXMuX3BvcnRhbEhvc3QgPSBfcG9ydGFsSG9zdDtcbiAgICAgICAgdGhpcy5fcGFuZSA9IF9wYW5lO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IF9zdGF0ZTtcbiAgICAgICAgdGhpcy5fYmFja2Ryb3BFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYmFja2Ryb3BDbGljayA9IG5ldyByeGpzX1N1YmplY3QuU3ViamVjdCgpO1xuICAgIH1cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5oYXNCYWNrZHJvcCkge1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoQmFja2Ryb3AoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXR0YWNoUmVzdWx0ID0gdGhpcy5fcG9ydGFsSG9zdC5hdHRhY2gocG9ydGFsKTtcbiAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICByZXR1cm4gYXR0YWNoUmVzdWx0O1xuICAgIH07XG4gICAgT3ZlcmxheVJlZi5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kZXRhdGNoQmFja2Ryb3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcnRhbEhvc3QuZGV0YWNoKCk7XG4gICAgfTtcbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kZXRhdGNoQmFja2Ryb3AoKTtcbiAgICAgICAgdGhpcy5fcG9ydGFsSG9zdC5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS5oYXNBdHRhY2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcnRhbEhvc3QuaGFzQXR0YWNoZWQoKTtcbiAgICB9O1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLmJhY2tkcm9wQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYWNrZHJvcENsaWNrLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gICAgLyoqIEdldHMgdGhlIGN1cnJlbnQgc3RhdGUgY29uZmlnIG9mIHRoZSBvdmVybGF5LiAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfTtcbiAgICAvKiogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgYmFzZWQgb24gdGhlIHBvc2l0aW9uIHN0cmF0ZWd5LiAqL1xuICAgIE92ZXJsYXlSZWYucHJvdG90eXBlLnVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUucG9zaXRpb25TdHJhdGVneSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUucG9zaXRpb25TdHJhdGVneS5hcHBseSh0aGlzLl9wYW5lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEF0dGFjaGVzIGEgYmFja2Ryb3AgZm9yIHRoaXMgb3ZlcmxheS4gKi9cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS5fYXR0YWNoQmFja2Ryb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2JhY2tkcm9wRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9iYWNrZHJvcEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbWQtb3ZlcmxheS1iYWNrZHJvcCcpO1xuICAgICAgICB0aGlzLl9wYW5lLnBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fYmFja2Ryb3BFbGVtZW50KTtcbiAgICAgICAgLy8gRm9yd2FyZCBiYWNrZHJvcCBjbGlja3Mgc3VjaCB0aGF0IHRoZSBjb25zdW1lciBvZiB0aGUgb3ZlcmxheSBjYW4gcGVyZm9ybSB3aGF0ZXZlclxuICAgICAgICAvLyBhY3Rpb24gZGVzaXJlZCB3aGVuIHN1Y2ggYSBjbGljayBvY2N1cnMgKHVzdWFsbHkgY2xvc2luZyB0aGUgb3ZlcmxheSkuXG4gICAgICAgIHRoaXMuX2JhY2tkcm9wRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9iYWNrZHJvcENsaWNrLm5leHQobnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBZGQgY2xhc3MgdG8gZmFkZS1pbiB0aGUgYmFja2Ryb3AgYWZ0ZXIgb25lIGZyYW1lLlxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2JhY2tkcm9wRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdtZC1vdmVybGF5LWJhY2tkcm9wLXNob3dpbmcnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiogRGV0YWNoZXMgdGhlIGJhY2tkcm9wIChpZiBhbnkpIGFzc29jaWF0ZWQgd2l0aCB0aGUgb3ZlcmxheS4gKi9cbiAgICBPdmVybGF5UmVmLnByb3RvdHlwZS5fZGV0YXRjaEJhY2tkcm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYmFja2Ryb3BUb0RldGFjaCA9IHRoaXMuX2JhY2tkcm9wRWxlbWVudDtcbiAgICAgICAgaWYgKGJhY2tkcm9wVG9EZXRhY2gpIHtcbiAgICAgICAgICAgIGJhY2tkcm9wVG9EZXRhY2guY2xhc3NMaXN0LnJlbW92ZSgnbWQtb3ZlcmxheS1iYWNrZHJvcC1zaG93aW5nJyk7XG4gICAgICAgICAgICBiYWNrZHJvcFRvRGV0YWNoLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgYmFja2Ryb3BUb0RldGFjaC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJhY2tkcm9wVG9EZXRhY2gpO1xuICAgICAgICAgICAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgYSBuZXcgcG9ydGFsIGhhcyBiZWVuIGF0dGFjaGVkIHRvIHRoaXMgb3ZlcmxheSBzaW5jZSB3ZSBzdGFydGVkXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZpbmcgdGhlIGJhY2tkcm9wLiBJZiB0aGF0IGlzIHRoZSBjYXNlLCBvbmx5IGNsZWFyIHRoZSBiYWNrZHJvcCByZWZlcmVuY2UgaWYgaXRcbiAgICAgICAgICAgICAgICAvLyBpcyBzdGlsbCB0aGUgc2FtZSBpbnN0YW5jZSB0aGF0IHdlIHN0YXJ0ZWQgdG8gcmVtb3ZlLlxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fYmFja2Ryb3BFbGVtZW50ID09IGJhY2tkcm9wVG9EZXRhY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2JhY2tkcm9wRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBPdmVybGF5UmVmO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkOCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ4ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIFNpbXBsZSB1dGlsaXR5IGZvciBnZXR0aW5nIHRoZSBib3VuZHMgb2YgdGhlIGJyb3dzZXIgdmlld3BvcnQuXG4gKiBUT0RPOiBpbnRlcm5hbFxuICovXG52YXIgVmlld3BvcnRSdWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlld3BvcnRSdWxlcigpIHtcbiAgICB9XG4gICAgLy8gVE9ETyhqZWxib3Vybik6IGNhY2hlIHRoZSBkb2N1bWVudCdzIGJvdW5kaW5nIHJlY3QgYW5kIG9ubHkgdXBkYXRlIGl0IHdoZW4gdGhlIHdpbmRvd1xuICAgIC8vIGlzIHJlc2l6ZWQgKGRlYm91bmNlZCkuXG4gICAgLyoqIEdldHMgYSBDbGllbnRSZWN0IGZvciB0aGUgdmlld3BvcnQncyBib3VuZHMuICovXG4gICAgVmlld3BvcnRSdWxlci5wcm90b3R5cGUuZ2V0Vmlld3BvcnRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBVc2UgdGhlIGRvY3VtZW50IGVsZW1lbnQncyBib3VuZGluZyByZWN0IHJhdGhlciB0aGFuIHRoZSB3aW5kb3cgc2Nyb2xsIHByb3BlcnRpZXNcbiAgICAgICAgLy8gKGUuZy4gcGFnZVlPZmZzZXQsIHNjcm9sbFkpIGR1ZSB0byBpbiBpc3N1ZSBpbiBDaHJvbWUgYW5kIElFIHdoZXJlIHdpbmRvdyBzY3JvbGxcbiAgICAgICAgLy8gcHJvcGVydGllcyBhbmQgY2xpZW50IGNvb3JkaW5hdGVzIChib3VuZGluZ0NsaWVudFJlY3QsIGNsaWVudFgvWSwgZXRjLikgYXJlIGluIGRpZmZlcmVudFxuICAgICAgICAvLyBjb25jZXB0dWFsIHZpZXdwb3J0cy4gVW5kZXIgbW9zdCBjaXJjdW1zdGFuY2VzIHRoZXNlIHZpZXdwb3J0cyBhcmUgZXF1aXZhbGVudCwgYnV0IHRoZXlcbiAgICAgICAgLy8gY2FuIGRpc2FncmVlIHdoZW4gdGhlIHBhZ2UgaXMgcGluY2gtem9vbWVkIChvbiBkZXZpY2VzIHRoYXQgc3VwcG9ydCB0b3VjaCkuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00ODkyMDYjYzRcbiAgICAgICAgLy8gV2UgdXNlIHRoZSBkb2N1bWVudEVsZW1lbnQgaW5zdGVhZCBvZiB0aGUgYm9keSBiZWNhdXNlLCBieSBkZWZhdWx0ICh3aXRob3V0IGEgY3NzIHJlc2V0KVxuICAgICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZ2l2ZSB0aGUgZG9jdW1lbnQgYm9keSBhbiA4cHggbWFyZ2luLCB3aGljaCBpcyBub3QgaW5jbHVkZWQgaW5cbiAgICAgICAgLy8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuXG4gICAgICAgIHZhciBkb2N1bWVudFJlY3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBzY3JvbGxQb3NpdGlvbiA9IHRoaXMuZ2V0Vmlld3BvcnRTY3JvbGxQb3NpdGlvbihkb2N1bWVudFJlY3QpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICB2YXIgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogc2Nyb2xsUG9zaXRpb24udG9wLFxuICAgICAgICAgICAgbGVmdDogc2Nyb2xsUG9zaXRpb24ubGVmdCxcbiAgICAgICAgICAgIGJvdHRvbTogc2Nyb2xsUG9zaXRpb24udG9wICsgaGVpZ2h0LFxuICAgICAgICAgICAgcmlnaHQ6IHNjcm9sbFBvc2l0aW9uLmxlZnQgKyB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgKHRvcCwgbGVmdCkgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydC5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRSZWN0XG4gICAgICovXG4gICAgVmlld3BvcnRSdWxlci5wcm90b3R5cGUuZ2V0Vmlld3BvcnRTY3JvbGxQb3NpdGlvbiA9IGZ1bmN0aW9uIChkb2N1bWVudFJlY3QpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50UmVjdCA9PT0gdm9pZCAwKSB7IGRvY3VtZW50UmVjdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgfVxuICAgICAgICAvLyBUaGUgdG9wLWxlZnQtY29ybmVyIG9mIHRoZSB2aWV3cG9ydCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGRvY3VtZW50XG4gICAgICAgIC8vIGJvZHksIG5vcm1hbGx5IGp1c3QgKHNjcm9sbExlZnQsIHNjcm9sbFRvcCkuIEhvd2V2ZXIsIENocm9tZSBhbmQgRmlyZWZveCBkaXNhZ3JlZSBhYm91dFxuICAgICAgICAvLyB3aGV0aGVyIGBkb2N1bWVudC5ib2R5YCBvciBgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50YCBpcyB0aGUgc2Nyb2xsZWQgZWxlbWVudCwgc28gcmVhZGluZ1xuICAgICAgICAvLyBgc2Nyb2xsVG9wYCBhbmQgYHNjcm9sbExlZnRgIGlzIGluY29uc2lzdGVudC4gSG93ZXZlciwgdXNpbmcgdGhlIGJvdW5kaW5nIHJlY3Qgb2ZcbiAgICAgICAgLy8gYGRvY3VtZW50LmRvY3VtZW50RWxlbWVudGAgd29ya3MgY29uc2lzdGVudGx5LCB3aGVyZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCB2YWx1ZXMgd2lsbFxuICAgICAgICAvLyBlcXVhbCBuZWdhdGl2ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAgICB2YXIgdG9wID0gZG9jdW1lbnRSZWN0LnRvcCA8IDAgJiYgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgPT0gMCA/XG4gICAgICAgICAgICAtZG9jdW1lbnRSZWN0LnRvcCA6XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcbiAgICAgICAgdmFyIGxlZnQgPSBkb2N1bWVudFJlY3QubGVmdCA8IDAgJiYgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0ID09IDAgP1xuICAgICAgICAgICAgLWRvY3VtZW50UmVjdC5sZWZ0IDpcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0b3AsIGxlZnQ6IGxlZnQgfTtcbiAgICB9O1xuICAgIFZpZXdwb3J0UnVsZXIgPSBfX2RlY29yYXRlJDgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBWaWV3cG9ydFJ1bGVyKTtcbiAgICByZXR1cm4gVmlld3BvcnRSdWxlcjtcbn0oKSk7XG5cbi8qKlxuICogQXBwbGllcyBhIENTUyB0cmFuc2Zvcm0gdG8gYW4gZWxlbWVudCwgaW5jbHVkaW5nIGJyb3dzZXItcHJlZml4ZWQgcHJvcGVydGllcy5cbiAqIEBwYXJhbSBlbGVtZW50XG4gKiBAcGFyYW0gdHJhbnNmb3JtVmFsdWVcbiAqL1xuZnVuY3Rpb24gYXBwbHlDc3NUcmFuc2Zvcm0oZWxlbWVudCwgdHJhbnNmb3JtVmFsdWUpIHtcbiAgICAvLyBJdCdzIGltcG9ydGFudCB0byB0cmltIHRoZSByZXN1bHQsIGJlY2F1c2UgdGhlIGJyb3dzZXIgd2lsbCBpZ25vcmUgdGhlIHNldCBvcGVyYXRpb25cbiAgICAvLyBpZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZS5cbiAgICB2YXIgdmFsdWUgPSB0cmFuc2Zvcm1WYWx1ZS50cmltKCk7XG4gICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSB2YWx1ZTtcbiAgICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHZhbHVlO1xufVxuXG4vKiogVGhlIHBvaW50cyBvZiB0aGUgb3JpZ2luIGVsZW1lbnQgYW5kIHRoZSBvdmVybGF5IGVsZW1lbnQgdG8gY29ubmVjdC4gKi9cbnZhciBDb25uZWN0aW9uUG9zaXRpb25QYWlyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25uZWN0aW9uUG9zaXRpb25QYWlyKG9yaWdpbiwgb3ZlcmxheSkge1xuICAgICAgICB0aGlzLm9yaWdpblggPSBvcmlnaW4ub3JpZ2luWDtcbiAgICAgICAgdGhpcy5vcmlnaW5ZID0gb3JpZ2luLm9yaWdpblk7XG4gICAgICAgIHRoaXMub3ZlcmxheVggPSBvdmVybGF5Lm92ZXJsYXlYO1xuICAgICAgICB0aGlzLm92ZXJsYXlZID0gb3ZlcmxheS5vdmVybGF5WTtcbiAgICB9XG4gICAgcmV0dXJuIENvbm5lY3Rpb25Qb3NpdGlvblBhaXI7XG59KCkpO1xuXG4vKipcbiAqIEEgc3RyYXRlZ3kgZm9yIHBvc2l0aW9uaW5nIG92ZXJsYXlzLiBVc2luZyB0aGlzIHN0cmF0ZWd5LCBhbiBvdmVybGF5IGlzIGdpdmVuIGFuXG4gKiBpbXBsaWN0IHBvc2l0aW9uIHJlbGF0aXZlIHNvbWUgb3JpZ2luIGVsZW1lbnQuIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBpcyBkZWZpbmVkIGluIHRlcm1zIG9mXG4gKiBhIHBvaW50IG9uIHRoZSBvcmlnaW4gZWxlbWVudCB0aGF0IGlzIGNvbm5lY3RlZCB0byBhIHBvaW50IG9uIHRoZSBvdmVybGF5IGVsZW1lbnQuIEZvciBleGFtcGxlLFxuICogYSBiYXNpYyBkcm9wZG93biBpcyBjb25uZWN0aW5nIHRoZSBib3R0b20tbGVmdCBjb3JuZXIgb2YgdGhlIG9yaWdpbiB0byB0aGUgdG9wLWxlZnQgY29ybmVyXG4gKiBvZiB0aGUgb3ZlcmxheS5cbiAqL1xudmFyIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3koX2Nvbm5lY3RlZFRvLCBfb3JpZ2luUG9zLCBfb3ZlcmxheVBvcywgX3ZpZXdwb3J0UnVsZXIpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkVG8gPSBfY29ubmVjdGVkVG87XG4gICAgICAgIHRoaXMuX29yaWdpblBvcyA9IF9vcmlnaW5Qb3M7XG4gICAgICAgIHRoaXMuX292ZXJsYXlQb3MgPSBfb3ZlcmxheVBvcztcbiAgICAgICAgdGhpcy5fdmlld3BvcnRSdWxlciA9IF92aWV3cG9ydFJ1bGVyO1xuICAgICAgICAvLyBUT0RPKGplbGJvdXJuKTogc2V0IFJUTCB0byB0aGUgYWN0dWFsIHZhbHVlIGZyb20gdGhlIGFwcC5cbiAgICAgICAgLyoqIFdoZXRoZXIgdGhlIHdlJ3JlIGRlYWxpbmcgd2l0aCBhbiBSVEwgY29udGV4dCAqL1xuICAgICAgICB0aGlzLl9pc1J0bCA9IGZhbHNlO1xuICAgICAgICAvKiogT3JkZXJlZCBsaXN0IG9mIHByZWZlcnJlZCBwb3NpdGlvbnMsIGZyb20gbW9zdCB0byBsZWFzdCBkZXNpcmFibGUuICovXG4gICAgICAgIHRoaXMuX3ByZWZlcnJlZFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLl9vcmlnaW4gPSB0aGlzLl9jb25uZWN0ZWRUby5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLndpdGhGYWxsYmFja1Bvc2l0aW9uKF9vcmlnaW5Qb3MsIF9vdmVybGF5UG9zKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLCBcInBvc2l0aW9uc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWZlcnJlZFBvc2l0aW9ucztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIG92ZXJsYXkgZWxlbWVudCwgdXNpbmcgd2hpY2hldmVyIHByZWZlcnJlZCBwb3NpdGlvbiByZWxhdGl2ZVxuICAgICAqIHRvIHRoZSBvcmlnaW4gZml0cyBvbi1zY3JlZW4uXG4gICAgICogVE9ETzogaW50ZXJuYWxcbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdGhlIGJvdW5kaW5nIHJlY3RzIGZvciB0aGUgb3JpZ2luIGFuZCB0aGUgb3ZlcmxheSB0byBkZXRlcm1pbmUgaG93IHRvIHBvc2l0aW9uXG4gICAgICAgIC8vIHRoZSBvdmVybGF5IHJlbGF0aXZlIHRvIHRoZSBvcmlnaW4uXG4gICAgICAgIHZhciBvcmlnaW5SZWN0ID0gdGhpcy5fb3JpZ2luLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgb3ZlcmxheVJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAvLyBXZSB1c2UgdGhlIHZpZXdwb3J0IHJlY3QgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBwb3NpdGlvbiB3b3VsZCBnbyBvZmYtc2NyZWVuLlxuICAgICAgICB2YXIgdmlld3BvcnRSZWN0ID0gdGhpcy5fdmlld3BvcnRSdWxlci5nZXRWaWV3cG9ydFJlY3QoKTtcbiAgICAgICAgdmFyIGZpcnN0T3ZlcmxheVBvaW50ID0gbnVsbDtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBwbGFjZSB0aGUgb3ZlcmxheSBpbiB0aGUgZmlyc3Qgb2YgdGhlIHByZWZlcnJlZCBwb3NpdGlvbnMgc3VjaCB0aGF0IHRoZVxuICAgICAgICAvLyBvdmVybGF5IGZpdHMgb24tc2NyZWVuLlxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fcHJlZmVycmVkUG9zaXRpb25zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHBvcyA9IF9hW19pXTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgKHgsIHkpIHBvaW50IG9mIGNvbm5lY3Rpb24gb24gdGhlIG9yaWdpbiwgYW5kIHRoZW4gdXNlIHRoYXQgdG8gZ2V0IHRoZVxuICAgICAgICAgICAgLy8gKHRvcCwgbGVmdCkgY29vcmRpbmF0ZSBmb3IgdGhlIG92ZXJsYXkgYXQgYHBvc2AuXG4gICAgICAgICAgICB2YXIgb3JpZ2luUG9pbnQgPSB0aGlzLl9nZXRPcmlnaW5Db25uZWN0aW9uUG9pbnQob3JpZ2luUmVjdCwgcG9zKTtcbiAgICAgICAgICAgIHZhciBvdmVybGF5UG9pbnQgPSB0aGlzLl9nZXRPdmVybGF5UG9pbnQob3JpZ2luUG9pbnQsIG92ZXJsYXlSZWN0LCBwb3MpO1xuICAgICAgICAgICAgZmlyc3RPdmVybGF5UG9pbnQgPSBmaXJzdE92ZXJsYXlQb2ludCB8fCBvdmVybGF5UG9pbnQ7XG4gICAgICAgICAgICAvLyBJZiB0aGUgb3ZlcmxheSBpbiB0aGUgY2FsY3VsYXRlZCBwb3NpdGlvbiBmaXRzIG9uLXNjcmVlbiwgcHV0IGl0IHRoZXJlIGFuZCB3ZSdyZSBkb25lLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3dpbGxPdmVybGF5Rml0V2l0aGluVmlld3BvcnQob3ZlcmxheVBvaW50LCBvdmVybGF5UmVjdCwgdmlld3BvcnRSZWN0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEVsZW1lbnRQb3NpdGlvbihlbGVtZW50LCBvdmVybGF5UG9pbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhqZWxib3Vybik6IGZhbGxiYWNrIGJlaGF2aW9yIGZvciB3aGVuIG5vbmUgb2YgdGhlIHByZWZlcnJlZCBwb3NpdGlvbnMgZml0IG9uLXNjcmVlbi5cbiAgICAgICAgLy8gRm9yIG5vdywganVzdCBzdGljayBpdCBpbiB0aGUgZmlyc3QgcG9zaXRpb24gYW5kIGxldCBpdCBnbyBvZmYtc2NyZWVuLlxuICAgICAgICB0aGlzLl9zZXRFbGVtZW50UG9zaXRpb24oZWxlbWVudCwgZmlyc3RPdmVybGF5UG9pbnQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH07XG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUud2l0aEZhbGxiYWNrUG9zaXRpb24gPSBmdW5jdGlvbiAob3JpZ2luUG9zLCBvdmVybGF5UG9zKSB7XG4gICAgICAgIHRoaXMuX3ByZWZlcnJlZFBvc2l0aW9ucy5wdXNoKG5ldyBDb25uZWN0aW9uUG9zaXRpb25QYWlyKG9yaWdpblBvcywgb3ZlcmxheVBvcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhvcml6b250YWwgKHgpIFwic3RhcnRcIiBkaW1lbnNpb24gYmFzZWQgb24gd2hldGhlciB0aGUgb3ZlcmxheSBpcyBpbiBhbiBSVEwgY29udGV4dC5cbiAgICAgKiBAcGFyYW0gcmVjdFxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLl9nZXRTdGFydFggPSBmdW5jdGlvbiAocmVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNSdGwgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaG9yaXpvbnRhbCAoeCkgXCJlbmRcIiBkaW1lbnNpb24gYmFzZWQgb24gd2hldGhlciB0aGUgb3ZlcmxheSBpcyBpbiBhbiBSVEwgY29udGV4dC5cbiAgICAgKiBAcGFyYW0gcmVjdFxuICAgICAqL1xuICAgIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLl9nZXRFbmRYID0gZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUnRsID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlICh4LCB5KSBjb29yZGluYXRlIG9mIGEgY29ubmVjdGlvbiBwb2ludCBvbiB0aGUgb3JpZ2luIGJhc2VkIG9uIGEgcmVsYXRpdmUgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIG9yaWdpblJlY3RcbiAgICAgKiBAcGFyYW0gcG9zXG4gICAgICovXG4gICAgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuX2dldE9yaWdpbkNvbm5lY3Rpb25Qb2ludCA9IGZ1bmN0aW9uIChvcmlnaW5SZWN0LCBwb3MpIHtcbiAgICAgICAgdmFyIG9yaWdpblN0YXJ0WCA9IHRoaXMuX2dldFN0YXJ0WChvcmlnaW5SZWN0KTtcbiAgICAgICAgdmFyIG9yaWdpbkVuZFggPSB0aGlzLl9nZXRFbmRYKG9yaWdpblJlY3QpO1xuICAgICAgICB2YXIgeDtcbiAgICAgICAgaWYgKHBvcy5vcmlnaW5YID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB4ID0gb3JpZ2luU3RhcnRYICsgKG9yaWdpblJlY3Qud2lkdGggLyAyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHggPSBwb3Mub3JpZ2luWCA9PSAnc3RhcnQnID8gb3JpZ2luU3RhcnRYIDogb3JpZ2luRW5kWDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeTtcbiAgICAgICAgaWYgKHBvcy5vcmlnaW5ZID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB5ID0gb3JpZ2luUmVjdC50b3AgKyAob3JpZ2luUmVjdC5oZWlnaHQgLyAyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHkgPSBwb3Mub3JpZ2luWSA9PSAndG9wJyA/IG9yaWdpblJlY3QudG9wIDogb3JpZ2luUmVjdC5ib3R0b207XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgKHgsIHkpIGNvb3JkaW5hdGUgb2YgdGhlIHRvcC1sZWZ0IGNvcm5lciBvZiB0aGUgb3ZlcmxheSBnaXZlbiBhIGdpdmVuIHBvc2l0aW9uIGFuZFxuICAgICAqIG9yaWdpbiBwb2ludCB0byB3aGljaCB0aGUgb3ZlcmxheSBzaG91bGQgYmUgY29ubmVjdGVkLlxuICAgICAqIEBwYXJhbSBvcmlnaW5Qb2ludFxuICAgICAqIEBwYXJhbSBvdmVybGF5UmVjdFxuICAgICAqIEBwYXJhbSBwb3NcbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5fZ2V0T3ZlcmxheVBvaW50ID0gZnVuY3Rpb24gKG9yaWdpblBvaW50LCBvdmVybGF5UmVjdCwgcG9zKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgKG92ZXJsYXlTdGFydFgsIG92ZXJsYXlTdGFydFkpLCB0aGUgc3RhcnQgb2YgdGhlIHBvdGVudGlhbCBvdmVybGF5IHBvc2l0aW9uXG4gICAgICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW4gcG9pbnQuXG4gICAgICAgIHZhciBvdmVybGF5U3RhcnRYO1xuICAgICAgICBpZiAocG9zLm92ZXJsYXlYID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICBvdmVybGF5U3RhcnRYID0gLW92ZXJsYXlSZWN0LndpZHRoIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG92ZXJsYXlTdGFydFggPSBwb3Mub3ZlcmxheVggPT0gJ3N0YXJ0JyA/IDAgOiAtb3ZlcmxheVJlY3Qud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG92ZXJsYXlTdGFydFk7XG4gICAgICAgIGlmIChwb3Mub3ZlcmxheVkgPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIG92ZXJsYXlTdGFydFkgPSAtb3ZlcmxheVJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG92ZXJsYXlTdGFydFkgPSBwb3Mub3ZlcmxheVkgPT0gJ3RvcCcgPyAwIDogLW92ZXJsYXlSZWN0LmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogb3JpZ2luUG9pbnQueCArIG92ZXJsYXlTdGFydFgsXG4gICAgICAgICAgICB5OiBvcmlnaW5Qb2ludC55ICsgb3ZlcmxheVN0YXJ0WVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBvdmVybGF5IHBvc2l0aW9uZWQgYXQgdGhlIGdpdmVuIHBvaW50IHdpbGwgZml0IG9uLXNjcmVlbi5cbiAgICAgKiBAcGFyYW0gb3ZlcmxheVBvaW50IFRoZSB0b3AtbGVmdCBjb29yZGluYXRlIG9mIHRoZSBvdmVybGF5LlxuICAgICAqIEBwYXJhbSBvdmVybGF5UmVjdCBCb3VuZGluZyByZWN0IG9mIHRoZSBvdmVybGF5LCB1c2VkIHRvIGdldCBpdHMgc2l6ZS5cbiAgICAgKiBAcGFyYW0gdmlld3BvcnRSZWN0IFRoZSBib3VuZGluZyB2aWV3cG9ydC5cbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5fd2lsbE92ZXJsYXlGaXRXaXRoaW5WaWV3cG9ydCA9IGZ1bmN0aW9uIChvdmVybGF5UG9pbnQsIG92ZXJsYXlSZWN0LCB2aWV3cG9ydFJlY3QpIHtcbiAgICAgICAgLy8gVE9ETyhqZWxib3Vybik6IHByb2JhYmx5IGFsc28gd2FudCBzb21lIHNwYWNlIGJldHdlZW4gb3ZlcmxheSBlZGdlIGFuZCB2aWV3cG9ydCBlZGdlLlxuICAgICAgICByZXR1cm4gb3ZlcmxheVBvaW50LnggPj0gdmlld3BvcnRSZWN0LmxlZnQgJiZcbiAgICAgICAgICAgIG92ZXJsYXlQb2ludC54ICsgb3ZlcmxheVJlY3Qud2lkdGggPD0gdmlld3BvcnRSZWN0LnJpZ2h0ICYmXG4gICAgICAgICAgICBvdmVybGF5UG9pbnQueSA+PSB2aWV3cG9ydFJlY3QudG9wICYmXG4gICAgICAgICAgICBvdmVybGF5UG9pbnQueSArIG92ZXJsYXlSZWN0LmhlaWdodCA8PSB2aWV3cG9ydFJlY3QuYm90dG9tO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGh5c2ljYWxseSBwb3NpdGlvbnMgdGhlIG92ZXJsYXkgZWxlbWVudCB0byB0aGUgZ2l2ZW4gY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwYXJhbSBvdmVybGF5UG9pbnRcbiAgICAgKi9cbiAgICBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5fc2V0RWxlbWVudFBvc2l0aW9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIG92ZXJsYXlQb2ludCkge1xuICAgICAgICB2YXIgc2Nyb2xsUG9zID0gdGhpcy5fdmlld3BvcnRSdWxlci5nZXRWaWV3cG9ydFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgICAgIHZhciB4ID0gb3ZlcmxheVBvaW50LnggKyBzY3JvbGxQb3MubGVmdDtcbiAgICAgICAgdmFyIHkgPSBvdmVybGF5UG9pbnQueSArIHNjcm9sbFBvcy50b3A7XG4gICAgICAgIC8vIFRPRE8oamVsYm91cm4pOiB3ZSBkb24ndCB3YW50IHRvIGFsd2F5cyBvdmVyd3JpdGUgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSBoZXJlLFxuICAgICAgICAvLyBiZWNhdXNlIGl0IHdpbGwgbmVlZCB0byBiZSB1c2VkIGZvciBhbmltYXRpb25zLlxuICAgICAgICBhcHBseUNzc1RyYW5zZm9ybShlbGVtZW50LCBcInRyYW5zbGF0ZVgoXCIgKyB4ICsgXCJweCkgdHJhbnNsYXRlWShcIiArIHkgKyBcInB4KVwiKTtcbiAgICB9O1xuICAgIHJldHVybiBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5O1xufSgpKTtcblxuLyoqXG4gKiBBIHN0cmF0ZWd5IGZvciBwb3NpdGlvbmluZyBvdmVybGF5cy4gVXNpbmcgdGhpcyBzdHJhdGVneSwgYW4gb3ZlcmxheSBpcyBnaXZlbiBhblxuICogZXhwbGljaXQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGJyb3dzZXIncyB2aWV3cG9ydC5cbiAqL1xudmFyIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3koKSB7XG4gICAgICAgIHRoaXMuX2Nzc1Bvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5fdG9wID0gJyc7XG4gICAgICAgIHRoaXMuX2JvdHRvbSA9ICcnO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gJyc7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gJyc7XG4gICAgICAgIC8qKiBBcnJheSBvZiBpbmRpdmlkdWFsIGFwcGxpY2F0aW9ucyBvZiB0cmFuc2xhdGVYKCkuIEN1cnJlbnRseSBvbmx5IGZvciBjZW50ZXJpbmcuICovXG4gICAgICAgIHRoaXMuX3RyYW5zbGF0ZVggPSBbXTtcbiAgICAgICAgLyoqIEFycmF5IG9mIGluZGl2aWR1YWwgYXBwbGljYXRpb25zIG9mIHRyYW5zbGF0ZVkoKS4gQ3VycmVudGx5IG9ubHkgZm9yIGNlbnRlcmluZy4gKi9cbiAgICAgICAgdGhpcy5fdHJhbnNsYXRlWSA9IFtdO1xuICAgIH1cbiAgICAvKiogU2V0cyB0aGUgZWxlbWVudCB0byB1c2UgQ1NTIHBvc2l0aW9uOiBmaXhlZCAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmZpeGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jc3NQb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIFNldHMgdGhlIGVsZW1lbnQgdG8gdXNlIENTUyBwb3NpdGlvbjogYWJzb2x1dGUuIFRoaXMgaXMgdGhlIGRlZmF1bHQuICovXG4gICAgR2xvYmFsUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuYWJzb2x1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2Nzc1Bvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogU2V0cyB0aGUgdG9wIHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5LiBDbGVhcnMgYW55IHByZXZpb3VzbHkgc2V0IHZlcnRpY2FsIHBvc2l0aW9uLiAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLnRvcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9ib3R0b20gPSAnJztcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRlWSA9IFtdO1xuICAgICAgICB0aGlzLl90b3AgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogU2V0cyB0aGUgbGVmdCBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheS4gQ2xlYXJzIGFueSBwcmV2aW91c2x5IHNldCBob3Jpem9udGFsIHBvc2l0aW9uLiAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmxlZnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmlnaHQgPSAnJztcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRlWCA9IFtdO1xuICAgICAgICB0aGlzLl9sZWZ0ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIFNldHMgdGhlIGJvdHRvbSBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheS4gQ2xlYXJzIGFueSBwcmV2aW91c2x5IHNldCB2ZXJ0aWNhbCBwb3NpdGlvbi4gKi9cbiAgICBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5ib3R0b20gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdG9wID0gJyc7XG4gICAgICAgIHRoaXMuX3RyYW5zbGF0ZVkgPSBbXTtcbiAgICAgICAgdGhpcy5fYm90dG9tID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIFNldHMgdGhlIHJpZ2h0IHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5LiBDbGVhcnMgYW55IHByZXZpb3VzbHkgc2V0IGhvcml6b250YWwgcG9zaXRpb24uICovXG4gICAgR2xvYmFsUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUucmlnaHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbGVmdCA9ICcnO1xuICAgICAgICB0aGlzLl90cmFuc2xhdGVYID0gW107XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2VudGVycyB0aGUgb3ZlcmxheSBob3Jpem9udGFsbHkgd2l0aCBhbiBvcHRpb25hbCBvZmZzZXQuXG4gICAgICogQ2xlYXJzIGFueSBwcmV2aW91c2x5IHNldCBob3Jpem9udGFsIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kucHJvdG90eXBlLmNlbnRlckhvcml6b250YWxseSA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9ICcwcHgnOyB9XG4gICAgICAgIHRoaXMuX2xlZnQgPSAnNTAlJztcbiAgICAgICAgdGhpcy5fcmlnaHQgPSAnJztcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRlWCA9IFsnLTUwJScsIG9mZnNldF07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2VudGVycyB0aGUgb3ZlcmxheSB2ZXJ0aWNhbGx5IHdpdGggYW4gb3B0aW9uYWwgb2Zmc2V0LlxuICAgICAqIENsZWFycyBhbnkgcHJldmlvdXNseSBzZXQgdmVydGljYWwgcG9zaXRpb24uXG4gICAgICovXG4gICAgR2xvYmFsUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuY2VudGVyVmVydGljYWxseSA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7IG9mZnNldCA9ICcwcHgnOyB9XG4gICAgICAgIHRoaXMuX3RvcCA9ICc1MCUnO1xuICAgICAgICB0aGlzLl9ib3R0b20gPSAnJztcbiAgICAgICAgdGhpcy5fdHJhbnNsYXRlWSA9IFsnLTUwJScsIG9mZnNldF07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIHBvc2l0aW9uIHRvIHRoZSBlbGVtZW50LlxuICAgICAqIFRPRE86IGludGVybmFsXG4gICAgICovXG4gICAgR2xvYmFsUG9zaXRpb25TdHJhdGVneS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gdGhpcy5fY3NzUG9zaXRpb247XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gdGhpcy5fdG9wO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSB0aGlzLl9sZWZ0O1xuICAgICAgICBlbGVtZW50LnN0eWxlLmJvdHRvbSA9IHRoaXMuX2JvdHRvbTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5yaWdodCA9IHRoaXMuX3JpZ2h0O1xuICAgICAgICAvLyBUT0RPKGplbGJvdXJuKTogd2UgZG9uJ3Qgd2FudCB0byBhbHdheXMgb3ZlcndyaXRlIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHkgaGVyZSxcbiAgICAgICAgLy8gYmVjYXVzZSBpdCB3aWxsIG5lZWQgdG8gYmUgdXNlZCBmb3IgYW5pbWF0aW9ucy5cbiAgICAgICAgdmFyIHRyYW5sYXRlWCA9IHRoaXMuX3JlZHVjZVRyYW5zbGF0ZVZhbHVlcygndHJhbnNsYXRlWCcsIHRoaXMuX3RyYW5zbGF0ZVgpO1xuICAgICAgICB2YXIgdHJhbnNsYXRlWSA9IHRoaXMuX3JlZHVjZVRyYW5zbGF0ZVZhbHVlcygndHJhbnNsYXRlWScsIHRoaXMuX3RyYW5zbGF0ZVkpO1xuICAgICAgICBhcHBseUNzc1RyYW5zZm9ybShlbGVtZW50LCB0cmFubGF0ZVggKyBcIiBcIiArIHRyYW5zbGF0ZVkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH07XG4gICAgLyoqIFJlZHVjZSBhIGxpc3Qgb2YgdHJhbnNsYXRlIHZhbHVlcyB0byBhIHN0cmluZyB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHkgKi9cbiAgICBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5LnByb3RvdHlwZS5fcmVkdWNlVHJhbnNsYXRlVmFsdWVzID0gZnVuY3Rpb24gKHRyYW5zbGF0ZUZuLCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuICh0cmFuc2xhdGVGbiArIFwiKFwiICsgdCArIFwiKVwiKTsgfSkuam9pbignICcpO1xuICAgIH07XG4gICAgcmV0dXJuIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3k7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQ3ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDcgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKiBCdWlsZGVyIGZvciBvdmVybGF5IHBvc2l0aW9uIHN0cmF0ZWd5LiAqL1xudmFyIE92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIoX3ZpZXdwb3J0UnVsZXIpIHtcbiAgICAgICAgdGhpcy5fdmlld3BvcnRSdWxlciA9IF92aWV3cG9ydFJ1bGVyO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlcyBhIGdsb2JhbCBwb3NpdGlvbiBzdHJhdGVneS4gKi9cbiAgICBPdmVybGF5UG9zaXRpb25CdWlsZGVyLnByb3RvdHlwZS5nbG9iYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgR2xvYmFsUG9zaXRpb25TdHJhdGVneSgpO1xuICAgIH07XG4gICAgLyoqIENyZWF0ZXMgYSByZWxhdGl2ZSBwb3NpdGlvbiBzdHJhdGVneS4gKi9cbiAgICBPdmVybGF5UG9zaXRpb25CdWlsZGVyLnByb3RvdHlwZS5jb25uZWN0ZWRUbyA9IGZ1bmN0aW9uIChlbGVtZW50UmVmLCBvcmlnaW5Qb3MsIG92ZXJsYXlQb3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5KGVsZW1lbnRSZWYsIG9yaWdpblBvcywgb3ZlcmxheVBvcywgdGhpcy5fdmlld3BvcnRSdWxlcik7XG4gICAgfTtcbiAgICBPdmVybGF5UG9zaXRpb25CdWlsZGVyID0gX19kZWNvcmF0ZSQ3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW1ZpZXdwb3J0UnVsZXJdKVxuICAgIF0sIE92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIpO1xuICAgIHJldHVybiBPdmVybGF5UG9zaXRpb25CdWlsZGVyO1xufSgpKTtcblxuLyoqXG4gKiBUaGUgT3ZlcmxheUNvbnRhaW5lciBpcyB0aGUgY29udGFpbmVyIGluIHdoaWNoIGFsbCBvdmVybGF5cyB3aWxsIGxvYWQuXG4gKiBJdCBzaG91bGQgYmUgcHJvdmlkZWQgaW4gdGhlIHJvb3QgY29tcG9uZW50IHRvIGVuc3VyZSBpdCBpcyBwcm9wZXJseSBzaGFyZWQuXG4gKi9cbnZhciBPdmVybGF5Q29udGFpbmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPdmVybGF5Q29udGFpbmVyKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBvdmVybGF5IGNvbnRhaW5lciBlbGVtZW50LiAgSXQgd2lsbCBsYXppbHlcbiAgICAgKiBjcmVhdGUgdGhlIGVsZW1lbnQgdGhlIGZpcnN0IHRpbWUgIGl0IGlzIGNhbGxlZCB0byBmYWNpbGl0YXRlIHVzaW5nXG4gICAgICogdGhlIGNvbnRhaW5lciBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMuXG4gICAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSB0aGUgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKi9cbiAgICBPdmVybGF5Q29udGFpbmVyLnByb3RvdHlwZS5nZXRDb250YWluZXJFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUNvbnRhaW5lcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXJFbGVtZW50O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBvdmVybGF5IGNvbnRhaW5lciBlbGVtZW50LCB3aGljaCBpcyBzaW1wbHkgYSBkaXZcbiAgICAgKiB3aXRoIHRoZSAnbWQtb3ZlcmxheS1jb250YWluZXInIGNsYXNzIG9uIHRoZSBkb2N1bWVudCBib2R5LlxuICAgICAqL1xuICAgIE92ZXJsYXlDb250YWluZXIucHJvdG90eXBlLl9jcmVhdGVDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ21kLW92ZXJsYXktY29udGFpbmVyJyk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyRWxlbWVudCA9IGNvbnRhaW5lcjtcbiAgICB9O1xuICAgIHJldHVybiBPdmVybGF5Q29udGFpbmVyO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkNiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ2ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKiogTmV4dCBvdmVybGF5IHVuaXF1ZSBJRC4gKi9cbnZhciBuZXh0VW5pcXVlSWQgPSAwO1xuLyoqIFRoZSBkZWZhdWx0IHN0YXRlIGZvciBuZXdseSBjcmVhdGVkIG92ZXJsYXlzLiAqL1xudmFyIGRlZmF1bHRTdGF0ZSA9IG5ldyBPdmVybGF5U3RhdGUoKTtcbi8qKlxuICogU2VydmljZSB0byBjcmVhdGUgT3ZlcmxheXMuIE92ZXJsYXlzIGFyZSBkeW5hbWljYWxseSBhZGRlZCBwaWVjZXMgb2YgZmxvYXRpbmcgVUksIG1lYW50IHRvIGJlXG4gKiB1c2VkIGFzIGEgbG93LWxldmVsIGJ1aWxkaW5nIGJ1aWxkaW5nIGJsb2NrIGZvciBvdGhlciBjb21wb25lbnRzLiBEaWFsb2dzLCB0b29sdGlwcywgbWVudXMsXG4gKiBzZWxlY3RzLCBldGMuIGNhbiBhbGwgYmUgYnVpbHQgdXNpbmcgb3ZlcmxheXMuIFRoZSBzZXJ2aWNlIHNob3VsZCBwcmltYXJpbHkgYmUgdXNlZCBieSBhdXRob3JzXG4gKiBvZiByZS11c2FibGUgY29tcG9uZW50cyByYXRoZXIgdGhhbiBkZXZlbG9wZXJzIGJ1aWxkaW5nIGVuZC11c2VyIGFwcGxpY2F0aW9ucy5cbiAqXG4gKiBBbiBvdmVybGF5ICppcyogYSBQb3J0YWxIb3N0LCBzbyBhbnkga2luZCBvZiBQb3J0YWwgY2FuIGJlIGxvYWRlZCBpbnRvIG9uZS5cbiAqL1xudmFyIE92ZXJsYXkgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE92ZXJsYXkoX292ZXJsYXlDb250YWluZXIsIF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIF9wb3NpdGlvbkJ1aWxkZXIpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheUNvbnRhaW5lciA9IF9vdmVybGF5Q29udGFpbmVyO1xuICAgICAgICB0aGlzLl9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgICAgICB0aGlzLl9wb3NpdGlvbkJ1aWxkZXIgPSBfcG9zaXRpb25CdWlsZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG92ZXJsYXkuXG4gICAgICogQHBhcmFtIHN0YXRlIFN0YXRlIHRvIGFwcGx5IHRvIHRoZSBvdmVybGF5LlxuICAgICAqIEByZXR1cm5zIEEgcmVmZXJlbmNlIHRvIHRoZSBjcmVhdGVkIG92ZXJsYXkuXG4gICAgICovXG4gICAgT3ZlcmxheS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7IHN0YXRlID0gZGVmYXVsdFN0YXRlOyB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVPdmVybGF5UmVmKHRoaXMuX2NyZWF0ZVBhbmVFbGVtZW50KCksIHN0YXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwb3NpdGlvbiBidWlsZGVyIHRoYXQgY2FuIGJlIHVzZWQsIHZpYSBmbHVlbnQgQVBJLFxuICAgICAqIHRvIGNvbnN0cnVjdCBhbmQgY29uZmlndXJlIGEgcG9zaXRpb24gc3RyYXRlZ3kuXG4gICAgICovXG4gICAgT3ZlcmxheS5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbkJ1aWxkZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBET00gZWxlbWVudCBmb3IgYW4gb3ZlcmxheSBhbmQgYXBwZW5kcyBpdCB0byB0aGUgb3ZlcmxheSBjb250YWluZXIuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGNyZWF0ZWQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBPdmVybGF5LnByb3RvdHlwZS5fY3JlYXRlUGFuZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHBhbmUuaWQgPSBcIm1kLW92ZXJsYXktXCIgKyBuZXh0VW5pcXVlSWQrKztcbiAgICAgICAgcGFuZS5jbGFzc0xpc3QuYWRkKCdtZC1vdmVybGF5LXBhbmUnKTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheUNvbnRhaW5lci5nZXRDb250YWluZXJFbGVtZW50KCkuYXBwZW5kQ2hpbGQocGFuZSk7XG4gICAgICAgIHJldHVybiBwYW5lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRG9tUG9ydGFsSG9zdCBpbnRvIHdoaWNoIHRoZSBvdmVybGF5IGNvbnRlbnQgY2FuIGJlIGxvYWRlZC5cbiAgICAgKiBAcGFyYW0gcGFuZSBUaGUgRE9NIGVsZW1lbnQgdG8gdHVybiBpbnRvIGEgcG9ydGFsIGhvc3QuXG4gICAgICogQHJldHVybnMgQSBwb3J0YWwgaG9zdCBmb3IgdGhlIGdpdmVuIERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIE92ZXJsYXkucHJvdG90eXBlLl9jcmVhdGVQb3J0YWxIb3N0ID0gZnVuY3Rpb24gKHBhbmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb21Qb3J0YWxIb3N0KHBhbmUsIHRoaXMuX2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE92ZXJsYXlSZWYgZm9yIGFuIG92ZXJsYXkgaW4gdGhlIGdpdmVuIERPTSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSBwYW5lIERPTSBlbGVtZW50IGZvciB0aGUgb3ZlcmxheVxuICAgICAqIEBwYXJhbSBzdGF0ZVxuICAgICAqIEByZXR1cm5zIHtPdmVybGF5UmVmfVxuICAgICAqL1xuICAgIE92ZXJsYXkucHJvdG90eXBlLl9jcmVhdGVPdmVybGF5UmVmID0gZnVuY3Rpb24gKHBhbmUsIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgT3ZlcmxheVJlZih0aGlzLl9jcmVhdGVQb3J0YWxIb3N0KHBhbmUpLCBwYW5lLCBzdGF0ZSk7XG4gICAgfTtcbiAgICBPdmVybGF5ID0gX19kZWNvcmF0ZSQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDYoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW092ZXJsYXlDb250YWluZXIsIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBPdmVybGF5UG9zaXRpb25CdWlsZGVyXSlcbiAgICBdLCBPdmVybGF5KTtcbiAgICByZXR1cm4gT3ZlcmxheTtcbn0oKSk7XG4vKiogUHJvdmlkZXJzIGZvciBPdmVybGF5IGFuZCBpdHMgcmVsYXRlZCBpbmplY3RhYmxlcy4gKi9cbnZhciBPVkVSTEFZX1BST1ZJREVSUyA9IFtcbiAgICBWaWV3cG9ydFJ1bGVyLFxuICAgIE92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIsXG4gICAgT3ZlcmxheSxcbiAgICBPdmVybGF5Q29udGFpbmVyLFxuXTtcblxudmFyIF9fZGVjb3JhdGUkNSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ1ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKiogRGVmYXVsdCBzZXQgb2YgcG9zaXRpb25zIGZvciB0aGUgb3ZlcmxheS4gRm9sbG93cyB0aGUgYmVoYXZpb3Igb2YgYSBkcm9wZG93bi4gKi9cbnZhciBkZWZhdWx0UG9zaXRpb25MaXN0ID0gW1xuICAgIG5ldyBDb25uZWN0aW9uUG9zaXRpb25QYWlyKHsgb3JpZ2luWDogJ3N0YXJ0Jywgb3JpZ2luWTogJ2JvdHRvbScgfSwgeyBvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICd0b3AnIH0pLFxuICAgIG5ldyBDb25uZWN0aW9uUG9zaXRpb25QYWlyKHsgb3JpZ2luWDogJ3N0YXJ0Jywgb3JpZ2luWTogJ3RvcCcgfSwgeyBvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICdib3R0b20nIH0pLFxuXTtcbi8qKlxuICogRGlyZWN0aXZlIGFwcGxpZWQgdG8gYW4gZWxlbWVudCB0byBtYWtlIGl0IHVzYWJsZSBhcyBhbiBvcmlnaW4gZm9yIGFuIE92ZXJsYXkgdXNpbmcgYVxuICogQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5cbiAqL1xudmFyIE92ZXJsYXlPcmlnaW4gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE92ZXJsYXlPcmlnaW4oX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT3ZlcmxheU9yaWdpbi5wcm90b3R5cGUsIFwiZWxlbWVudFJlZlwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWY7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE92ZXJsYXlPcmlnaW4gPSBfX2RlY29yYXRlJDUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1tvdmVybGF5LW9yaWdpbl0nLFxuICAgICAgICAgICAgZXhwb3J0QXM6ICdvdmVybGF5T3JpZ2luJyxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuRWxlbWVudFJlZl0pXG4gICAgXSwgT3ZlcmxheU9yaWdpbik7XG4gICAgcmV0dXJuIE92ZXJsYXlPcmlnaW47XG59KCkpO1xuLyoqXG4gKiBEaXJlY3RpdmUgdG8gZmFjaWxpdGF0ZSBkZWNsYXJhdGl2ZSBjcmVhdGlvbiBvZiBhbiBPdmVybGF5IHVzaW5nIGEgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneS5cbiAqL1xudmFyIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE8oamVsYm91cm4pOiBpbnB1dHMgZm9yIHNpemUsIHNjcm9sbCBiZWhhdmlvciwgYW5pbWF0aW9uLCBldGMuXG4gICAgZnVuY3Rpb24gQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZShfb3ZlcmxheSwgdGVtcGxhdGVSZWYsIHZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheSA9IF9vdmVybGF5O1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZVBvcnRhbCA9IG5ldyBUZW1wbGF0ZVBvcnRhbCh0ZW1wbGF0ZVJlZiwgdmlld0NvbnRhaW5lclJlZik7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvdmVybGF5UmVmXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheVJlZjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIFRPRE86IGludGVybmFsICovXG4gICAgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZU92ZXJsYXkoKTtcbiAgICB9O1xuICAgIC8qKiBUT0RPOiBpbnRlcm5hbCAqL1xuICAgIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9kZXN0cm95T3ZlcmxheSgpO1xuICAgIH07XG4gICAgLyoqIENyZWF0ZXMgYW4gb3ZlcmxheSBhbmQgYXR0YWNoZXMgdGhpcyBkaXJlY3RpdmUncyB0ZW1wbGF0ZSB0byBpdC4gKi9cbiAgICBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZS5fY3JlYXRlT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBvc2l0aW9ucyB8fCAhdGhpcy5wb3NpdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IGRlZmF1bHRQb3NpdGlvbkxpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG92ZXJsYXlDb25maWcgPSBuZXcgT3ZlcmxheVN0YXRlKCk7XG4gICAgICAgIG92ZXJsYXlDb25maWcucG9zaXRpb25TdHJhdGVneSA9XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKCkuY29ubmVjdGVkVG8odGhpcy5vcmlnaW4uZWxlbWVudFJlZiwgeyBvcmlnaW5YOiB0aGlzLnBvc2l0aW9uc1swXS5vdmVybGF5WCwgb3JpZ2luWTogdGhpcy5wb3NpdGlvbnNbMF0ub3JpZ2luWSB9LCB7IG92ZXJsYXlYOiB0aGlzLnBvc2l0aW9uc1swXS5vdmVybGF5WCwgb3ZlcmxheVk6IHRoaXMucG9zaXRpb25zWzBdLm92ZXJsYXlZIH0pO1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUob3ZlcmxheUNvbmZpZyk7XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3RlbXBsYXRlUG9ydGFsKTtcbiAgICB9O1xuICAgIC8qKiBEZXN0cm95cyB0aGUgb3ZlcmxheSBjcmVhdGVkIGJ5IHRoaXMgZGlyZWN0aXZlLiAqL1xuICAgIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUucHJvdG90eXBlLl9kZXN0cm95T3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDUoJ2Rlc2lnbjp0eXBlJywgT3ZlcmxheU9yaWdpbilcbiAgICBdLCBDb25uZWN0ZWRPdmVybGF5RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvcmlnaW5cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDUoJ2Rlc2lnbjp0eXBlJywgQXJyYXkpXG4gICAgXSwgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZS5wcm90b3R5cGUsIFwicG9zaXRpb25zXCIsIHZvaWQgMCk7XG4gICAgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUkNShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Nvbm5lY3RlZC1vdmVybGF5XSdcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW092ZXJsYXksIF9hbmd1bGFyX2NvcmUuVGVtcGxhdGVSZWYsIF9hbmd1bGFyX2NvcmUuVmlld0NvbnRhaW5lclJlZl0pXG4gICAgXSwgQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZSk7XG4gICAgcmV0dXJuIENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmU7XG59KCkpO1xudmFyIE92ZXJsYXlNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE92ZXJsYXlNb2R1bGUoKSB7XG4gICAgfVxuICAgIE92ZXJsYXlNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBPdmVybGF5TW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBPVkVSTEFZX1BST1ZJREVSUyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE92ZXJsYXlNb2R1bGUgPSBfX2RlY29yYXRlJDUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtQb3J0YWxNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW0Nvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmUsIE92ZXJsYXlPcmlnaW5dLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZSwgT3ZlcmxheU9yaWdpbl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ1KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE92ZXJsYXlNb2R1bGUpO1xuICAgIHJldHVybiBPdmVybGF5TW9kdWxlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMTEgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogVXRpbGl0eSBmb3IgY2hlY2tpbmcgdGhlIGludGVyYWN0aXZpdHkgb2YgYW4gZWxlbWVudCwgc3VjaCBhcyB3aGV0aGVyIGlzIGlzIGZvY3VzYWJsZSBvclxuICogdGFiYmFibGUuXG4gKlxuICogTk9URTogQ3VycmVudGx5IGRvZXMgbm90IGNhcHR1cmUgYW55IHNwZWNpYWwgZWxlbWVudCBiZWhhdmlvcnMsIGJyb3dzZXIgcXVpcmtzLCBvciBlZGdlIGNhc2VzLlxuICogVGhpcyBpcyBhIGJhc2ljL25haXZlIHN0YXJ0aW5nIHBvaW50IG9udG8gd2hpY2ggZnVydGhlciBiZWhhdmlvciB3aWxsIGJlIGFkZGVkLlxuICpcbiAqIFRoaXMgY2xhc3MgdXNlcyBpbnN0YW5jZSBtZXRob2RzIGluc3RlYWQgb2Ygc3RhdGljIGZ1bmN0aW9ucyBzbyB0aGF0IGFsdGVybmF0ZSBpbXBsZW1lbnRhdGlvbnNcbiAqIGNhbiBiZSBpbmplY3RlZC5cbiAqXG4gKiBUT0RPKGplbGJvdXJuKTogZXhwbG9yZSB1c2luZyBhbGx5LmpzIGRpcmVjdGx5IGZvciBpdHMgc2lnbmlmaWNhbnRseSBtb3JlIHJvYnVzdFxuICogY2hlY2tzIChuZWVkIHRvIGV2YWx1YXRlIHBheWxvYWQgc2l6ZSwgcGVyZm9ybWFuY2UsIGFuZCBjb21wYXRpYmlsaXR5IHdpdGggdHJlZS1zaGFraW5nKS5cbiAqL1xudmFyIEludGVyYWN0aXZpdHlDaGVja2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnRlcmFjdGl2aXR5Q2hlY2tlcigpIHtcbiAgICB9XG4gICAgLyoqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIGRpc2FibGVkLiAqL1xuICAgIEludGVyYWN0aXZpdHlDaGVja2VyLnByb3RvdHlwZS5pc0Rpc2FibGVkID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gVGhpcyBkb2VzIG5vdCBjYXB0dXJlIHNvbWUgY2FzZXMsIHN1Y2ggYXMgYSBub24tZm9ybSBjb250cm9sIHdpdGggYSBkaXNhYmxlZCBhdHRyaWJ1dGUgb3JcbiAgICAgICAgLy8gYSBmb3JtIGNvbnRyb2wgaW5zaWRlIG9mIGEgZGlzYWJsZWQgZm9ybSwgYnV0IHNob3VsZCBjYXB0dXJlIHRoZSBtb3N0IGNvbW1vbiBjYXNlcy5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgdmlzaWJsZSBmb3IgdGhlIHB1cnBvc2VzIG9mIGludGVyYWN0aXZpdHkuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgY2FwdHVyZSBzdGF0ZXMgbGlrZSBgZGlzcGxheTogbm9uZWAgYW5kIGB2aXNpYmlsaXR5OiBoaWRkZW5gLCBidXQgbm90IHRoaW5ncyBsaWtlXG4gICAgICogYmVpbmcgY2xpcHBlZCBieSBhbiBgb3ZlcmZsb3c6IGhpZGRlbmAgcGFyZW50IG9yIGJlaW5nIG91dHNpZGUgdGhlIHZpZXdwb3J0LlxuICAgICAqL1xuICAgIEludGVyYWN0aXZpdHlDaGVja2VyLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgYWRkaXRpb25hbCBzcGVjaWFsIGNhc2VzIHRoYXQgdGhpcyBkb2VzIG5vdCBjYXB0dXJlLCBidXQgdGhpcyB3aWxsIHdvcmsgZm9yXG4gICAgICAgIC8vIHRoZSBtb3N0IGNvbW1vbiBjYXNlcy5cbiAgICAgICAgLy8gVXNlIGxvZ2ljIGZyb20galF1ZXJ5IHRvIGNoZWNrIGZvciBgZGlzcGxheTogbm9uZWAuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL21hc3Rlci9zcmMvY3NzL2hpZGRlblZpc2libGVTZWxlY3RvcnMuanMjTDEyXG4gICAgICAgIGlmICghKGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgZWxlbWVudC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgY3NzIGB2aXNpYmlsaXR5YCBwcm9wZXJ0eS5cbiAgICAgICAgLy8gVE9ETyhqZWxib3Vybik6IGRvIGFueSBicm93c2VycyB3ZSBzdXBwb3J0IHJldHVybiBhbiBlbXB0eSBzdHJpbmcgaW5zdGVhZCBvZiAndmlzaWJsZSc/XG4gICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Zpc2liaWxpdHknKSA9PSAndmlzaWJsZSc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBjYW4gYmUgcmVhY2hlZCB2aWEgVGFiIGtleS5cbiAgICAgKiBBc3N1bWVzIHRoYXQgdGhlIGVsZW1lbnQgaGFzIGFscmVhZHkgYmVlbiBjaGVja2VkIHdpdGggaXNGb2N1c2FibGUuXG4gICAgICovXG4gICAgSW50ZXJhY3Rpdml0eUNoZWNrZXIucHJvdG90eXBlLmlzVGFiYmFibGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAvLyBBZ2FpbiwgbmFpdmUgYXBwcm9hY2ggdGhhdCBkb2VzIG5vdCBjYXB0dXJlIG1hbnkgc3BlY2lhbCBjYXNlcyBhbmQgYnJvd3NlciBxdWlya3MuXG4gICAgICAgIHJldHVybiBlbGVtZW50LnRhYkluZGV4ID49IDA7XG4gICAgfTtcbiAgICAvKiogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgY2FuIGJlIGZvY3VzZWQgYnkgdGhlIHVzZXIuICovXG4gICAgSW50ZXJhY3Rpdml0eUNoZWNrZXIucHJvdG90eXBlLmlzRm9jdXNhYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gUGVyZm9ybSBjaGVja3MgaW4gb3JkZXIgb2YgbGVmdCB0byBtb3N0IGV4cGVuc2l2ZS5cbiAgICAgICAgLy8gQWdhaW4sIG5haXZlIGFwcHJvYWNoIHRoYXQgZG9lcyBub3QgY2FwdHVyZSBtYW55IGVkZ2UgY2FzZXMgYW5kIGJyb3dzZXIgcXVpcmtzLlxuICAgICAgICByZXR1cm4gaXNQb3RlbnRpYWxseUZvY3VzYWJsZShlbGVtZW50KSAmJiAhdGhpcy5pc0Rpc2FibGVkKGVsZW1lbnQpICYmIHRoaXMuaXNWaXNpYmxlKGVsZW1lbnQpO1xuICAgIH07XG4gICAgSW50ZXJhY3Rpdml0eUNoZWNrZXIgPSBfX2RlY29yYXRlJDExKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDExKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIEludGVyYWN0aXZpdHlDaGVja2VyKTtcbiAgICByZXR1cm4gSW50ZXJhY3Rpdml0eUNoZWNrZXI7XG59KCkpO1xuLyoqIEdldHMgd2hldGhlciBhbiBlbGVtZW50J3MgICovXG5mdW5jdGlvbiBpc05hdGl2ZUZvcm1FbGVtZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG5vZGVOYW1lID09PSAnaW5wdXQnIHx8XG4gICAgICAgIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fFxuICAgICAgICBub2RlTmFtZSA9PT0gJ2J1dHRvbicgfHxcbiAgICAgICAgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYSc7XG59XG4vKiogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgYW4gPGlucHV0IHR5cGU9XCJoaWRkZW5cIj4uICovXG5mdW5jdGlvbiBpc0hpZGRlbklucHV0KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gaXNJbnB1dEVsZW1lbnQoZWxlbWVudCkgJiYgZWxlbWVudC50eXBlID09ICdoaWRkZW4nO1xufVxuLyoqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIGFuIGFuY2hvciB0aGF0IGhhcyBhbiBocmVmIGF0dHJpYnV0ZS4gKi9cbmZ1bmN0aW9uIGlzQW5jaG9yV2l0aEhyZWYoZWxlbWVudCkge1xuICAgIHJldHVybiBpc0FuY2hvckVsZW1lbnQoZWxlbWVudCkgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2hyZWYnKTtcbn1cbi8qKiBHZXRzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBhbiBpbnB1dCBlbGVtZW50LiAqL1xuZnVuY3Rpb24gaXNJbnB1dEVsZW1lbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50Lm5vZGVOYW1lID09ICdpbnB1dCc7XG59XG4vKiogR2V0cyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgYW4gYW5jaG9yIGVsZW1lbnQuICovXG5mdW5jdGlvbiBpc0FuY2hvckVsZW1lbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ2EnO1xufVxuLyoqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGhhcyBhIHZhbGlkIHRhYmluZGV4LiAqL1xuZnVuY3Rpb24gaGFzVmFsaWRUYWJJbmRleChlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSB8fCBlbGVtZW50LnRhYkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdGFiSW5kZXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAvLyBJRTExIHBhcnNlcyB0YWJpbmRleD1cIlwiIGFzIHRoZSB2YWx1ZSBcIi0zMjc2OFwiXG4gICAgaWYgKHRhYkluZGV4ID09ICctMzI3NjgnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICEhKHRhYkluZGV4ICYmICFpc05hTihwYXJzZUludCh0YWJJbmRleCwgMTApKSk7XG59XG4vKipcbiAqIEdldHMgd2hldGhlciBhbiBlbGVtZW50IGlzIHBvdGVudGlhbGx5IGZvY3VzYWJsZSB3aXRob3V0IHRha2luZyBjdXJyZW50IHZpc2libGUvZGlzYWJsZWQgc3RhdGVcbiAqIGludG8gYWNjb3VudC5cbiAqL1xuZnVuY3Rpb24gaXNQb3RlbnRpYWxseUZvY3VzYWJsZShlbGVtZW50KSB7XG4gICAgLy8gSW5wdXRzIGFyZSBwb3RlbnRpYWxseSBmb2N1c2FibGUgKnVubGVzcyogdGhleSdyZSB0eXBlPVwiaGlkZGVuXCIuXG4gICAgaWYgKGlzSGlkZGVuSW5wdXQoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNOYXRpdmVGb3JtRWxlbWVudChlbGVtZW50KSB8fFxuICAgICAgICBpc0FuY2hvcldpdGhIcmVmKGVsZW1lbnQpIHx8XG4gICAgICAgIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSB8fFxuICAgICAgICBoYXNWYWxpZFRhYkluZGV4KGVsZW1lbnQpO1xufVxuXG52YXIgX19kZWNvcmF0ZSQxMCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxMCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBEaXJlY3RpdmUgZm9yIHRyYXBwaW5nIGZvY3VzIHdpdGhpbiBhIHJlZ2lvbi5cbiAqXG4gKiBOT1RFOiBUaGlzIGRpcmVjdGl2ZSBjdXJyZW50bHkgdXNlcyBhIHZlcnkgc2ltcGxlIChuYWl2ZSkgYXBwcm9hY2ggdG8gZm9jdXMgdHJhcHBpbmcuXG4gKiBJdCBhc3N1bWVzIHRoYXQgdGhlIHRhYiBvcmRlciBpcyB0aGUgc2FtZSBhcyBET00gb3JkZXIsIHdoaWNoIGlzIG5vdCBuZWNlc3NhcmlseSB0cnVlLlxuICogVGhpbmdzIGxpa2UgdGFiSW5kZXggPiAwLCBmbGV4IGBvcmRlcmAsIGFuZCBzaGFkb3cgcm9vdHMgY2FuIGNhdXNlIHRvIHR3byB0byBtaXNhbGlnbi5cbiAqIFRoaXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGEgbW9yZSBpbnRlbGxpZ2VudCBzb2x1dGlvbiBiZWZvcmUgdGhlIGxpYnJhcnkgaXMgY29uc2lkZXJlZCBzdGFibGUuXG4gKi9cbnZhciBGb2N1c1RyYXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZvY3VzVHJhcChfY2hlY2tlcikge1xuICAgICAgICB0aGlzLl9jaGVja2VyID0gX2NoZWNrZXI7XG4gICAgfVxuICAgIC8qKiBGb2N1c2VzIHRoZSBmaXJzdCB0YWJiYWJsZSBlbGVtZW50IHdpdGhpbiB0aGUgZm9jdXMgdHJhcCByZWdpb24uICovXG4gICAgRm9jdXNUcmFwLnByb3RvdHlwZS5mb2N1c0ZpcnN0VGFiYmFibGVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVkaXJlY3RUb0VsZW1lbnQgPSB0aGlzLl9nZXRGaXJzdFRhYmJhYmxlRWxlbWVudCh0aGlzLnRyYXBwZWRDb250ZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBpZiAocmVkaXJlY3RUb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJlZGlyZWN0VG9FbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBGb2N1c2VzIHRoZSBsYXN0IHRhYmJhYmxlIGVsZW1lbnQgd2l0aGluIHRoZSBmb2N1cyB0cmFwIHJlZ2lvbi4gKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLmZvY3VzTGFzdFRhYmJhYmxlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlZGlyZWN0VG9FbGVtZW50ID0gdGhpcy5fZ2V0TGFzdFRhYmJhYmxlRWxlbWVudCh0aGlzLnRyYXBwZWRDb250ZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBpZiAocmVkaXJlY3RUb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJlZGlyZWN0VG9FbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBHZXQgdGhlIGZpcnN0IHRhYmJhYmxlIGVsZW1lbnQgZnJvbSBhIERPTSBzdWJ0cmVlIChpbmNsdXNpdmUpLiAqL1xuICAgIEZvY3VzVHJhcC5wcm90b3R5cGUuX2dldEZpcnN0VGFiYmFibGVFbGVtZW50ID0gZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrZXIuaXNGb2N1c2FibGUocm9vdCkgJiYgdGhpcy5fY2hlY2tlci5pc1RhYmJhYmxlKHJvb3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRlIGluIERPTSBvcmRlci5cbiAgICAgICAgdmFyIGNoaWxkQ291bnQgPSByb290LmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0YWJiYWJsZUNoaWxkID0gdGhpcy5fZ2V0Rmlyc3RUYWJiYWJsZUVsZW1lbnQocm9vdC5jaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBpZiAodGFiYmFibGVDaGlsZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0YWJiYWJsZUNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqIEdldCB0aGUgbGFzdCB0YWJiYWJsZSBlbGVtZW50IGZyb20gYSBET00gc3VidHJlZSAoaW5jbHVzaXZlKS4gKi9cbiAgICBGb2N1c1RyYXAucHJvdG90eXBlLl9nZXRMYXN0VGFiYmFibGVFbGVtZW50ID0gZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrZXIuaXNGb2N1c2FibGUocm9vdCkgJiYgdGhpcy5fY2hlY2tlci5pc1RhYmJhYmxlKHJvb3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRlIGluIHJldmVyc2UgRE9NIG9yZGVyLlxuICAgICAgICBmb3IgKHZhciBpID0gcm9vdC5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIHRhYmJhYmxlQ2hpbGQgPSB0aGlzLl9nZXRMYXN0VGFiYmFibGVFbGVtZW50KHJvb3QuY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgaWYgKHRhYmJhYmxlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFiYmFibGVDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMTAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZCgndHJhcHBlZENvbnRlbnQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTAoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmKVxuICAgIF0sIEZvY3VzVHJhcC5wcm90b3R5cGUsIFwidHJhcHBlZENvbnRlbnRcIiwgdm9pZCAwKTtcbiAgICBGb2N1c1RyYXAgPSBfX2RlY29yYXRlJDEwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnZm9jdXMtdHJhcCcsXG4gICAgICAgICAgICAvLyBUT0RPKGplbGJvdXJuKTogbW92ZSB0aGlzIHRvIGEgc2VwYXJhdGUgZmlsZS5cbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgPGRpdiB0YWJpbmRleD1cXFwiMFxcXCIgKGZvY3VzKT1cXFwiZm9jdXNMYXN0VGFiYmFibGVFbGVtZW50KClcXFwiPjwvZGl2PlxcbiAgPGRpdiAjdHJhcHBlZENvbnRlbnQ+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvZGl2PlxcbiAgPGRpdiB0YWJpbmRleD1cXFwiMFxcXCIgKGZvY3VzKT1cXFwiZm9jdXNGaXJzdFRhYmJhYmxlRWxlbWVudCgpXFxcIj48L2Rpdj5cIixcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDEwKCdkZXNpZ246cGFyYW10eXBlcycsIFtJbnRlcmFjdGl2aXR5Q2hlY2tlcl0pXG4gICAgXSwgRm9jdXNUcmFwKTtcbiAgICByZXR1cm4gRm9jdXNUcmFwO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMTIgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTIgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xudmFyIExJVkVfQU5OT1VOQ0VSX0VMRU1FTlRfVE9LRU4gPSBuZXcgX2FuZ3VsYXJfY29yZS5PcGFxdWVUb2tlbignbWRMaXZlQW5ub3VuY2VyRWxlbWVudCcpO1xudmFyIE1kTGl2ZUFubm91bmNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRMaXZlQW5ub3VuY2VyKGVsZW1lbnRUb2tlbikge1xuICAgICAgICAvLyBXZSBpbmplY3QgdGhlIGxpdmUgZWxlbWVudCBhcyBgYW55YCBiZWNhdXNlIHRoZSBjb25zdHJ1Y3RvciBzaWduYXR1cmUgY2Fubm90IHJlZmVyZW5jZVxuICAgICAgICAvLyBicm93c2VyIGdsb2JhbHMgKEhUTUxFbGVtZW50KSBvbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMsIHNpbmNlIGhhdmluZyBhIGNsYXNzIGRlY29yYXRvclxuICAgICAgICAvLyBjYXVzZXMgVHlwZVNjcmlwdCB0byBwcmVzZXJ2ZSB0aGUgY29uc3RydWN0b3Igc2lnbmF0dXJlIHR5cGVzLlxuICAgICAgICB0aGlzLl9saXZlRWxlbWVudCA9IGVsZW1lbnRUb2tlbiB8fCB0aGlzLl9jcmVhdGVMaXZlRWxlbWVudCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBNZXNzYWdlIHRvIGJlIGFubm91bmNlZCB0byB0aGUgc2NyZWVucmVhZGVyXG4gICAgICogQHBhcmFtIHBvbGl0ZW5lc3MgVGhlIHBvbGl0ZW5lc3Mgb2YgdGhlIGFubm91bmNlciBlbGVtZW50LlxuICAgICAqL1xuICAgIE1kTGl2ZUFubm91bmNlci5wcm90b3R5cGUuYW5ub3VuY2UgPSBmdW5jdGlvbiAobWVzc2FnZSwgcG9saXRlbmVzcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocG9saXRlbmVzcyA9PT0gdm9pZCAwKSB7IHBvbGl0ZW5lc3MgPSAncG9saXRlJzsgfVxuICAgICAgICB0aGlzLl9saXZlRWxlbWVudC50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAvLyBUT0RPOiBlbnN1cmUgY2hhbmdpbmcgdGhlIHBvbGl0ZW5lc3Mgd29ya3Mgb24gYWxsIGVudmlyb25tZW50cyB3ZSBzdXBwb3J0LlxuICAgICAgICB0aGlzLl9saXZlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsIHBvbGl0ZW5lc3MpO1xuICAgICAgICAvLyBUaGlzIDEwMG1zIHRpbWVvdXQgaXMgbmVjZXNzYXJ5IGZvciBzb21lIGJyb3dzZXIgKyBzY3JlZW4tcmVhZGVyIGNvbWJpbmF0aW9uczpcbiAgICAgICAgLy8gLSBCb3RoIEpBV1MgYW5kIE5WREEgb3ZlciBJRTExIHdpbGwgbm90IGFubm91bmNlIGFueXRoaW5nIHdpdGhvdXQgYSBub24temVybyB0aW1lb3V0LlxuICAgICAgICAvLyAtIFdpdGggQ2hyb21lIGFuZCBJRTExIHdpdGggTlZEQSBvciBKQVdTLCBhIHJlcGVhdGVkIChpZGVudGljYWwpIG1lc3NhZ2Ugd29uJ3QgYmUgcmVhZCBhXG4gICAgICAgIC8vICAgc2Vjb25kIHRpbWUgd2l0aG91dCBjbGVhcmluZyBhbmQgdGhlbiB1c2luZyBhIG5vbi16ZXJvIGRlbGF5LlxuICAgICAgICAvLyAodXNpbmcgSkFXUyAxNyBhdCB0aW1lIG9mIHRoaXMgd3JpdGluZykuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2xpdmVFbGVtZW50LnRleHRDb250ZW50ID0gbWVzc2FnZTsgfSwgMTAwKTtcbiAgICB9O1xuICAgIE1kTGl2ZUFubm91bmNlci5wcm90b3R5cGUuX2NyZWF0ZUxpdmVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGl2ZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGxpdmVFbC5jbGFzc0xpc3QuYWRkKCdtZC12aXN1YWxseS1oaWRkZW4nKTtcbiAgICAgICAgbGl2ZUVsLnNldEF0dHJpYnV0ZSgnYXJpYS1hdG9taWMnLCAndHJ1ZScpO1xuICAgICAgICBsaXZlRWwuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGl2ZUVsKTtcbiAgICAgICAgcmV0dXJuIGxpdmVFbDtcbiAgICB9O1xuICAgIE1kTGl2ZUFubm91bmNlciA9IF9fZGVjb3JhdGUkMTIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSxcbiAgICAgICAgX19wYXJhbSgwLCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLFxuICAgICAgICBfX3BhcmFtKDAsIF9hbmd1bGFyX2NvcmUuSW5qZWN0KExJVkVfQU5OT1VOQ0VSX0VMRU1FTlRfVE9LRU4pKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgTWRMaXZlQW5ub3VuY2VyKTtcbiAgICByZXR1cm4gTWRMaXZlQW5ub3VuY2VyO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkOSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ5ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgQTExWV9QUk9WSURFUlMgPSBbTWRMaXZlQW5ub3VuY2VyLCBJbnRlcmFjdGl2aXR5Q2hlY2tlcl07XG52YXIgQTExeU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQTExeU1vZHVsZSgpIHtcbiAgICB9XG4gICAgQTExeU1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IEExMXlNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IEExMVlfUFJPVklERVJTLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQTExeU1vZHVsZSA9IF9fZGVjb3JhdGUkOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbRm9jdXNUcmFwXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtGb2N1c1RyYXBdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkOSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBBMTF5TW9kdWxlKTtcbiAgICByZXR1cm4gQTExeU1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMkNSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQxMyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxMyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyogQWRqdXN0cyBjb25maWd1cmF0aW9uIG9mIG91ciBnZXN0dXJlIGxpYnJhcnksIEhhbW1lci4gKi9cbnZhciBNZEdlc3R1cmVDb25maWcgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQ1KE1kR2VzdHVyZUNvbmZpZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZEdlc3R1cmVDb25maWcoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAvKiBMaXN0IG9mIG5ldyBldmVudCBuYW1lcyB0byBhZGQgdG8gdGhlIGdlc3R1cmUgc3VwcG9ydCBsaXN0ICovXG4gICAgICAgIHRoaXMuZXZlbnRzID0gW1xuICAgICAgICAgICAgJ2RyYWcnLFxuICAgICAgICAgICAgJ2RyYWdzdGFydCcsXG4gICAgICAgICAgICAnZHJhZ2VuZCcsXG4gICAgICAgICAgICAnZHJhZ3JpZ2h0JyxcbiAgICAgICAgICAgICdkcmFnbGVmdCcsXG4gICAgICAgICAgICAnbG9uZ3ByZXNzJyxcbiAgICAgICAgICAgICdzbGlkZScsXG4gICAgICAgICAgICAnc2xpZGVzdGFydCcsXG4gICAgICAgICAgICAnc2xpZGVlbmQnLFxuICAgICAgICAgICAgJ3NsaWRlcmlnaHQnLFxuICAgICAgICAgICAgJ3NsaWRlbGVmdCdcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBCdWlsZHMgSGFtbWVyIGluc3RhbmNlIG1hbnVhbGx5IHRvIGFkZCBjdXN0b20gcmVjb2duaXplcnMgdGhhdCBtYXRjaCB0aGUgTWF0ZXJpYWwgRGVzaWduIHNwZWMuXG4gICAgICpcbiAgICAgKiBPdXIgZ2VzdHVyZSBuYW1lcyBjb21lIGZyb20gdGhlIE1hdGVyaWFsIERlc2lnbiBnZXN0dXJlcyBzcGVjOlxuICAgICAqIGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvcGF0dGVybnMvZ2VzdHVyZXMuaHRtbCNnZXN0dXJlcy10b3VjaC1tZWNoYW5pY3NcbiAgICAgKlxuICAgICAqIE1vcmUgaW5mb3JtYXRpb24gb24gZGVmYXVsdCByZWNvZ25pemVycyBjYW4gYmUgZm91bmQgaW4gSGFtbWVyIGRvY3M6XG4gICAgICogaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9yZWNvZ25pemVyLXBhbi9cbiAgICAgKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL3JlY29nbml6ZXItcHJlc3MvXG4gICAgICpcbiAgICAgKiBUT0RPOiBDb25maXJtIHRocmVzaG9sZCBudW1iZXJzIHdpdGggTWF0ZXJpYWwgRGVzaWduIFVYIFRlYW1cbiAgICAgKiAqL1xuICAgIE1kR2VzdHVyZUNvbmZpZy5wcm90b3R5cGUuYnVpbGRIYW1tZXIgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgbWMgPSBuZXcgSGFtbWVyKGVsZW1lbnQpO1xuICAgICAgICAvLyBEZWZhdWx0IEhhbW1lciBSZWNvZ25pemVycy5cbiAgICAgICAgdmFyIHBhbiA9IG5ldyBIYW1tZXIuUGFuKCk7XG4gICAgICAgIHZhciBzd2lwZSA9IG5ldyBIYW1tZXIuU3dpcGUoKTtcbiAgICAgICAgdmFyIHByZXNzID0gbmV3IEhhbW1lci5QcmVzcygpO1xuICAgICAgICAvLyBOb3RpY2UgdGhhdCBhIEhhbW1lckpTIHJlY29nbml6ZXIgY2FuIG9ubHkgZGVwZW5kIG9uIG9uZSBvdGhlciByZWNvZ25pemVyIG9uY2UuXG4gICAgICAgIC8vIE90aGVyd2lzZSB0aGUgcHJldmlvdXMgYHJlY29nbml6ZVdpdGhgIHdpbGwgYmUgZHJvcHBlZC5cbiAgICAgICAgdmFyIHNsaWRlID0gdGhpcy5fY3JlYXRlUmVjb2duaXplcihwYW4sIHsgZXZlbnQ6ICdzbGlkZScsIHRocmVzaG9sZDogMCB9LCBzd2lwZSk7XG4gICAgICAgIHZhciBkcmFnID0gdGhpcy5fY3JlYXRlUmVjb2duaXplcihzbGlkZSwgeyBldmVudDogJ2RyYWcnLCB0aHJlc2hvbGQ6IDYgfSwgc3dpcGUpO1xuICAgICAgICB2YXIgbG9uZ3ByZXNzID0gdGhpcy5fY3JlYXRlUmVjb2duaXplcihwcmVzcywgeyBldmVudDogJ2xvbmdwcmVzcycsIHRpbWU6IDUwMCB9KTtcbiAgICAgICAgLy8gT3ZlcndyaXRlIHRoZSBkZWZhdWx0IGBwYW5gIGV2ZW50IHRvIHVzZSB0aGUgc3dpcGUgZXZlbnQuXG4gICAgICAgIHBhbi5yZWNvZ25pemVXaXRoKHN3aXBlKTtcbiAgICAgICAgLy8gQWRkIGN1c3RvbWl6ZWQgZ2VzdHVyZXMgdG8gSGFtbWVyIG1hbmFnZXJcbiAgICAgICAgbWMuYWRkKFtzd2lwZSwgcHJlc3MsIHBhbiwgZHJhZywgc2xpZGUsIGxvbmdwcmVzc10pO1xuICAgICAgICByZXR1cm4gbWM7XG4gICAgfTtcbiAgICAvKiogQ3JlYXRlcyBhIG5ldyByZWNvZ25pemVyLCB3aXRob3V0IGFmZmVjdGluZyB0aGUgZGVmYXVsdCByZWNvZ25pemVycyBvZiBIYW1tZXJKUyAqL1xuICAgIE1kR2VzdHVyZUNvbmZpZy5wcm90b3R5cGUuX2NyZWF0ZVJlY29nbml6ZXIgPSBmdW5jdGlvbiAoYmFzZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgaW5oZXJpdGFuY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBpbmhlcml0YW5jZXNbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY29nbml6ZXIgPSBuZXcgYmFzZS5jb25zdHJ1Y3RvcihvcHRpb25zKTtcbiAgICAgICAgaW5oZXJpdGFuY2VzLnB1c2goYmFzZSk7XG4gICAgICAgIGluaGVyaXRhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbSk7IH0pO1xuICAgICAgICByZXR1cm4gcmVjb2duaXplcjtcbiAgICB9O1xuICAgIE1kR2VzdHVyZUNvbmZpZyA9IF9fZGVjb3JhdGUkMTMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRHZXN0dXJlQ29uZmlnKTtcbiAgICByZXR1cm4gTWRHZXN0dXJlQ29uZmlnO1xufShfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIuSGFtbWVyR2VzdHVyZUNvbmZpZykpO1xuXG52YXIgX19kZWNvcmF0ZSQxNCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxNCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBDbGFzcyB0byBjb29yZGluYXRlIHVuaXF1ZSBzZWxlY3Rpb24gYmFzZWQgb24gbmFtZS5cbiAqIEludGVuZGVkIHRvIGJlIGNvbnN1bWVkIGFzIGFuIEFuZ3VsYXIgc2VydmljZS5cbiAqIFRoaXMgc2VydmljZSBpcyBuZWVkZWQgYmVjYXVzZSBuYXRpdmUgcmFkaW8gY2hhbmdlIGV2ZW50cyBhcmUgb25seSBmaXJlZCBvbiB0aGUgaXRlbSBjdXJyZW50bHlcbiAqIGJlaW5nIHNlbGVjdGVkLCBhbmQgd2Ugc3RpbGwgbmVlZCB0byB1bmNoZWNrIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uXG4gKlxuICogVGhpcyBzZXJ2aWNlIGRvZXMgbm90ICpzdG9yZSogYW55IElEcyBhbmQgbmFtZXMgYmVjYXVzZSB0aGV5IG1heSBjaGFuZ2UgYXQgYW55IHRpbWUsIHNvIGl0IGlzXG4gKiBsZXNzIGVycm9yLXByb25lIGlmIHRoZXkgYXJlIHNpbXBseSBwYXNzZWQgdGhyb3VnaCB3aGVuIHRoZSBldmVudHMgb2NjdXIuXG4gKi9cbnZhciBNZFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlcigpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIC8qKiBOb3RpZnkgb3RoZXIgaXRlbXMgdGhhdCBzZWxlY3Rpb24gZm9yIHRoZSBnaXZlbiBuYW1lIGhhcyBiZWVuIHNldC4gKi9cbiAgICBNZFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIChpZCwgbmFtZSkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fbGlzdGVuZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gX2FbX2ldO1xuICAgICAgICAgICAgbGlzdGVuZXIoaWQsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogTGlzdGVuIGZvciBmdXR1cmUgY2hhbmdlcyB0byBpdGVtIHNlbGVjdGlvbi4gKi9cbiAgICBNZFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBNZFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIgPSBfX2RlY29yYXRlJDE0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDE0KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlcik7XG4gICAgcmV0dXJuIE1kVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlcjtcbn0oKSk7XG5cbi8qKlxuICogQW5ub3RhdGlvbiBGYWN0b3J5IHRoYXQgYWxsb3dzIEhUTUwgc3R5bGUgYm9vbGVhbiBhdHRyaWJ1dGVzLiBGb3IgZXhhbXBsZSxcbiAqIGEgZmllbGQgZGVjbGFyZWQgbGlrZSB0aGlzOlxuXG4gKiBARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdjb21wb25lbnQnIH0pIGNsYXNzIE15Q29tcG9uZW50IHtcbiAqICAgQElucHV0KCkgQEJvb2xlYW5GaWVsZFZhbHVlRmFjdG9yeSgpIG15RmllbGQ6IGJvb2xlYW47XG4gKiB9XG4gKlxuICogWW91IGNvdWxkIHNldCBpdCB1cCB0aGlzIHdheTpcbiAqICAgPGNvbXBvbmVudCBteUZpZWxkPlxuICogb3I6XG4gKiAgIDxjb21wb25lbnQgbXlGaWVsZD1cIlwiPlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZnVuY3Rpb24gQm9vbGVhbkZpZWxkVmFsdWUoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvb2xlYW5GaWVsZFZhbHVlTWV0YWRhdGEodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHRhcmdldFtrZXldO1xuICAgICAgICB2YXIgbG9jYWxLZXkgPSBcIl9fbWRfcHJpdmF0ZV9zeW1ib2xfXCIgKyBrZXk7XG4gICAgICAgIHRhcmdldFtsb2NhbEtleV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW2xvY2FsS2V5XTsgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tsb2NhbEtleV0gPSB2YWx1ZSAhPSBudWxsICYmIFwiXCIgKyB2YWx1ZSAhPT0gJ2ZhbHNlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuLy8gRHVlIHRvIGEgYnVnIGluIHRoZSBDaHJvbWVEcml2ZXIsIEFuZ3VsYXIgMiBrZXlib2FyZCBldmVudHMgYXJlIG5vdCB0cmlnZ2VyZWQgYnkgYHNlbmRLZXlzYFxuLy8gZHVyaW5nIEUyRSB0ZXN0cyB3aGVuIHVzaW5nIGRvdCBub3RhdGlvbiBzdWNoIGFzIGAoa2V5ZG93bi5yaWdodEFycm93KWAuIFRvIGdldCBhcm91bmQgdGhpcyxcbi8vIHdlIGFyZSB0ZW1wb3JhcmlseSB1c2luZyBhIHNpbmdsZSAoa2V5ZG93bikgaGFuZGxlci5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvOTQxOVxudmFyIFVQX0FSUk9XID0gMzg7XG52YXIgRE9XTl9BUlJPVyA9IDQwO1xudmFyIFJJR0hUX0FSUk9XID0gMzk7XG52YXIgTEVGVF9BUlJPVyA9IDM3O1xudmFyIEVOVEVSID0gMTM7XG52YXIgVEFCID0gOTtcblxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBNZENvcmVNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ29yZU1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWRDb3JlTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRDb3JlTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbQTExWV9QUk9WSURFUlMsIE9WRVJMQVlfUFJPVklERVJTXSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kQ29yZU1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtNZExpbmVNb2R1bGUsIFJ0bE1vZHVsZSwgTWRSaXBwbGVNb2R1bGUsIFBvcnRhbE1vZHVsZSwgT3ZlcmxheU1vZHVsZSwgQTExeU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRMaW5lTW9kdWxlLCBSdGxNb2R1bGUsIE1kUmlwcGxlTW9kdWxlLCBQb3J0YWxNb2R1bGUsIE92ZXJsYXlNb2R1bGUsIEExMXlNb2R1bGVdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRDb3JlTW9kdWxlKTtcbiAgICByZXR1cm4gTWRDb3JlTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMTYgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTYgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDEgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vKipcbiAqIFByb3ZpZGVyIEV4cHJlc3Npb24gdGhhdCBhbGxvd3MgbWQtYnV0dG9uLXRvZ2dsZS1ncm91cCB0byByZWdpc3RlciBhcyBhIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICogVGhpcyBhbGxvd3MgaXQgdG8gc3VwcG9ydCBbKG5nTW9kZWwpXS5cbiAqL1xudmFyIE1EX0JVVFRPTl9UT0dHTEVfR1JPVVBfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogX2FuZ3VsYXJfZm9ybXMuTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZEJ1dHRvblRvZ2dsZUdyb3VwOyB9KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbnZhciBfdW5pcXVlSWRDb3VudGVyID0gMDtcbi8qKiBBIHNpbXBsZSBjaGFuZ2UgZXZlbnQgZW1pdHRlZCBieSBlaXRoZXIgTWRCdXR0b25Ub2dnbGUgb3IgTWRCdXR0b25Ub2dnbGVHcm91cC4gKi9cbnZhciBNZEJ1dHRvblRvZ2dsZUNoYW5nZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRCdXR0b25Ub2dnbGVDaGFuZ2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZEJ1dHRvblRvZ2dsZUNoYW5nZTtcbn0oKSk7XG4vKiogRXhjbHVzaXZlIHNlbGVjdGlvbiBidXR0b24gdG9nZ2xlIGdyb3VwIHRoYXQgYmVoYXZlcyBsaWtlIGEgcmFkaW8tYnV0dG9uIGdyb3VwLiAqL1xudmFyIE1kQnV0dG9uVG9nZ2xlR3JvdXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQnV0dG9uVG9nZ2xlR3JvdXAoKSB7XG4gICAgICAgIC8qKiBUaGUgdmFsdWUgZm9yIHRoZSBidXR0b24gdG9nZ2xlIGdyb3VwLiBTaG91bGQgbWF0Y2ggY3VycmVudGx5IHNlbGVjdGVkIGJ1dHRvbiB0b2dnbGUuICovXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqIFRoZSBIVE1MIG5hbWUgYXR0cmlidXRlIGFwcGxpZWQgdG8gdG9nZ2xlcyBpbiB0aGlzIGdyb3VwLiAqL1xuICAgICAgICB0aGlzLl9uYW1lID0gXCJtZC1yYWRpby1ncm91cC1cIiArIF91bmlxdWVJZENvdW50ZXIrKztcbiAgICAgICAgLyoqIERpc2FibGVzIGFsbCB0b2dnbGVzIGluIHRoZSBncm91cC4gKi9cbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBudWxsO1xuICAgICAgICAvKiogVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBidXR0b24gdG9nZ2xlLCBzaG91bGQgbWF0Y2ggdGhlIHZhbHVlLiAqL1xuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IG51bGw7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBidXR0b24gdG9nZ2xlIGdyb3VwIGlzIGluaXRpYWxpemVkIG9yIG5vdC4gKi9cbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAvKiogVGhlIG1ldGhvZCB0byBiZSBjYWxsZWQgaW4gb3JkZXIgdG8gdXBkYXRlIG5nTW9kZWwuICovXG4gICAgICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmdW5jdGlvbiAodmFsdWUpIHsgfTtcbiAgICAgICAgLyoqIG9uVG91Y2ggZnVuY3Rpb24gcmVnaXN0ZXJlZCB2aWEgcmVnaXN0ZXJPblRvdWNoIChDb250cm9sVmFsdWVBY2Nlc3NvcikuICovXG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBncm91cCdzIHZhbHVlIGNoYW5nZXMuICovXG4gICAgICAgIHRoaXMuX2NoYW5nZSA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogQ2hpbGQgYnV0dG9uIHRvZ2dsZSBidXR0b25zLiAqL1xuICAgICAgICB0aGlzLl9idXR0b25Ub2dnbGVzID0gbnVsbDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcImNoYW5nZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIFRPRE86IGludGVybmFsICovXG4gICAgTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUJ1dHRvblRvZ2dsZU5hbWVzKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UpID8gdHJ1ZSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlICE9IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTZWxlY3RlZEJ1dHRvblRvZ2dsZUZyb21WYWx1ZSgpO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgZW1pdCBhIGNoYW5nZSBldmVudCBpZiB0aGUgdmlldyBpcyBjb21wbGV0ZWx5IGluaXRpYWxpemVkLlxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gZW1pdCBhIGNoYW5nZSBldmVudCBmb3IgdGhlIGluaXRpYWwgdmFsdWVzLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHNlbGVjdGVkID8gc2VsZWN0ZWQudmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkICYmICFzZWxlY3RlZC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLl91cGRhdGVCdXR0b25Ub2dnbGVOYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2J1dHRvblRvZ2dsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1dHRvblRvZ2dsZXMuZm9yRWFjaChmdW5jdGlvbiAodG9nZ2xlKSB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlLm5hbWUgPSBfdGhpcy5fbmFtZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBUT0RPOiBSZWZhY3RvciBpbnRvIHNoYXJlZCBjb2RlIHdpdGggcmFkaW8uXG4gICAgTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUuX3VwZGF0ZVNlbGVjdGVkQnV0dG9uVG9nZ2xlRnJvbVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaXNBbHJlYWR5U2VsZWN0ZWQgPSB0aGlzLl9zZWxlY3RlZCAhPSBudWxsICYmIHRoaXMuX3NlbGVjdGVkLnZhbHVlID09IHRoaXMuX3ZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fYnV0dG9uVG9nZ2xlcyAhPSBudWxsICYmICFpc0FscmVhZHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nQnV0dG9uVG9nZ2xlID0gdGhpcy5fYnV0dG9uVG9nZ2xlcy5maWx0ZXIoZnVuY3Rpb24gKGJ1dHRvblRvZ2dsZSkgeyByZXR1cm4gYnV0dG9uVG9nZ2xlLnZhbHVlID09IF90aGlzLl92YWx1ZTsgfSlbMF07XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdCdXR0b25Ub2dnbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gbWF0Y2hpbmdCdXR0b25Ub2dnbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9idXR0b25Ub2dnbGVzLmZvckVhY2goZnVuY3Rpb24gKGJ1dHRvblRvZ2dsZSkge1xuICAgICAgICAgICAgICAgICAgICBidXR0b25Ub2dnbGUuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogRGlzcGF0Y2ggY2hhbmdlIGV2ZW50IHdpdGggY3VycmVudCBzZWxlY3Rpb24gYW5kIGdyb3VwIHZhbHVlLiAqL1xuICAgIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLl9lbWl0Q2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBNZEJ1dHRvblRvZ2dsZUNoYW5nZSgpO1xuICAgICAgICBldmVudC5zb3VyY2UgPSB0aGlzLl9zZWxlY3RlZDtcbiAgICAgICAgZXZlbnQudmFsdWUgPSB0aGlzLl92YWx1ZTtcbiAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbihldmVudC52YWx1ZSk7XG4gICAgICAgIHRoaXMuX2NoYW5nZS5lbWl0KGV2ZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogVE9ETzogaW50ZXJuYWxcbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogVE9ETzogaW50ZXJuYWxcbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogVE9ETzogaW50ZXJuYWxcbiAgICAgKi9cbiAgICBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQxNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDE2KCdkZXNpZ246dHlwZScsIHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcImNoYW5nZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db250ZW50Q2hpbGRyZW4oX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1kQnV0dG9uVG9nZ2xlOyB9KSksIFxuICAgICAgICBfX21ldGFkYXRhJDE2KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuUXVlcnlMaXN0KVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcIl9idXR0b25Ub2dnbGVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQxNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTYoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcIm5hbWVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSxcbiAgICAgICAgQm9vbGVhbkZpZWxkVmFsdWUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTYoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZEJ1dHRvblRvZ2dsZUdyb3VwLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNignZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRCdXR0b25Ub2dnbGVHcm91cC5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlR3JvdXAucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIG51bGwpO1xuICAgIE1kQnV0dG9uVG9nZ2xlR3JvdXAgPSBfX2RlY29yYXRlJDE2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1idXR0b24tdG9nZ2xlLWdyb3VwOm5vdChbbXVsdGlwbGVdKScsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtNRF9CVVRUT05fVE9HR0xFX0dST1VQX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAncm9sZSc6ICdyYWRpb2dyb3VwJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNignZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZEJ1dHRvblRvZ2dsZUdyb3VwKTtcbiAgICByZXR1cm4gTWRCdXR0b25Ub2dnbGVHcm91cDtcbn0oKSk7XG4vKiogTXVsdGlwbGUgc2VsZWN0aW9uIGJ1dHRvbi10b2dnbGUgZ3JvdXAuICovXG52YXIgTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUoKSB7XG4gICAgICAgIC8qKiBEaXNhYmxlcyBhbGwgdG9nZ2xlcyBpbiB0aGUgZ3JvdXAuICovXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gbnVsbDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlKSA/IHRydWUgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfX2RlY29yYXRlJDE2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNignZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG4gICAgTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlID0gX19kZWNvcmF0ZSQxNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtYnV0dG9uLXRvZ2dsZS1ncm91cFttdWx0aXBsZV0nLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTYoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlKTtcbiAgICByZXR1cm4gTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlO1xufSgpKTtcbnZhciBNZEJ1dHRvblRvZ2dsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRCdXR0b25Ub2dnbGUodG9nZ2xlR3JvdXAsIHRvZ2dsZUdyb3VwTXVsdGlwbGUsIGJ1dHRvblRvZ2dsZURpc3BhdGNoZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5idXR0b25Ub2dnbGVEaXNwYXRjaGVyID0gYnV0dG9uVG9nZ2xlRGlzcGF0Y2hlcjtcbiAgICAgICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoaXMgYnV0dG9uIHRvZ2dsZSBpcyBjaGVja2VkLiAqL1xuICAgICAgICB0aGlzLl9jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIC8qKiBXaGV0aGVyIG9yIG5vdCB0aGlzIGJ1dHRvbiB0b2dnbGUgaXMgZGlzYWJsZWQuICovXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gbnVsbDtcbiAgICAgICAgLyoqIFZhbHVlIGFzc2lnbmVkIHRvIHRoaXMgYnV0dG9uIHRvZ2dsZS4gKi9cbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgICAgICAvKiogV2hldGhlciBvciBub3QgdGhlIGJ1dHRvbiB0b2dnbGUgaXMgYSBzaW5nbGUgc2VsZWN0aW9uLiAqL1xuICAgICAgICB0aGlzLl9pc1NpbmdsZVNlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgZ3JvdXAgdmFsdWUgY2hhbmdlcy4gKi9cbiAgICAgICAgdGhpcy5fY2hhbmdlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAgPSB0b2dnbGVHcm91cDtcbiAgICAgICAgdGhpcy5idXR0b25Ub2dnbGVHcm91cE11bHRpcGxlID0gdG9nZ2xlR3JvdXBNdWx0aXBsZTtcbiAgICAgICAgaWYgKHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXApIHtcbiAgICAgICAgICAgIGJ1dHRvblRvZ2dsZURpc3BhdGNoZXIubGlzdGVuKGZ1bmN0aW9uIChpZCwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChpZCAhPSBfdGhpcy5pZCAmJiBuYW1lID09IF90aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fdHlwZSA9ICdyYWRpbyc7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwLm5hbWU7XG4gICAgICAgICAgICB0aGlzLl9pc1NpbmdsZVNlbGVjdG9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlcmUgaXMgbm8gZ3JvdXAgYXQgYWxsLCB0cmVhdCB0aGUgYnV0dG9uIHRvZ2dsZSBhcyBhIGNoZWNrYm94IHNvIGl0IGNhbiBiZVxuICAgICAgICAgICAgLy8gdG9nZ2xlZCBvbiBvciBvZmYuXG4gICAgICAgICAgICB0aGlzLl90eXBlID0gJ2NoZWNrYm94JztcbiAgICAgICAgICAgIHRoaXMuX2lzU2luZ2xlU2VsZWN0b3IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLCBcImNoYW5nZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZS5hc09ic2VydmFibGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gXCJtZC1idXR0b24tdG9nZ2xlLVwiICsgX3VuaXF1ZUlkQ291bnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwICYmIHRoaXMuX3ZhbHVlID09IHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLCBcImlucHV0SWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkICsgXCItaW5wdXRcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZSwgXCJjaGVja2VkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3Q2hlY2tlZFN0YXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNTaW5nbGVTZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIGlmIChuZXdDaGVja2VkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aWZ5IGFsbCBidXR0b24gdG9nZ2xlcyB3aXRoIHRoZSBzYW1lIG5hbWUgKGluIHRoZSBzYW1lIGdyb3VwKSB0byB1bi1jaGVjay5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25Ub2dnbGVEaXNwYXRjaGVyLm5vdGlmeSh0aGlzLmlkLCB0aGlzLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NoZWNrZWQgPSBuZXdDaGVja2VkU3RhdGU7XG4gICAgICAgICAgICBpZiAobmV3Q2hlY2tlZFN0YXRlICYmIHRoaXMuX2lzU2luZ2xlU2VsZWN0b3IgJiYgdGhpcy5idXR0b25Ub2dnbGVHcm91cC52YWx1ZSAhPSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25Ub2dnbGVHcm91cC5zZWxlY3RlZCA9IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAvKiogTWRCdXR0b25Ub2dnbGVHcm91cCByZWFkcyB0aGlzIHRvIGFzc2lnbiBpdHMgb3duIHZhbHVlLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92YWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwICE9IG51bGwgJiYgdGhpcy5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIERpc3BhdGNoIGNoYW5nZSBldmVudCB3aXRoIGN1cnJlbnQgdmFsdWUuICovXG4gICAgTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLl9lbWl0Q2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBNZEJ1dHRvblRvZ2dsZUNoYW5nZSgpO1xuICAgICAgICBldmVudC5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBldmVudC52YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICB0aGlzLl9jaGFuZ2UuZW1pdChldmVudCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQgfHwgKHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAgIT0gbnVsbCAmJiB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwLmRpc2FibGVkKSB8fFxuICAgICAgICAgICAgICAgICh0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUgIT0gbnVsbCAmJiB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUuZGlzYWJsZWQpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gZmFsc2UpID8gdHJ1ZSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBUb2dnbGUgdGhlIHN0YXRlIG9mIHRoZSBjdXJyZW50IGJ1dHRvbiB0b2dnbGUuICovXG4gICAgTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLl90b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgfTtcbiAgICAvKiogQ2hlY2tzIHRoZSBidXR0b24gdG9nZ2xlIGR1ZSB0byBhbiBpbnRlcmFjdGlvbiB3aXRoIHRoZSB1bmRlcmx5aW5nIG5hdGl2ZSBpbnB1dC4gKi9cbiAgICBNZEJ1dHRvblRvZ2dsZS5wcm90b3R5cGUuX29uSW5wdXRDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLl9pc1NpbmdsZVNlbGVjdG9yKSB7XG4gICAgICAgICAgICAvLyBQcm9wYWdhdGUgdGhlIGNoYW5nZSBvbmUtd2F5IHZpYSB0aGUgZ3JvdXAsIHdoaWNoIHdpbGwgaW4gdHVybiBtYXJrIHRoaXNcbiAgICAgICAgICAgIC8vIGJ1dHRvbiB0b2dnbGUgYXMgY2hlY2tlZC5cbiAgICAgICAgICAgIHRoaXMuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvblRvZ2dsZUdyb3VwLnNlbGVjdGVkID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uVG9nZ2xlR3JvdXAub25Ub3VjaGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbWl0IGEgY2hhbmdlIGV2ZW50IHdoZW4gdGhlIG5hdGl2ZSBpbnB1dCBkb2VzLlxuICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICB9O1xuICAgIC8qKiBUT0RPOiBpbnRlcm5hbCAqL1xuICAgIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZS5fb25JbnB1dENsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gc3RvcCBwcm9wYWdhdGlvbiBmb3IgY2xpY2sgZXZlbnRzIG9uIHRoZSB2aXN1YWwgaGlkZGVuIGlucHV0IGVsZW1lbnQuXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHdoZW4gYSB1c2VyIGNsaWNrcyBvbiBhIGxhYmVsIGVsZW1lbnQsIGEgZ2VuZXJhdGVkIGNsaWNrIGV2ZW50IHdpbGwgYmVcbiAgICAgICAgLy8gZGlzcGF0Y2hlZCBvbiB0aGUgYXNzb2NpYXRlZCBpbnB1dCBlbGVtZW50LiBTaW5jZSB3ZSBhcmUgdXNpbmcgYSBsYWJlbCBlbGVtZW50IGFzIG91clxuICAgICAgICAvLyByb290IGNvbnRhaW5lciwgdGhlIGNsaWNrIGV2ZW50IG9uIHRoZSBgc2xpZGUtdG9nZ2xlYCB3aWxsIGJlIGV4ZWN1dGVkIHR3aWNlLlxuICAgICAgICAvLyBUaGUgcmVhbCBjbGljayBldmVudCB3aWxsIGJ1YmJsZSB1cCwgYW5kIHRoZSBnZW5lcmF0ZWQgY2xpY2sgZXZlbnQgYWxzbyB0cmllcyB0byBidWJibGUgdXAuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBsZWFkIHRvIG11bHRpcGxlIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgLy8gUHJldmVudGluZyBidWJibGluZyBmb3IgdGhlIHNlY29uZCBldmVudCB3aWxsIHNvbHZlIHRoYXQgaXNzdWUuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQxNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoKSxcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNignZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLCBcImlkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQxNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTYoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQxNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDE2KCdkZXNpZ246dHlwZScsIHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlKVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZSwgXCJjaGFuZ2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2NsYXNzLm1kLWJ1dHRvbi10b2dnbGUtY2hlY2tlZCcpLFxuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDE2KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLCBcImNoZWNrZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kQnV0dG9uVG9nZ2xlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnY2xhc3MubWQtYnV0dG9uLXRvZ2dsZS1kaXNhYmxlZCcpLFxuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDE2KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRCdXR0b25Ub2dnbGUucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuICAgIE1kQnV0dG9uVG9nZ2xlID0gX19kZWNvcmF0ZSQxNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLWJ1dHRvbi10b2dnbGUnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGxhYmVsIFthdHRyLmZvcl09XFxcImlucHV0SWRcXFwiIGNsYXNzPVxcXCJtZC1idXR0b24tdG9nZ2xlLWxhYmVsXFxcIj4gPGlucHV0ICNpbnB1dCBjbGFzcz1cXFwibWQtYnV0dG9uLXRvZ2dsZS1pbnB1dCBtZC12aXN1YWxseS1oaWRkZW5cXFwiIFt0eXBlXT1cXFwiX3R5cGVcXFwiIFtpZF09XFxcImlucHV0SWRcXFwiIFtjaGVja2VkXT1cXFwiY2hlY2tlZFxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiIFtuYW1lXT1cXFwibmFtZVxcXCIgKGNoYW5nZSk9XFxcIl9vbklucHV0Q2hhbmdlKCRldmVudClcXFwiIChjbGljayk9XFxcIl9vbklucHV0Q2xpY2soJGV2ZW50KVxcXCI+IDxkaXYgY2xhc3M9XFxcIm1kLWJ1dHRvbi10b2dnbGUtbGFiZWwtY29udGVudFxcXCI+IDxuZy1jb250ZW50PjwvbmctY29udGVudD4gPC9kaXY+IDwvbGFiZWw+IFwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCJtZC1idXR0b24tdG9nZ2xlLWdyb3VwIHsgYm94LXNoYWRvdzogMHB4IDNweCAxcHggLTJweCByZ2JhKDAsIDAsIDAsIDAuMiksIDBweCAycHggMnB4IDBweCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwcHggMXB4IDVweCAwcHggcmdiYSgwLCAwLCAwLCAwLjEyKTsgcG9zaXRpb246IHJlbGF0aXZlOyBkaXNwbGF5OiBpbmxpbmUtZmxleDsgYm9yZGVyLXJhZGl1czogM3B4OyBjdXJzb3I6IHBvaW50ZXI7IHdoaXRlLXNwYWNlOiBub3dyYXA7IH0gLm1kLWJ1dHRvbi10b2dnbGUtZGlzYWJsZWQgLm1kLWJ1dHRvbi10b2dnbGUtbGFiZWwtY29udGVudCB7IGN1cnNvcjogZGVmYXVsdDsgfSBtZC1idXR0b24tdG9nZ2xlIHsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgfSAubWQtYnV0dG9uLXRvZ2dsZS1sYWJlbC1jb250ZW50IHsgZGlzcGxheTogaW5saW5lLWJsb2NrOyBsaW5lLWhlaWdodDogMzZweDsgcGFkZGluZzogMCAxNnB4OyBjdXJzb3I6IHBvaW50ZXI7IH0gLm1kLWJ1dHRvbi10b2dnbGUtbGFiZWwtY29udGVudCA+ICogeyB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9IC8qIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvbi10b2dnbGUuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgIH0pLFxuICAgICAgICBfX3BhcmFtJDEoMCwgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSxcbiAgICAgICAgX19wYXJhbSQxKDEsIF9hbmd1bGFyX2NvcmUuT3B0aW9uYWwoKSksIFxuICAgICAgICBfX21ldGFkYXRhJDE2KCdkZXNpZ246cGFyYW10eXBlcycsIFtNZEJ1dHRvblRvZ2dsZUdyb3VwLCBNZEJ1dHRvblRvZ2dsZUdyb3VwTXVsdGlwbGUsIE1kVW5pcXVlU2VsZWN0aW9uRGlzcGF0Y2hlcl0pXG4gICAgXSwgTWRCdXR0b25Ub2dnbGUpO1xuICAgIHJldHVybiBNZEJ1dHRvblRvZ2dsZTtcbn0oKSk7XG52YXIgTWRCdXR0b25Ub2dnbGVNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQnV0dG9uVG9nZ2xlTW9kdWxlKCkge1xuICAgIH1cbiAgICBNZEJ1dHRvblRvZ2dsZU1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kQnV0dG9uVG9nZ2xlTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWRVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRCdXR0b25Ub2dnbGVNb2R1bGUgPSBfX2RlY29yYXRlJDE2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbX2FuZ3VsYXJfZm9ybXMuRm9ybXNNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW01kQnV0dG9uVG9nZ2xlR3JvdXAsIE1kQnV0dG9uVG9nZ2xlR3JvdXBNdWx0aXBsZSwgTWRCdXR0b25Ub2dnbGVdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRCdXR0b25Ub2dnbGVHcm91cCwgTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlLCBNZEJ1dHRvblRvZ2dsZV0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNignZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZEJ1dHRvblRvZ2dsZU1vZHVsZSk7XG4gICAgcmV0dXJuIE1kQnV0dG9uVG9nZ2xlTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZXh0ZW5kcyQ2ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBfX2RlY29yYXRlJDE3ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDE3ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vLyBUT0RPKGplbGJvdXJuKTogTWFrZSB0aGUgYGlzTW91c2VEb3duYCBzdHVmZiBkb25lIHdpdGggb25lIGdsb2JhbCBsaXN0ZW5lci5cbi8vIFRPRE8oa2FyYSk6IENvbnZlcnQgYXR0cmlidXRlIHNlbGVjdG9ycyB0byBjbGFzc2VzIHdoZW4gYXR0ciBtYXBzIGJlY29tZSBhdmFpbGFibGVcbnZhciBNZEJ1dHRvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRCdXR0b24oX2VsZW1lbnRSZWYsIF9yZW5kZXJlcikge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgYnV0dG9uIGhhcyBmb2N1cyBmcm9tIHRoZSBrZXlib2FyZCAobm90IHRoZSBtb3VzZSkuIFVzZWQgZm9yIGNsYXNzIGJpbmRpbmcuICovXG4gICAgICAgIHRoaXMuX2lzS2V5Ym9hcmRGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIC8qKiBXaGV0aGVyIGEgbW91c2Vkb3duIGhhcyBvY2N1cnJlZCBvbiB0aGlzIGVsZW1lbnQgaW4gdGhlIGxhc3QgMTAwbXMuICovXG4gICAgICAgIHRoaXMuX2lzTW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSByaXBwbGUgZWZmZWN0IG9uIGNsaWNrIHNob3VsZCBiZSBkaXNhYmxlZC4gKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlUmlwcGxlID0gZmFsc2U7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEJ1dHRvbi5wcm90b3R5cGUsIFwiY29sb3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRCdXR0b24ucHJvdG90eXBlLl9zZXRNb3VzZWRvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFdlIG9ubHkgKnNob3cqIHRoZSBmb2N1cyBzdHlsZSB3aGVuIGZvY3VzIGhhcyBjb21lIHRvIHRoZSBidXR0b24gdmlhIHRoZSBrZXlib2FyZC5cbiAgICAgICAgLy8gVGhlIE1hdGVyaWFsIERlc2lnbiBzcGVjIGlzIHNpbGVudCBvbiB0aGlzIHRvcGljLCBhbmQgd2l0aG91dCBkb2luZyB0aGlzLCB0aGVcbiAgICAgICAgLy8gYnV0dG9uIGNvbnRpbnVlcyB0byBsb29rIDphY3RpdmUgYWZ0ZXIgY2xpY2tpbmcuXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL21hcmN5c3V0dG9uLmNvbS9idXR0b24tZm9jdXMtaGVsbC9cbiAgICAgICAgdGhpcy5faXNNb3VzZURvd24gPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgX3RoaXMuX2lzTW91c2VEb3duID0gZmFsc2U7IH0sIDEwMCk7XG4gICAgfTtcbiAgICBNZEJ1dHRvbi5wcm90b3R5cGUuX3VwZGF0ZUNvbG9yID0gZnVuY3Rpb24gKG5ld0NvbG9yKSB7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRDb2xvcih0aGlzLl9jb2xvciwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50Q29sb3IobmV3Q29sb3IsIHRydWUpO1xuICAgICAgICB0aGlzLl9jb2xvciA9IG5ld0NvbG9yO1xuICAgIH07XG4gICAgTWRCdXR0b24ucHJvdG90eXBlLl9zZXRFbGVtZW50Q29sb3IgPSBmdW5jdGlvbiAoY29sb3IsIGlzQWRkKSB7XG4gICAgICAgIGlmIChjb2xvciAhPSBudWxsICYmIGNvbG9yICE9ICcnKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBcIm1kLVwiICsgY29sb3IsIGlzQWRkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRCdXR0b24ucHJvdG90eXBlLl9zZXRLZXlib2FyZEZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc0tleWJvYXJkRm9jdXNlZCA9ICF0aGlzLl9pc01vdXNlRG93bjtcbiAgICB9O1xuICAgIE1kQnV0dG9uLnByb3RvdHlwZS5fcmVtb3ZlS2V5Ym9hcmRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faXNLZXlib2FyZEZvY3VzZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIC8qKiBUT0RPKGhhbnNsKTogZTJlIHRlc3QgdGhpcyBmdW5jdGlvbi4gKi9cbiAgICBNZEJ1dHRvbi5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH07XG4gICAgTWRCdXR0b24ucHJvdG90eXBlLmdldEhvc3RFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH07XG4gICAgTWRCdXR0b24ucHJvdG90eXBlLmlzUm91bmRCdXR0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZSgnbWQtaWNvbi1idXR0b24nKSB8fFxuICAgICAgICAgICAgZWwuaGFzQXR0cmlidXRlKCdtZC1mYWInKSB8fFxuICAgICAgICAgICAgZWwuaGFzQXR0cmlidXRlKCdtZC1taW5pLWZhYicpO1xuICAgIH07XG4gICAgTWRCdXR0b24ucHJvdG90eXBlLmlzUmlwcGxlRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRpc2FibGVSaXBwbGU7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDE3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLFxuICAgICAgICBCb29sZWFuRmllbGRWYWx1ZSgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNygnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kQnV0dG9uLnByb3RvdHlwZSwgXCJkaXNhYmxlUmlwcGxlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQxNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTcoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kQnV0dG9uLnByb3RvdHlwZSwgXCJjb2xvclwiLCBudWxsKTtcbiAgICBNZEJ1dHRvbiA9IF9fZGVjb3JhdGUkMTcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdidXR0b25bbWQtYnV0dG9uXSwgYnV0dG9uW21kLXJhaXNlZC1idXR0b25dLCBidXR0b25bbWQtaWNvbi1idXR0b25dLCAnICtcbiAgICAgICAgICAgICAgICAnYnV0dG9uW21kLWZhYl0sIGJ1dHRvblttZC1taW5pLWZhYl0nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWQtYnV0dG9uLWZvY3VzXSc6ICdfaXNLZXlib2FyZEZvY3VzZWQnLFxuICAgICAgICAgICAgICAgICcobW91c2Vkb3duKSc6ICdfc2V0TW91c2Vkb3duKCknLFxuICAgICAgICAgICAgICAgICcoZm9jdXMpJzogJ19zZXRLZXlib2FyZEZvY3VzKCknLFxuICAgICAgICAgICAgICAgICcoYmx1ciknOiAnX3JlbW92ZUtleWJvYXJkRm9jdXMoKScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHNwYW4gY2xhc3M9XFxcIm1kLWJ1dHRvbi13cmFwcGVyXFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9zcGFuPiA8ZGl2IG1kLXJpcHBsZSAqbmdJZj1cXFwiaXNSaXBwbGVFbmFibGVkKClcXFwiIGNsYXNzPVxcXCJtZC1idXR0b24tcmlwcGxlXFxcIiBbY2xhc3MubWQtYnV0dG9uLXJpcHBsZS1yb3VuZF09XFxcImlzUm91bmRCdXR0b24oKVxcXCIgW21kLXJpcHBsZS10cmlnZ2VyXT1cXFwiZ2V0SG9zdEVsZW1lbnQoKVxcXCIgW21kLXJpcHBsZS1jb2xvcl09XFxcImlzUm91bmRCdXR0b24oKSA/ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMiknIDogJydcXFwiIG1kLXJpcHBsZS1iYWNrZ3JvdW5kLWNvbG9yPVxcXCJyZ2JhKDAsIDAsIDAsIDApXFxcIj48L2Rpdj4gXCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIlttZC1yYWlzZWQtYnV0dG9uXSwgW21kLWZhYl0sIFttZC1taW5pLWZhYl0sIFttZC1idXR0b25dLCBbbWQtaWNvbi1idXR0b25dIHsgYm94LXNpemluZzogYm9yZGVyLWJveDsgcG9zaXRpb246IHJlbGF0aXZlOyBjdXJzb3I6IHBvaW50ZXI7IHVzZXItc2VsZWN0OiBub25lOyBvdXRsaW5lOiBub25lOyBib3JkZXI6IG5vbmU7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgdGV4dC1kZWNvcmF0aW9uOiBub25lOyB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7IGZvbnQtc2l6ZTogMTRweDsgZm9udC1mYW1pbHk6IFJvYm90bywgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgc2Fucy1zZXJpZjsgZm9udC13ZWlnaHQ6IDUwMDsgY29sb3I6IGN1cnJlbnRDb2xvcjsgdGV4dC1hbGlnbjogY2VudGVyOyBtYXJnaW46IDA7IG1pbi13aWR0aDogODhweDsgbGluZS1oZWlnaHQ6IDM2cHg7IHBhZGRpbmc6IDAgMTZweDsgYm9yZGVyLXJhZGl1czogM3B4OyB9IFtkaXNhYmxlZF1bbWQtcmFpc2VkLWJ1dHRvbl0sIFtkaXNhYmxlZF1bbWQtZmFiXSwgW2Rpc2FibGVkXVttZC1taW5pLWZhYl0sIFtkaXNhYmxlZF1bbWQtYnV0dG9uXSwgW2Rpc2FibGVkXVttZC1pY29uLWJ1dHRvbl0geyBjdXJzb3I6IGRlZmF1bHQ7IH0gLm1kLWJ1dHRvbi1mb2N1c1ttZC1yYWlzZWQtYnV0dG9uXTo6YWZ0ZXIsIC5tZC1idXR0b24tZm9jdXNbbWQtZmFiXTo6YWZ0ZXIsIC5tZC1idXR0b24tZm9jdXNbbWQtbWluaS1mYWJdOjphZnRlciwgLm1kLWJ1dHRvbi1mb2N1c1ttZC1idXR0b25dOjphZnRlciwgLm1kLWJ1dHRvbi1mb2N1c1ttZC1pY29uLWJ1dHRvbl06OmFmdGVyIHsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IGJvdHRvbTogMDsgcmlnaHQ6IDA7IGNvbnRlbnQ6ICcnOyBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMTIpOyBib3JkZXItcmFkaXVzOiBpbmhlcml0OyBwb2ludGVyLWV2ZW50czogbm9uZTsgfSBbbWQtcmFpc2VkLWJ1dHRvbl0sIFttZC1mYWJdLCBbbWQtbWluaS1mYWJdIHsgYm94LXNoYWRvdzogMHB4IDNweCAxcHggLTJweCByZ2JhKDAsIDAsIDAsIDAuMiksIDBweCAycHggMnB4IDBweCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwcHggMXB4IDVweCAwcHggcmdiYSgwLCAwLCAwLCAwLjEyKTsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTsgdHJhbnNpdGlvbjogYmFja2dyb3VuZCA0MDBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKSwgYm94LXNoYWRvdyAyODBtcyBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpOyB9IFttZC1yYWlzZWQtYnV0dG9uXTphY3RpdmUsIFttZC1mYWJdOmFjdGl2ZSwgW21kLW1pbmktZmFiXTphY3RpdmUgeyBib3gtc2hhZG93OiAwcHggNXB4IDVweCAtM3B4IHJnYmEoMCwgMCwgMCwgMC4yKSwgMHB4IDhweCAxMHB4IDFweCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwcHggM3B4IDE0cHggMnB4IHJnYmEoMCwgMCwgMCwgMC4xMik7IH0gW2Rpc2FibGVkXVttZC1yYWlzZWQtYnV0dG9uXSwgW2Rpc2FibGVkXVttZC1mYWJdLCBbZGlzYWJsZWRdW21kLW1pbmktZmFiXSB7IGJveC1zaGFkb3c6IG5vbmU7IH0gW21kLWJ1dHRvbl06aG92ZXI6OmFmdGVyLCBbbWQtaWNvbi1idXR0b25dOmhvdmVyOjphZnRlciB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyBib3R0b206IDA7IHJpZ2h0OiAwOyBjb250ZW50OiAnJzsgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjEyKTsgYm9yZGVyLXJhZGl1czogaW5oZXJpdDsgcG9pbnRlci1ldmVudHM6IG5vbmU7IH0gW21kLWJ1dHRvbl1bZGlzYWJsZWRdOmhvdmVyLm1kLXByaW1hcnksIFttZC1idXR0b25dW2Rpc2FibGVkXTpob3Zlci5tZC1hY2NlbnQsIFttZC1idXR0b25dW2Rpc2FibGVkXTpob3Zlci5tZC13YXJuLCBbbWQtYnV0dG9uXVtkaXNhYmxlZF06aG92ZXI6OmFmdGVyLCBbbWQtaWNvbi1idXR0b25dW2Rpc2FibGVkXTpob3Zlci5tZC1wcmltYXJ5LCBbbWQtaWNvbi1idXR0b25dW2Rpc2FibGVkXTpob3Zlci5tZC1hY2NlbnQsIFttZC1pY29uLWJ1dHRvbl1bZGlzYWJsZWRdOmhvdmVyLm1kLXdhcm4sIFttZC1pY29uLWJ1dHRvbl1bZGlzYWJsZWRdOmhvdmVyOjphZnRlciB7IGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyB9IFttZC1mYWJdIHsgbWluLXdpZHRoOiAwOyBib3JkZXItcmFkaXVzOiA1MCU7IHdpZHRoOiA1NnB4OyBoZWlnaHQ6IDU2cHg7IHBhZGRpbmc6IDA7IH0gW21kLWZhYl0gaSwgW21kLWZhYl0gbWQtaWNvbiB7IHBhZGRpbmc6IDE2cHggMDsgfSBbbWQtbWluaS1mYWJdIHsgbWluLXdpZHRoOiAwOyBib3JkZXItcmFkaXVzOiA1MCU7IHdpZHRoOiA0MHB4OyBoZWlnaHQ6IDQwcHg7IHBhZGRpbmc6IDA7IH0gW21kLW1pbmktZmFiXSBpLCBbbWQtbWluaS1mYWJdIG1kLWljb24geyBwYWRkaW5nOiA4cHggMDsgfSBbbWQtaWNvbi1idXR0b25dIHsgbWluLXdpZHRoOiAwOyBwYWRkaW5nOiAwOyB3aWR0aDogNDBweDsgaGVpZ2h0OiA0MHB4OyBsaW5lLWhlaWdodDogMjRweDsgYm9yZGVyLXJhZGl1czogNTAlOyB9IFttZC1pY29uLWJ1dHRvbl0gLm1kLWJ1dHRvbi13cmFwcGVyID4gKiB7IHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IH0gLm1kLWJ1dHRvbi1yaXBwbGUgeyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgYm90dG9tOiAwOyByaWdodDogMDsgfSAubWQtYnV0dG9uLXJpcHBsZS1yb3VuZCB7IGJvcmRlci1yYWRpdXM6IDUwJTsgei1pbmRleDogMTsgfSBAbWVkaWEgc2NyZWVuIGFuZCAoLW1zLWhpZ2gtY29udHJhc3Q6IGFjdGl2ZSkgeyAubWQtcmFpc2VkLWJ1dHRvbiwgLm1kLWZhYiwgLm1kLW1pbmktZmFiIHsgYm9yZGVyOiAxcHggc29saWQgI2ZmZjsgfSB9IC8qIyBzb3VyY2VNYXBwaW5nVVJMPWJ1dHRvbi5jc3MubWFwICovIFwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNygnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBNZEJ1dHRvbik7XG4gICAgcmV0dXJuIE1kQnV0dG9uO1xufSgpKTtcbnZhciBNZEFuY2hvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDYoTWRBbmNob3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRBbmNob3IoZWxlbWVudFJlZiwgcmVuZGVyZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZWxlbWVudFJlZiwgcmVuZGVyZXIpO1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IG51bGw7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEFuY2hvci5wcm90b3R5cGUsIFwidGFiSW5kZXhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkID8gLTEgOiAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRBbmNob3IucHJvdG90eXBlLCBcImlzQXJpYURpc2FibGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEFuY2hvci5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2Rpc2FibGVkOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gVGhlIHByZXNlbmNlIG9mICphbnkqIGRpc2FibGVkIHZhbHVlIG1ha2VzIHRoZSBjb21wb25lbnQgZGlzYWJsZWQsICpleGNlcHQqIGZvciBmYWxzZS5cbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT0gZmFsc2UpID8gdHJ1ZSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kQW5jaG9yLnByb3RvdHlwZS5faGFsdERpc2FibGVkRXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEEgZGlzYWJsZWQgYnV0dG9uIHNob3VsZG4ndCBhcHBseSBhbnkgYWN0aW9uc1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDE3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygndGFiSW5kZXgnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTcoJ2Rlc2lnbjp0eXBlJywgTnVtYmVyKVxuICAgIF0sIE1kQW5jaG9yLnByb3RvdHlwZSwgXCJ0YWJJbmRleFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnYXR0ci5hcmlhLWRpc2FibGVkJyksIFxuICAgICAgICBfX21ldGFkYXRhJDE3KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZEFuY2hvci5wcm90b3R5cGUsIFwiaXNBcmlhRGlzYWJsZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2F0dHIuZGlzYWJsZWQnKSxcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZGlzYWJsZWQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTcoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kQW5jaG9yLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbiAgICBNZEFuY2hvciA9IF9fZGVjb3JhdGUkMTcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdhW21kLWJ1dHRvbl0sIGFbbWQtcmFpc2VkLWJ1dHRvbl0sIGFbbWQtaWNvbi1idXR0b25dLCBhW21kLWZhYl0sIGFbbWQtbWluaS1mYWJdJyxcbiAgICAgICAgICAgIGlucHV0czogWydjb2xvciddLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdbY2xhc3MubWQtYnV0dG9uLWZvY3VzXSc6ICdfaXNLZXlib2FyZEZvY3VzZWQnLFxuICAgICAgICAgICAgICAgICcobW91c2Vkb3duKSc6ICdfc2V0TW91c2Vkb3duKCknLFxuICAgICAgICAgICAgICAgICcoZm9jdXMpJzogJ19zZXRLZXlib2FyZEZvY3VzKCknLFxuICAgICAgICAgICAgICAgICcoYmx1ciknOiAnX3JlbW92ZUtleWJvYXJkRm9jdXMoKScsXG4gICAgICAgICAgICAgICAgJyhjbGljayknOiAnX2hhbHREaXNhYmxlZEV2ZW50cygkZXZlbnQpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8c3BhbiBjbGFzcz1cXFwibWQtYnV0dG9uLXdyYXBwZXJcXFwiPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L3NwYW4+IDxkaXYgbWQtcmlwcGxlICpuZ0lmPVxcXCJpc1JpcHBsZUVuYWJsZWQoKVxcXCIgY2xhc3M9XFxcIm1kLWJ1dHRvbi1yaXBwbGVcXFwiIFtjbGFzcy5tZC1idXR0b24tcmlwcGxlLXJvdW5kXT1cXFwiaXNSb3VuZEJ1dHRvbigpXFxcIiBbbWQtcmlwcGxlLXRyaWdnZXJdPVxcXCJnZXRIb3N0RWxlbWVudCgpXFxcIiBbbWQtcmlwcGxlLWNvbG9yXT1cXFwiaXNSb3VuZEJ1dHRvbigpID8gJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4yKScgOiAnJ1xcXCIgbWQtcmlwcGxlLWJhY2tncm91bmQtY29sb3I9XFxcInJnYmEoMCwgMCwgMCwgMClcXFwiPjwvZGl2PiBcIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiW21kLXJhaXNlZC1idXR0b25dLCBbbWQtZmFiXSwgW21kLW1pbmktZmFiXSwgW21kLWJ1dHRvbl0sIFttZC1pY29uLWJ1dHRvbl0geyBib3gtc2l6aW5nOiBib3JkZXItYm94OyBwb3NpdGlvbjogcmVsYXRpdmU7IGN1cnNvcjogcG9pbnRlcjsgdXNlci1zZWxlY3Q6IG5vbmU7IG91dGxpbmU6IG5vbmU7IGJvcmRlcjogbm9uZTsgZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aGl0ZS1zcGFjZTogbm93cmFwOyB0ZXh0LWRlY29yYXRpb246IG5vbmU7IHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTsgZm9udC1zaXplOiAxNHB4OyBmb250LWZhbWlseTogUm9ib3RvLCBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBzYW5zLXNlcmlmOyBmb250LXdlaWdodDogNTAwOyBjb2xvcjogY3VycmVudENvbG9yOyB0ZXh0LWFsaWduOiBjZW50ZXI7IG1hcmdpbjogMDsgbWluLXdpZHRoOiA4OHB4OyBsaW5lLWhlaWdodDogMzZweDsgcGFkZGluZzogMCAxNnB4OyBib3JkZXItcmFkaXVzOiAzcHg7IH0gW2Rpc2FibGVkXVttZC1yYWlzZWQtYnV0dG9uXSwgW2Rpc2FibGVkXVttZC1mYWJdLCBbZGlzYWJsZWRdW21kLW1pbmktZmFiXSwgW2Rpc2FibGVkXVttZC1idXR0b25dLCBbZGlzYWJsZWRdW21kLWljb24tYnV0dG9uXSB7IGN1cnNvcjogZGVmYXVsdDsgfSAubWQtYnV0dG9uLWZvY3VzW21kLXJhaXNlZC1idXR0b25dOjphZnRlciwgLm1kLWJ1dHRvbi1mb2N1c1ttZC1mYWJdOjphZnRlciwgLm1kLWJ1dHRvbi1mb2N1c1ttZC1taW5pLWZhYl06OmFmdGVyLCAubWQtYnV0dG9uLWZvY3VzW21kLWJ1dHRvbl06OmFmdGVyLCAubWQtYnV0dG9uLWZvY3VzW21kLWljb24tYnV0dG9uXTo6YWZ0ZXIgeyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgYm90dG9tOiAwOyByaWdodDogMDsgY29udGVudDogJyc7IGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4xMik7IGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7IHBvaW50ZXItZXZlbnRzOiBub25lOyB9IFttZC1yYWlzZWQtYnV0dG9uXSwgW21kLWZhYl0sIFttZC1taW5pLWZhYl0geyBib3gtc2hhZG93OiAwcHggM3B4IDFweCAtMnB4IHJnYmEoMCwgMCwgMCwgMC4yKSwgMHB4IDJweCAycHggMHB4IHJnYmEoMCwgMCwgMCwgMC4xNCksIDBweCAxcHggNXB4IDBweCByZ2JhKDAsIDAsIDAsIDAuMTIpOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApOyB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDQwMG1zIGN1YmljLWJlemllcigwLjI1LCAwLjgsIDAuMjUsIDEpLCBib3gtc2hhZG93IDI4MG1zIGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7IH0gW21kLXJhaXNlZC1idXR0b25dOmFjdGl2ZSwgW21kLWZhYl06YWN0aXZlLCBbbWQtbWluaS1mYWJdOmFjdGl2ZSB7IGJveC1zaGFkb3c6IDBweCA1cHggNXB4IC0zcHggcmdiYSgwLCAwLCAwLCAwLjIpLCAwcHggOHB4IDEwcHggMXB4IHJnYmEoMCwgMCwgMCwgMC4xNCksIDBweCAzcHggMTRweCAycHggcmdiYSgwLCAwLCAwLCAwLjEyKTsgfSBbZGlzYWJsZWRdW21kLXJhaXNlZC1idXR0b25dLCBbZGlzYWJsZWRdW21kLWZhYl0sIFtkaXNhYmxlZF1bbWQtbWluaS1mYWJdIHsgYm94LXNoYWRvdzogbm9uZTsgfSBbbWQtYnV0dG9uXTpob3Zlcjo6YWZ0ZXIsIFttZC1pY29uLWJ1dHRvbl06aG92ZXI6OmFmdGVyIHsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IGJvdHRvbTogMDsgcmlnaHQ6IDA7IGNvbnRlbnQ6ICcnOyBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMTIpOyBib3JkZXItcmFkaXVzOiBpbmhlcml0OyBwb2ludGVyLWV2ZW50czogbm9uZTsgfSBbbWQtYnV0dG9uXVtkaXNhYmxlZF06aG92ZXIubWQtcHJpbWFyeSwgW21kLWJ1dHRvbl1bZGlzYWJsZWRdOmhvdmVyLm1kLWFjY2VudCwgW21kLWJ1dHRvbl1bZGlzYWJsZWRdOmhvdmVyLm1kLXdhcm4sIFttZC1idXR0b25dW2Rpc2FibGVkXTpob3Zlcjo6YWZ0ZXIsIFttZC1pY29uLWJ1dHRvbl1bZGlzYWJsZWRdOmhvdmVyLm1kLXByaW1hcnksIFttZC1pY29uLWJ1dHRvbl1bZGlzYWJsZWRdOmhvdmVyLm1kLWFjY2VudCwgW21kLWljb24tYnV0dG9uXVtkaXNhYmxlZF06aG92ZXIubWQtd2FybiwgW21kLWljb24tYnV0dG9uXVtkaXNhYmxlZF06aG92ZXI6OmFmdGVyIHsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IH0gW21kLWZhYl0geyBtaW4td2lkdGg6IDA7IGJvcmRlci1yYWRpdXM6IDUwJTsgd2lkdGg6IDU2cHg7IGhlaWdodDogNTZweDsgcGFkZGluZzogMDsgfSBbbWQtZmFiXSBpLCBbbWQtZmFiXSBtZC1pY29uIHsgcGFkZGluZzogMTZweCAwOyB9IFttZC1taW5pLWZhYl0geyBtaW4td2lkdGg6IDA7IGJvcmRlci1yYWRpdXM6IDUwJTsgd2lkdGg6IDQwcHg7IGhlaWdodDogNDBweDsgcGFkZGluZzogMDsgfSBbbWQtbWluaS1mYWJdIGksIFttZC1taW5pLWZhYl0gbWQtaWNvbiB7IHBhZGRpbmc6IDhweCAwOyB9IFttZC1pY29uLWJ1dHRvbl0geyBtaW4td2lkdGg6IDA7IHBhZGRpbmc6IDA7IHdpZHRoOiA0MHB4OyBoZWlnaHQ6IDQwcHg7IGxpbmUtaGVpZ2h0OiAyNHB4OyBib3JkZXItcmFkaXVzOiA1MCU7IH0gW21kLWljb24tYnV0dG9uXSAubWQtYnV0dG9uLXdyYXBwZXIgPiAqIHsgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgfSAubWQtYnV0dG9uLXJpcHBsZSB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyBsZWZ0OiAwOyBib3R0b206IDA7IHJpZ2h0OiAwOyB9IC5tZC1idXR0b24tcmlwcGxlLXJvdW5kIHsgYm9yZGVyLXJhZGl1czogNTAlOyB6LWluZGV4OiAxOyB9IEBtZWRpYSBzY3JlZW4gYW5kICgtbXMtaGlnaC1jb250cmFzdDogYWN0aXZlKSB7IC5tZC1yYWlzZWQtYnV0dG9uLCAubWQtZmFiLCAubWQtbWluaS1mYWIgeyBib3JkZXI6IDFweCBzb2xpZCAjZmZmOyB9IH0gLyojIHNvdXJjZU1hcHBpbmdVUkw9YnV0dG9uLmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNygnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBNZEFuY2hvcik7XG4gICAgcmV0dXJuIE1kQW5jaG9yO1xufShNZEJ1dHRvbikpO1xudmFyIE1kQnV0dG9uTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEJ1dHRvbk1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWRCdXR0b25Nb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZEJ1dHRvbk1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kQnV0dG9uTW9kdWxlID0gX19kZWNvcmF0ZSQxNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW19hbmd1bGFyX2NvbW1vbi5Db21tb25Nb2R1bGUsIE1kUmlwcGxlTW9kdWxlXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNZEJ1dHRvbiwgTWRBbmNob3JdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRCdXR0b24sIE1kQW5jaG9yXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDE3KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQnV0dG9uTW9kdWxlKTtcbiAgICByZXR1cm4gTWRCdXR0b25Nb2R1bGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQxOCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxOCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBNb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgaW50ZWdlciB1c2VkIHRvIGF1dG8tZ2VuZXJhdGUgdW5pcXVlIGlkcyBmb3IgY2hlY2tib3ggY29tcG9uZW50cy5cbiAqL1xudmFyIG5leHRJZCA9IDA7XG4vKipcbiAqIFByb3ZpZGVyIEV4cHJlc3Npb24gdGhhdCBhbGxvd3MgbWQtY2hlY2tib3ggdG8gcmVnaXN0ZXIgYXMgYSBDb250cm9sVmFsdWVBY2Nlc3Nvci4gVGhpcyBhbGxvd3MgaXRcbiAqIHRvIHN1cHBvcnQgWyhuZ01vZGVsKV0uXG4gKi9cbnZhciBNRF9DSEVDS0JPWF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IF9hbmd1bGFyX2Zvcm1zLk5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWRDaGVja2JveDsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGRpZmZlcmVudCBzdGF0ZXMgdGhhdCByZXF1aXJlIGN1c3RvbSB0cmFuc2l0aW9ucyBiZXR3ZWVuIHRoZW0uXG4gKi9cbihmdW5jdGlvbiAoVHJhbnNpdGlvbkNoZWNrU3RhdGUpIHtcbiAgICAvKiogVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIGNvbXBvbmVudCBiZWZvcmUgYW55IHVzZXIgaW50ZXJhY3Rpb24uICovXG4gICAgVHJhbnNpdGlvbkNoZWNrU3RhdGVbVHJhbnNpdGlvbkNoZWNrU3RhdGVbXCJJbml0XCJdID0gMF0gPSBcIkluaXRcIjtcbiAgICAvKiogVGhlIHN0YXRlIHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50IHdoZW4gaXQncyBiZWNvbWluZyBjaGVja2VkLiAqL1xuICAgIFRyYW5zaXRpb25DaGVja1N0YXRlW1RyYW5zaXRpb25DaGVja1N0YXRlW1wiQ2hlY2tlZFwiXSA9IDFdID0gXCJDaGVja2VkXCI7XG4gICAgLyoqIFRoZSBzdGF0ZSByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudCB3aGVuIGl0J3MgYmVjb21pbmcgdW5jaGVja2VkLiAqL1xuICAgIFRyYW5zaXRpb25DaGVja1N0YXRlW1RyYW5zaXRpb25DaGVja1N0YXRlW1wiVW5jaGVja2VkXCJdID0gMl0gPSBcIlVuY2hlY2tlZFwiO1xuICAgIC8qKiBUaGUgc3RhdGUgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQgd2hlbiBpdCdzIGJlY29taW5nIGluZGV0ZXJtaW5hdGUuICovXG4gICAgVHJhbnNpdGlvbkNoZWNrU3RhdGVbVHJhbnNpdGlvbkNoZWNrU3RhdGVbXCJJbmRldGVybWluYXRlXCJdID0gM10gPSBcIkluZGV0ZXJtaW5hdGVcIjtcbn0pKGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUgfHwgKGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUgPSB7fSkpO1xuLy8gQSBzaW1wbGUgY2hhbmdlIGV2ZW50IGVtaXR0ZWQgYnkgdGhlIE1kQ2hlY2tib3ggY29tcG9uZW50LlxudmFyIE1kQ2hlY2tib3hDaGFuZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2hlY2tib3hDaGFuZ2UoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZENoZWNrYm94Q2hhbmdlO1xufSgpKTtcbi8qKlxuICogQSBtYXRlcmlhbCBkZXNpZ24gY2hlY2tib3ggY29tcG9uZW50LiBTdXBwb3J0cyBhbGwgb2YgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYW4gSFRNTDUgY2hlY2tib3gsXG4gKiBhbmQgZXhwb3NlcyBhIHNpbWlsYXIgQVBJLiBBbiBNZENoZWNrYm94IGNhbiBiZSBlaXRoZXIgY2hlY2tlZCwgdW5jaGVja2VkLCBpbmRldGVybWluYXRlLCBvclxuICogZGlzYWJsZWQuIE5vdGUgdGhhdCBhbGwgYWRkaXRpb25hbCBhY2Nlc3NpYmlsaXR5IGF0dHJpYnV0ZXMgYXJlIHRha2VuIGNhcmUgb2YgYnkgdGhlIGNvbXBvbmVudCxcbiAqIHNvIHRoZXJlIGlzIG5vIG5lZWQgdG8gcHJvdmlkZSB0aGVtIHlvdXJzZWxmLiBIb3dldmVyLCBpZiB5b3Ugd2FudCB0byBvbWl0IGEgbGFiZWwgYW5kIHN0aWxsXG4gKiBoYXZlIHRoZSBjaGVja2JveCBiZSBhY2Nlc3NpYmxlLCB5b3UgbWF5IHN1cHBseSBhbiBbYXJpYS1sYWJlbF0gaW5wdXQuXG4gKiBTZWU6IGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvY29tcG9uZW50cy9zZWxlY3Rpb24tY29udHJvbHMuaHRtbFxuICovXG52YXIgTWRDaGVja2JveCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDaGVja2JveChfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2hlZCB0byB0aGUgYXJpYS1sYWJlbCBhdHRyaWJ1dGUgb2YgdGhlIGhvc3QgZWxlbWVudC4gSW4gbW9zdCBjYXNlcywgYXJpYWwtbGFiZWxsZWRieSB3aWxsXG4gICAgICAgICAqIHRha2UgcHJlY2VkZW5jZSBzbyB0aGlzIG1heSBiZSBvbWl0dGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hcmlhTGFiZWwgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZXJzIGNhbiBzcGVjaWZ5IHRoZSBgYXJpYS1sYWJlbGxlZGJ5YCBhdHRyaWJ1dGUgd2hpY2ggd2lsbCBiZSBmb3J3YXJkZWQgdG8gdGhlIGlucHV0IGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXJpYUxhYmVsbGVkYnkgPSBudWxsO1xuICAgICAgICAvKiogQSB1bmlxdWUgaWQgZm9yIHRoZSBjaGVja2JveC4gSWYgb25lIGlzIG5vdCBzdXBwbGllZCwgaXQgaXMgYXV0by1nZW5lcmF0ZWQuICovXG4gICAgICAgIHRoaXMuaWQgPSBcIm1kLWNoZWNrYm94LVwiICsgKytuZXh0SWQ7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBjaGVja2JveCBpcyByZXF1aXJlZCBvciBub3QuICovXG4gICAgICAgIHRoaXMucmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIFdoZXRoZXIgb3Igbm90IHRoZSBjaGVja2JveCBzaG91bGQgY29tZSBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGxhYmVsLiAqL1xuICAgICAgICB0aGlzLmFsaWduID0gJ3N0YXJ0JztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGRpc2FibGVkLiBXaGVuIHRoZSBjaGVja2JveCBpcyBkaXNhYmxlZCBpdCBjYW5ub3QgYmUgaW50ZXJhY3RlZCB3aXRoLlxuICAgICAgICAgKiBUaGUgY29ycmVjdCBBUklBIGF0dHJpYnV0ZXMgYXJlIGFwcGxpZWQgdG8gZGVub3RlIHRoaXMgdG8gYXNzaXN0aXZlIHRlY2hub2xvZ3kuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGFiaW5kZXggYXR0cmlidXRlIGZvciB0aGUgY2hlY2tib3guIE5vdGUgdGhhdCB3aGVuIHRoZSBjaGVja2JveCBpcyBkaXNhYmxlZCwgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgKiBvbiB0aGUgaG9zdCBlbGVtZW50IHdpbGwgYmUgcmVtb3ZlZC4gSXQgd2lsbCBiZSBwbGFjZWQgYmFjayB3aGVuIHRoZSBjaGVja2JveCBpcyByZS1lbmFibGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWJpbmRleCA9IDA7XG4gICAgICAgIC8qKiBOYW1lIHZhbHVlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgaW5wdXQgZWxlbWVudCBpZiBwcmVzZW50ICovXG4gICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGNoZWNrYm94J3MgYGNoZWNrZWRgIHZhbHVlIGNoYW5nZXMuICovXG4gICAgICAgIHRoaXMuY2hhbmdlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBDYWxsZWQgd2hlbiB0aGUgY2hlY2tib3ggaXMgYmx1cnJlZC4gTmVlZGVkIHRvIHByb3Blcmx5IGltcGxlbWVudCBDb250cm9sVmFsdWVBY2Nlc3Nvci4gKi9cbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIHRoaXMuX2N1cnJlbnRBbmltYXRpb25DbGFzcyA9ICcnO1xuICAgICAgICB0aGlzLl9jdXJyZW50Q2hlY2tTdGF0ZSA9IGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUuSW5pdDtcbiAgICAgICAgdGhpcy5fY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbmRldGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmdW5jdGlvbiAodmFsdWUpIHsgfTtcbiAgICAgICAgdGhpcy5oYXNGb2N1cyA9IGZhbHNlO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRDaGVja2JveC5wcm90b3R5cGUsIFwiaW5wdXRJZFwiLCB7XG4gICAgICAgIC8qKiBJRCB0byBiZSBhcHBsaWVkIHRvIHRoZSBgaW5wdXRgIGVsZW1lbnQgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJpbnB1dC1cIiArIHRoaXMuaWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZENoZWNrYm94LnByb3RvdHlwZSwgXCJjaGVja2VkXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNoZWNrYm94IGlzIGNoZWNrZWQuIE5vdGUgdGhhdCBzZXR0aW5nIGBjaGVja2VkYCB3aWxsIGltbWVkaWF0ZWx5IHNldFxuICAgICAgICAgKiBgaW5kZXRlcm1pbmF0ZWAgdG8gZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGVja2VkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChjaGVja2VkKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tlZCAhPSB0aGlzLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmRldGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tlZCA9IGNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkNoZWNrU3RhdGUodGhpcy5fY2hlY2tlZCA/IGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUuQ2hlY2tlZCA6IGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUuVW5jaGVja2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImluZGV0ZXJtaW5hdGVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY2hlY2tib3ggaXMgaW5kZXRlcm1pbmF0ZS4gVGhpcyBpcyBhbHNvIGtub3duIGFzIFwibWl4ZWRcIiBtb2RlIGFuZCBjYW4gYmUgdXNlZCB0b1xuICAgICAgICAgKiByZXByZXNlbnQgYSBjaGVja2JveCB3aXRoIHRocmVlIHN0YXRlcywgZS5nLiBhIGNoZWNrYm94IHRoYXQgcmVwcmVzZW50cyBhIG5lc3RlZCBsaXN0IG9mXG4gICAgICAgICAqIGNoZWNrYWJsZSBpdGVtcy4gTm90ZSB0aGF0IHdoZW5ldmVyIGBjaGVja2VkYCBpcyBzZXQsIGluZGV0ZXJtaW5hdGUgaXMgaW1tZWRpYXRlbHkgc2V0IHRvXG4gICAgICAgICAqIGZhbHNlLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgd2ViIHBsYXRmb3JtIGluIHRoYXQgaW5kZXRlcm1pbmF0ZSBzdGF0ZSBvbiBuYXRpdmVcbiAgICAgICAgICogY2hlY2tib3hlcyBpcyBvbmx5IHJlbW92ZSB3aGVuIHRoZSB1c2VyIG1hbnVhbGx5IGNoZWNrcyB0aGUgY2hlY2tib3ggKHJhdGhlciB0aGFuIHNldHRpbmcgdGhlXG4gICAgICAgICAqIGBjaGVja2VkYCBwcm9wZXJ0eSBwcm9ncmFtbWF0aWNhbGx5KS4gSG93ZXZlciwgd2UgZmVlbCB0aGF0IHRoaXMgYmVoYXZpb3IgaXMgbW9yZSBhY2NvbW1vZGF0aW5nXG4gICAgICAgICAqIHRvIHRoZSB3YXkgY29uc3VtZXJzIHdvdWxkIGVudmlzaW9uIHVzaW5nIHRoaXMgY29tcG9uZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5kZXRlcm1pbmF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoaW5kZXRlcm1pbmF0ZSkge1xuICAgICAgICAgICAgdGhpcy5faW5kZXRlcm1pbmF0ZSA9IGluZGV0ZXJtaW5hdGU7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5kZXRlcm1pbmF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25DaGVja1N0YXRlKGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUuSW5kZXRlcm1pbmF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uQ2hlY2tTdGF0ZSh0aGlzLmNoZWNrZWQgPyBleHBvcnRzLlRyYW5zaXRpb25DaGVja1N0YXRlLkNoZWNrZWQgOiBleHBvcnRzLlRyYW5zaXRpb25DaGVja1N0YXRlLlVuY2hlY2tlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogVE9ETzogaW50ZXJuYWxcbiAgICAgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9ICEhdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIFRPRE86IGludGVybmFsXG4gICAgICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuID0gZm47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIFRPRE86IGludGVybmFsXG4gICAgICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLl90cmFuc2l0aW9uQ2hlY2tTdGF0ZSA9IGZ1bmN0aW9uIChuZXdTdGF0ZSkge1xuICAgICAgICB2YXIgb2xkU3RhdGUgPSB0aGlzLl9jdXJyZW50Q2hlY2tTdGF0ZTtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG4gICAgICAgIHZhciBlbGVtZW50UmVmID0gdGhpcy5fZWxlbWVudFJlZjtcbiAgICAgICAgaWYgKG9sZFN0YXRlID09PSBuZXdTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50QW5pbWF0aW9uQ2xhc3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgdGhpcy5fY3VycmVudEFuaW1hdGlvbkNsYXNzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3VycmVudEFuaW1hdGlvbkNsYXNzID0gdGhpcy5fZ2V0QW5pbWF0aW9uQ2xhc3NGb3JDaGVja1N0YXRlVHJhbnNpdGlvbihvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICB0aGlzLl9jdXJyZW50Q2hlY2tTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEFuaW1hdGlvbkNsYXNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyhlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRoaXMuX2N1cnJlbnRBbmltYXRpb25DbGFzcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLl9lbWl0Q2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBNZENoZWNrYm94Q2hhbmdlKCk7XG4gICAgICAgIGV2ZW50LnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIGV2ZW50LmNoZWNrZWQgPSB0aGlzLmNoZWNrZWQ7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4odGhpcy5jaGVja2VkKTtcbiAgICAgICAgdGhpcy5jaGFuZ2UuZW1pdChldmVudCk7XG4gICAgfTtcbiAgICAvKiogSW5mb3JtcyB0aGUgY29tcG9uZW50IHdoZW4gdGhlIGlucHV0IGhhcyBmb2N1cyBzbyB0aGF0IHdlIGNhbiBzdHlsZSBhY2NvcmRpbmdseSAqL1xuICAgIE1kQ2hlY2tib3gucHJvdG90eXBlLl9vbklucHV0Rm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzRm9jdXMgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqIEluZm9ybXMgdGhlIGNvbXBvbmVudCB3aGVuIHdlIGxvc2UgZm9jdXMgaW4gb3JkZXIgdG8gc3R5bGUgYWNjb3JkaW5nbHkgKi9cbiAgICBNZENoZWNrYm94LnByb3RvdHlwZS5fb25JbnB1dEJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGBjaGVja2VkYCB2YWx1ZSBiZXR3ZWVuIHRydWUgYW5kIGZhbHNlXG4gICAgICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSAhdGhpcy5jaGVja2VkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRXZlbnQgaGFuZGxlciBmb3IgY2hlY2tib3ggaW5wdXQgZWxlbWVudC5cbiAgICAgKiBUb2dnbGVzIGNoZWNrZWQgc3RhdGUgaWYgZWxlbWVudCBpcyBub3QgZGlzYWJsZWQuXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICovXG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX29uSW50ZXJhY3Rpb25FdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBXZSBhbHdheXMgaGF2ZSB0byBzdG9wIHByb3BhZ2F0aW9uIG9uIHRoZSBjaGFuZ2UgZXZlbnQuXG4gICAgICAgIC8vIE90aGVyd2lzZSB0aGUgY2hhbmdlIGV2ZW50LCBmcm9tIHRoZSBpbnB1dCBlbGVtZW50LCB3aWxsIGJ1YmJsZSB1cCBhbmRcbiAgICAgICAgLy8gZW1pdCBpdHMgZXZlbnQgb2JqZWN0IHRvIHRoZSBgY2hhbmdlYCBvdXRwdXQuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgICAvLyBFbWl0IG91ciBjdXN0b20gY2hhbmdlIGV2ZW50IGlmIHRoZSBuYXRpdmUgaW5wdXQgZW1pdHRlZCBvbmUuXG4gICAgICAgICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gb25seSBlbWl0IGl0LCBpZiB0aGUgbmF0aXZlIGlucHV0IHRyaWdnZXJlZCBvbmUsIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciBhIGNoYW5nZSBldmVudCwgd2hlbiB0aGUgYGNoZWNrZWRgIHZhcmlhYmxlIGNoYW5nZXMgZm9yIGV4YW1wbGUuXG4gICAgICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX29uSW5wdXRDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBXZSBoYXZlIHRvIHN0b3AgcHJvcGFnYXRpb24gZm9yIGNsaWNrIGV2ZW50cyBvbiB0aGUgdmlzdWFsIGhpZGRlbiBpbnB1dCBlbGVtZW50LlxuICAgICAgICAvLyBCeSBkZWZhdWx0LCB3aGVuIGEgdXNlciBjbGlja3Mgb24gYSBsYWJlbCBlbGVtZW50LCBhIGdlbmVyYXRlZCBjbGljayBldmVudCB3aWxsIGJlXG4gICAgICAgIC8vIGRpc3BhdGNoZWQgb24gdGhlIGFzc29jaWF0ZWQgaW5wdXQgZWxlbWVudC4gU2luY2Ugd2UgYXJlIHVzaW5nIGEgbGFiZWwgZWxlbWVudCBhcyBvdXJcbiAgICAgICAgLy8gcm9vdCBjb250YWluZXIsIHRoZSBjbGljayBldmVudCBvbiB0aGUgYGNoZWNrYm94YCB3aWxsIGJlIGV4ZWN1dGVkIHR3aWNlLlxuICAgICAgICAvLyBUaGUgcmVhbCBjbGljayBldmVudCB3aWxsIGJ1YmJsZSB1cCwgYW5kIHRoZSBnZW5lcmF0ZWQgY2xpY2sgZXZlbnQgYWxzbyB0cmllcyB0byBidWJibGUgdXAuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBsZWFkIHRvIG11bHRpcGxlIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgLy8gUHJldmVudGluZyBidWJibGluZyBmb3IgdGhlIHNlY29uZCBldmVudCB3aWxsIHNvbHZlIHRoYXQgaXNzdWUuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgTWRDaGVja2JveC5wcm90b3R5cGUuX2dldEFuaW1hdGlvbkNsYXNzRm9yQ2hlY2tTdGF0ZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgICAgIHZhciBhbmltU3VmZml4O1xuICAgICAgICBzd2l0Y2ggKG9sZFN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUuSW5pdDpcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZWRnZSBjYXNlIHdoZXJlIHVzZXIgaW50ZXJhY3RzIHdpdGggY2hlY2tib3ggdGhhdCBkb2VzIG5vdCBoYXZlIFsobmdNb2RlbCldIG9yXG4gICAgICAgICAgICAgICAgLy8gW2NoZWNrZWRdIGJvdW5kIHRvIGl0LlxuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gZXhwb3J0cy5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5DaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1TdWZmaXggPSAndW5jaGVja2VkLWNoZWNrZWQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5VbmNoZWNrZWQ6XG4gICAgICAgICAgICAgICAgYW5pbVN1ZmZpeCA9IG5ld1N0YXRlID09PSBleHBvcnRzLlRyYW5zaXRpb25DaGVja1N0YXRlLkNoZWNrZWQgP1xuICAgICAgICAgICAgICAgICAgICAndW5jaGVja2VkLWNoZWNrZWQnIDogJ3VuY2hlY2tlZC1pbmRldGVybWluYXRlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5DaGVja2VkOlxuICAgICAgICAgICAgICAgIGFuaW1TdWZmaXggPSBuZXdTdGF0ZSA9PT0gZXhwb3J0cy5UcmFuc2l0aW9uQ2hlY2tTdGF0ZS5VbmNoZWNrZWQgP1xuICAgICAgICAgICAgICAgICAgICAnY2hlY2tlZC11bmNoZWNrZWQnIDogJ2NoZWNrZWQtaW5kZXRlcm1pbmF0ZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUuSW5kZXRlcm1pbmF0ZTpcbiAgICAgICAgICAgICAgICBhbmltU3VmZml4ID0gbmV3U3RhdGUgPT09IGV4cG9ydHMuVHJhbnNpdGlvbkNoZWNrU3RhdGUuQ2hlY2tlZCA/XG4gICAgICAgICAgICAgICAgICAgICdpbmRldGVybWluYXRlLWNoZWNrZWQnIDogJ2luZGV0ZXJtaW5hdGUtdW5jaGVja2VkJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJtZC1jaGVja2JveC1hbmltLVwiICsgYW5pbVN1ZmZpeDtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMTgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdhcmlhLWxhYmVsJyksIFxuICAgICAgICBfX21ldGFkYXRhJDE4KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZENoZWNrYm94LnByb3RvdHlwZSwgXCJhcmlhTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDE4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnYXJpYS1sYWJlbGxlZGJ5JyksIFxuICAgICAgICBfX21ldGFkYXRhJDE4KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZENoZWNrYm94LnByb3RvdHlwZSwgXCJhcmlhTGFiZWxsZWRieVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMTgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDE4KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZENoZWNrYm94LnByb3RvdHlwZSwgXCJpZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMTgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksXG4gICAgICAgIEJvb2xlYW5GaWVsZFZhbHVlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDE4KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRDaGVja2JveC5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDE4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxOCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRDaGVja2JveC5wcm90b3R5cGUsIFwiYWxpZ25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDE4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxOCgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQxOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTgoJ2Rlc2lnbjp0eXBlJywgTnVtYmVyKVxuICAgIF0sIE1kQ2hlY2tib3gucHJvdG90eXBlLCBcInRhYmluZGV4XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQxOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTgoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kQ2hlY2tib3gucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDE4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTgoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIpXG4gICAgXSwgTWRDaGVja2JveC5wcm90b3R5cGUsIFwiY2hhbmdlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQxOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTgoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImNoZWNrZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTgoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kQ2hlY2tib3gucHJvdG90eXBlLCBcImluZGV0ZXJtaW5hdGVcIiwgbnVsbCk7XG4gICAgTWRDaGVja2JveCA9IF9fZGVjb3JhdGUkMTgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1jaGVja2JveCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bGFiZWwgY2xhc3M9XFxcIm1kLWNoZWNrYm94LWxheW91dFxcXCI+IDxkaXYgY2xhc3M9XFxcIm1kLWNoZWNrYm94LWlubmVyLWNvbnRhaW5lclxcXCI+IDxpbnB1dCBjbGFzcz1cXFwibWQtY2hlY2tib3gtaW5wdXQgbWQtdmlzdWFsbHktaGlkZGVuXFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCIgW2lkXT1cXFwiaW5wdXRJZFxcXCIgW3JlcXVpcmVkXT1cXFwicmVxdWlyZWRcXFwiIFtjaGVja2VkXT1cXFwiY2hlY2tlZFxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiIFtuYW1lXT1cXFwibmFtZVxcXCIgW3RhYkluZGV4XT1cXFwidGFiaW5kZXhcXFwiIFtpbmRldGVybWluYXRlXT1cXFwiaW5kZXRlcm1pbmF0ZVxcXCIgW2F0dHIuYXJpYS1sYWJlbF09XFxcImFyaWFMYWJlbFxcXCIgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cXFwiYXJpYUxhYmVsbGVkYnlcXFwiIChmb2N1cyk9XFxcIl9vbklucHV0Rm9jdXMoKVxcXCIgKGJsdXIpPVxcXCJfb25JbnB1dEJsdXIoKVxcXCIgKGNoYW5nZSk9XFxcIl9vbkludGVyYWN0aW9uRXZlbnQoJGV2ZW50KVxcXCIgKGNsaWNrKT1cXFwiX29uSW5wdXRDbGljaygkZXZlbnQpXFxcIj4gPGRpdiBjbGFzcz1cXFwibWQtaW5rLXJpcHBsZVxcXCI+PC9kaXY+IDxkaXYgY2xhc3M9XFxcIm1kLWNoZWNrYm94LWZyYW1lXFxcIj48L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWQtY2hlY2tib3gtYmFja2dyb3VuZFxcXCI+IDxzdmcgdmVyc2lvbj1cXFwiMS4xXFxcIiBjbGFzcz1cXFwibWQtY2hlY2tib3gtY2hlY2ttYXJrXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNCAyNFxcXCIgeG1sOnNwYWNlPVxcXCJwcmVzZXJ2ZVxcXCI+IDxwYXRoIGNsYXNzPVxcXCJtZC1jaGVja2JveC1jaGVja21hcmstcGF0aFxcXCIgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCJ3aGl0ZVxcXCIgZD1cXFwiTTQuMSwxMi43IDksMTcuNiAyMC4zLDYuM1xcXCIvPiA8L3N2Zz4gPCEtLSBFbGVtZW50IGZvciByZW5kZXJpbmcgdGhlIGluZGV0ZXJtaW5hdGUgc3RhdGUgY2hlY2tib3guIC0tPiA8ZGl2IGNsYXNzPVxcXCJtZC1jaGVja2JveC1taXhlZG1hcmtcXFwiPjwvZGl2PiA8L2Rpdj4gPC9kaXY+IDxzcGFuIGNsYXNzPVxcXCJtZC1jaGVja2JveC1sYWJlbFxcXCI+IDxuZy1jb250ZW50PjwvbmctY29udGVudD4gPC9zcGFuPiA8L2xhYmVsPiBcIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiQGtleWZyYW1lcyBtZC1jaGVja2JveC1mYWRlLWluLWJhY2tncm91bmQgeyAwJSB7IG9wYWNpdHk6IDA7IH0gNTAlIHsgb3BhY2l0eTogMTsgfSB9IEBrZXlmcmFtZXMgbWQtY2hlY2tib3gtZmFkZS1vdXQtYmFja2dyb3VuZCB7IDAlLCA1MCUgeyBvcGFjaXR5OiAxOyB9IDEwMCUgeyBvcGFjaXR5OiAwOyB9IH0gQGtleWZyYW1lcyBtZC1jaGVja2JveC11bmNoZWNrZWQtY2hlY2tlZC1jaGVja21hcmstcGF0aCB7IDAlLCA1MCUgeyBzdHJva2UtZGFzaG9mZnNldDogMjIuOTEwMjY7IH0gNTAlIHsgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAsIDAsIDAuMiwgMC4xKTsgfSAxMDAlIHsgc3Ryb2tlLWRhc2hvZmZzZXQ6IDA7IH0gfSBAa2V5ZnJhbWVzIG1kLWNoZWNrYm94LXVuY2hlY2tlZC1pbmRldGVybWluYXRlLW1peGVkbWFyayB7IDAlLCA2OC4yJSB7IHRyYW5zZm9ybTogc2NhbGVYKDApOyB9IDY4LjIlIHsgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAsIDAsIDAsIDEpOyB9IDEwMCUgeyB0cmFuc2Zvcm06IHNjYWxlWCgxKTsgfSB9IEBrZXlmcmFtZXMgbWQtY2hlY2tib3gtY2hlY2tlZC11bmNoZWNrZWQtY2hlY2ttYXJrLXBhdGggeyBmcm9tIHsgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNCwgMCwgMSwgMSk7IHN0cm9rZS1kYXNob2Zmc2V0OiAwOyB9IHRvIHsgc3Ryb2tlLWRhc2hvZmZzZXQ6IC0yMi45MTAyNjsgfSB9IEBrZXlmcmFtZXMgbWQtY2hlY2tib3gtY2hlY2tlZC1pbmRldGVybWluYXRlLWNoZWNrbWFyayB7IGZyb20geyBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMCwgMCwgMC4yLCAwLjEpOyBvcGFjaXR5OiAxOyB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfSB0byB7IG9wYWNpdHk6IDA7IHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTsgfSB9IEBrZXlmcmFtZXMgbWQtY2hlY2tib3gtaW5kZXRlcm1pbmF0ZS1jaGVja2VkLWNoZWNrbWFyayB7IGZyb20geyBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4xNCwgMCwgMCwgMSk7IG9wYWNpdHk6IDA7IHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTsgfSB0byB7IG9wYWNpdHk6IDE7IHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH0gfSBAa2V5ZnJhbWVzIG1kLWNoZWNrYm94LWNoZWNrZWQtaW5kZXRlcm1pbmF0ZS1taXhlZG1hcmsgeyBmcm9tIHsgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAsIDAsIDAuMiwgMC4xKTsgb3BhY2l0eTogMDsgdHJhbnNmb3JtOiByb3RhdGUoLTQ1ZGVnKTsgfSB0byB7IG9wYWNpdHk6IDE7IHRyYW5zZm9ybTogcm90YXRlKDBkZWcpOyB9IH0gQGtleWZyYW1lcyBtZC1jaGVja2JveC1pbmRldGVybWluYXRlLWNoZWNrZWQtbWl4ZWRtYXJrIHsgZnJvbSB7IGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjE0LCAwLCAwLCAxKTsgb3BhY2l0eTogMTsgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH0gdG8geyBvcGFjaXR5OiAwOyB0cmFuc2Zvcm06IHJvdGF0ZSgzMTVkZWcpOyB9IH0gQGtleWZyYW1lcyBtZC1jaGVja2JveC1pbmRldGVybWluYXRlLXVuY2hlY2tlZC1taXhlZG1hcmsgeyAwJSB7IGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGxpbmVhcjsgb3BhY2l0eTogMTsgdHJhbnNmb3JtOiBzY2FsZVgoMSk7IH0gMzIuOCUsIDEwMCUgeyBvcGFjaXR5OiAwOyB0cmFuc2Zvcm06IHNjYWxlWCgwKTsgfSB9IC5tZC1jaGVja2JveC1mcmFtZSwgLm1kLWNoZWNrYm94LWJhY2tncm91bmQsIC5tZC1jaGVja2JveC1jaGVja21hcmsgeyBib3R0b206IDA7IGxlZnQ6IDA7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgcmlnaHQ6IDA7IHRvcDogMDsgfSAubWQtY2hlY2tib3gtY2hlY2ttYXJrLCAubWQtY2hlY2tib3gtbWl4ZWRtYXJrIHsgd2lkdGg6IGNhbGMoMTAwJSAtIDRweCk7IH0gLm1kLWNoZWNrYm94LWZyYW1lLCAubWQtY2hlY2tib3gtYmFja2dyb3VuZCB7IGJvcmRlci1yYWRpdXM6IDJweDsgYm94LXNpemluZzogYm9yZGVyLWJveDsgcG9pbnRlci1ldmVudHM6IG5vbmU7IH0gbWQtY2hlY2tib3ggeyBjdXJzb3I6IHBvaW50ZXI7IH0gLm1kLWNoZWNrYm94LWxheW91dCB7IGN1cnNvcjogaW5oZXJpdDsgYWxpZ24taXRlbXM6IGJhc2VsaW5lOyBkaXNwbGF5OiBpbmxpbmUtZmxleDsgfSAubWQtY2hlY2tib3gtaW5uZXItY29udGFpbmVyIHsgZGlzcGxheTogaW5saW5lLWJsb2NrOyBoZWlnaHQ6IDIwcHg7IGxpbmUtaGVpZ2h0OiAwOyBtYXJnaW46IGF1dG87IG1hcmdpbi1yaWdodDogOHB4OyBvcmRlcjogMDsgcG9zaXRpb246IHJlbGF0aXZlOyB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB3aGl0ZS1zcGFjZTogbm93cmFwOyB3aWR0aDogMjBweDsgfSBbZGlyPSdydGwnXSAubWQtY2hlY2tib3gtaW5uZXItY29udGFpbmVyIHsgbWFyZ2luLWxlZnQ6IDhweDsgbWFyZ2luLXJpZ2h0OiBhdXRvOyB9IC5tZC1jaGVja2JveC1sYXlvdXQgLm1kLWNoZWNrYm94LWxhYmVsIHsgbGluZS1oZWlnaHQ6IDI0cHg7IH0gLm1kLWNoZWNrYm94LWZyYW1lIHsgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IGJvcmRlcjogMnB4IHNvbGlkOyB0cmFuc2l0aW9uOiBib3JkZXItY29sb3IgOTBtcyBjdWJpYy1iZXppZXIoMCwgMCwgMC4yLCAwLjEpOyB3aWxsLWNoYW5nZTogYm9yZGVyLWNvbG9yOyB9IC5tZC1jaGVja2JveC1iYWNrZ3JvdW5kIHsgYWxpZ24taXRlbXM6IGNlbnRlcjsgZGlzcGxheTogaW5saW5lLWZsZXg7IGp1c3RpZnktY29udGVudDogY2VudGVyOyB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDkwbXMgY3ViaWMtYmV6aWVyKDAsIDAsIDAuMiwgMC4xKSwgb3BhY2l0eSA5MG1zIGN1YmljLWJlemllcigwLCAwLCAwLjIsIDAuMSk7IHdpbGwtY2hhbmdlOiBiYWNrZ3JvdW5kLWNvbG9yLCBvcGFjaXR5OyB9IC5tZC1jaGVja2JveC1jaGVja21hcmsgeyB3aWR0aDogMTAwJTsgfSAubWQtY2hlY2tib3gtY2hlY2ttYXJrLXBhdGggeyBzdHJva2UtZGFzaG9mZnNldDogMjIuOTEwMjY7IHN0cm9rZS1kYXNoYXJyYXk6IDIyLjkxMDI2OyBzdHJva2Utd2lkdGg6IDIuNjY2NjdweDsgfSAubWQtY2hlY2tib3gtbWl4ZWRtYXJrIHsgaGVpZ2h0OiAycHg7IG9wYWNpdHk6IDA7IHRyYW5zZm9ybTogc2NhbGVYKDApIHJvdGF0ZSgwZGVnKTsgfSAubWQtY2hlY2tib3gtYWxpZ24tZW5kIC5tZC1jaGVja2JveC1pbm5lci1jb250YWluZXIgeyBvcmRlcjogMTsgbWFyZ2luLWxlZnQ6IDhweDsgbWFyZ2luLXJpZ2h0OiBhdXRvOyB9IFtkaXI9J3J0bCddIC5tZC1jaGVja2JveC1hbGlnbi1lbmQgLm1kLWNoZWNrYm94LWlubmVyLWNvbnRhaW5lciB7IG1hcmdpbi1sZWZ0OiBhdXRvOyBtYXJnaW4tcmlnaHQ6IDhweDsgfSAubWQtY2hlY2tib3gtY2hlY2tlZCAubWQtY2hlY2tib3gtY2hlY2ttYXJrIHsgb3BhY2l0eTogMTsgfSAubWQtY2hlY2tib3gtY2hlY2tlZCAubWQtY2hlY2tib3gtY2hlY2ttYXJrLXBhdGggeyBzdHJva2UtZGFzaG9mZnNldDogMDsgfSAubWQtY2hlY2tib3gtY2hlY2tlZCAubWQtY2hlY2tib3gtbWl4ZWRtYXJrIHsgdHJhbnNmb3JtOiBzY2FsZVgoMSkgcm90YXRlKC00NWRlZyk7IH0gLm1kLWNoZWNrYm94LWluZGV0ZXJtaW5hdGUgLm1kLWNoZWNrYm94LWNoZWNrbWFyayB7IG9wYWNpdHk6IDA7IHRyYW5zZm9ybTogcm90YXRlKDQ1ZGVnKTsgfSAubWQtY2hlY2tib3gtaW5kZXRlcm1pbmF0ZSAubWQtY2hlY2tib3gtY2hlY2ttYXJrLXBhdGggeyBzdHJva2UtZGFzaG9mZnNldDogMDsgfSAubWQtY2hlY2tib3gtaW5kZXRlcm1pbmF0ZSAubWQtY2hlY2tib3gtbWl4ZWRtYXJrIHsgb3BhY2l0eTogMTsgdHJhbnNmb3JtOiBzY2FsZVgoMSkgcm90YXRlKDBkZWcpOyB9IC5tZC1jaGVja2JveC11bmNoZWNrZWQgLm1kLWNoZWNrYm94LWJhY2tncm91bmQgeyBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgfSAubWQtY2hlY2tib3gtZGlzYWJsZWQgeyBjdXJzb3I6IGRlZmF1bHQ7IH0gLm1kLWNoZWNrYm94LWFuaW0tdW5jaGVja2VkLWNoZWNrZWQgLm1kLWNoZWNrYm94LWJhY2tncm91bmQgeyBhbmltYXRpb246IDE4MG1zIGxpbmVhciAwbXMgbWQtY2hlY2tib3gtZmFkZS1pbi1iYWNrZ3JvdW5kOyB9IC5tZC1jaGVja2JveC1hbmltLXVuY2hlY2tlZC1jaGVja2VkIC5tZC1jaGVja2JveC1jaGVja21hcmstcGF0aCB7IGFuaW1hdGlvbjogMTgwbXMgbGluZWFyIDBtcyBtZC1jaGVja2JveC11bmNoZWNrZWQtY2hlY2tlZC1jaGVja21hcmstcGF0aDsgfSAubWQtY2hlY2tib3gtYW5pbS11bmNoZWNrZWQtaW5kZXRlcm1pbmF0ZSAubWQtY2hlY2tib3gtYmFja2dyb3VuZCB7IGFuaW1hdGlvbjogMTgwbXMgbGluZWFyIDBtcyBtZC1jaGVja2JveC1mYWRlLWluLWJhY2tncm91bmQ7IH0gLm1kLWNoZWNrYm94LWFuaW0tdW5jaGVja2VkLWluZGV0ZXJtaW5hdGUgLm1kLWNoZWNrYm94LW1peGVkbWFyayB7IGFuaW1hdGlvbjogOTBtcyBsaW5lYXIgMG1zIG1kLWNoZWNrYm94LXVuY2hlY2tlZC1pbmRldGVybWluYXRlLW1peGVkbWFyazsgfSAubWQtY2hlY2tib3gtYW5pbS1jaGVja2VkLXVuY2hlY2tlZCAubWQtY2hlY2tib3gtYmFja2dyb3VuZCB7IGFuaW1hdGlvbjogMTgwbXMgbGluZWFyIDBtcyBtZC1jaGVja2JveC1mYWRlLW91dC1iYWNrZ3JvdW5kOyB9IC5tZC1jaGVja2JveC1hbmltLWNoZWNrZWQtdW5jaGVja2VkIC5tZC1jaGVja2JveC1jaGVja21hcmstcGF0aCB7IGFuaW1hdGlvbjogOTBtcyBsaW5lYXIgMG1zIG1kLWNoZWNrYm94LWNoZWNrZWQtdW5jaGVja2VkLWNoZWNrbWFyay1wYXRoOyB9IC5tZC1jaGVja2JveC1hbmltLWNoZWNrZWQtaW5kZXRlcm1pbmF0ZSAubWQtY2hlY2tib3gtY2hlY2ttYXJrIHsgYW5pbWF0aW9uOiA5MG1zIGxpbmVhciAwbXMgbWQtY2hlY2tib3gtY2hlY2tlZC1pbmRldGVybWluYXRlLWNoZWNrbWFyazsgfSAubWQtY2hlY2tib3gtYW5pbS1jaGVja2VkLWluZGV0ZXJtaW5hdGUgLm1kLWNoZWNrYm94LW1peGVkbWFyayB7IGFuaW1hdGlvbjogOTBtcyBsaW5lYXIgMG1zIG1kLWNoZWNrYm94LWNoZWNrZWQtaW5kZXRlcm1pbmF0ZS1taXhlZG1hcms7IH0gLm1kLWNoZWNrYm94LWFuaW0taW5kZXRlcm1pbmF0ZS1jaGVja2VkIC5tZC1jaGVja2JveC1jaGVja21hcmsgeyBhbmltYXRpb246IDUwMG1zIGxpbmVhciAwbXMgbWQtY2hlY2tib3gtaW5kZXRlcm1pbmF0ZS1jaGVja2VkLWNoZWNrbWFyazsgfSAubWQtY2hlY2tib3gtYW5pbS1pbmRldGVybWluYXRlLWNoZWNrZWQgLm1kLWNoZWNrYm94LW1peGVkbWFyayB7IGFuaW1hdGlvbjogNTAwbXMgbGluZWFyIDBtcyBtZC1jaGVja2JveC1pbmRldGVybWluYXRlLWNoZWNrZWQtbWl4ZWRtYXJrOyB9IC5tZC1jaGVja2JveC1hbmltLWluZGV0ZXJtaW5hdGUtdW5jaGVja2VkIC5tZC1jaGVja2JveC1iYWNrZ3JvdW5kIHsgYW5pbWF0aW9uOiAxODBtcyBsaW5lYXIgMG1zIG1kLWNoZWNrYm94LWZhZGUtb3V0LWJhY2tncm91bmQ7IH0gLm1kLWNoZWNrYm94LWFuaW0taW5kZXRlcm1pbmF0ZS11bmNoZWNrZWQgLm1kLWNoZWNrYm94LW1peGVkbWFyayB7IGFuaW1hdGlvbjogMzAwbXMgbGluZWFyIDBtcyBtZC1jaGVja2JveC1pbmRldGVybWluYXRlLXVuY2hlY2tlZC1taXhlZG1hcms7IH0gLm1kLWNoZWNrYm94LWlucHV0IHsgYm90dG9tOiAwOyBsZWZ0OiA1MCU7IH0gLm1kLWluay1yaXBwbGUgeyBib3JkZXItcmFkaXVzOiA1MCU7IG9wYWNpdHk6IDA7IGhlaWdodDogNDhweDsgbGVmdDogNTAlOyBvdmVyZmxvdzogaGlkZGVuOyBwb2ludGVyLWV2ZW50czogbm9uZTsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDUwJTsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7IHRyYW5zaXRpb246IG9wYWNpdHkgZWFzZSAyODBtcywgYmFja2dyb3VuZC1jb2xvciBlYXNlIDI4MG1zOyB3aWR0aDogNDhweDsgfSAubWQtY2hlY2tib3gtZm9jdXNlZCAubWQtaW5rLXJpcHBsZSB7IG9wYWNpdHk6IDE7IH0gLm1kLWNoZWNrYm94LWRpc2FibGVkIC5tZC1pbmstcmlwcGxlIHsgYmFja2dyb3VuZC1jb2xvcjogIzAwMDsgfSAvKiMgc291cmNlTWFwcGluZ1VSTD1jaGVja2JveC5jc3MubWFwICovIFwiXSxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1kLWNoZWNrYm94LWluZGV0ZXJtaW5hdGVdJzogJ2luZGV0ZXJtaW5hdGUnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWQtY2hlY2tib3gtY2hlY2tlZF0nOiAnY2hlY2tlZCcsXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tZC1jaGVja2JveC1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWQtY2hlY2tib3gtYWxpZ24tZW5kXSc6ICdhbGlnbiA9PSBcImVuZFwiJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1kLWNoZWNrYm94LWZvY3VzZWRdJzogJ2hhc0ZvY3VzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtNRF9DSEVDS0JPWF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDE4KCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWZdKVxuICAgIF0sIE1kQ2hlY2tib3gpO1xuICAgIHJldHVybiBNZENoZWNrYm94O1xufSgpKTtcbnZhciBNZENoZWNrYm94TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENoZWNrYm94TW9kdWxlKCkge1xuICAgIH1cbiAgICBNZENoZWNrYm94TW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRDaGVja2JveE1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kQ2hlY2tib3hNb2R1bGUgPSBfX2RlY29yYXRlJDE4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBleHBvcnRzOiBbTWRDaGVja2JveF0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZENoZWNrYm94XSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDE4KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2hlY2tib3hNb2R1bGUpO1xuICAgIHJldHVybiBNZENoZWNrYm94TW9kdWxlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMTkgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTkgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDIgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vKipcbiAqIFByb3ZpZGVyIEV4cHJlc3Npb24gdGhhdCBhbGxvd3MgbWQtcmFkaW8tZ3JvdXAgdG8gcmVnaXN0ZXIgYXMgYSBDb250cm9sVmFsdWVBY2Nlc3Nvci4gVGhpc1xuICogYWxsb3dzIGl0IHRvIHN1cHBvcnQgWyhuZ01vZGVsKV0gYW5kIG5nQ29udHJvbC5cbiAqL1xudmFyIE1EX1JBRElPX0dST1VQX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogX2FuZ3VsYXJfZm9ybXMuTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZFJhZGlvR3JvdXA7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xuLy8gVE9ETyhtdGxpbik6XG4vLyBJbmsgcmlwcGxlIGlzIGN1cnJlbnRseSBwbGFjZWhvbGRlci5cbi8vIERldGVybWluZSBtb3Rpb24gc3BlYyBmb3IgYnV0dG9uIHRyYW5zaXRpb25zLlxuLy8gRGVzaWduIHJldmlldy5cbi8vIFJUTFxuLy8gU3VwcG9ydCBmb3JtcyBBUEkuXG4vLyBVc2UgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG52YXIgX3VuaXF1ZUlkQ291bnRlciQxID0gMDtcbi8qKiBBIHNpbXBsZSBjaGFuZ2UgZXZlbnQgZW1pdHRlZCBieSBlaXRoZXIgTWRSYWRpb0J1dHRvbiBvciBNZFJhZGlvR3JvdXAuICovXG52YXIgTWRSYWRpb0NoYW5nZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRSYWRpb0NoYW5nZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kUmFkaW9DaGFuZ2U7XG59KCkpO1xudmFyIE1kUmFkaW9Hcm91cCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRSYWRpb0dyb3VwKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VsZWN0ZWQgdmFsdWUgZm9yIGdyb3VwLiBTaG91bGQgZXF1YWwgdGhlIHZhbHVlIG9mIHRoZSBzZWxlY3RlZCByYWRpbyBidXR0b24gaWYgdGhlcmUgKmlzKlxuICAgICAgICAgKiBhIGNvcnJlc3BvbmRpbmcgcmFkaW8gYnV0dG9uIHdpdGggYSBtYXRjaGluZyB2YWx1ZS4gSWYgdGhlcmUgaXMgKm5vdCogc3VjaCBhIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgICogcmFkaW8gYnV0dG9uLCB0aGlzIHZhbHVlIHBlcnNpc3RzIHRvIGJlIGFwcGxpZWQgaW4gY2FzZSBhIG5ldyByYWRpbyBidXR0b24gaXMgYWRkZWQgd2l0aCBhXG4gICAgICAgICAqIG1hdGNoaW5nIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdmFsdWUgPSBudWxsO1xuICAgICAgICAvKiogVGhlIEhUTUwgbmFtZSBhdHRyaWJ1dGUgYXBwbGllZCB0byByYWRpbyBidXR0b25zIGluIHRoaXMgZ3JvdXAuICovXG4gICAgICAgIHRoaXMuX25hbWUgPSBcIm1kLXJhZGlvLWdyb3VwLVwiICsgX3VuaXF1ZUlkQ291bnRlciQxKys7XG4gICAgICAgIC8qKiBEaXNhYmxlcyBhbGwgaW5kaXZpZHVhbCByYWRpbyBidXR0b25zIGFzc2lnbmVkIHRvIHRoaXMgZ3JvdXAuICovXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIHJhZGlvIGJ1dHRvbi4gU2hvdWxkIG1hdGNoIHZhbHVlLiAqL1xuICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IG51bGw7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBgdmFsdWVgIGhhcyBiZWVuIHNldCB0byBpdHMgaW5pdGlhbCB2YWx1ZS4gKi9cbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAvKiogVGhlIG1ldGhvZCB0byBiZSBjYWxsZWQgaW4gb3JkZXIgdG8gdXBkYXRlIG5nTW9kZWwgKi9cbiAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbiA9IGZ1bmN0aW9uICh2YWx1ZSkgeyB9O1xuICAgICAgICAvKiogb25Ub3VjaCBmdW5jdGlvbiByZWdpc3RlcmVkIHZpYSByZWdpc3Rlck9uVG91Y2ggKENvbnRyb2xWYWx1ZUFjY2Vzc29yKS4gKi9cbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGdyb3VwIHZhbHVlIGNoYW5nZXMuICovXG4gICAgICAgIHRoaXMuY2hhbmdlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBDaGlsZCByYWRpbyBidXR0b25zLiAqL1xuICAgICAgICB0aGlzLl9yYWRpb3MgPSBudWxsO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX25hbWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVJhZGlvQnV0dG9uTmFtZXMoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9Hcm91cC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBwcmVzZW5jZSBvZiAqYW55KiBkaXNhYmxlZCB2YWx1ZSBtYWtlcyB0aGUgY29tcG9uZW50IGRpc2FibGVkLCAqZXhjZXB0KiBmb3IgZmFsc2UuXG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9ICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSBmYWxzZSkgPyB0cnVlIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9Hcm91cC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92YWx1ZSAhPSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIFNldCB0aGlzIGJlZm9yZSBwcm9jZWVkaW5nIHRvIGVuc3VyZSBubyBjaXJjdWxhciBsb29wIG9jY3VycyB3aXRoIHNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNlbGVjdGVkUmFkaW9Gcm9tVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGZpcmUgYSBjaGFuZ2UgZXZlbnQgaWYgdGhpcyBpc24ndCB0aGUgZmlyc3QgdGltZSB0aGUgdmFsdWUgaXMgZXZlciBzZXQuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBzZWxlY3RlZCA/IHNlbGVjdGVkLnZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCAmJiAhc2VsZWN0ZWQuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHByb3BlcnRpZXMgb25jZSBjb250ZW50IGNoaWxkcmVuIGFyZSBhdmFpbGFibGUuXG4gICAgICogVGhpcyBhbGxvd3MgdXMgdG8gcHJvcGFnYXRlIHJlbGV2YW50IGF0dHJpYnV0ZXMgdG8gYXNzb2NpYXRlZCBidXR0b25zLlxuICAgICAqIFRPRE86IGludGVybmFsXG4gICAgICovXG4gICAgTWRSYWRpb0dyb3VwLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE1hcmsgdGhpcyBjb21wb25lbnQgYXMgaW5pdGlhbGl6ZWQgaW4gQWZ0ZXJDb250ZW50SW5pdCBiZWNhdXNlIHRoZSBpbml0aWFsIHZhbHVlIGNhblxuICAgICAgICAvLyBwb3NzaWJseSBiZSBzZXQgYnkgTmdNb2RlbCBvbiBNZFJhZGlvR3JvdXAsIGFuZCBpdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBPbkluaXQgb2YgdGhlXG4gICAgICAgIC8vIE5nTW9kZWwgb2NjdXJzICphZnRlciogdGhlIE9uSW5pdCBvZiB0aGUgTWRSYWRpb0dyb3VwLlxuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1hcmsgdGhpcyBncm91cCBhcyBiZWluZyBcInRvdWNoZWRcIiAoZm9yIG5nTW9kZWwpLiBNZWFudCB0byBiZSBjYWxsZWQgYnkgdGhlIGNvbnRhaW5lZFxuICAgICAqIHJhZGlvIGJ1dHRvbnMgdXBvbiB0aGVpciBibHVyLlxuICAgICAqL1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUuX3RvdWNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5vblRvdWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUuX3VwZGF0ZVJhZGlvQnV0dG9uTmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9yYWRpb3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3JhZGlvcy5mb3JFYWNoKGZ1bmN0aW9uIChyYWRpbykge1xuICAgICAgICAgICAgICAgIHJhZGlvLm5hbWUgPSBfdGhpcy5uYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBVcGRhdGVzIHRoZSBgc2VsZWN0ZWRgIHJhZGlvIGJ1dHRvbiBmcm9tIHRoZSBpbnRlcm5hbCBfdmFsdWUgc3RhdGUuICovXG4gICAgTWRSYWRpb0dyb3VwLnByb3RvdHlwZS5fdXBkYXRlU2VsZWN0ZWRSYWRpb0Zyb21WYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGFscmVhZHkgbWF0Y2hlcyB0aGUgc2VsZWN0ZWQgcmFkaW8sIGRvIG5vdGhpbmcuXG4gICAgICAgIHZhciBpc0FscmVhZHlTZWxlY3RlZCA9IHRoaXMuX3NlbGVjdGVkICE9IG51bGwgJiYgdGhpcy5fc2VsZWN0ZWQudmFsdWUgPT0gdGhpcy5fdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9yYWRpb3MgIT0gbnVsbCAmJiAhaXNBbHJlYWR5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGluZ1JhZGlvID0gdGhpcy5fcmFkaW9zLmZpbHRlcihmdW5jdGlvbiAocmFkaW8pIHsgcmV0dXJuIHJhZGlvLnZhbHVlID09IF90aGlzLl92YWx1ZTsgfSlbMF07XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmdSYWRpbykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBtYXRjaGluZ1JhZGlvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy52YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFkaW9zLmZvckVhY2goZnVuY3Rpb24gKHJhZGlvKSB7IHJhZGlvLmNoZWNrZWQgPSBmYWxzZTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBEaXNwYXRjaCBjaGFuZ2UgZXZlbnQgd2l0aCBjdXJyZW50IHNlbGVjdGlvbiBhbmQgZ3JvdXAgdmFsdWUuICovXG4gICAgTWRSYWRpb0dyb3VwLnByb3RvdHlwZS5fZW1pdENoYW5nZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgTWRSYWRpb0NoYW5nZSgpO1xuICAgICAgICBldmVudC5zb3VyY2UgPSB0aGlzLl9zZWxlY3RlZDtcbiAgICAgICAgZXZlbnQudmFsdWUgPSB0aGlzLl92YWx1ZTtcbiAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbihldmVudC52YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICAqIFRPRE86IGludGVybmFsXG4gICAgICAqL1xuICAgIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIFRPRE86IGludGVybmFsXG4gICAgICovXG4gICAgTWRSYWRpb0dyb3VwLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogVE9ETzogaW50ZXJuYWxcbiAgICAgKi9cbiAgICBNZFJhZGlvR3JvdXAucHJvdG90eXBlLnJlZ2lzdGVyT25Ub3VjaGVkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDE5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTkoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIpXG4gICAgXSwgTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJjaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDE5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db250ZW50Q2hpbGRyZW4oX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1kUmFkaW9CdXR0b247IH0pKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTkoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5RdWVyeUxpc3QpXG4gICAgXSwgTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJfcmFkaW9zXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQxOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTkoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kUmFkaW9Hcm91cC5wcm90b3R5cGUsIFwibmFtZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJhbGlnblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMTkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDE5KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRSYWRpb0dyb3VwLnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCBudWxsKTtcbiAgICBNZFJhZGlvR3JvdXAgPSBfX2RlY29yYXRlJDE5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1yYWRpby1ncm91cCcsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtNRF9SQURJT19HUk9VUF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAncm9sZSc6ICdyYWRpb2dyb3VwJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQxOSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFJhZGlvR3JvdXApO1xuICAgIHJldHVybiBNZFJhZGlvR3JvdXA7XG59KCkpO1xudmFyIE1kUmFkaW9CdXR0b24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kUmFkaW9CdXR0b24ocmFkaW9Hcm91cCwgcmFkaW9EaXNwYXRjaGVyKSB7XG4gICAgICAgIC8vIEFzc2VydGlvbnMuIElkZWFsbHkgdGhlc2Ugc2hvdWxkIGJlIHN0cmlwcGVkIG91dCBieSB0aGUgY29tcGlsZXIuXG4gICAgICAgIC8vIFRPRE8oamVsYm91cm4pOiBBc3NlcnQgdGhhdCB0aGVyZSdzIG5vIG5hbWUgYmluZGluZyBBTkQgYSBwYXJlbnQgcmFkaW8gZ3JvdXAuXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmFkaW9EaXNwYXRjaGVyID0gcmFkaW9EaXNwYXRjaGVyO1xuICAgICAgICAvKiogV2hldGhlciB0aGlzIHJhZGlvIGlzIGNoZWNrZWQuICovXG4gICAgICAgIHRoaXMuX2NoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIFRoZSB1bmlxdWUgSUQgZm9yIHRoZSByYWRpbyBidXR0b24uICovXG4gICAgICAgIHRoaXMuaWQgPSBcIm1kLXJhZGlvLVwiICsgX3VuaXF1ZUlkQ291bnRlciQxKys7XG4gICAgICAgIC8qKiBWYWx1ZSBhc3NpZ25lZCB0byB0aGlzIHJhZGlvLiovXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgZ3JvdXAgdmFsdWUgY2hhbmdlcy4gKi9cbiAgICAgICAgdGhpcy5jaGFuZ2UgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5yYWRpb0dyb3VwID0gcmFkaW9Hcm91cDtcbiAgICAgICAgcmFkaW9EaXNwYXRjaGVyLmxpc3RlbihmdW5jdGlvbiAoaWQsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChpZCAhPSBfdGhpcy5pZCAmJiBuYW1lID09IF90aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwiaW5wdXRJZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWQgKyBcIi1pbnB1dFwiO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwiY2hlY2tlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld0NoZWNrZWRTdGF0ZSkge1xuICAgICAgICAgICAgaWYgKG5ld0NoZWNrZWRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBhbGwgcmFkaW8gYnV0dG9ucyB3aXRoIHRoZSBzYW1lIG5hbWUgdG8gdW4tY2hlY2suXG4gICAgICAgICAgICAgICAgdGhpcy5yYWRpb0Rpc3BhdGNoZXIubm90aWZ5KHRoaXMuaWQsIHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jaGVja2VkID0gbmV3Q2hlY2tlZFN0YXRlO1xuICAgICAgICAgICAgaWYgKG5ld0NoZWNrZWRTdGF0ZSAmJiB0aGlzLnJhZGlvR3JvdXAgJiYgdGhpcy5yYWRpb0dyb3VwLnZhbHVlICE9IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhZGlvR3JvdXAuc2VsZWN0ZWQgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICAvKiogTWRSYWRpb0dyb3VwIHJlYWRzIHRoaXMgdG8gYXNzaWduIGl0cyBvd24gdmFsdWUuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbHVlICE9IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmFkaW9Hcm91cCAhPSBudWxsICYmIHRoaXMuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJhZGlvR3JvdXAudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImFsaWduXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxpZ24gfHwgKHRoaXMucmFkaW9Hcm91cCAhPSBudWxsICYmIHRoaXMucmFkaW9Hcm91cC5hbGlnbikgfHwgJ3N0YXJ0JztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FsaWduID0gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkIHx8ICh0aGlzLnJhZGlvR3JvdXAgIT0gbnVsbCAmJiB0aGlzLnJhZGlvR3JvdXAuZGlzYWJsZWQpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgLy8gVGhlIHByZXNlbmNlIG9mICphbnkqIGRpc2FibGVkIHZhbHVlIG1ha2VzIHRoZSBjb21wb25lbnQgZGlzYWJsZWQsICpleGNlcHQqIGZvciBmYWxzZS5cbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IGZhbHNlKSA/IHRydWUgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogVE9ETzogaW50ZXJuYWwgKi9cbiAgICBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmFkaW9Hcm91cCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHJhZGlvIGlzIGluc2lkZSBhIHJhZGlvIGdyb3VwLCBkZXRlcm1pbmUgaWYgaXQgc2hvdWxkIGJlIGNoZWNrZWRcbiAgICAgICAgICAgIHRoaXMuY2hlY2tlZCA9IHRoaXMucmFkaW9Hcm91cC52YWx1ZSA9PT0gdGhpcy5fdmFsdWU7XG4gICAgICAgICAgICAvLyBDb3B5IG5hbWUgZnJvbSBwYXJlbnQgcmFkaW8gZ3JvdXBcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMucmFkaW9Hcm91cC5uYW1lO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogRGlzcGF0Y2ggY2hhbmdlIGV2ZW50IHdpdGggY3VycmVudCB2YWx1ZS4gKi9cbiAgICBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZS5fZW1pdENoYW5nZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgTWRSYWRpb0NoYW5nZSgpO1xuICAgICAgICBldmVudC5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBldmVudC52YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICB0aGlzLmNoYW5nZS5lbWl0KGV2ZW50KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdlIHVzZSBhIGhpZGRlbiBuYXRpdmUgaW5wdXQgZmllbGQgdG8gaGFuZGxlIGNoYW5nZXMgdG8gZm9jdXMgc3RhdGUgdmlhIGtleWJvYXJkIG5hdmlnYXRpb24sXG4gICAgICogd2l0aCB2aXN1YWwgcmVuZGVyaW5nIGRvbmUgc2VwYXJhdGVseS4gVGhlIG5hdGl2ZSBlbGVtZW50IGlzIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBvdmVyYWxsXG4gICAgICogc3RhdGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZS5fb25JbnB1dEZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc0ZvY3VzZWQgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqIFRPRE86IGludGVybmFsICovXG4gICAgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUuX29uSW5wdXRCbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMucmFkaW9Hcm91cCkge1xuICAgICAgICAgICAgdGhpcy5yYWRpb0dyb3VwLl90b3VjaCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogVE9ETzogaW50ZXJuYWwgKi9cbiAgICBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZS5fb25JbnB1dENsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gc3RvcCBwcm9wYWdhdGlvbiBmb3IgY2xpY2sgZXZlbnRzIG9uIHRoZSB2aXN1YWwgaGlkZGVuIGlucHV0IGVsZW1lbnQuXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHdoZW4gYSB1c2VyIGNsaWNrcyBvbiBhIGxhYmVsIGVsZW1lbnQsIGEgZ2VuZXJhdGVkIGNsaWNrIGV2ZW50IHdpbGwgYmVcbiAgICAgICAgLy8gZGlzcGF0Y2hlZCBvbiB0aGUgYXNzb2NpYXRlZCBpbnB1dCBlbGVtZW50LiBTaW5jZSB3ZSBhcmUgdXNpbmcgYSBsYWJlbCBlbGVtZW50IGFzIG91clxuICAgICAgICAvLyByb290IGNvbnRhaW5lciwgdGhlIGNsaWNrIGV2ZW50IG9uIHRoZSBgcmFkaW8tYnV0dG9uYCB3aWxsIGJlIGV4ZWN1dGVkIHR3aWNlLlxuICAgICAgICAvLyBUaGUgcmVhbCBjbGljayBldmVudCB3aWxsIGJ1YmJsZSB1cCwgYW5kIHRoZSBnZW5lcmF0ZWQgY2xpY2sgZXZlbnQgYWxzbyB0cmllcyB0byBidWJibGUgdXAuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBsZWFkIHRvIG11bHRpcGxlIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgLy8gUHJldmVudGluZyBidWJibGluZyBmb3IgdGhlIHNlY29uZCBldmVudCB3aWxsIHNvbHZlIHRoYXQgaXNzdWUuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIHJhZGlvIGJ1dHRvbiByZWNlaXZlZCBhIGNsaWNrIG9yIHRoZSBpbnB1dCByZWNvZ25pemVkIGFueSBjaGFuZ2UuXG4gICAgICogQ2xpY2tpbmcgb24gYSBsYWJlbCBlbGVtZW50LCB3aWxsIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgb24gdGhlIGFzc29jaWF0ZWQgaW5wdXQuXG4gICAgICogVE9ETzogaW50ZXJuYWxcbiAgICAgKi9cbiAgICBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZS5fb25JbnB1dENoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBXZSBhbHdheXMgaGF2ZSB0byBzdG9wIHByb3BhZ2F0aW9uIG9uIHRoZSBjaGFuZ2UgZXZlbnQuXG4gICAgICAgIC8vIE90aGVyd2lzZSB0aGUgY2hhbmdlIGV2ZW50LCBmcm9tIHRoZSBpbnB1dCBlbGVtZW50LCB3aWxsIGJ1YmJsZSB1cCBhbmRcbiAgICAgICAgLy8gZW1pdCBpdHMgZXZlbnQgb2JqZWN0IHRvIHRoZSBgY2hhbmdlYCBvdXRwdXQuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICAgICAgaWYgKHRoaXMucmFkaW9Hcm91cCkge1xuICAgICAgICAgICAgdGhpcy5yYWRpb0dyb3VwLl90b3VjaCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDE5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnY2xhc3MubWQtcmFkaW8tZm9jdXNlZCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxOSgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcIl9pc0ZvY3VzZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDE5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnaWQnKSxcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxOSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwiaWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDE5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxOSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMTkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdhcmlhLWxhYmVsJyksIFxuICAgICAgICBfX21ldGFkYXRhJDE5KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJhcmlhTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDE5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnYXJpYS1sYWJlbGxlZGJ5JyksIFxuICAgICAgICBfX21ldGFkYXRhJDE5KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJhcmlhTGFiZWxsZWRieVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMTkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxOSgnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcilcbiAgICBdLCBNZFJhZGlvQnV0dG9uLnByb3RvdHlwZSwgXCJjaGFuZ2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDE5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnY2xhc3MubWQtcmFkaW8tY2hlY2tlZCcpLFxuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDE5KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwiY2hlY2tlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDE5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQxOSgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQxOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTkoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kUmFkaW9CdXR0b24ucHJvdG90eXBlLCBcImFsaWduXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMTkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKCdjbGFzcy5tZC1yYWRpby1kaXNhYmxlZCcpLFxuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDE5KCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRSYWRpb0J1dHRvbi5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG4gICAgTWRSYWRpb0J1dHRvbiA9IF9fZGVjb3JhdGUkMTkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1yYWRpby1idXR0b24nLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPCEtLSBUT0RPKGplbGJvdXJuKTogcmVuZGVyIHRoZSByYWRpbyBvbiBlaXRoZXIgc2lkZSBvZiB0aGUgY29udGVudCAtLT4gPCEtLSBUT0RPKG10bGluKTogRXZhbHVhdGUgdHJhZGUtb2ZmcyBvZiB1c2luZyBuYXRpdmUgcmFkaW8gdnMuIGNvc3Qgb2YgYWRkaXRpb25hbCBiaW5kaW5ncy4gLS0+IDxsYWJlbCBbYXR0ci5mb3JdPVxcXCJpbnB1dElkXFxcIiBjbGFzcz1cXFwibWQtcmFkaW8tbGFiZWxcXFwiPiA8IS0tIFRoZSBhY3R1YWwgJ3JhZGlvJyBwYXJ0IG9mIHRoZSBjb250cm9sLiAtLT4gPGRpdiBjbGFzcz1cXFwibWQtcmFkaW8tY29udGFpbmVyXFxcIj4gPGRpdiBjbGFzcz1cXFwibWQtcmFkaW8tb3V0ZXItY2lyY2xlXFxcIj48L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWQtcmFkaW8taW5uZXItY2lyY2xlXFxcIj48L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWQtaW5rLXJpcHBsZVxcXCI+PC9kaXY+IDwvZGl2PiA8aW5wdXQgI2lucHV0IGNsYXNzPVxcXCJtZC1yYWRpby1pbnB1dCBtZC12aXN1YWxseS1oaWRkZW5cXFwiIHR5cGU9XFxcInJhZGlvXFxcIiBbaWRdPVxcXCJpbnB1dElkXFxcIiBbY2hlY2tlZF09XFxcImNoZWNrZWRcXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiBbbmFtZV09XFxcIm5hbWVcXFwiIFthdHRyLmFyaWEtbGFiZWxdPVxcXCJhcmlhTGFiZWxcXFwiIFthdHRyLmFyaWEtbGFiZWxsZWRieV09XFxcImFyaWFMYWJlbGxlZGJ5XFxcIiAoY2hhbmdlKT1cXFwiX29uSW5wdXRDaGFuZ2UoJGV2ZW50KVxcXCIgKGZvY3VzKT1cXFwiX29uSW5wdXRGb2N1cygpXFxcIiAoYmx1cik9XFxcIl9vbklucHV0Qmx1cigpXFxcIiAoY2xpY2spPVxcXCJfb25JbnB1dENsaWNrKCRldmVudClcXFwiPiA8IS0tIFRoZSBsYWJlbCBjb250ZW50IGZvciByYWRpbyBjb250cm9sLiAtLT4gPGRpdiBjbGFzcz1cXFwibWQtcmFkaW8tbGFiZWwtY29udGVudFxcXCIgW2NsYXNzLm1kLXJhZGlvLWFsaWduLWVuZF09XFxcImFsaWduID09ICdlbmQnXFxcIj4gPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PiA8L2Rpdj4gPC9sYWJlbD4gXCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIm1kLXJhZGlvLWJ1dHRvbiB7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgfSAubWQtcmFkaW8tbGFiZWwgeyBjdXJzb3I6IHBvaW50ZXI7IGRpc3BsYXk6IGlubGluZS1mbGV4OyBhbGlnbi1pdGVtczogYmFzZWxpbmU7IHdoaXRlLXNwYWNlOiBub3dyYXA7IH0gLm1kLXJhZGlvLWNvbnRhaW5lciB7IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgaGVpZ2h0OiAyMHB4OyBwb3NpdGlvbjogcmVsYXRpdmU7IHdpZHRoOiAyMHB4OyB0b3A6IDJweDsgfSAubWQtcmFkaW8tb3V0ZXItY2lyY2xlIHsgYm9yZGVyOiBzb2xpZCAycHg7IGJvcmRlci1yYWRpdXM6IDUwJTsgYm94LXNpemluZzogYm9yZGVyLWJveDsgaGVpZ2h0OiAyMHB4OyBsZWZ0OiAwOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgdHJhbnNpdGlvbjogYm9yZGVyLWNvbG9yIGVhc2UgMjgwbXM7IHdpZHRoOiAyMHB4OyB9IC5tZC1yYWRpby1pbm5lci1jaXJjbGUgeyBib3JkZXItcmFkaXVzOiA1MCU7IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IGhlaWdodDogMjBweDsgbGVmdDogMDsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IHRyYW5zaXRpb246IHRyYW5zZm9ybSBlYXNlIDI4MG1zLCBiYWNrZ3JvdW5kLWNvbG9yIGVhc2UgMjgwbXM7IHRyYW5zZm9ybTogc2NhbGUoMCk7IHdpZHRoOiAyMHB4OyB9IC5tZC1yYWRpby1jaGVja2VkIC5tZC1yYWRpby1pbm5lci1jaXJjbGUgeyB0cmFuc2Zvcm06IHNjYWxlKDAuNSk7IH0gLm1kLXJhZGlvLWxhYmVsLWNvbnRlbnQgeyBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IG9yZGVyOiAwOyBsaW5lLWhlaWdodDogaW5oZXJpdDsgcGFkZGluZy1sZWZ0OiA4cHg7IHBhZGRpbmctcmlnaHQ6IDA7IH0gW2Rpcj0ncnRsJ10gLm1kLXJhZGlvLWxhYmVsLWNvbnRlbnQgeyBwYWRkaW5nLXJpZ2h0OiA4cHg7IHBhZGRpbmctbGVmdDogMDsgfSAubWQtcmFkaW8tbGFiZWwtY29udGVudC5tZC1yYWRpby1hbGlnbi1lbmQgeyBvcmRlcjogLTE7IHBhZGRpbmctbGVmdDogMDsgcGFkZGluZy1yaWdodDogOHB4OyB9IFtkaXI9J3J0bCddIC5tZC1yYWRpby1sYWJlbC1jb250ZW50Lm1kLXJhZGlvLWFsaWduLWVuZCB7IHBhZGRpbmctcmlnaHQ6IDA7IHBhZGRpbmctbGVmdDogOHB4OyB9IC5tZC1yYWRpby1kaXNhYmxlZCwgLm1kLXJhZGlvLWRpc2FibGVkIC5tZC1yYWRpby1sYWJlbCB7IGN1cnNvcjogZGVmYXVsdDsgfSAubWQtaW5rLXJpcHBsZSB7IGJvcmRlci1yYWRpdXM6IDUwJTsgb3BhY2l0eTogMDsgaGVpZ2h0OiA0OHB4OyBsZWZ0OiA1MCU7IG92ZXJmbG93OiBoaWRkZW47IHBvaW50ZXItZXZlbnRzOiBub25lOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogNTAlOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTsgdHJhbnNpdGlvbjogb3BhY2l0eSBlYXNlIDI4MG1zLCBiYWNrZ3JvdW5kLWNvbG9yIGVhc2UgMjgwbXM7IHdpZHRoOiA0OHB4OyB9IC5tZC1yYWRpby1mb2N1c2VkIC5tZC1pbmstcmlwcGxlIHsgb3BhY2l0eTogMTsgfSAubWQtcmFkaW8tZGlzYWJsZWQgLm1kLWluay1yaXBwbGUgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwOyB9IC8qIyBzb3VyY2VNYXBwaW5nVVJMPXJhZGlvLmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG4gICAgICAgIH0pLFxuICAgICAgICBfX3BhcmFtJDIoMCwgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTkoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW01kUmFkaW9Hcm91cCwgTWRVbmlxdWVTZWxlY3Rpb25EaXNwYXRjaGVyXSlcbiAgICBdLCBNZFJhZGlvQnV0dG9uKTtcbiAgICByZXR1cm4gTWRSYWRpb0J1dHRvbjtcbn0oKSk7XG52YXIgTWRSYWRpb01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRSYWRpb01vZHVsZSgpIHtcbiAgICB9XG4gICAgTWRSYWRpb01vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kUmFkaW9Nb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtNZFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXJdLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRSYWRpb01vZHVsZSA9IF9fZGVjb3JhdGUkMTkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNZFJhZGlvR3JvdXAsIE1kUmFkaW9CdXR0b25dLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRSYWRpb0dyb3VwLCBNZFJhZGlvQnV0dG9uXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDE5KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kUmFkaW9Nb2R1bGUpO1xuICAgIHJldHVybiBNZFJhZGlvTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMjEgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBNZFNlbGVjdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTZWxlY3QoKSB7XG4gICAgfVxuICAgIE1kU2VsZWN0ID0gX19kZWNvcmF0ZSQyMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLXNlbGVjdCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJJJ20gYSBzZWxlY3QhXCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIiAvKiMgc291cmNlTWFwcGluZ1VSTD1zZWxlY3QuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDIxKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kU2VsZWN0KTtcbiAgICByZXR1cm4gTWRTZWxlY3Q7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQyMCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQyMCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIE1kU2VsZWN0TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNlbGVjdE1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWRTZWxlY3RNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZFNlbGVjdE1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kU2VsZWN0TW9kdWxlID0gX19kZWNvcmF0ZSQyMChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW10sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRTZWxlY3RdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRTZWxlY3RdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjAoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRTZWxlY3RNb2R1bGUpO1xuICAgIHJldHVybiBNZFNlbGVjdE1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDIyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDIyID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTURfU0xJREVfVE9HR0xFX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IF9hbmd1bGFyX2Zvcm1zLk5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBfYW5ndWxhcl9jb3JlLmZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWRTbGlkZVRvZ2dsZTsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG4vLyBBIHNpbXBsZSBjaGFuZ2UgZXZlbnQgZW1pdHRlZCBieSB0aGUgTWRTbGlkZVRvZ2dsZSBjb21wb25lbnQuXG52YXIgTWRTbGlkZVRvZ2dsZUNoYW5nZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTbGlkZVRvZ2dsZUNoYW5nZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIE1kU2xpZGVUb2dnbGVDaGFuZ2U7XG59KCkpO1xuLy8gSW5jcmVhc2luZyBpbnRlZ2VyIGZvciBnZW5lcmF0aW5nIHVuaXF1ZSBpZHMgZm9yIHNsaWRlLXRvZ2dsZSBjb21wb25lbnRzLlxudmFyIG5leHRJZCQxID0gMDtcbnZhciBNZFNsaWRlVG9nZ2xlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNsaWRlVG9nZ2xlKF9lbGVtZW50UmVmLCBfcmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChfKSB7IH07XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAvLyBBIHVuaXF1ZSBpZCBmb3IgdGhlIHNsaWRlLXRvZ2dsZS4gQnkgZGVmYXVsdCB0aGUgaWQgaXMgYXV0by1nZW5lcmF0ZWQuXG4gICAgICAgIHRoaXMuX3VuaXF1ZUlkID0gXCJtZC1zbGlkZS10b2dnbGUtXCIgKyArK25leHRJZCQxO1xuICAgICAgICB0aGlzLl9jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2hhc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzTW91c2Vkb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NsaWRlUmVuZGVyZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5pZCA9IHRoaXMuX3VuaXF1ZUlkO1xuICAgICAgICB0aGlzLnRhYkluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5hcmlhTGFiZWwgPSBudWxsO1xuICAgICAgICB0aGlzLmFyaWFMYWJlbGxlZGJ5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hhbmdlID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlID0gdGhpcy5fY2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICAvLyBSZXR1cm5zIHRoZSB1bmlxdWUgaWQgZm9yIHRoZSB2aXN1YWwgaGlkZGVuIGlucHV0LlxuICAgICAgICB0aGlzLmdldElucHV0SWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoKF90aGlzLmlkIHx8IF90aGlzLl91bmlxdWVJZCkgKyBcIi1pbnB1dFwiKTsgfTtcbiAgICB9XG4gICAgLyoqIFRPRE86IGludGVybmFsICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zbGlkZVJlbmRlcmVyID0gbmV3IFNsaWRlVG9nZ2xlUmVuZGVyZXIodGhpcy5fZWxlbWVudFJlZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgb25DaGFuZ2VFdmVudCBtZXRob2Qgd2lsbCBiZSBhbHNvIGNhbGxlZCBvbiBjbGljay5cbiAgICAgKiBUaGlzIGlzIGJlY2F1c2UgZXZlcnl0aGluZyBmb3IgdGhlIHNsaWRlLXRvZ2dsZSBpcyB3cmFwcGVkIGluc2lkZSBvZiBhIGxhYmVsLFxuICAgICAqIHdoaWNoIHRyaWdnZXJzIGEgb25DaGFuZ2UgZXZlbnQgb24gY2xpY2suXG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX29uQ2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gV2UgYWx3YXlzIGhhdmUgdG8gc3RvcCBwcm9wYWdhdGlvbiBvbiB0aGUgY2hhbmdlIGV2ZW50LlxuICAgICAgICAvLyBPdGhlcndpc2UgdGhlIGNoYW5nZSBldmVudCwgZnJvbSB0aGUgaW5wdXQgZWxlbWVudCwgd2lsbCBidWJibGUgdXAgYW5kXG4gICAgICAgIC8vIGVtaXQgaXRzIGV2ZW50IG9iamVjdCB0byB0aGUgY29tcG9uZW50J3MgYGNoYW5nZWAgb3V0cHV0LlxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gT25jZSBhIGRyYWcgaXMgY3VycmVudGx5IGluIHByb2dyZXNzLCB3ZSBkbyBub3Qgd2FudCB0byB0b2dnbGUgdGhlIHNsaWRlLXRvZ2dsZSBvbiBhIGNsaWNrLlxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgIXRoaXMuX3NsaWRlUmVuZGVyZXIuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICAgICAgLy8gRW1pdCBvdXIgY3VzdG9tIGNoYW5nZSBldmVudCBpZiB0aGUgbmF0aXZlIGlucHV0IGVtaXR0ZWQgb25lLlxuICAgICAgICAgICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIG9ubHkgZW1pdCBpdCwgaWYgdGhlIG5hdGl2ZSBpbnB1dCB0cmlnZ2VyZWQgb25lLCBiZWNhdXNlXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQsIHdoZW4gdGhlIGBjaGVja2VkYCB2YXJpYWJsZSBjaGFuZ2VzIGZvciBleGFtcGxlLlxuICAgICAgICAgICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLl9vbklucHV0Q2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQoKTtcbiAgICAgICAgLy8gV2UgaGF2ZSB0byBzdG9wIHByb3BhZ2F0aW9uIGZvciBjbGljayBldmVudHMgb24gdGhlIHZpc3VhbCBoaWRkZW4gaW5wdXQgZWxlbWVudC5cbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgd2hlbiBhIHVzZXIgY2xpY2tzIG9uIGEgbGFiZWwgZWxlbWVudCwgYSBnZW5lcmF0ZWQgY2xpY2sgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBkaXNwYXRjaGVkIG9uIHRoZSBhc3NvY2lhdGVkIGlucHV0IGVsZW1lbnQuIFNpbmNlIHdlIGFyZSB1c2luZyBhIGxhYmVsIGVsZW1lbnQgYXMgb3VyXG4gICAgICAgIC8vIHJvb3QgY29udGFpbmVyLCB0aGUgY2xpY2sgZXZlbnQgb24gdGhlIGBzbGlkZS10b2dnbGVgIHdpbGwgYmUgZXhlY3V0ZWQgdHdpY2UuXG4gICAgICAgIC8vIFRoZSByZWFsIGNsaWNrIGV2ZW50IHdpbGwgYnViYmxlIHVwLCBhbmQgdGhlIGdlbmVyYXRlZCBjbGljayBldmVudCBhbHNvIHRyaWVzIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGxlYWQgdG8gbXVsdGlwbGUgY2xpY2sgZXZlbnRzLlxuICAgICAgICAvLyBQcmV2ZW50aW5nIGJ1YmJsaW5nIGZvciB0aGUgc2Vjb25kIGV2ZW50IHdpbGwgc29sdmUgdGhhdCBpc3N1ZS5cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfTtcbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5fc2V0TW91c2Vkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBXZSBvbmx5ICpzaG93KiB0aGUgZm9jdXMgc3R5bGUgd2hlbiBmb2N1cyBoYXMgY29tZSB0byB0aGUgYnV0dG9uIHZpYSB0aGUga2V5Ym9hcmQuXG4gICAgICAgIC8vIFRoZSBNYXRlcmlhbCBEZXNpZ24gc3BlYyBpcyBzaWxlbnQgb24gdGhpcyB0b3BpYywgYW5kIHdpdGhvdXQgZG9pbmcgdGhpcywgdGhlXG4gICAgICAgIC8vIGJ1dHRvbiBjb250aW51ZXMgdG8gbG9vayA6YWN0aXZlIGFmdGVyIGNsaWNraW5nLlxuICAgICAgICAvLyBAc2VlIGh0dHA6Ly9tYXJjeXN1dHRvbi5jb20vYnV0dG9uLWZvY3VzLWhlbGwvXG4gICAgICAgIHRoaXMuX2lzTW91c2Vkb3duID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5faXNNb3VzZWRvd24gPSBmYWxzZTsgfSwgMTAwKTtcbiAgICB9O1xuICAgIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLl9vbklucHV0Rm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE9ubHkgc2hvdyB0aGUgZm9jdXMgLyByaXBwbGUgaW5kaWNhdG9yIHdoZW4gdGhlIGZvY3VzIHdhcyBub3QgdHJpZ2dlcmVkIGJ5IGEgbW91c2VcbiAgICAgICAgLy8gaW50ZXJhY3Rpb24gb24gdGhlIGNvbXBvbmVudC5cbiAgICAgICAgaWYgKCF0aGlzLl9pc01vdXNlZG93bikge1xuICAgICAgICAgICAgdGhpcy5faGFzRm9jdXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5fb25JbnB1dEJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2hhc0ZvY3VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRlZCBhcyBwYXJ0IG9mIENvbnRyb2xWYWx1ZUFjY2Vzc29yLlxuICAgICAqIFRPRE86IGludGVybmFsXG4gICAgICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogVE9ETzogaW50ZXJuYWxcbiAgICAgKi9cbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogVE9ETzogaW50ZXJuYWxcbiAgICAgKi9cbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLCBcImNoZWNrZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuX2NoZWNrZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja2VkICE9PSAhIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tlZCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2UodGhpcy5fY2hlY2tlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJjb2xvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29sb3IodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9ICF0aGlzLmNoZWNrZWQ7XG4gICAgfTtcbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5fdXBkYXRlQ29sb3IgPSBmdW5jdGlvbiAobmV3Q29sb3IpIHtcbiAgICAgICAgdGhpcy5fc2V0RWxlbWVudENvbG9yKHRoaXMuX2NvbG9yLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRDb2xvcihuZXdDb2xvciwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX2NvbG9yID0gbmV3Q29sb3I7XG4gICAgfTtcbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5fc2V0RWxlbWVudENvbG9yID0gZnVuY3Rpb24gKGNvbG9yLCBpc0FkZCkge1xuICAgICAgICBpZiAoY29sb3IgIT0gbnVsbCAmJiBjb2xvciAhPSAnJykge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgXCJtZC1cIiArIGNvbG9yLCBpc0FkZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBFbWl0cyB0aGUgY2hhbmdlIGV2ZW50IHRvIHRoZSBgY2hhbmdlYCBvdXRwdXQgRXZlbnRFbWl0dGVyICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX2VtaXRDaGFuZ2VFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IE1kU2xpZGVUb2dnbGVDaGFuZ2UoKTtcbiAgICAgICAgZXZlbnQuc291cmNlID0gdGhpcztcbiAgICAgICAgZXZlbnQuY2hlY2tlZCA9IHRoaXMuY2hlY2tlZDtcbiAgICAgICAgdGhpcy5fY2hhbmdlLmVtaXQoZXZlbnQpO1xuICAgIH07XG4gICAgLyoqIFRPRE86IGludGVybmFsICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX29uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zbGlkZVJlbmRlcmVyLnN0YXJ0VGh1bWJEcmFnKHRoaXMuY2hlY2tlZCk7XG4gICAgfTtcbiAgICAvKiogVE9ETzogaW50ZXJuYWwgKi9cbiAgICBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZS5fb25EcmFnID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3NsaWRlUmVuZGVyZXIudXBkYXRlVGh1bWJQb3NpdGlvbihldmVudC5kZWx0YVgpO1xuICAgIH07XG4gICAgLyoqIFRPRE86IGludGVybmFsICovXG4gICAgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUuX29uRHJhZ0VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gTm90aWNlIHRoYXQgd2UgaGF2ZSB0byBzdG9wIG91dHNpZGUgb2YgdGhlIGN1cnJlbnQgZXZlbnQgaGFuZGxlcixcbiAgICAgICAgLy8gYmVjYXVzZSBvdGhlcndpc2UgdGhlIGNsaWNrIGV2ZW50IHdpbGwgYmUgZmlyZWQgYW5kIHdpbGwgcmVzZXQgdGhlIG5ldyBjaGVja2VkIHZhcmlhYmxlLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNoZWNrZWQgPSBfdGhpcy5fc2xpZGVSZW5kZXJlci5zdG9wVGh1bWJEcmFnKCk7XG4gICAgICAgIH0sIDApO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQyMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSxcbiAgICAgICAgQm9vbGVhbkZpZWxkVmFsdWUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjIoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMjIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksXG4gICAgICAgIEJvb2xlYW5GaWVsZFZhbHVlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDIyKCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDIyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyMignZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMjIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDIyKCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJpZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMjIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDIyKCdkZXNpZ246dHlwZScsIE51bWJlcilcbiAgICBdLCBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJ0YWJJbmRleFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMjIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDIyKCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFNsaWRlVG9nZ2xlLnByb3RvdHlwZSwgXCJhcmlhTGFiZWxcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDIyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyMignZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiYXJpYUxhYmVsbGVkYnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDIyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjIoJ2Rlc2lnbjp0eXBlJywgcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUpXG4gICAgXSwgTWRTbGlkZVRvZ2dsZS5wcm90b3R5cGUsIFwiY2hhbmdlXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQyMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjIoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLCBcImNoZWNrZWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQyMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjIoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kU2xpZGVUb2dnbGUucHJvdG90eXBlLCBcImNvbG9yXCIsIG51bGwpO1xuICAgIE1kU2xpZGVUb2dnbGUgPSBfX2RlY29yYXRlJDIyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtc2xpZGUtdG9nZ2xlJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1kLWNoZWNrZWRdJzogJ2NoZWNrZWQnLFxuICAgICAgICAgICAgICAgICdbY2xhc3MubWQtZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1kLXNsaWRlLXRvZ2dsZSBwcmVmaXggd2lsbCBjaGFuZ2UsIG9uY2UgdGhlIHRlbXBvcmFyeSByaXBwbGUgaXMgcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1kLXNsaWRlLXRvZ2dsZS1mb2N1c2VkXSc6ICdfaGFzRm9jdXMnLFxuICAgICAgICAgICAgICAgICcobW91c2Vkb3duKSc6ICdfc2V0TW91c2Vkb3duKCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGxhYmVsIGNsYXNzPVxcXCJtZC1zbGlkZS10b2dnbGUtbGFiZWxcXFwiPiA8ZGl2IGNsYXNzPVxcXCJtZC1zbGlkZS10b2dnbGUtY29udGFpbmVyXFxcIj4gPGRpdiBjbGFzcz1cXFwibWQtc2xpZGUtdG9nZ2xlLWJhclxcXCI+PC9kaXY+IDxkaXYgY2xhc3M9XFxcIm1kLXNsaWRlLXRvZ2dsZS10aHVtYi1jb250YWluZXJcXFwiIChzbGlkZXN0YXJ0KT1cXFwiX29uRHJhZ1N0YXJ0KClcXFwiIChzbGlkZSk9XFxcIl9vbkRyYWcoJGV2ZW50KVxcXCIgKHNsaWRlZW5kKT1cXFwiX29uRHJhZ0VuZCgpXFxcIj4gPGRpdiBjbGFzcz1cXFwibWQtc2xpZGUtdG9nZ2xlLXRodW1iXFxcIj4gPGRpdiBjbGFzcz1cXFwibWQtaW5rLXJpcHBsZVxcXCI+PC9kaXY+IDwvZGl2PiA8L2Rpdj4gPGlucHV0ICNpbnB1dCBjbGFzcz1cXFwibWQtc2xpZGUtdG9nZ2xlLWlucHV0IG1kLXZpc3VhbGx5LWhpZGRlblxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiIFtpZF09XFxcImdldElucHV0SWQoKVxcXCIgW3JlcXVpcmVkXT1cXFwicmVxdWlyZWRcXFwiIFt0YWJJbmRleF09XFxcInRhYkluZGV4XFxcIiBbY2hlY2tlZF09XFxcImNoZWNrZWRcXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiBbYXR0ci5uYW1lXT1cXFwibmFtZVxcXCIgW2F0dHIuYXJpYS1sYWJlbF09XFxcImFyaWFMYWJlbFxcXCIgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cXFwiYXJpYUxhYmVsbGVkYnlcXFwiIChibHVyKT1cXFwiX29uSW5wdXRCbHVyKClcXFwiIChmb2N1cyk9XFxcIl9vbklucHV0Rm9jdXMoKVxcXCIgKGNoYW5nZSk9XFxcIl9vbkNoYW5nZUV2ZW50KCRldmVudClcXFwiIChjbGljayk9XFxcIl9vbklucHV0Q2xpY2soJGV2ZW50KVxcXCI+IDwvZGl2PiA8c3BhbiBjbGFzcz1cXFwibWQtc2xpZGUtdG9nZ2xlLWNvbnRlbnRcXFwiPiA8bmctY29udGVudD48L25nLWNvbnRlbnQ+IDwvc3Bhbj4gPC9sYWJlbD4gXCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0IHsgZGlzcGxheTogZmxleDsgaGVpZ2h0OiAyNHB4OyBtYXJnaW46IDE2cHggMDsgbGluZS1oZWlnaHQ6IDI0cHg7IHdoaXRlLXNwYWNlOiBub3dyYXA7IHVzZXItc2VsZWN0OiBub25lOyBvdXRsaW5lOiBub25lOyB9IDpob3N0Lm1kLWNoZWNrZWQgLm1kLXNsaWRlLXRvZ2dsZS10aHVtYi1jb250YWluZXIgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDEwMCUsIDAsIDApOyB9IDpob3N0IC5tZC1pbmstcmlwcGxlIHsgYm9yZGVyLXJhZGl1czogNTAlOyBvcGFjaXR5OiAwOyBoZWlnaHQ6IDQ4cHg7IGxlZnQ6IDUwJTsgb3ZlcmZsb3c6IGhpZGRlbjsgcG9pbnRlci1ldmVudHM6IG5vbmU7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiA1MCU7IHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpOyB0cmFuc2l0aW9uOiBvcGFjaXR5IGVhc2UgMjgwbXMsIGJhY2tncm91bmQtY29sb3IgZWFzZSAyODBtczsgd2lkdGg6IDQ4cHg7IH0gOmhvc3QubWQtc2xpZGUtdG9nZ2xlLWZvY3VzZWQgLm1kLWluay1yaXBwbGUgeyBvcGFjaXR5OiAxOyB9IDpob3N0Lm1kLXNsaWRlLXRvZ2dsZS1kaXNhYmxlZCAubWQtaW5rLXJpcHBsZSB7IGJhY2tncm91bmQtY29sb3I6ICMwMDA7IH0gOmhvc3QubWQtZGlzYWJsZWQgLm1kLXNsaWRlLXRvZ2dsZS1sYWJlbCwgOmhvc3QubWQtZGlzYWJsZWQgLm1kLXNsaWRlLXRvZ2dsZS1jb250YWluZXIgeyBjdXJzb3I6IGRlZmF1bHQ7IH0gLm1kLXNsaWRlLXRvZ2dsZS1jb250ZW50IHsgZm9udC1zaXplOiAxNHB4OyBmb250LWZhbWlseTogUm9ib3RvLCBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBzYW5zLXNlcmlmOyBmb250LXdlaWdodDogNTAwOyB9IC5tZC1zbGlkZS10b2dnbGUtbGFiZWwgeyBkaXNwbGF5OiBmbGV4OyBmbGV4OiAxOyBjdXJzb3I6IHBvaW50ZXI7IH0gLm1kLXNsaWRlLXRvZ2dsZS1jb250YWluZXIgeyBjdXJzb3I6IGdyYWI7IHdpZHRoOiAzNnB4OyBoZWlnaHQ6IDI0cHg7IHBvc2l0aW9uOiByZWxhdGl2ZTsgdXNlci1zZWxlY3Q6IG5vbmU7IG1hcmdpbi1yaWdodDogOHB4OyB9IC5tZC1zbGlkZS10b2dnbGUtdGh1bWItY29udGFpbmVyIHsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDJweDsgbGVmdDogMDsgei1pbmRleDogMTsgd2lkdGg6IDE2cHg7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7IHRyYW5zaXRpb246IGFsbCA4MG1zIGxpbmVhcjsgdHJhbnNpdGlvbi1wcm9wZXJ0eTogdHJhbnNmb3JtOyB9IC5tZC1zbGlkZS10b2dnbGUtdGh1bWItY29udGFpbmVyLm1kLWRyYWdnaW5nIHsgdHJhbnNpdGlvbi1kdXJhdGlvbjogMG1zOyB9IC5tZC1zbGlkZS10b2dnbGUtdGh1bWIgeyBwb3NpdGlvbjogYWJzb2x1dGU7IG1hcmdpbjogMDsgbGVmdDogMDsgdG9wOiAwOyBoZWlnaHQ6IDIwcHg7IHdpZHRoOiAyMHB4OyBib3JkZXItcmFkaXVzOiA1MCU7IGJveC1zaGFkb3c6IDBweCAycHggMXB4IC0xcHggcmdiYSgwLCAwLCAwLCAwLjIpLCAwcHggMXB4IDFweCAwcHggcmdiYSgwLCAwLCAwLCAwLjE0KSwgMHB4IDFweCAzcHggMHB4IHJnYmEoMCwgMCwgMCwgMC4xMik7IH0gLm1kLXNsaWRlLXRvZ2dsZS1iYXIgeyBwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDFweDsgdG9wOiA1cHg7IHdpZHRoOiAzNHB4OyBoZWlnaHQ6IDE0cHg7IGJvcmRlci1yYWRpdXM6IDhweDsgfSAubWQtc2xpZGUtdG9nZ2xlLWlucHV0IHsgYm90dG9tOiAwOyBsZWZ0OiAxMHB4OyB9IC5tZC1zbGlkZS10b2dnbGUtYmFyLCAubWQtc2xpZGUtdG9nZ2xlLXRodW1iIHsgdHJhbnNpdGlvbjogYWxsIDgwbXMgbGluZWFyOyB0cmFuc2l0aW9uLXByb3BlcnR5OiBiYWNrZ3JvdW5kLWNvbG9yOyB0cmFuc2l0aW9uLWRlbGF5OiA1MG1zOyB9IC8qIyBzb3VyY2VNYXBwaW5nVVJMPXNsaWRlLXRvZ2dsZS5jc3MubWFwICovIFwiXSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW01EX1NMSURFX1RPR0dMRV9WQUxVRV9BQ0NFU1NPUl0sXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQyMignZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBNZFNsaWRlVG9nZ2xlKTtcbiAgICByZXR1cm4gTWRTbGlkZVRvZ2dsZTtcbn0oKSk7XG4vKipcbiAqIFJlbmRlcmVyIGZvciB0aGUgU2xpZGUgVG9nZ2xlIGNvbXBvbmVudCwgd2hpY2ggc2VwYXJhdGVzIERPTSBtb2RpZmljYXRpb24gaW4gaXRzIG93biBjbGFzc1xuICovXG52YXIgU2xpZGVUb2dnbGVSZW5kZXJlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2xpZGVUb2dnbGVSZW5kZXJlcihfZWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuX3RodW1iRWwgPSBfZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tZC1zbGlkZS10b2dnbGUtdGh1bWItY29udGFpbmVyJyk7XG4gICAgICAgIHRoaXMuX3RodW1iQmFyRWwgPSBfZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tZC1zbGlkZS10b2dnbGUtYmFyJyk7XG4gICAgfVxuICAgIC8qKiBXaGV0aGVyIHRoZSBzbGlkZS10b2dnbGUgaXMgY3VycmVudGx5IGRyYWdnaW5nLiAqL1xuICAgIFNsaWRlVG9nZ2xlUmVuZGVyZXIucHJvdG90eXBlLmlzRHJhZ2dpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX3RodW1iQmFyV2lkdGg7XG4gICAgfTtcbiAgICAvKiogSW5pdGlhbGl6ZXMgdGhlIGRyYWcgb2YgdGhlIHNsaWRlLXRvZ2dsZS4gKi9cbiAgICBTbGlkZVRvZ2dsZVJlbmRlcmVyLnByb3RvdHlwZS5zdGFydFRodW1iRHJhZyA9IGZ1bmN0aW9uIChjaGVja2VkKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGh1bWJCYXJXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5fdGh1bWJCYXJXaWR0aCA9IHRoaXMuX3RodW1iQmFyRWwuY2xpZW50V2lkdGggLSB0aGlzLl90aHVtYkVsLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tlZCA9IGNoZWNrZWQ7XG4gICAgICAgICAgICB0aGlzLl90aHVtYkVsLmNsYXNzTGlzdC5hZGQoJ21kLWRyYWdnaW5nJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBTdG9wcyB0aGUgY3VycmVudCBkcmFnIGFuZCByZXR1cm5zIHRoZSBuZXcgY2hlY2tlZCB2YWx1ZS4gKi9cbiAgICBTbGlkZVRvZ2dsZVJlbmRlcmVyLnByb3RvdHlwZS5zdG9wVGh1bWJEcmFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fdGh1bWJCYXJXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5fdGh1bWJCYXJXaWR0aCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl90aHVtYkVsLmNsYXNzTGlzdC5yZW1vdmUoJ21kLWRyYWdnaW5nJyk7XG4gICAgICAgICAgICBhcHBseUNzc1RyYW5zZm9ybSh0aGlzLl90aHVtYkVsLCAnJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVyY2VudGFnZSA+IDUwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogVXBkYXRlcyB0aGUgdGh1bWIgY29udGFpbmVycyBwb3NpdGlvbiBmcm9tIHRoZSBzcGVjaWZpZWQgZGlzdGFuY2UuICovXG4gICAgU2xpZGVUb2dnbGVSZW5kZXJlci5wcm90b3R5cGUudXBkYXRlVGh1bWJQb3NpdGlvbiA9IGZ1bmN0aW9uIChkaXN0YW5jZSkge1xuICAgICAgICBpZiAodGhpcy5fdGh1bWJCYXJXaWR0aCkge1xuICAgICAgICAgICAgdGhpcy5fcGVyY2VudGFnZSA9IHRoaXMuX2dldFRodW1iUGVyY2VudGFnZShkaXN0YW5jZSk7XG4gICAgICAgICAgICBhcHBseUNzc1RyYW5zZm9ybSh0aGlzLl90aHVtYkVsLCBcInRyYW5zbGF0ZTNkKFwiICsgdGhpcy5fcGVyY2VudGFnZSArIFwiJSwgMCwgMClcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBSZXRyaWV2ZXMgdGhlIHBlcmNlbnRhZ2Ugb2YgdGh1bWIgZnJvbSB0aGUgbW92ZWQgZGlzdGFuY2UuICovXG4gICAgU2xpZGVUb2dnbGVSZW5kZXJlci5wcm90b3R5cGUuX2dldFRodW1iUGVyY2VudGFnZSA9IGZ1bmN0aW9uIChkaXN0YW5jZSkge1xuICAgICAgICB2YXIgcGVyY2VudGFnZSA9IChkaXN0YW5jZSAvIHRoaXMuX3RodW1iQmFyV2lkdGgpICogMTAwO1xuICAgICAgICAvLyBXaGVuIHRoZSB0b2dnbGUgd2FzIGluaXRpYWxseSBjaGVja2VkLCB0aGVuIHdlIGhhdmUgdG8gc3RhcnQgdGhlIGRyYWcgYXQgdGhlIGVuZC5cbiAgICAgICAgaWYgKHRoaXMuX2NoZWNrZWQpIHtcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgKz0gMTAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihwZXJjZW50YWdlLCAxMDApKTtcbiAgICB9O1xuICAgIHJldHVybiBTbGlkZVRvZ2dsZVJlbmRlcmVyO1xufSgpKTtcbnZhciBNZFNsaWRlVG9nZ2xlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNsaWRlVG9nZ2xlTW9kdWxlKCkge1xuICAgIH1cbiAgICBNZFNsaWRlVG9nZ2xlTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRTbGlkZVRvZ2dsZU1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkhBTU1FUl9HRVNUVVJFX0NPTkZJRywgdXNlQ2xhc3M6IE1kR2VzdHVyZUNvbmZpZyB9XVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRTbGlkZVRvZ2dsZU1vZHVsZSA9IF9fZGVjb3JhdGUkMjIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtfYW5ndWxhcl9mb3Jtcy5Gb3Jtc01vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRTbGlkZVRvZ2dsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFNsaWRlVG9nZ2xlXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDIyKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kU2xpZGVUb2dnbGVNb2R1bGUpO1xuICAgIHJldHVybiBNZFNsaWRlVG9nZ2xlTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMjMgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjMgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogVmlzdWFsbHksIGEgMzBweCBzZXBhcmF0aW9uIGJldHdlZW4gdGljayBtYXJrcyBsb29rcyBiZXN0LiBUaGlzIGlzIHZlcnkgc3ViamVjdGl2ZSBidXQgaXQgaXNcbiAqIHRoZSBkZWZhdWx0IHNlcGFyYXRpb24gd2UgY2hvc2UuXG4gKi9cbnZhciBNSU5fQVVUT19USUNLX1NFUEFSQVRJT04gPSAzMDtcbi8qKlxuICogUHJvdmlkZXIgRXhwcmVzc2lvbiB0aGF0IGFsbG93cyBtZC1zbGlkZXIgdG8gcmVnaXN0ZXIgYXMgYSBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAqIFRoaXMgYWxsb3dzIGl0IHRvIHN1cHBvcnQgWyhuZ01vZGVsKV0gYW5kIFtmb3JtQ29udHJvbF0uXG4gKi9cbnZhciBNRF9TTElERVJfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogX2FuZ3VsYXJfZm9ybXMuTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IF9hbmd1bGFyX2NvcmUuZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNZFNsaWRlcjsgfSksXG4gICAgbXVsdGk6IHRydWVcbn07XG52YXIgTWRTbGlkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU2xpZGVyKGVsZW1lbnRSZWYpIHtcbiAgICAgICAgLyoqIEEgcmVuZGVyZXIgdG8gaGFuZGxlIHVwZGF0aW5nIHRoZSBzbGlkZXIncyB0aHVtYiBhbmQgZmlsbCB0cmFjay4gKi9cbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICAgICAgICAvKiogVGhlIGRpbWVuc2lvbnMgb2YgdGhlIHNsaWRlci4gKi9cbiAgICAgICAgdGhpcy5fc2xpZGVyRGltZW5zaW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIFdoZXRoZXIgb3Igbm90IHRvIHNob3cgdGhlIHRodW1iIGxhYmVsLiAqL1xuICAgICAgICB0aGlzLnRodW1iTGFiZWwgPSBmYWxzZTtcbiAgICAgICAgLyoqIFRoZSBtaW5pdW11bSB2YWx1ZSB0aGF0IHRoZSBzbGlkZXIgY2FuIGhhdmUuICovXG4gICAgICAgIHRoaXMuX21pbiA9IDA7XG4gICAgICAgIC8qKiBUaGUgbWF4aW11bSB2YWx1ZSB0aGF0IHRoZSBzbGlkZXIgY2FuIGhhdmUuICovXG4gICAgICAgIHRoaXMuX21heCA9IDEwMDtcbiAgICAgICAgLyoqIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBzbGlkZXIgdGhhdCBjb2luY2lkZXMgd2l0aCB0aGUgdmFsdWUuICovXG4gICAgICAgIHRoaXMuX3BlcmNlbnQgPSAwO1xuICAgICAgICB0aGlzLl9jb250cm9sVmFsdWVBY2Nlc3NvckNoYW5nZUZuID0gZnVuY3Rpb24gKHZhbHVlKSB7IH07XG4gICAgICAgIC8qKiBvblRvdWNoIGZ1bmN0aW9uIHJlZ2lzdGVyZWQgdmlhIHJlZ2lzdGVyT25Ub3VjaCAoQ29udHJvbFZhbHVlQWNjZXNzb3IpLiAqL1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgLyoqIFRoZSB2YWx1ZXMgYXQgd2hpY2ggdGhlIHRodW1iIHdpbGwgc25hcC4gKi9cbiAgICAgICAgdGhpcy5zdGVwID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSB0aHVtYiBpcyBzbGlkaW5nLlxuICAgICAgICAgKiBVc2VkIHRvIGRldGVybWluZSBpZiB0aGVyZSBzaG91bGQgYmUgYSB0cmFuc2l0aW9uIGZvciB0aGUgdGh1bWIgYW5kIGZpbGwgdHJhY2suXG4gICAgICAgICAqIFRPRE86IGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzU2xpZGluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHNsaWRlciBpcyBhY3RpdmUgKGNsaWNrZWQgb3Igc2xpZGluZykuXG4gICAgICAgICAqIFVzZWQgdG8gc2hyaW5rIGFuZCBncm93IHRoZSB0aHVtYiBhcyBhY2NvcmRpbmcgdG8gdGhlIE1hdGVyaWFsIERlc2lnbiBzcGVjLlxuICAgICAgICAgKiBUT0RPOiBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvKiogSW5kaWNhdG9yIGZvciBpZiB0aGUgdmFsdWUgaGFzIGJlZW4gc2V0IG9yIG5vdC4gKi9cbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICAvKiogVmFsdWUgb2YgdGhlIHNsaWRlci4gKi9cbiAgICAgICAgdGhpcy5fdmFsdWUgPSAwO1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IG5ldyBTbGlkZXJSZW5kZXJlcihlbGVtZW50UmVmKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2xpZGVyLnByb3RvdHlwZSwgXCJtaW5cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9taW47XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaGFzIHRvIGJlIGZvcmNlZCBhcyBhIG51bWJlciB0byBoYW5kbGUgdGhlIG1hdGggbGF0ZXIuXG4gICAgICAgICAgICB0aGlzLl9taW4gPSBOdW1iZXIodik7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgd2Fzbid0IGV4cGxpY2l0bHkgc2V0IGJ5IHRoZSB1c2VyLCBzZXQgaXQgdG8gdGhlIG1pbi5cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9taW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwibWF4XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWF4O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9tYXggPSBOdW1iZXIodik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNsaWRlci5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgLy8gT25seSBzZXQgdGhlIHZhbHVlIHRvIGEgdmFsaWQgbnVtYmVyLiB2IGlzIGNhc3RlZCB0byBhbiBhbnkgYXMgd2Uga25vdyBpdCB3aWxsIGNvbWUgaW4gYXMgYVxuICAgICAgICAgICAgLy8gc3RyaW5nIGJ1dCBpdCBpcyBsYWJlbGVkIGFzIGEgbnVtYmVyIHdoaWNoIGNhdXNlcyBwYXJzZUZsb2F0IHRvIG5vdCBhY2NlcHQgaXQuXG4gICAgICAgICAgICBpZiAoaXNOYU4ocGFyc2VGbG9hdCh2KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IE51bWJlcih2KTtcbiAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbFZhbHVlQWNjZXNzb3JDaGFuZ2VGbih0aGlzLl92YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIE9uY2UgdGhlIHNsaWRlciBoYXMgcmVuZGVyZWQsIGdyYWIgdGhlIGRpbWVuc2lvbnMgYW5kIHVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIHRodW1iIGFuZFxuICAgICAqIGZpbGwgdHJhY2suXG4gICAgICogVE9ETzogaW50ZXJuYWxcbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9zbGlkZXJEaW1lbnNpb25zID0gdGhpcy5fcmVuZGVyZXIuZ2V0U2xpZGVyRGltZW5zaW9ucygpO1xuICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGNhbGxlZCBhZnRlciBjb250ZW50IGluaXQgYmVjYXVzZSB0aGUgdmFsdWUgY2FuIGJlIHNldCB0byB0aGUgbWluIGlmIHRoZVxuICAgICAgICAvLyB2YWx1ZSBpdHNlbGYgaXNuJ3Qgc2V0LiBJZiB0aGlzIGhhcHBlbnMsIHRoZSBjb250cm9sIHZhbHVlIGFjY2Vzc29yIG5lZWRzIHRvIGJlIHVwZGF0ZWQuXG4gICAgICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4odGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMuc25hcFRodW1iVG9WYWx1ZSgpO1xuICAgICAgICB0aGlzLl91cGRhdGVUaWNrU2VwYXJhdGlvbigpO1xuICAgIH07XG4gICAgLyoqIFRPRE86IGludGVybmFsICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkRm9jdXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUZyb21Qb3NpdGlvbihldmVudC5jbGllbnRYKTtcbiAgICAgICAgdGhpcy5zbmFwVGh1bWJUb1ZhbHVlKCk7XG4gICAgfTtcbiAgICAvKiogVE9ETzogaW50ZXJuYWwgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUub25TbGlkZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgdGhlIHNsaWRlIGZyb20gc2VsZWN0aW5nIGFueXRoaW5nIGVsc2UuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVGcm9tUG9zaXRpb24oZXZlbnQuY2VudGVyLngpO1xuICAgIH07XG4gICAgLyoqIFRPRE86IGludGVybmFsICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLm9uU2xpZGVTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuaXNTbGlkaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZEZvY3VzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVGcm9tUG9zaXRpb24oZXZlbnQuY2VudGVyLngpO1xuICAgIH07XG4gICAgLyoqIFRPRE86IGludGVybmFsICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLm9uU2xpZGVFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc25hcFRodW1iVG9WYWx1ZSgpO1xuICAgIH07XG4gICAgLyoqIFRPRE86IGludGVybmFsICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzU2xpZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NsaWRlckRpbWVuc2lvbnMgPSB0aGlzLl9yZW5kZXJlci5nZXRTbGlkZXJEaW1lbnNpb25zKCk7XG4gICAgICAgIC8vIFNraXAgdXBkYXRpbmcgdGhlIHZhbHVlIGFuZCBwb3NpdGlvbiBhcyB0aGVyZSBpcyBubyBuZXcgcGxhY2VtZW50LlxuICAgICAgICB0aGlzLl9yZW5kZXJlci51cGRhdGVUaHVtYkFuZEZpbGxQb3NpdGlvbih0aGlzLl9wZXJjZW50LCB0aGlzLl9zbGlkZXJEaW1lbnNpb25zLndpZHRoKTtcbiAgICB9O1xuICAgIC8qKiBUT0RPOiBpbnRlcm5hbCAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5vbkJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgd2l0aG91dCBhIHBoeXNpY2FsIHBvc2l0aW9uLCB0aGUgcGVyY2VudGFnZSBuZWVkcyB0byBiZSByZWNhbGN1bGF0ZWRcbiAgICAgKiBpbmRlcGVuZGVudCBvZiB0aGUgcGh5c2ljYWwgbG9jYXRpb24uXG4gICAgICogVGhpcyBpcyBhbHNvIHVzZWQgdG8gbW92ZSB0aGUgdGh1bWIgdG8gYSBzbmFwcGVkIHZhbHVlIG9uY2Ugc2xpZGluZyBpcyBkb25lLlxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS51cGRhdGVQZXJjZW50RnJvbVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wZXJjZW50ID0gdGhpcy5jYWxjdWxhdGVQZXJjZW50YWdlKHRoaXMudmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBuZXcgdmFsdWUgZnJvbSB0aGUgbmV3IHBoeXNpY2FsIGxvY2F0aW9uLiBUaGUgdmFsdWUgd2lsbCBhbHdheXMgYmUgc25hcHBlZC5cbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUudXBkYXRlVmFsdWVGcm9tUG9zaXRpb24gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9zbGlkZXJEaW1lbnNpb25zLmxlZnQ7XG4gICAgICAgIHZhciBzaXplID0gdGhpcy5fc2xpZGVyRGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgLy8gVGhlIGV4YWN0IHZhbHVlIGlzIGNhbGN1bGF0ZWQgZnJvbSB0aGUgZXZlbnQgYW5kIHVzZWQgdG8gZmluZCB0aGUgY2xvc2VzdCBzbmFwIHZhbHVlLlxuICAgICAgICB0aGlzLl9wZXJjZW50ID0gdGhpcy5jbGFtcCgocG9zIC0gb2Zmc2V0KSAvIHNpemUpO1xuICAgICAgICB2YXIgZXhhY3RWYWx1ZSA9IHRoaXMuY2FsY3VsYXRlVmFsdWUodGhpcy5fcGVyY2VudCk7XG4gICAgICAgIC8vIFRoaXMgY2FsY3VsYXRpb24gZmluZHMgdGhlIGNsb3Nlc3Qgc3RlcCBieSBmaW5kaW5nIHRoZSBjbG9zZXN0IHdob2xlIG51bWJlciBkaXZpc2libGUgYnkgdGhlXG4gICAgICAgIC8vIHN0ZXAgcmVsYXRpdmUgdG8gdGhlIG1pbi5cbiAgICAgICAgdmFyIGNsb3Nlc3RWYWx1ZSA9IE1hdGgucm91bmQoKGV4YWN0VmFsdWUgLSB0aGlzLm1pbikgLyB0aGlzLnN0ZXApICogdGhpcy5zdGVwICsgdGhpcy5taW47XG4gICAgICAgIC8vIFRoZSB2YWx1ZSBuZWVkcyB0byBzbmFwIHRvIHRoZSBtaW4gYW5kIG1heC5cbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuY2xhbXAoY2xvc2VzdFZhbHVlLCB0aGlzLm1pbiwgdGhpcy5tYXgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci51cGRhdGVUaHVtYkFuZEZpbGxQb3NpdGlvbih0aGlzLl9wZXJjZW50LCB0aGlzLl9zbGlkZXJEaW1lbnNpb25zLndpZHRoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNuYXBzIHRoZSB0aHVtYiB0byB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgKiBDYWxsZWQgYWZ0ZXIgYSBjbGljayBvciBkcmFnIGV2ZW50IGlzIG92ZXIuXG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLnNuYXBUaHVtYlRvVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUGVyY2VudEZyb21WYWx1ZSgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci51cGRhdGVUaHVtYkFuZEZpbGxQb3NpdGlvbih0aGlzLl9wZXJjZW50LCB0aGlzLl9zbGlkZXJEaW1lbnNpb25zLndpZHRoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHNlcGFyYXRpb24gaW4gcGl4ZWxzIG9mIHRpY2sgbWFya3MuIElmIHRoZXJlIGlzIG5vIHRpY2sgaW50ZXJ2YWwgb3IgdGhlIGludGVydmFsXG4gICAgICogaXMgc2V0IHRvIHNvbWV0aGluZyBvdGhlciB0aGFuIGEgbnVtYmVyIG9yICdhdXRvJywgbm90aGluZyBoYXBwZW5zLlxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5fdXBkYXRlVGlja1NlcGFyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90aWNrSW50ZXJ2YWwgPT0gJ2F1dG8nKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVBdXRvVGlja1NlcGFyYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChOdW1iZXIodGhpcy5fdGlja0ludGVydmFsKSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGlja1NlcGFyYXRpb25Gcm9tSW50ZXJ2YWwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgb3B0aW1hbCBzZXBhcmF0aW9uIGluIHBpeGVscyBvZiB0aWNrIG1hcmtzIGJhc2VkIG9uIHRoZSBtaW5pbXVtIGF1dG8gdGlja1xuICAgICAqIHNlcGFyYXRpb24gY29uc3RhbnQuXG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl91cGRhdGVBdXRvVGlja1NlcGFyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFdlJ3JlIGxvb2tpbmcgZm9yIHRoZSBtdWx0aXBsZSBvZiBzdGVwIGZvciB3aGljaCB0aGUgc2VwYXJhdGlvbiBiZXR3ZWVuIGlzIGdyZWF0ZXIgdGhhbiB0aGVcbiAgICAgICAgLy8gbWluaW11bSB0aWNrIHNlcGFyYXRpb24uXG4gICAgICAgIHZhciBzbGlkZXJXaWR0aCA9IHRoaXMuX3NsaWRlckRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIHRvdGFsIFwid2lkdGhcIiBvZiB0aGUgc2xpZGVyIGluIHRlcm1zIG9mIHZhbHVlcy5cbiAgICAgICAgdmFyIHZhbHVlV2lkdGggPSB0aGlzLm1heCAtIHRoaXMubWluO1xuICAgICAgICAvLyBDYWxjdWxhdGUgaG93IG1hbnkgdmFsdWVzIGV4aXN0IHdpdGhpbiAxcHggb24gdGhlIHNsaWRlci5cbiAgICAgICAgdmFyIHZhbHVlUGVyUGl4ZWwgPSB2YWx1ZVdpZHRoIC8gc2xpZGVyV2lkdGg7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBob3cgbWFueSB2YWx1ZXMgZXhpc3QgaW4gdGhlIG1pbmltdW0gdGljayBzZXBhcmF0aW9uIChweCkuXG4gICAgICAgIHZhciB2YWx1ZVBlclNlcGFyYXRpb24gPSB2YWx1ZVBlclBpeGVsICogTUlOX0FVVE9fVElDS19TRVBBUkFUSU9OO1xuICAgICAgICAvLyBDYWxjdWxhdGUgaG93IG1hbnkgc3RlcHMgZXhpc3QgaW4gdGhpcyBzZXBhcmF0aW9uLiBUaGlzIHdpbGwgYmUgdGhlIGxvd2VzdCB2YWx1ZSB5b3UgY2FuXG4gICAgICAgIC8vIG11bHRpcGx5IHN0ZXAgYnkgdG8gZ2V0IGEgc2VwYXJhdGlvbiB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbWluaW11bSB0aWNrXG4gICAgICAgIC8vIHNlcGFyYXRpb24uXG4gICAgICAgIHZhciBzdGVwc1BlclNlcGFyYXRpb24gPSBNYXRoLmNlaWwodmFsdWVQZXJTZXBhcmF0aW9uIC8gdGhpcy5zdGVwKTtcbiAgICAgICAgLy8gR2V0IHRoZSBwZXJjZW50YWdlIG9mIHRoZSBzbGlkZXIgZm9yIHdoaWNoIHRoaXMgdGljayB3b3VsZCBiZSBsb2NhdGVkIHNvIHdlIGNhbiB0aGVuIGRyYXdcbiAgICAgICAgLy8gaXQgb24gdGhlIHNsaWRlci5cbiAgICAgICAgdmFyIHRpY2tQZXJjZW50YWdlID0gdGhpcy5jYWxjdWxhdGVQZXJjZW50YWdlKCh0aGlzLnN0ZXAgKiBzdGVwc1BlclNlcGFyYXRpb24pICsgdGhpcy5taW4pO1xuICAgICAgICAvLyBUaGUgcGl4ZWwgdmFsdWUgb2YgdGhlIHRpY2sgaXMgdGhlIHBlcmNlbnRhZ2UgKiB0aGUgd2lkdGggb2YgdGhlIHNsaWRlci4gVXNlIHRoaXMgdG8gZHJhd1xuICAgICAgICAvLyB0aGUgdGlja3Mgb24gdGhlIHNsaWRlci5cbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuZHJhd1RpY2tzKHNsaWRlcldpZHRoICogdGlja1BlcmNlbnRhZ2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgc2VwYXJhdGlvbiBvZiB0aWNrIG1hcmtzIGJ5IGZpbmRpbmcgdGhlIHBpeGVsIHZhbHVlIG9mIHRoZSB0aWNrSW50ZXJ2YWwuXG4gICAgICovXG4gICAgTWRTbGlkZXIucHJvdG90eXBlLl91cGRhdGVUaWNrU2VwYXJhdGlvbkZyb21JbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRm9yY2UgdGlja0ludGVydmFsIHRvIGJlIGEgbnVtYmVyIHNvIGl0IGNhbiBiZSB1c2VkIGluIGNhbGN1bGF0aW9ucy5cbiAgICAgICAgdmFyIGludGVydmFsID0gdGhpcy5fdGlja0ludGVydmFsO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGZpcnN0IHZhbHVlIGEgdGljayB3aWxsIGJlIGxvY2F0ZWQgYXQgYnkgZ2V0dGluZyB0aGUgc3RlcCBhdCB3aGljaCB0aGUgaW50ZXJ2YWxcbiAgICAgICAgLy8gbGFuZHMgYW5kIGFkZGluZyB0aGF0IHRvIHRoZSBtaW4uXG4gICAgICAgIHZhciB0aWNrVmFsdWUgPSAodGhpcy5zdGVwICogaW50ZXJ2YWwpICsgdGhpcy5taW47XG4gICAgICAgIC8vIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBzdGVwIG9uIHRoZSBzbGlkZXIgaXMgbmVlZGVkIGluIG9yZGVyIHRvIGNhbGN1bGF0ZSB0aGUgcGl4ZWwgb2Zmc2V0XG4gICAgICAgIC8vIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgc2xpZGVyLiBUaGlzIG9mZnNldCBpcyB0aGUgdGljayBzZXBhcmF0aW9uLlxuICAgICAgICB2YXIgdGlja1BlcmNlbnRhZ2UgPSB0aGlzLmNhbGN1bGF0ZVBlcmNlbnRhZ2UodGlja1ZhbHVlKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuZHJhd1RpY2tzKHRoaXMuX3NsaWRlckRpbWVuc2lvbnMud2lkdGggKiB0aWNrUGVyY2VudGFnZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBzbGlkZXIgdGhhdCBhIHZhbHVlIGlzLlxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5jYWxjdWxhdGVQZXJjZW50YWdlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB2YWx1ZSBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHNsaWRlciBjb3JyZXNwb25kcyB0by5cbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuY2FsY3VsYXRlVmFsdWUgPSBmdW5jdGlvbiAocGVyY2VudGFnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4gKyAocGVyY2VudGFnZSAqICh0aGlzLm1heCAtIHRoaXMubWluKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBudW1iZXIgYmV0d2VlbiB0d28gbnVtYmVycy5cbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUuY2xhbXAgPSBmdW5jdGlvbiAodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgICAgIGlmIChtaW4gPT09IHZvaWQgMCkgeyBtaW4gPSAwOyB9XG4gICAgICAgIGlmIChtYXggPT09IHZvaWQgMCkgeyBtYXggPSAxOyB9XG4gICAgICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHZhbHVlLCBtYXgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogVE9ETzogaW50ZXJuYWxcbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9zbGlkZXJEaW1lbnNpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnNuYXBUaHVtYlRvVmFsdWUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBUT0RPOiBpbnRlcm5hbFxuICAgICAqL1xuICAgIE1kU2xpZGVyLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX2NvbnRyb2xWYWx1ZUFjY2Vzc29yQ2hhbmdlRm4gPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogVE9ETzogaW50ZXJuYWxcbiAgICAgKi9cbiAgICBNZFNsaWRlci5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMjMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksXG4gICAgICAgIEJvb2xlYW5GaWVsZFZhbHVlKCksXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2NsYXNzLm1kLXNsaWRlci1kaXNhYmxlZCcpLFxuICAgICAgICBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtZGlzYWJsZWQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjMoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFNsaWRlci5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDIzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgndGh1bWItbGFiZWwnKSxcbiAgICAgICAgQm9vbGVhbkZpZWxkVmFsdWUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjMoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZFNsaWRlci5wcm90b3R5cGUsIFwidGh1bWJMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMjMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDIzKCdkZXNpZ246dHlwZScsIE51bWJlcilcbiAgICBdLCBNZFNsaWRlci5wcm90b3R5cGUsIFwic3RlcFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMjMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCd0aWNrLWludGVydmFsJyksIFxuICAgICAgICBfX21ldGFkYXRhJDIzKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNsaWRlci5wcm90b3R5cGUsIFwiX3RpY2tJbnRlcnZhbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMjMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS12YWx1ZW1pbicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyMygnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTbGlkZXIucHJvdG90eXBlLCBcIm1pblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDIzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLFxuICAgICAgICBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtdmFsdWVtYXgnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjMoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2xpZGVyLnByb3RvdHlwZSwgXCJtYXhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQyMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSxcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnYXR0ci5hcmlhLXZhbHVlbm93JyksIFxuICAgICAgICBfX21ldGFkYXRhJDIzKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNsaWRlci5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XG4gICAgTWRTbGlkZXIgPSBfX2RlY29yYXRlJDIzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtc2xpZGVyJyxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW01EX1NMSURFUl9WQUxVRV9BQ0NFU1NPUl0sXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ3RhYmluZGV4JzogJzAnLFxuICAgICAgICAgICAgICAgICcoY2xpY2spJzogJ29uQ2xpY2soJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgJyhzbGlkZSknOiAnb25TbGlkZSgkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAnKHNsaWRlc3RhcnQpJzogJ29uU2xpZGVTdGFydCgkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAnKHNsaWRlZW5kKSc6ICdvblNsaWRlRW5kKCknLFxuICAgICAgICAgICAgICAgICcod2luZG93OnJlc2l6ZSknOiAnb25SZXNpemUoKScsXG4gICAgICAgICAgICAgICAgJyhibHVyKSc6ICdvbkJsdXIoKScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWQtc2xpZGVyLXdyYXBwZXJcXFwiPiA8ZGl2IGNsYXNzPVxcXCJtZC1zbGlkZXItY29udGFpbmVyXFxcIiBbY2xhc3MubWQtc2xpZGVyLXNsaWRpbmddPVxcXCJpc1NsaWRpbmdcXFwiIFtjbGFzcy5tZC1zbGlkZXItYWN0aXZlXT1cXFwiaXNBY3RpdmVcXFwiIFtjbGFzcy5tZC1zbGlkZXItdGh1bWItbGFiZWwtc2hvd2luZ109XFxcInRodW1iTGFiZWxcXFwiPiA8ZGl2IGNsYXNzPVxcXCJtZC1zbGlkZXItdHJhY2stY29udGFpbmVyXFxcIj4gPGRpdiBjbGFzcz1cXFwibWQtc2xpZGVyLXRyYWNrXFxcIj48L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWQtc2xpZGVyLXRyYWNrIG1kLXNsaWRlci10cmFjay1maWxsXFxcIj48L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWQtc2xpZGVyLXRpY2stY29udGFpbmVyXFxcIj48L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWQtc2xpZGVyLWxhc3QtdGljay1jb250YWluZXJcXFwiPjwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWQtc2xpZGVyLXRodW1iLWNvbnRhaW5lclxcXCI+IDxkaXYgY2xhc3M9XFxcIm1kLXNsaWRlci10aHVtYi1wb3NpdGlvblxcXCI+IDxkaXYgY2xhc3M9XFxcIm1kLXNsaWRlci10aHVtYlxcXCI+PC9kaXY+IDxkaXYgY2xhc3M9XFxcIm1kLXNsaWRlci10aHVtYi1sYWJlbFxcXCI+IDxzcGFuIGNsYXNzPVxcXCJtZC1zbGlkZXItdGh1bWItbGFiZWwtdGV4dFxcXCI+e3t2YWx1ZX19PC9zcGFuPiA8L2Rpdj4gPC9kaXY+IDwvZGl2PiA8L2Rpdj4gPC9kaXY+IFwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCJtZC1zbGlkZXIgeyBoZWlnaHQ6IDQ4cHg7IG1pbi13aWR0aDogMTI4cHg7IHBvc2l0aW9uOiByZWxhdGl2ZTsgcGFkZGluZzogMDsgZGlzcGxheTogaW5saW5lLWJsb2NrOyBvdXRsaW5lOiBub25lOyB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyB9IG1kLXNsaWRlciAqLCBtZC1zbGlkZXIgKjo6YWZ0ZXIgeyBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9IC5tZC1zbGlkZXItd3JhcHBlciB7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IHBhZGRpbmctbGVmdDogOHB4OyBwYWRkaW5nLXJpZ2h0OiA4cHg7IH0gLm1kLXNsaWRlci1jb250YWluZXIgeyBwb3NpdGlvbjogcmVsYXRpdmU7IH0gLm1kLXNsaWRlci10cmFjay1jb250YWluZXIgeyB3aWR0aDogMTAwJTsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDIzcHg7IGhlaWdodDogMnB4OyB9IC5tZC1zbGlkZXItdHJhY2sgeyBwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDA7IHJpZ2h0OiAwOyBoZWlnaHQ6IDEwMCU7IH0gLm1kLXNsaWRlci10cmFjay1maWxsIHsgdHJhbnNpdGlvbi1kdXJhdGlvbjogNDAwbXM7IHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKTsgdHJhbnNpdGlvbi1wcm9wZXJ0eTogd2lkdGgsIGhlaWdodDsgfSAubWQtc2xpZGVyLXRpY2stY29udGFpbmVyLCAubWQtc2xpZGVyLWxhc3QtdGljay1jb250YWluZXIgeyBwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDA7IHJpZ2h0OiAwOyBoZWlnaHQ6IDEwMCU7IH0gLm1kLXNsaWRlci10aHVtYi1jb250YWluZXIgeyBwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDA7IHRvcDogNTAlOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApOyB0cmFuc2l0aW9uLWR1cmF0aW9uOiA0MDBtczsgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjI1LCAwLjgsIDAuMjUsIDEpOyB0cmFuc2l0aW9uLXByb3BlcnR5OiBsZWZ0LCBib3R0b207IH0gLm1kLXNsaWRlci10aHVtYi1wb3NpdGlvbiB7IHRyYW5zaXRpb246IHRyYW5zZm9ybSA0MDBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKTsgfSAubWQtc2xpZGVyLXRodW1iIHsgei1pbmRleDogMTsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDE0cHg7IGxlZnQ6IC0xMHB4OyB3aWR0aDogMjBweDsgaGVpZ2h0OiAyMHB4OyBib3JkZXItcmFkaXVzOiAyMHB4OyB0cmFuc2Zvcm06IHNjYWxlKDAuNyk7IHRyYW5zaXRpb246IHRyYW5zZm9ybSA0MDBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKTsgfSAubWQtc2xpZGVyLXRodW1iOjphZnRlciB7IGNvbnRlbnQ6ICcnOyBwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAyMHB4OyBoZWlnaHQ6IDIwcHg7IGJvcmRlci1yYWRpdXM6IDIwcHg7IGJvcmRlci13aWR0aDogM3B4OyBib3JkZXItc3R5bGU6IHNvbGlkOyB0cmFuc2l0aW9uOiBpbmhlcml0OyB9IC5tZC1zbGlkZXItdGh1bWItbGFiZWwgeyBkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsgcG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAtMTRweDsgdG9wOiAtMTdweDsgd2lkdGg6IDI4cHg7IGhlaWdodDogMjhweDsgYm9yZGVyLXJhZGl1czogNTAlOyB0cmFuc2Zvcm06IHNjYWxlKDAuNCkgdHJhbnNsYXRlM2QoMCwgNjcuNXB4LCAwKSByb3RhdGUoNDVkZWcpOyB0cmFuc2l0aW9uOiAzMDBtcyBjdWJpYy1iZXppZXIoMC4zNSwgMCwgMC4yNSwgMSk7IHRyYW5zaXRpb24tcHJvcGVydHk6IHRyYW5zZm9ybSwgYm9yZGVyLXJhZGl1czsgfSAubWQtc2xpZGVyLXRodW1iLWxhYmVsLXRleHQgeyB6LWluZGV4OiAxOyBmb250LXNpemU6IDEycHg7IGZvbnQtd2VpZ2h0OiBib2xkOyBvcGFjaXR5OiAwOyB0cmFuc2Zvcm06IHJvdGF0ZSgtNDVkZWcpOyB0cmFuc2l0aW9uOiBvcGFjaXR5IDMwMG1zIGN1YmljLWJlemllcigwLjM1LCAwLCAwLjI1LCAxKTsgfSAubWQtc2xpZGVyLWNvbnRhaW5lcjpub3QoLm1kLXNsaWRlci10aHVtYi1sYWJlbC1zaG93aW5nKSAubWQtc2xpZGVyLXRodW1iLWxhYmVsIHsgZGlzcGxheTogbm9uZTsgfSAubWQtc2xpZGVyLWFjdGl2ZS5tZC1zbGlkZXItdGh1bWItbGFiZWwtc2hvd2luZyAubWQtc2xpZGVyLXRodW1iIHsgdHJhbnNmb3JtOiBzY2FsZSgwKTsgfSAubWQtc2xpZGVyLXNsaWRpbmcgLm1kLXNsaWRlci10aHVtYi1wb3NpdGlvbiwgLm1kLXNsaWRlci1zbGlkaW5nIC5tZC1zbGlkZXItdHJhY2stZmlsbCB7IHRyYW5zaXRpb246IG5vbmU7IGN1cnNvcjogZGVmYXVsdDsgfSAubWQtc2xpZGVyLWFjdGl2ZSAubWQtc2xpZGVyLXRodW1iIHsgdHJhbnNmb3JtOiBzY2FsZSgxKTsgfSAubWQtc2xpZGVyLWFjdGl2ZSAubWQtc2xpZGVyLXRodW1iLWxhYmVsIHsgYm9yZGVyLXJhZGl1czogNTAlIDUwJSAwOyB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7IH0gLm1kLXNsaWRlci1hY3RpdmUgLm1kLXNsaWRlci10aHVtYi1sYWJlbC10ZXh0IHsgb3BhY2l0eTogMTsgfSAvKiMgc291cmNlTWFwcGluZ1VSTD1zbGlkZXIuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQyMygnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmXSlcbiAgICBdLCBNZFNsaWRlcik7XG4gICAgcmV0dXJuIE1kU2xpZGVyO1xufSgpKTtcbi8qKlxuICogUmVuZGVyZXIgY2xhc3MgaW4gb3JkZXIgdG8ga2VlcCBhbGwgZG9tIG1hbmlwdWxhdGlvbiBpbiBvbmUgcGxhY2UgYW5kIG91dHNpZGUgb2YgdGhlIG1haW4gY2xhc3MuXG4gKi9cbnZhciBTbGlkZXJSZW5kZXJlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2xpZGVyUmVuZGVyZXIoZWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9zbGlkZXJFbGVtZW50ID0gZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIHRoZSBzbGlkZXIgdHJhY2sgZWxlbWVudC5cbiAgICAgKiBUaGUgdHJhY2sgaXMgdXNlZCByYXRoZXIgdGhhbiB0aGUgbmF0aXZlIGVsZW1lbnQgdG8gaWdub3JlIHRoZSBleHRyYSBzcGFjZSB0aGF0IHRoZSB0aHVtYiBjYW5cbiAgICAgKiB0YWtlIHVwLlxuICAgICAqL1xuICAgIFNsaWRlclJlbmRlcmVyLnByb3RvdHlwZS5nZXRTbGlkZXJEaW1lbnNpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJhY2tFbGVtZW50ID0gdGhpcy5fc2xpZGVyRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubWQtc2xpZGVyLXRyYWNrJyk7XG4gICAgICAgIHJldHVybiB0cmFja0VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHBoeXNpY2FsIHBvc2l0aW9uIG9mIHRoZSB0aHVtYiBhbmQgZmlsbCB0cmFjayBvbiB0aGUgc2xpZGVyLlxuICAgICAqL1xuICAgIFNsaWRlclJlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVUaHVtYkFuZEZpbGxQb3NpdGlvbiA9IGZ1bmN0aW9uIChwZXJjZW50LCB3aWR0aCkge1xuICAgICAgICAvLyBBIGNvbnRhaW5lciBlbGVtZW50IHRoYXQgaXMgdXNlZCB0byBhdm9pZCBvdmVyd3JpdGluZyB0aGUgdHJhbnNmb3JtIG9uIHRoZSB0aHVtYiBpdHNlbGYuXG4gICAgICAgIHZhciB0aHVtYlBvc2l0aW9uRWxlbWVudCA9IHRoaXMuX3NsaWRlckVsZW1lbnQucXVlcnlTZWxlY3RvcignLm1kLXNsaWRlci10aHVtYi1wb3NpdGlvbicpO1xuICAgICAgICB2YXIgZmlsbFRyYWNrRWxlbWVudCA9IHRoaXMuX3NsaWRlckVsZW1lbnQucXVlcnlTZWxlY3RvcignLm1kLXNsaWRlci10cmFjay1maWxsJyk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IE1hdGgucm91bmQocGVyY2VudCAqIHdpZHRoKTtcbiAgICAgICAgZmlsbFRyYWNrRWxlbWVudC5zdHlsZS53aWR0aCA9IHBvc2l0aW9uICsgXCJweFwiO1xuICAgICAgICBhcHBseUNzc1RyYW5zZm9ybSh0aHVtYlBvc2l0aW9uRWxlbWVudCwgXCJ0cmFuc2xhdGVYKFwiICsgcG9zaXRpb24gKyBcInB4KVwiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvY3VzZXMgdGhlIG5hdGl2ZSBlbGVtZW50LlxuICAgICAqIEN1cnJlbnRseSBvbmx5IHVzZWQgdG8gYWxsb3cgYSBibHVyIGV2ZW50IHRvIGZpcmUgYnV0IHdpbGwgYmUgdXNlZCB3aXRoIGtleWJvYXJkIGlucHV0IGxhdGVyLlxuICAgICAqL1xuICAgIFNsaWRlclJlbmRlcmVyLnByb3RvdHlwZS5hZGRGb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2xpZGVyRWxlbWVudC5mb2N1cygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGlja3Mgb250byB0aGUgdGljayBjb250YWluZXIuXG4gICAgICovXG4gICAgU2xpZGVyUmVuZGVyZXIucHJvdG90eXBlLmRyYXdUaWNrcyA9IGZ1bmN0aW9uICh0aWNrU2VwYXJhdGlvbikge1xuICAgICAgICB2YXIgdGlja0NvbnRhaW5lciA9IHRoaXMuX3NsaWRlckVsZW1lbnQucXVlcnlTZWxlY3RvcignLm1kLXNsaWRlci10aWNrLWNvbnRhaW5lcicpO1xuICAgICAgICB2YXIgdGlja0NvbnRhaW5lcldpZHRoID0gdGlja0NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgLy8gQW4gZXh0cmEgZWxlbWVudCBmb3IgdGhlIGxhc3QgdGljayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgbGluZWFyIGdyYWRpZW50IGNhbm5vdCBiZSB0b2xkIHRvXG4gICAgICAgIC8vIGFsd2F5cyBkcmF3IGEgdGljayBhdCB0aGUgZW5kIG9mIHRoZSBncmFkaWVudC4gVG8gZ2V0IGFyb3VuZCB0aGlzLCB0aGVyZSBpcyBhIHNlY29uZFxuICAgICAgICAvLyBjb250YWluZXIgZm9yIHRpY2tzIHRoYXQgaGFzIGEgc2luZ2xlIHRpY2sgbWFyayBvbiB0aGUgdmVyeSByaWdodCBlZGdlLlxuICAgICAgICB2YXIgbGFzdFRpY2tDb250YWluZXIgPSB0aGlzLl9zbGlkZXJFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tZC1zbGlkZXItbGFzdC10aWNrLWNvbnRhaW5lcicpO1xuICAgICAgICAvLyBTdWJ0cmFjdCAxIGZyb20gdGhlIHRpY2sgc2VwYXJhdGlvbiB0byBjZW50ZXIgdGhlIHRpY2suXG4gICAgICAgIC8vIFRPRE86IEV2YWx1YXRlIHRoZSByZW5kZXJpbmcgcGVyZm9ybWFuY2Ugb2YgdXNpbmcgcmVwZWF0aW5nIGJhY2tncm91bmQgZ3JhZGllbnRzLlxuICAgICAgICB0aWNrQ29udGFpbmVyLnN0eWxlLmJhY2tncm91bmQgPSBcInJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIGJsYWNrLCBibGFjayAycHgsIFwiICtcbiAgICAgICAgICAgIChcInRyYW5zcGFyZW50IDJweCwgdHJhbnNwYXJlbnQgXCIgKyAodGlja1NlcGFyYXRpb24gLSAxKSArIFwicHgpXCIpO1xuICAgICAgICAvLyBBZGQgYSB0aWNrIHRvIHRoZSB2ZXJ5IGVuZCBieSBzdGFydGluZyBvbiB0aGUgcmlnaHQgc2lkZSBhbmQgYWRkaW5nIGEgMnB4IGJsYWNrIGxpbmUuXG4gICAgICAgIGxhc3RUaWNrQ29udGFpbmVyLnN0eWxlLmJhY2tncm91bmQgPSBcImxpbmVhci1ncmFkaWVudCh0byBsZWZ0LCBibGFjaywgYmxhY2sgMnB4LCB0cmFuc3BhcmVudCBcIiArXG4gICAgICAgICAgICBcIjJweCwgdHJhbnNwYXJlbnQpXCI7XG4gICAgICAgIC8vIElmIHRoZSBzZWNvbmQgdG8gbGFzdCB0aWNrIGlzIHRvbyBjbG9zZSAoYSBzZXBhcmF0aW9uIG9mIGxlc3MgdGhhbiBoYWxmIHRoZSBub3JtYWxcbiAgICAgICAgLy8gc2VwYXJhdGlvbiksIGRvbid0IHNob3cgaXQgYnkgZGVjcmVhc2luZyB0aGUgd2lkdGggb2YgdGhlIHRpY2sgY29udGFpbmVyIGVsZW1lbnQuXG4gICAgICAgIGlmICh0aWNrQ29udGFpbmVyV2lkdGggJSB0aWNrU2VwYXJhdGlvbiA8ICh0aWNrU2VwYXJhdGlvbiAvIDIpKSB7XG4gICAgICAgICAgICB0aWNrQ29udGFpbmVyLnN0eWxlLndpZHRoID0gdGlja0NvbnRhaW5lcldpZHRoIC0gdGlja1NlcGFyYXRpb24gKyAncHgnO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2xpZGVyUmVuZGVyZXI7XG59KCkpO1xudmFyIE1kU2xpZGVyTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNsaWRlck1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWRTbGlkZXJNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZFNsaWRlck1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkhBTU1FUl9HRVNUVVJFX0NPTkZJRywgdXNlQ2xhc3M6IE1kR2VzdHVyZUNvbmZpZyB9XVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRTbGlkZXJNb2R1bGUgPSBfX2RlY29yYXRlJDIzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbX2FuZ3VsYXJfZm9ybXMuRm9ybXNNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW01kU2xpZGVyXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kU2xpZGVyXSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogX2FuZ3VsYXJfcGxhdGZvcm1Ccm93c2VyLkhBTU1FUl9HRVNUVVJFX0NPTkZJRywgdXNlQ2xhc3M6IE1kR2VzdHVyZUNvbmZpZyB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDIzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kU2xpZGVyTW9kdWxlKTtcbiAgICByZXR1cm4gTWRTbGlkZXJNb2R1bGU7XG59KCkpO1xuXG52YXIgX19leHRlbmRzJDcgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIF9fZGVjb3JhdGUkMjQgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjQgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDMgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vKiogRXhjZXB0aW9uIHRocm93biB3aGVuIHR3byBNZFNpZGVuYXYgYXJlIG1hdGNoaW5nIHRoZSBzYW1lIHNpZGUuICovXG52YXIgTWREdXBsaWNhdGVkU2lkZW5hdkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkNyhNZER1cGxpY2F0ZWRTaWRlbmF2RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWREdXBsaWNhdGVkU2lkZW5hdkVycm9yKGFsaWduKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiQSBzaWRlbmF2IHdhcyBhbHJlYWR5IGRlY2xhcmVkIGZvciAnYWxpZ249XFxcIlwiICsgYWxpZ24gKyBcIlxcXCInXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTWREdXBsaWNhdGVkU2lkZW5hdkVycm9yO1xufShNZEVycm9yKSk7XG4vKipcbiAqIDxtZC1zaWRlbmF2PiBjb21wb25lbnQuXG4gKlxuICogVGhpcyBjb21wb25lbnQgY29ycmVzcG9uZHMgdG8gdGhlIGRyYXdlciBvZiB0aGUgc2lkZW5hdi5cbiAqXG4gKiBQbGVhc2UgcmVmZXIgdG8gUkVBRE1FLm1kIGZvciBleGFtcGxlcyBvbiBob3cgdG8gdXNlIGl0LlxuICovXG52YXIgTWRTaWRlbmF2ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gX2VsZW1lbnRSZWYgVGhlIERPTSBlbGVtZW50IHJlZmVyZW5jZS4gVXNlZCBmb3IgdHJhbnNpdGlvbiBhbmQgd2lkdGggY2FsY3VsYXRpb24uXG4gICAgICogICAgIElmIG5vdCBhdmFpbGFibGUgd2UgZG8gbm90IGhvb2sgb24gdHJhbnNpdGlvbnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWRTaWRlbmF2KF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgLyoqIEFsaWdubWVudCBvZiB0aGUgc2lkZW5hdiAoZGlyZWN0aW9uIG5ldXRyYWwpOyB3aGV0aGVyICdzdGFydCcgb3IgJ2VuZCcuICovXG4gICAgICAgIHRoaXMuYWxpZ24gPSAnc3RhcnQnO1xuICAgICAgICAvKiogTW9kZSBvZiB0aGUgc2lkZW5hdjsgd2hldGhlciAnb3Zlcicgb3IgJ3NpZGUnLiAqL1xuICAgICAgICB0aGlzLm1vZGUgPSAnb3Zlcic7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBzaWRlbmF2IGlzIG9wZW5lZC4gKi9cbiAgICAgICAgdGhpcy5fb3BlbmVkID0gZmFsc2U7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNpZGVuYXYgaXMgYmVpbmcgb3BlbmVkLiBVc2UgdGhpcyB0byBzeW5jaHJvbml6ZSBhbmltYXRpb25zLiAqL1xuICAgICAgICB0aGlzLm9uT3BlblN0YXJ0ID0gbmV3IF9hbmd1bGFyX2NvcmUuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNpZGVuYXYgaXMgZnVsbHkgb3BlbmVkLiAqL1xuICAgICAgICB0aGlzLm9uT3BlbiA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzaWRlbmF2IGlzIGJlaW5nIGNsb3NlZC4gVXNlIHRoaXMgdG8gc3luY2hyb25pemUgYW5pbWF0aW9ucy4gKi9cbiAgICAgICAgdGhpcy5vbkNsb3NlU3RhcnQgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2lkZW5hdiBpcyBmdWxseSBjbG9zZWQuICovXG4gICAgICAgIHRoaXMub25DbG9zZSA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uID0gZmFsc2U7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIm9wZW5lZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzaWRlbmF2IGlzIG9wZW5lZC4gV2Ugb3ZlcmxvYWQgdGhpcyBiZWNhdXNlIHdlIHRyaWdnZXIgYW4gZXZlbnQgd2hlbiBpdFxuICAgICAgICAgKiBzdGFydHMgb3IgZW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9vcGVuZWQ7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIC8vIFRPRE8oamVsYm91cm4pOiB0aGlzIGNvZXJjaW9uIGdvZXMgYXdheSB3aGVuIEJvb2xlYW5GaWVsZFZhbHVlIGlzIHJlbW92ZWQuXG4gICAgICAgICAgICB2YXIgYm9vbGVhblZhbHVlID0gdiAhPSBudWxsICYmIFwiXCIgKyB2ICE9PSAnZmFsc2UnO1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoYm9vbGVhblZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIE9wZW4gdGhpcyBzaWRlbmF2LCBhbmQgcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIGl0J3MgZnVsbHkgb3BlbmVkIChvciBnZXRcbiAgICAgKiByZWplY3RlZCBpZiBpdCBkaWRuJ3QpLiAqL1xuICAgIE1kU2lkZW5hdi5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlKHRydWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhpcyBzaWRlbmF2LCBhbmQgcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIGl0J3MgZnVsbHkgY2xvc2VkIChvciBnZXRcbiAgICAgKiByZWplY3RlZCBpZiBpdCBkaWRuJ3QpLlxuICAgICAqL1xuICAgIE1kU2lkZW5hdi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZShmYWxzZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhpcyBzaWRlbmF2LiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyBvcGVuKCkgd2hlbiBpdCdzIGFscmVhZHkgb3BlbmVkLCBvclxuICAgICAqIGNsb3NlKCkgd2hlbiBpdCdzIGNsb3NlZC5cbiAgICAgKiBAcGFyYW0gaXNPcGVuXG4gICAgICovXG4gICAgTWRTaWRlbmF2LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoaXNPcGVuKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChpc09wZW4gPT09IHZvaWQgMCkgeyBpc09wZW4gPSAhdGhpcy5vcGVuZWQ7IH1cbiAgICAgICAgLy8gU2hvcnRjdXQgaXQgaWYgd2UncmUgYWxyZWFkeSBvcGVuZWQuXG4gICAgICAgIGlmIChpc09wZW4gPT09IHRoaXMub3BlbmVkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzT3BlbiA/IHRoaXMuX29wZW5Qcm9taXNlIDogdGhpcy5fY2xvc2VQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZW5lZCA9IGlzT3BlbjtcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIGlmIChpc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMub25PcGVuU3RhcnQuZW1pdChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZVN0YXJ0LmVtaXQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT3Blbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wZW5Qcm9taXNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcGVuUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX29wZW5Qcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9vcGVuUHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcGVuUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZVByb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Nsb3NlUHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2xvc2VQcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlUHJvbWlzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV2hlbiB0cmFuc2l0aW9uIGhhcyBmaW5pc2hlZCwgc2V0IHRoZSBpbnRlcm5hbCBzdGF0ZSBmb3IgY2xhc3NlcyBhbmQgZW1pdCB0aGUgcHJvcGVyIGV2ZW50LlxuICAgICAqIFRoZSBldmVudCBwYXNzZWQgaXMgYWN0dWFsbHkgb2YgdHlwZSBUcmFuc2l0aW9uRXZlbnQsIGJ1dCB0aGF0IHR5cGUgaXMgbm90IGF2YWlsYWJsZSBpblxuICAgICAqIEFuZHJvaWQgc28gd2UgdXNlIGFueS5cbiAgICAgKi9cbiAgICBNZFNpZGVuYXYucHJvdG90eXBlLl9vblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiAodHJhbnNpdGlvbkV2ZW50KSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uRXZlbnQudGFyZ2V0ID09IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudFxuICAgICAgICAgICAgJiYgdHJhbnNpdGlvbkV2ZW50LnByb3BlcnR5TmFtZS5lbmRzV2l0aCgndHJhbnNmb3JtJykpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcGVuZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb3BlblByb21pc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcGVuUHJvbWlzZVJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlUHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlUHJvbWlzZVJlamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9uT3Blbi5lbWl0KG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlUHJvbWlzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlUHJvbWlzZVJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wZW5Qcm9taXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BlblByb21pc2VSZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlLmVtaXQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vcGVuUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZVByb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJfaXNDbG9zaW5nXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX29wZW5lZCAmJiB0aGlzLl90cmFuc2l0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJfaXNPcGVuaW5nXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3BlbmVkICYmIHRoaXMuX3RyYW5zaXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIl9pc0Nsb3NlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl9vcGVuZWQgJiYgIXRoaXMuX3RyYW5zaXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXYucHJvdG90eXBlLCBcIl9pc09wZW5lZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wZW5lZCAmJiAhdGhpcy5fdHJhbnNpdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX2lzRW5kXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbGlnbiA9PSAnZW5kJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX21vZGVTaWRlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09ICdzaWRlJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX21vZGVPdmVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09ICdvdmVyJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX21vZGVQdXNoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09ICdwdXNoJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX3dpZHRoXCIsIHtcbiAgICAgICAgLyoqIFRPRE86IGludGVybmFsIChuZWVkZWQgYnkgTWRTaWRlbmF2TGF5b3V0KS4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBfX2RlY29yYXRlJDI0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJhbGlnblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMjQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDI0KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNpZGVuYXYucHJvdG90eXBlLCBcIm1vZGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDI0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoJ29wZW4tc3RhcnQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjQoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2lkZW5hdi5wcm90b3R5cGUsIFwib25PcGVuU3RhcnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDI0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoJ29wZW4nKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjQoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2lkZW5hdi5wcm90b3R5cGUsIFwib25PcGVuXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQyNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCdjbG9zZS1zdGFydCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJvbkNsb3NlU3RhcnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDI0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5PdXRwdXQoJ2Nsb3NlJyksIFxuICAgICAgICBfX21ldGFkYXRhJDI0KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNpZGVuYXYucHJvdG90eXBlLCBcIm9uQ2xvc2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDI0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNCgnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kU2lkZW5hdi5wcm90b3R5cGUsIFwib3BlbmVkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMjQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKCdjbGFzcy5tZC1zaWRlbmF2LWNsb3NpbmcnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjQoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX2lzQ2xvc2luZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDI0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnY2xhc3MubWQtc2lkZW5hdi1vcGVuaW5nJyksIFxuICAgICAgICBfX21ldGFkYXRhJDI0KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNpZGVuYXYucHJvdG90eXBlLCBcIl9pc09wZW5pbmdcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQyNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2NsYXNzLm1kLXNpZGVuYXYtY2xvc2VkJyksIFxuICAgICAgICBfX21ldGFkYXRhJDI0KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFNpZGVuYXYucHJvdG90eXBlLCBcIl9pc0Nsb3NlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDI0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnY2xhc3MubWQtc2lkZW5hdi1vcGVuZWQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjQoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kU2lkZW5hdi5wcm90b3R5cGUsIFwiX2lzT3BlbmVkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMjQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKCdjbGFzcy5tZC1zaWRlbmF2LWVuZCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJfaXNFbmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQyNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2NsYXNzLm1kLXNpZGVuYXYtc2lkZScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJfbW9kZVNpZGVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQyNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2NsYXNzLm1kLXNpZGVuYXYtb3ZlcicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJfbW9kZU92ZXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQyNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2NsYXNzLm1kLXNpZGVuYXYtcHVzaCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNCgnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRTaWRlbmF2LnByb3RvdHlwZSwgXCJfbW9kZVB1c2hcIiwgbnVsbCk7XG4gICAgTWRTaWRlbmF2ID0gX19kZWNvcmF0ZSQyNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLXNpZGVuYXYnLFxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnKHRyYW5zaXRpb25lbmQpJzogJ19vblRyYW5zaXRpb25FbmQoJGV2ZW50KScsXG4gICAgICAgICAgICAgICAgLy8gbXVzdCBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gYWxpZ25pbmcgdGV4dCBiYXNlZCBvbiB2YWx1ZVxuICAgICAgICAgICAgICAgICdbYXR0ci5hbGlnbl0nOiAnbnVsbCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjQoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuRWxlbWVudFJlZl0pXG4gICAgXSwgTWRTaWRlbmF2KTtcbiAgICByZXR1cm4gTWRTaWRlbmF2O1xufSgpKTtcbi8qKlxuICogPG1kLXNpZGVuYXYtbGF5b3V0PiBjb21wb25lbnQuXG4gKlxuICogVGhpcyBpcyB0aGUgcGFyZW50IGNvbXBvbmVudCB0byBvbmUgb3IgdHdvIDxtZC1zaWRlbmF2PnMgdGhhdCB2YWxpZGF0ZXMgdGhlIHN0YXRlIGludGVybmFsbHlcbiAqIGFuZCBjb29yZGluYXRlIHRoZSBiYWNrZHJvcCBhbmQgY29udGVudCBzdHlsaW5nLlxuICovXG52YXIgTWRTaWRlbmF2TGF5b3V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNpZGVuYXZMYXlvdXQoX2RpciwgX2VsZW1lbnQsIF9yZW5kZXJlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9kaXIgPSBfZGlyO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICAvLyBJZiBhIGBEaXJgIGRpcmVjdGl2ZSBleGlzdHMgdXAgdGhlIHRyZWUsIGxpc3RlbiBkaXJlY3Rpb24gY2hhbmdlcyBhbmQgdXBkYXRlIHRoZSBsZWZ0L3JpZ2h0XG4gICAgICAgIC8vIHByb3BlcnRpZXMgdG8gcG9pbnQgdG8gdGhlIHByb3BlciBzdGFydC9lbmQuXG4gICAgICAgIGlmIChfZGlyICE9IG51bGwpIHtcbiAgICAgICAgICAgIF9kaXIuZGlyQ2hhbmdlLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdmFsaWRhdGVEcmF3ZXJzKCk7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFNpZGVuYXZMYXlvdXQucHJvdG90eXBlLCBcInN0YXJ0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zdGFydDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kU2lkZW5hdkxheW91dC5wcm90b3R5cGUsIFwiZW5kXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9lbmQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBUT0RPOiBpbnRlcm5hbCAqL1xuICAgIE1kU2lkZW5hdkxheW91dC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBPbiBjaGFuZ2VzLCBhc3NlcnQgb24gY29uc2lzdGVuY3kuXG4gICAgICAgIHRoaXMuX3NpZGVuYXZzLmNoYW5nZXMuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl92YWxpZGF0ZURyYXdlcnMoKTsgfSk7XG4gICAgICAgIHRoaXMuX3NpZGVuYXZzLmZvckVhY2goZnVuY3Rpb24gKHNpZGVuYXYpIHsgcmV0dXJuIF90aGlzLl93YXRjaFNpZGVuYXZUb2dnbGUoc2lkZW5hdik7IH0pO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZURyYXdlcnMoKTtcbiAgICB9O1xuICAgIC8qXG4gICAgKiBTdWJzY3JpYmVzIHRvIHNpZGVuYXYgZXZlbnRzIGluIG9yZGVyIHRvIHNldCBhIGNsYXNzIG9uIHRoZSBtYWluIGxheW91dCBlbGVtZW50IHdoZW4gdGhlIHNpZGVuYXZcbiAgICAqIGlzIG9wZW4gYW5kIHRoZSBiYWNrZHJvcCBpcyB2aXNpYmxlLiBUaGlzIGVuc3VyZXMgYW55IG92ZXJmbG93IG9uIHRoZSBsYXlvdXQgZWxlbWVudCBpcyBwcm9wZXJseVxuICAgICogaGlkZGVuLlxuICAgICovXG4gICAgTWRTaWRlbmF2TGF5b3V0LnByb3RvdHlwZS5fd2F0Y2hTaWRlbmF2VG9nZ2xlID0gZnVuY3Rpb24gKHNpZGVuYXYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFzaWRlbmF2IHx8IHNpZGVuYXYubW9kZSA9PT0gJ3NpZGUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2lkZW5hdi5vbk9wZW4uc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9zZXRMYXlvdXRDbGFzcyhzaWRlbmF2LCB0cnVlKTsgfSk7XG4gICAgICAgIHNpZGVuYXYub25DbG9zZS5zdWJzY3JpYmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3NldExheW91dENsYXNzKHNpZGVuYXYsIGZhbHNlKTsgfSk7XG4gICAgfTtcbiAgICAvKiBUb2dnbGVzIHRoZSAnbWQtc2lkZW5hdi1vcGVuZWQnIGNsYXNzIG9uIHRoZSBtYWluICdtZC1zaWRlbmF2LWxheW91dCcgZWxlbWVudC4gKi9cbiAgICBNZFNpZGVuYXZMYXlvdXQucHJvdG90eXBlLl9zZXRMYXlvdXRDbGFzcyA9IGZ1bmN0aW9uIChzaWRlbmF2LCBib29sKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdtZC1zaWRlbmF2LW9wZW5lZCcsIGJvb2wpO1xuICAgIH07XG4gICAgLyoqIFZhbGlkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgc2lkZW5hdiBjaGlsZHJlbiBjb21wb25lbnRzLiAqL1xuICAgIE1kU2lkZW5hdkxheW91dC5wcm90b3R5cGUuX3ZhbGlkYXRlRHJhd2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fc3RhcnQgPSB0aGlzLl9lbmQgPSBudWxsO1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIGF0IG1vc3Qgb25lIHN0YXJ0IGFuZCBvbmUgZW5kIHNpZGVuYXYuXG4gICAgICAgIHRoaXMuX3NpZGVuYXZzLmZvckVhY2goZnVuY3Rpb24gKHNpZGVuYXYpIHtcbiAgICAgICAgICAgIGlmIChzaWRlbmF2LmFsaWduID09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWREdXBsaWNhdGVkU2lkZW5hdkVycm9yKCdlbmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuX2VuZCA9IHNpZGVuYXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3N0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1kRHVwbGljYXRlZFNpZGVuYXZFcnJvcignc3RhcnQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuX3N0YXJ0ID0gc2lkZW5hdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3JpZ2h0ID0gdGhpcy5fbGVmdCA9IG51bGw7XG4gICAgICAgIC8vIERldGVjdCBpZiB3ZSdyZSBMVFIgb3IgUlRMLlxuICAgICAgICBpZiAodGhpcy5fZGlyID09IG51bGwgfHwgdGhpcy5fZGlyLnZhbHVlID09ICdsdHInKSB7XG4gICAgICAgICAgICB0aGlzLl9sZWZ0ID0gdGhpcy5fc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLl9yaWdodCA9IHRoaXMuX2VuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2xlZnQgPSB0aGlzLl9lbmQ7XG4gICAgICAgICAgICB0aGlzLl9yaWdodCA9IHRoaXMuX3N0YXJ0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZFNpZGVuYXZMYXlvdXQucHJvdG90eXBlLl9jbG9zZU1vZGFsU2lkZW5hdiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXJ0ICE9IG51bGwgJiYgdGhpcy5fc3RhcnQubW9kZSAhPSAnc2lkZScpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2VuZCAhPSBudWxsICYmIHRoaXMuX2VuZC5tb2RlICE9ICdzaWRlJykge1xuICAgICAgICAgICAgdGhpcy5fZW5kLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kU2lkZW5hdkxheW91dC5wcm90b3R5cGUuX2lzU2hvd2luZ0JhY2tkcm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2lzU2lkZW5hdk9wZW4odGhpcy5fc3RhcnQpICYmIHRoaXMuX3N0YXJ0Lm1vZGUgIT0gJ3NpZGUnKVxuICAgICAgICAgICAgfHwgKHRoaXMuX2lzU2lkZW5hdk9wZW4odGhpcy5fZW5kKSAmJiB0aGlzLl9lbmQubW9kZSAhPSAnc2lkZScpO1xuICAgIH07XG4gICAgTWRTaWRlbmF2TGF5b3V0LnByb3RvdHlwZS5faXNTaWRlbmF2T3BlbiA9IGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICAgIHJldHVybiBzaWRlICE9IG51bGwgJiYgc2lkZS5vcGVuZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBzaWRlbmF2LCBpZiBpdCdzIGluIHRoZSBwcm9wZXIgbW9kZSBhbmQgb3BlbmVkLlxuICAgICAqIFRoaXMgbWF5IHJlbGF5b3V0IHRoZSB2aWV3LCBzbyBkbyBub3QgY2FsbCB0aGlzIG9mdGVuLlxuICAgICAqIEBwYXJhbSBzaWRlbmF2XG4gICAgICogQHBhcmFtIG1vZGVcbiAgICAgKi9cbiAgICBNZFNpZGVuYXZMYXlvdXQucHJvdG90eXBlLl9nZXRTaWRlbmF2RWZmZWN0aXZlV2lkdGggPSBmdW5jdGlvbiAoc2lkZW5hdiwgbW9kZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2lzU2lkZW5hdk9wZW4oc2lkZW5hdikgJiYgc2lkZW5hdi5tb2RlID09IG1vZGUpID8gc2lkZW5hdi5fd2lkdGggOiAwO1xuICAgIH07XG4gICAgTWRTaWRlbmF2TGF5b3V0LnByb3RvdHlwZS5fZ2V0TWFyZ2luTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNpZGVuYXZFZmZlY3RpdmVXaWR0aCh0aGlzLl9sZWZ0LCAnc2lkZScpO1xuICAgIH07XG4gICAgTWRTaWRlbmF2TGF5b3V0LnByb3RvdHlwZS5fZ2V0TWFyZ2luUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTaWRlbmF2RWZmZWN0aXZlV2lkdGgodGhpcy5fcmlnaHQsICdzaWRlJyk7XG4gICAgfTtcbiAgICBNZFNpZGVuYXZMYXlvdXQucHJvdG90eXBlLl9nZXRQb3NpdGlvbkxlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTaWRlbmF2RWZmZWN0aXZlV2lkdGgodGhpcy5fbGVmdCwgJ3B1c2gnKTtcbiAgICB9O1xuICAgIE1kU2lkZW5hdkxheW91dC5wcm90b3R5cGUuX2dldFBvc2l0aW9uUmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTaWRlbmF2RWZmZWN0aXZlV2lkdGgodGhpcy5fcmlnaHQsICdwdXNoJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBob3Jpem9udGFsIG9mZnNldCBmb3IgdGhlIGNvbnRlbnQgYXJlYS4gIFRoZXJlIHNob3VsZCBuZXZlciBiZSBhIHZhbHVlIGZvciBib3RoXG4gICAgICogbGVmdCBhbmQgcmlnaHQsIHNvIGJ5IHN1YnRyYWN0aW5nIHRoZSByaWdodCB2YWx1ZSBmcm9tIHRoZSBsZWZ0IHZhbHVlLCB3ZSBzaG91bGQgYWx3YXlzIGdldFxuICAgICAqIHRoZSBhcHByb3ByaWF0ZSBvZmZzZXQuXG4gICAgICovXG4gICAgTWRTaWRlbmF2TGF5b3V0LnByb3RvdHlwZS5fZ2V0UG9zaXRpb25PZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRQb3NpdGlvbkxlZnQoKSAtIHRoaXMuX2dldFBvc2l0aW9uUmlnaHQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdXNpbmcgW25nU3R5bGVdIHJhdGhlciB0aGFuIHNlcGFyYXRlIFtzdHlsZS4uLl0gcHJvcGVydGllcyBiZWNhdXNlIFtzdHlsZS50cmFuc2Zvcm1dXG4gICAgICogZG9lc24ndCBzZWVtIHRvIHdvcmsgcmlnaHQgbm93LlxuICAgICAqL1xuICAgIE1kU2lkZW5hdkxheW91dC5wcm90b3R5cGUuX2dldFN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IHRoaXMuX2dldE1hcmdpbkxlZnQoKSArIFwicHhcIixcbiAgICAgICAgICAgIG1hcmdpblJpZ2h0OiB0aGlzLl9nZXRNYXJnaW5SaWdodCgpICsgXCJweFwiLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZTNkKFwiICsgdGhpcy5fZ2V0UG9zaXRpb25PZmZzZXQoKSArIFwicHgsIDAsIDApXCJcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMjQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZHJlbihNZFNpZGVuYXYpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNCgnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLlF1ZXJ5TGlzdClcbiAgICBdLCBNZFNpZGVuYXZMYXlvdXQucHJvdG90eXBlLCBcIl9zaWRlbmF2c1wiLCB2b2lkIDApO1xuICAgIE1kU2lkZW5hdkxheW91dCA9IF9fZGVjb3JhdGUkMjQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1zaWRlbmF2LWxheW91dCcsXG4gICAgICAgICAgICAvLyBEbyBub3QgdXNlIENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaC4gSXQgZG9lcyBub3Qgd29yayBmb3IgdGhpcyBjb21wb25lbnQgYmVjYXVzZVxuICAgICAgICAgICAgLy8gdGVjaG5pY2FsbHkgaXQgaXMgYSBzaWJsaW5nIG9mIE1kU2lkZW5hdiAob24gdGhlIGNvbnRlbnQgdHJlZSkgYW5kIGlzbid0IHVwZGF0ZWQgd2hlbiBNZFNpZGVuYXZcbiAgICAgICAgICAgIC8vIGNoYW5nZXMgaXRzIHN0YXRlLlxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWQtc2lkZW5hdi1iYWNrZHJvcFxcXCIgKGNsaWNrKT1cXFwiX2Nsb3NlTW9kYWxTaWRlbmF2KClcXFwiIFtjbGFzcy5tZC1zaWRlbmF2LXNob3duXT1cXFwiX2lzU2hvd2luZ0JhY2tkcm9wKClcXFwiPjwvZGl2PiA8bmctY29udGVudCBzZWxlY3Q9XFxcIm1kLXNpZGVuYXZcXFwiPjwvbmctY29udGVudD4gPGRpdiBjbGFzcz1cXFwibWQtc2lkZW5hdi1jb250ZW50XFxcIiBbbmdTdHlsZV09XFxcIl9nZXRTdHlsZXMoKVxcXCI+IDxuZy1jb250ZW50PjwvbmctY29udGVudD4gPC9kaXY+IFwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCJtZC1zaWRlbmF2LWxheW91dCB7IHBvc2l0aW9uOiByZWxhdGl2ZTsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTsgYm94LXNpemluZzogYm9yZGVyLWJveDsgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoOyBkaXNwbGF5OiBibG9jazsgb3ZlcmZsb3c6IGhpZGRlbjsgfSBtZC1zaWRlbmF2LWxheW91dFtmdWxsc2NyZWVuXSB7IHBvc2l0aW9uOiBmaXhlZDsgdG9wOiAwOyBsZWZ0OiAwOyByaWdodDogMDsgYm90dG9tOiAwOyB9IG1kLXNpZGVuYXYtbGF5b3V0W2Z1bGxzY3JlZW5dLm1kLXNpZGVuYXYtb3BlbmVkIHsgb3ZlcmZsb3c6IGhpZGRlbjsgfSAubWQtc2lkZW5hdi1iYWNrZHJvcCB7IHBvc2l0aW9uOiBmaXhlZDsgdG9wOiAwOyBsZWZ0OiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBkaXNwbGF5OiBibG9jazsgei1pbmRleDogMjsgdmlzaWJpbGl0eTogaGlkZGVuOyB9IC5tZC1zaWRlbmF2LWJhY2tkcm9wLm1kLXNpZGVuYXYtc2hvd24geyB2aXNpYmlsaXR5OiB2aXNpYmxlOyB9IC5tZC1zaWRlbmF2LWNvbnRlbnQgeyBwb3NpdGlvbjogcmVsYXRpdmU7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7IGRpc3BsYXk6IGJsb2NrOyBoZWlnaHQ6IDEwMCU7IG92ZXJmbG93OiBhdXRvOyB9IG1kLXNpZGVuYXYgeyBwb3NpdGlvbjogcmVsYXRpdmU7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7IGRpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgYm90dG9tOiAwOyB6LWluZGV4OiAzOyBtaW4td2lkdGg6IDUlOyBvdmVyZmxvdy15OiBhdXRvOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC0xMDAlLCAwLCAwKTsgfSBtZC1zaWRlbmF2Lm1kLXNpZGVuYXYtY2xvc2VkIHsgdmlzaWJpbGl0eTogaGlkZGVuOyB9IG1kLXNpZGVuYXYubWQtc2lkZW5hdi1jbG9zaW5nIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgtMTAwJSwgMCwgMCk7IHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07IH0gbWQtc2lkZW5hdi5tZC1zaWRlbmF2LW9wZW5pbmcgeyBib3gtc2hhZG93OiAwcHggMnB4IDFweCAtMXB4IHJnYmEoMCwgMCwgMCwgMC4yKSwgMHB4IDFweCAxcHggMHB4IHJnYmEoMCwgMCwgMCwgMC4xNCksIDBweCAxcHggM3B4IDBweCByZ2JhKDAsIDAsIDAsIDAuMTIpOyB2aXNpYmlsaXR5OiB2aXNpYmxlOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApOyB3aWxsLWNoYW5nZTogdHJhbnNmb3JtOyB9IG1kLXNpZGVuYXYubWQtc2lkZW5hdi1vcGVuZWQgeyBib3gtc2hhZG93OiAwcHggMnB4IDFweCAtMXB4IHJnYmEoMCwgMCwgMCwgMC4yKSwgMHB4IDFweCAxcHggMHB4IHJnYmEoMCwgMCwgMCwgMC4xNCksIDBweCAxcHggM3B4IDBweCByZ2JhKDAsIDAsIDAsIDAuMTIpOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApOyB9IG1kLXNpZGVuYXYubWQtc2lkZW5hdi1zaWRlIHsgei1pbmRleDogMTsgfSBtZC1zaWRlbmF2Lm1kLXNpZGVuYXYtZW5kIHsgcmlnaHQ6IDA7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMTAwJSwgMCwgMCk7IH0gbWQtc2lkZW5hdi5tZC1zaWRlbmF2LWVuZC5tZC1zaWRlbmF2LWNsb3NlZCB7IHZpc2liaWxpdHk6IGhpZGRlbjsgfSBtZC1zaWRlbmF2Lm1kLXNpZGVuYXYtZW5kLm1kLXNpZGVuYXYtY2xvc2luZyB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMTAwJSwgMCwgMCk7IHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07IH0gbWQtc2lkZW5hdi5tZC1zaWRlbmF2LWVuZC5tZC1zaWRlbmF2LW9wZW5pbmcgeyBib3gtc2hhZG93OiAwcHggMnB4IDFweCAtMXB4IHJnYmEoMCwgMCwgMCwgMC4yKSwgMHB4IDFweCAxcHggMHB4IHJnYmEoMCwgMCwgMCwgMC4xNCksIDBweCAxcHggM3B4IDBweCByZ2JhKDAsIDAsIDAsIDAuMTIpOyB2aXNpYmlsaXR5OiB2aXNpYmxlOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApOyB3aWxsLWNoYW5nZTogdHJhbnNmb3JtOyB9IG1kLXNpZGVuYXYubWQtc2lkZW5hdi1lbmQubWQtc2lkZW5hdi1vcGVuZWQgeyBib3gtc2hhZG93OiAwcHggMnB4IDFweCAtMXB4IHJnYmEoMCwgMCwgMCwgMC4yKSwgMHB4IDFweCAxcHggMHB4IHJnYmEoMCwgMCwgMCwgMC4xNCksIDBweCAxcHggM3B4IDBweCByZ2JhKDAsIDAsIDAsIDAuMTIpOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApOyB9IFtkaXI9J3J0bCddIG1kLXNpZGVuYXYgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDEwMCUsIDAsIDApOyB9IFtkaXI9J3J0bCddIG1kLXNpZGVuYXYubWQtc2lkZW5hdi1jbG9zZWQgeyB2aXNpYmlsaXR5OiBoaWRkZW47IH0gW2Rpcj0ncnRsJ10gbWQtc2lkZW5hdi5tZC1zaWRlbmF2LWNsb3NpbmcgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDEwMCUsIDAsIDApOyB3aWxsLWNoYW5nZTogdHJhbnNmb3JtOyB9IFtkaXI9J3J0bCddIG1kLXNpZGVuYXYubWQtc2lkZW5hdi1vcGVuaW5nIHsgYm94LXNoYWRvdzogMHB4IDJweCAxcHggLTFweCByZ2JhKDAsIDAsIDAsIDAuMiksIDBweCAxcHggMXB4IDBweCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwcHggMXB4IDNweCAwcHggcmdiYSgwLCAwLCAwLCAwLjEyKTsgdmlzaWJpbGl0eTogdmlzaWJsZTsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTsgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTsgfSBbZGlyPSdydGwnXSBtZC1zaWRlbmF2Lm1kLXNpZGVuYXYtb3BlbmVkIHsgYm94LXNoYWRvdzogMHB4IDJweCAxcHggLTFweCByZ2JhKDAsIDAsIDAsIDAuMiksIDBweCAxcHggMXB4IDBweCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwcHggMXB4IDNweCAwcHggcmdiYSgwLCAwLCAwLCAwLjEyKTsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTsgfSBbZGlyPSdydGwnXSBtZC1zaWRlbmF2Lm1kLXNpZGVuYXYtZW5kIHsgbGVmdDogMDsgcmlnaHQ6IGF1dG87IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLTEwMCUsIDAsIDApOyB9IFtkaXI9J3J0bCddIG1kLXNpZGVuYXYubWQtc2lkZW5hdi1lbmQubWQtc2lkZW5hdi1jbG9zZWQgeyB2aXNpYmlsaXR5OiBoaWRkZW47IH0gW2Rpcj0ncnRsJ10gbWQtc2lkZW5hdi5tZC1zaWRlbmF2LWVuZC5tZC1zaWRlbmF2LWNsb3NpbmcgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKC0xMDAlLCAwLCAwKTsgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTsgfSBbZGlyPSdydGwnXSBtZC1zaWRlbmF2Lm1kLXNpZGVuYXYtZW5kLm1kLXNpZGVuYXYtb3BlbmluZyB7IGJveC1zaGFkb3c6IDBweCAycHggMXB4IC0xcHggcmdiYSgwLCAwLCAwLCAwLjIpLCAwcHggMXB4IDFweCAwcHggcmdiYSgwLCAwLCAwLCAwLjE0KSwgMHB4IDFweCAzcHggMHB4IHJnYmEoMCwgMCwgMCwgMC4xMik7IHZpc2liaWxpdHk6IHZpc2libGU7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7IHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07IH0gW2Rpcj0ncnRsJ10gbWQtc2lkZW5hdi5tZC1zaWRlbmF2LWVuZC5tZC1zaWRlbmF2LW9wZW5lZCB7IGJveC1zaGFkb3c6IDBweCAycHggMXB4IC0xcHggcmdiYSgwLCAwLCAwLCAwLjIpLCAwcHggMXB4IDFweCAwcHggcmdiYSgwLCAwLCAwLCAwLjE0KSwgMHB4IDFweCAzcHggMHB4IHJnYmEoMCwgMCwgMCwgMC4xMik7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7IH0gLyojIHNvdXJjZU1hcHBpbmdVUkw9c2lkZW5hdi5jc3MubWFwICovIFwiLFxuXCJtZC1zaWRlbmF2IHsgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDQwMG1zIGN1YmljLWJlemllcigwLjI1LCAwLjgsIDAuMjUsIDEpOyB9IC5tZC1zaWRlbmF2LWNvbnRlbnQgeyB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gNDAwbXMgY3ViaWMtYmV6aWVyKDAuMjUsIDAuOCwgMC4yNSwgMSk7IH0gLm1kLXNpZGVuYXYtYmFja2Ryb3AubWQtc2lkZW5hdi1zaG93biB7IHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgNDAwbXMgY3ViaWMtYmV6aWVyKDAuMjUsIDAuOCwgMC4yNSwgMSk7IH0gLyojIHNvdXJjZU1hcHBpbmdVUkw9c2lkZW5hdi10cmFuc2l0aW9ucy5jc3MubWFwICovIFwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgfSksXG4gICAgICAgIF9fcGFyYW0kMygwLCBfYW5ndWxhcl9jb3JlLk9wdGlvbmFsKCkpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbRGlyLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWYsIF9hbmd1bGFyX2NvcmUuUmVuZGVyZXJdKVxuICAgIF0sIE1kU2lkZW5hdkxheW91dCk7XG4gICAgcmV0dXJuIE1kU2lkZW5hdkxheW91dDtcbn0oKSk7XG52YXIgTWRTaWRlbmF2TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNpZGVuYXZNb2R1bGUoKSB7XG4gICAgfVxuICAgIE1kU2lkZW5hdk1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kU2lkZW5hdk1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kU2lkZW5hdk1vZHVsZSA9IF9fZGVjb3JhdGUkMjQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtfYW5ndWxhcl9jb21tb24uQ29tbW9uTW9kdWxlXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNZFNpZGVuYXZMYXlvdXQsIE1kU2lkZW5hdl0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFNpZGVuYXZMYXlvdXQsIE1kU2lkZW5hdl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFNpZGVuYXZNb2R1bGUpO1xuICAgIHJldHVybiBNZFNpZGVuYXZNb2R1bGU7XG59KCkpO1xuXG52YXIgX19kZWNvcmF0ZSQyNSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQyNSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIE1kTGlzdERpdmlkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGlzdERpdmlkZXIoKSB7XG4gICAgfVxuICAgIE1kTGlzdERpdmlkZXIgPSBfX2RlY29yYXRlJDI1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1kaXZpZGVyJ1xuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRMaXN0RGl2aWRlcik7XG4gICAgcmV0dXJuIE1kTGlzdERpdmlkZXI7XG59KCkpO1xudmFyIE1kTGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRMaXN0KCkge1xuICAgIH1cbiAgICBNZExpc3QgPSBfX2RlY29yYXRlJDI1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtbGlzdCwgbWQtbmF2LWxpc3QnLFxuICAgICAgICAgICAgaG9zdDogeyAncm9sZSc6ICdsaXN0JyB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcbiAgICAgICAgICAgIHN0eWxlczogW1wibWQtbGlzdCwgbWQtbmF2LWxpc3QgeyBwYWRkaW5nLXRvcDogOHB4OyBkaXNwbGF5OiBibG9jazsgfSBtZC1saXN0IFttZC1zdWJoZWFkZXJdLCBtZC1uYXYtbGlzdCBbbWQtc3ViaGVhZGVyXSB7IGRpc3BsYXk6IGJsb2NrOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyBoZWlnaHQ6IDQ4cHg7IHBhZGRpbmc6IDE2cHg7IG1hcmdpbjogMDsgZm9udC1zaXplOiAxNHB4OyBmb250LXdlaWdodDogNTAwOyB9IG1kLWxpc3QgW21kLXN1YmhlYWRlcl06Zmlyc3QtY2hpbGQsIG1kLW5hdi1saXN0IFttZC1zdWJoZWFkZXJdOmZpcnN0LWNoaWxkIHsgbWFyZ2luLXRvcDogLThweDsgfSBtZC1saXN0IG1kLWxpc3QtaXRlbSAubWQtbGlzdC1pdGVtLCBtZC1saXN0IGFbbWQtbGlzdC1pdGVtXSAubWQtbGlzdC1pdGVtLCBtZC1uYXYtbGlzdCBtZC1saXN0LWl0ZW0gLm1kLWxpc3QtaXRlbSwgbWQtbmF2LWxpc3QgYVttZC1saXN0LWl0ZW1dIC5tZC1saXN0LWl0ZW0geyBkaXNwbGF5OiBmbGV4OyBmbGV4LWRpcmVjdGlvbjogcm93OyBhbGlnbi1pdGVtczogY2VudGVyOyBmb250LWZhbWlseTogUm9ib3RvLCBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBzYW5zLXNlcmlmOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyBmb250LXNpemU6IDE2cHg7IGhlaWdodDogNDhweDsgcGFkZGluZzogMCAxNnB4OyB9IG1kLWxpc3QgbWQtbGlzdC1pdGVtLm1kLWxpc3QtYXZhdGFyIC5tZC1saXN0LWl0ZW0sIG1kLWxpc3QgYVttZC1saXN0LWl0ZW1dLm1kLWxpc3QtYXZhdGFyIC5tZC1saXN0LWl0ZW0sIG1kLW5hdi1saXN0IG1kLWxpc3QtaXRlbS5tZC1saXN0LWF2YXRhciAubWQtbGlzdC1pdGVtLCBtZC1uYXYtbGlzdCBhW21kLWxpc3QtaXRlbV0ubWQtbGlzdC1hdmF0YXIgLm1kLWxpc3QtaXRlbSB7IGhlaWdodDogNTZweDsgfSBtZC1saXN0IG1kLWxpc3QtaXRlbS5tZC0yLWxpbmUgLm1kLWxpc3QtaXRlbSwgbWQtbGlzdCBhW21kLWxpc3QtaXRlbV0ubWQtMi1saW5lIC5tZC1saXN0LWl0ZW0sIG1kLW5hdi1saXN0IG1kLWxpc3QtaXRlbS5tZC0yLWxpbmUgLm1kLWxpc3QtaXRlbSwgbWQtbmF2LWxpc3QgYVttZC1saXN0LWl0ZW1dLm1kLTItbGluZSAubWQtbGlzdC1pdGVtIHsgaGVpZ2h0OiA3MnB4OyB9IG1kLWxpc3QgbWQtbGlzdC1pdGVtLm1kLTMtbGluZSAubWQtbGlzdC1pdGVtLCBtZC1saXN0IGFbbWQtbGlzdC1pdGVtXS5tZC0zLWxpbmUgLm1kLWxpc3QtaXRlbSwgbWQtbmF2LWxpc3QgbWQtbGlzdC1pdGVtLm1kLTMtbGluZSAubWQtbGlzdC1pdGVtLCBtZC1uYXYtbGlzdCBhW21kLWxpc3QtaXRlbV0ubWQtMy1saW5lIC5tZC1saXN0LWl0ZW0geyBoZWlnaHQ6IDg4cHg7IH0gbWQtbGlzdCBtZC1saXN0LWl0ZW0gLm1kLWxpc3QtdGV4dCwgbWQtbGlzdCBhW21kLWxpc3QtaXRlbV0gLm1kLWxpc3QtdGV4dCwgbWQtbmF2LWxpc3QgbWQtbGlzdC1pdGVtIC5tZC1saXN0LXRleHQsIG1kLW5hdi1saXN0IGFbbWQtbGlzdC1pdGVtXSAubWQtbGlzdC10ZXh0IHsgZGlzcGxheTogZmxleDsgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsgd2lkdGg6IDEwMCU7IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IG92ZXJmbG93OiBoaWRkZW47IHBhZGRpbmc6IDAgMTZweDsgfSBtZC1saXN0IG1kLWxpc3QtaXRlbSAubWQtbGlzdC10ZXh0ID4gKiwgbWQtbGlzdCBhW21kLWxpc3QtaXRlbV0gLm1kLWxpc3QtdGV4dCA+ICosIG1kLW5hdi1saXN0IG1kLWxpc3QtaXRlbSAubWQtbGlzdC10ZXh0ID4gKiwgbWQtbmF2LWxpc3QgYVttZC1saXN0LWl0ZW1dIC5tZC1saXN0LXRleHQgPiAqIHsgbWFyZ2luOiAwOyBwYWRkaW5nOiAwOyBmb250LXdlaWdodDogbm9ybWFsOyBmb250LXNpemU6IGluaGVyaXQ7IH0gbWQtbGlzdCBtZC1saXN0LWl0ZW0gLm1kLWxpc3QtdGV4dDplbXB0eSwgbWQtbGlzdCBhW21kLWxpc3QtaXRlbV0gLm1kLWxpc3QtdGV4dDplbXB0eSwgbWQtbmF2LWxpc3QgbWQtbGlzdC1pdGVtIC5tZC1saXN0LXRleHQ6ZW1wdHksIG1kLW5hdi1saXN0IGFbbWQtbGlzdC1pdGVtXSAubWQtbGlzdC10ZXh0OmVtcHR5IHsgZGlzcGxheTogbm9uZTsgfSBtZC1saXN0IG1kLWxpc3QtaXRlbSAubWQtbGlzdC10ZXh0OmZpcnN0LWNoaWxkLCBtZC1saXN0IGFbbWQtbGlzdC1pdGVtXSAubWQtbGlzdC10ZXh0OmZpcnN0LWNoaWxkLCBtZC1uYXYtbGlzdCBtZC1saXN0LWl0ZW0gLm1kLWxpc3QtdGV4dDpmaXJzdC1jaGlsZCwgbWQtbmF2LWxpc3QgYVttZC1saXN0LWl0ZW1dIC5tZC1saXN0LXRleHQ6Zmlyc3QtY2hpbGQgeyBwYWRkaW5nOiAwOyB9IG1kLWxpc3QgbWQtbGlzdC1pdGVtIFttZC1saXN0LWF2YXRhcl0sIG1kLWxpc3QgYVttZC1saXN0LWl0ZW1dIFttZC1saXN0LWF2YXRhcl0sIG1kLW5hdi1saXN0IG1kLWxpc3QtaXRlbSBbbWQtbGlzdC1hdmF0YXJdLCBtZC1uYXYtbGlzdCBhW21kLWxpc3QtaXRlbV0gW21kLWxpc3QtYXZhdGFyXSB7IHdpZHRoOiA0MHB4OyBoZWlnaHQ6IDQwcHg7IGJvcmRlci1yYWRpdXM6IDUwJTsgfSBtZC1saXN0IG1kLWxpc3QtaXRlbSBbbWQtbGlzdC1pY29uXSwgbWQtbGlzdCBhW21kLWxpc3QtaXRlbV0gW21kLWxpc3QtaWNvbl0sIG1kLW5hdi1saXN0IG1kLWxpc3QtaXRlbSBbbWQtbGlzdC1pY29uXSwgbWQtbmF2LWxpc3QgYVttZC1saXN0LWl0ZW1dIFttZC1saXN0LWljb25dIHsgd2lkdGg6IDI0cHg7IGhlaWdodDogMjRweDsgYm9yZGVyLXJhZGl1czogNTAlOyBwYWRkaW5nOiA0cHg7IH0gbWQtbGlzdCBtZC1saXN0LWl0ZW0gW21kLWxpbmVdLCBtZC1saXN0IGFbbWQtbGlzdC1pdGVtXSBbbWQtbGluZV0sIG1kLW5hdi1saXN0IG1kLWxpc3QtaXRlbSBbbWQtbGluZV0sIG1kLW5hdi1saXN0IGFbbWQtbGlzdC1pdGVtXSBbbWQtbGluZV0geyB3aGl0ZS1zcGFjZTogbm93cmFwOyBvdmVyZmxvdy14OiBoaWRkZW47IHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzOyBkaXNwbGF5OiBibG9jazsgYm94LXNpemluZzogYm9yZGVyLWJveDsgfSBtZC1saXN0IG1kLWxpc3QtaXRlbSBbbWQtbGluZV06bnRoLWNoaWxkKG4rMiksIG1kLWxpc3QgYVttZC1saXN0LWl0ZW1dIFttZC1saW5lXTpudGgtY2hpbGQobisyKSwgbWQtbmF2LWxpc3QgbWQtbGlzdC1pdGVtIFttZC1saW5lXTpudGgtY2hpbGQobisyKSwgbWQtbmF2LWxpc3QgYVttZC1saXN0LWl0ZW1dIFttZC1saW5lXTpudGgtY2hpbGQobisyKSB7IGZvbnQtc2l6ZTogMTRweDsgfSBtZC1saXN0W2RlbnNlXSwgbWQtbmF2LWxpc3RbZGVuc2VdIHsgcGFkZGluZy10b3A6IDRweDsgZGlzcGxheTogYmxvY2s7IH0gbWQtbGlzdFtkZW5zZV0gW21kLXN1YmhlYWRlcl0sIG1kLW5hdi1saXN0W2RlbnNlXSBbbWQtc3ViaGVhZGVyXSB7IGRpc3BsYXk6IGJsb2NrOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyBoZWlnaHQ6IDQwcHg7IHBhZGRpbmc6IDE2cHg7IG1hcmdpbjogMDsgZm9udC1zaXplOiAxM3B4OyBmb250LXdlaWdodDogNTAwOyB9IG1kLWxpc3RbZGVuc2VdIFttZC1zdWJoZWFkZXJdOmZpcnN0LWNoaWxkLCBtZC1uYXYtbGlzdFtkZW5zZV0gW21kLXN1YmhlYWRlcl06Zmlyc3QtY2hpbGQgeyBtYXJnaW4tdG9wOiAtNHB4OyB9IG1kLWxpc3RbZGVuc2VdIG1kLWxpc3QtaXRlbSAubWQtbGlzdC1pdGVtLCBtZC1saXN0W2RlbnNlXSBhW21kLWxpc3QtaXRlbV0gLm1kLWxpc3QtaXRlbSwgbWQtbmF2LWxpc3RbZGVuc2VdIG1kLWxpc3QtaXRlbSAubWQtbGlzdC1pdGVtLCBtZC1uYXYtbGlzdFtkZW5zZV0gYVttZC1saXN0LWl0ZW1dIC5tZC1saXN0LWl0ZW0geyBkaXNwbGF5OiBmbGV4OyBmbGV4LWRpcmVjdGlvbjogcm93OyBhbGlnbi1pdGVtczogY2VudGVyOyBmb250LWZhbWlseTogUm9ib3RvLCBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBzYW5zLXNlcmlmOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyBmb250LXNpemU6IDEzcHg7IGhlaWdodDogNDBweDsgcGFkZGluZzogMCAxNnB4OyB9IG1kLWxpc3RbZGVuc2VdIG1kLWxpc3QtaXRlbS5tZC1saXN0LWF2YXRhciAubWQtbGlzdC1pdGVtLCBtZC1saXN0W2RlbnNlXSBhW21kLWxpc3QtaXRlbV0ubWQtbGlzdC1hdmF0YXIgLm1kLWxpc3QtaXRlbSwgbWQtbmF2LWxpc3RbZGVuc2VdIG1kLWxpc3QtaXRlbS5tZC1saXN0LWF2YXRhciAubWQtbGlzdC1pdGVtLCBtZC1uYXYtbGlzdFtkZW5zZV0gYVttZC1saXN0LWl0ZW1dLm1kLWxpc3QtYXZhdGFyIC5tZC1saXN0LWl0ZW0geyBoZWlnaHQ6IDQ4cHg7IH0gbWQtbGlzdFtkZW5zZV0gbWQtbGlzdC1pdGVtLm1kLTItbGluZSAubWQtbGlzdC1pdGVtLCBtZC1saXN0W2RlbnNlXSBhW21kLWxpc3QtaXRlbV0ubWQtMi1saW5lIC5tZC1saXN0LWl0ZW0sIG1kLW5hdi1saXN0W2RlbnNlXSBtZC1saXN0LWl0ZW0ubWQtMi1saW5lIC5tZC1saXN0LWl0ZW0sIG1kLW5hdi1saXN0W2RlbnNlXSBhW21kLWxpc3QtaXRlbV0ubWQtMi1saW5lIC5tZC1saXN0LWl0ZW0geyBoZWlnaHQ6IDYwcHg7IH0gbWQtbGlzdFtkZW5zZV0gbWQtbGlzdC1pdGVtLm1kLTMtbGluZSAubWQtbGlzdC1pdGVtLCBtZC1saXN0W2RlbnNlXSBhW21kLWxpc3QtaXRlbV0ubWQtMy1saW5lIC5tZC1saXN0LWl0ZW0sIG1kLW5hdi1saXN0W2RlbnNlXSBtZC1saXN0LWl0ZW0ubWQtMy1saW5lIC5tZC1saXN0LWl0ZW0sIG1kLW5hdi1saXN0W2RlbnNlXSBhW21kLWxpc3QtaXRlbV0ubWQtMy1saW5lIC5tZC1saXN0LWl0ZW0geyBoZWlnaHQ6IDc2cHg7IH0gbWQtbGlzdFtkZW5zZV0gbWQtbGlzdC1pdGVtIC5tZC1saXN0LXRleHQsIG1kLWxpc3RbZGVuc2VdIGFbbWQtbGlzdC1pdGVtXSAubWQtbGlzdC10ZXh0LCBtZC1uYXYtbGlzdFtkZW5zZV0gbWQtbGlzdC1pdGVtIC5tZC1saXN0LXRleHQsIG1kLW5hdi1saXN0W2RlbnNlXSBhW21kLWxpc3QtaXRlbV0gLm1kLWxpc3QtdGV4dCB7IGRpc3BsYXk6IGZsZXg7IGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IHdpZHRoOiAxMDAlOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyBvdmVyZmxvdzogaGlkZGVuOyBwYWRkaW5nOiAwIDE2cHg7IH0gbWQtbGlzdFtkZW5zZV0gbWQtbGlzdC1pdGVtIC5tZC1saXN0LXRleHQgPiAqLCBtZC1saXN0W2RlbnNlXSBhW21kLWxpc3QtaXRlbV0gLm1kLWxpc3QtdGV4dCA+ICosIG1kLW5hdi1saXN0W2RlbnNlXSBtZC1saXN0LWl0ZW0gLm1kLWxpc3QtdGV4dCA+ICosIG1kLW5hdi1saXN0W2RlbnNlXSBhW21kLWxpc3QtaXRlbV0gLm1kLWxpc3QtdGV4dCA+ICogeyBtYXJnaW46IDA7IHBhZGRpbmc6IDA7IGZvbnQtd2VpZ2h0OiBub3JtYWw7IGZvbnQtc2l6ZTogaW5oZXJpdDsgfSBtZC1saXN0W2RlbnNlXSBtZC1saXN0LWl0ZW0gLm1kLWxpc3QtdGV4dDplbXB0eSwgbWQtbGlzdFtkZW5zZV0gYVttZC1saXN0LWl0ZW1dIC5tZC1saXN0LXRleHQ6ZW1wdHksIG1kLW5hdi1saXN0W2RlbnNlXSBtZC1saXN0LWl0ZW0gLm1kLWxpc3QtdGV4dDplbXB0eSwgbWQtbmF2LWxpc3RbZGVuc2VdIGFbbWQtbGlzdC1pdGVtXSAubWQtbGlzdC10ZXh0OmVtcHR5IHsgZGlzcGxheTogbm9uZTsgfSBtZC1saXN0W2RlbnNlXSBtZC1saXN0LWl0ZW0gLm1kLWxpc3QtdGV4dDpmaXJzdC1jaGlsZCwgbWQtbGlzdFtkZW5zZV0gYVttZC1saXN0LWl0ZW1dIC5tZC1saXN0LXRleHQ6Zmlyc3QtY2hpbGQsIG1kLW5hdi1saXN0W2RlbnNlXSBtZC1saXN0LWl0ZW0gLm1kLWxpc3QtdGV4dDpmaXJzdC1jaGlsZCwgbWQtbmF2LWxpc3RbZGVuc2VdIGFbbWQtbGlzdC1pdGVtXSAubWQtbGlzdC10ZXh0OmZpcnN0LWNoaWxkIHsgcGFkZGluZzogMDsgfSBtZC1saXN0W2RlbnNlXSBtZC1saXN0LWl0ZW0gW21kLWxpc3QtYXZhdGFyXSwgbWQtbGlzdFtkZW5zZV0gYVttZC1saXN0LWl0ZW1dIFttZC1saXN0LWF2YXRhcl0sIG1kLW5hdi1saXN0W2RlbnNlXSBtZC1saXN0LWl0ZW0gW21kLWxpc3QtYXZhdGFyXSwgbWQtbmF2LWxpc3RbZGVuc2VdIGFbbWQtbGlzdC1pdGVtXSBbbWQtbGlzdC1hdmF0YXJdIHsgd2lkdGg6IDQwcHg7IGhlaWdodDogNDBweDsgYm9yZGVyLXJhZGl1czogNTAlOyB9IG1kLWxpc3RbZGVuc2VdIG1kLWxpc3QtaXRlbSBbbWQtbGlzdC1pY29uXSwgbWQtbGlzdFtkZW5zZV0gYVttZC1saXN0LWl0ZW1dIFttZC1saXN0LWljb25dLCBtZC1uYXYtbGlzdFtkZW5zZV0gbWQtbGlzdC1pdGVtIFttZC1saXN0LWljb25dLCBtZC1uYXYtbGlzdFtkZW5zZV0gYVttZC1saXN0LWl0ZW1dIFttZC1saXN0LWljb25dIHsgd2lkdGg6IDI0cHg7IGhlaWdodDogMjRweDsgYm9yZGVyLXJhZGl1czogNTAlOyBwYWRkaW5nOiA0cHg7IH0gbWQtbGlzdFtkZW5zZV0gbWQtbGlzdC1pdGVtIFttZC1saW5lXSwgbWQtbGlzdFtkZW5zZV0gYVttZC1saXN0LWl0ZW1dIFttZC1saW5lXSwgbWQtbmF2LWxpc3RbZGVuc2VdIG1kLWxpc3QtaXRlbSBbbWQtbGluZV0sIG1kLW5hdi1saXN0W2RlbnNlXSBhW21kLWxpc3QtaXRlbV0gW21kLWxpbmVdIHsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgb3ZlcmZsb3cteDogaGlkZGVuOyB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpczsgZGlzcGxheTogYmxvY2s7IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IH0gbWQtbGlzdFtkZW5zZV0gbWQtbGlzdC1pdGVtIFttZC1saW5lXTpudGgtY2hpbGQobisyKSwgbWQtbGlzdFtkZW5zZV0gYVttZC1saXN0LWl0ZW1dIFttZC1saW5lXTpudGgtY2hpbGQobisyKSwgbWQtbmF2LWxpc3RbZGVuc2VdIG1kLWxpc3QtaXRlbSBbbWQtbGluZV06bnRoLWNoaWxkKG4rMiksIG1kLW5hdi1saXN0W2RlbnNlXSBhW21kLWxpc3QtaXRlbV0gW21kLWxpbmVdOm50aC1jaGlsZChuKzIpIHsgZm9udC1zaXplOiAxM3B4OyB9IG1kLWRpdmlkZXIgeyBkaXNwbGF5OiBibG9jazsgYm9yZGVyLXRvcDogMXB4IHNvbGlkOyBtYXJnaW46IDA7IH0gbWQtbmF2LWxpc3QgYSB7IHRleHQtZGVjb3JhdGlvbjogbm9uZTsgY29sb3I6IGluaGVyaXQ7IH0gbWQtbmF2LWxpc3QgLm1kLWxpc3QtaXRlbSB7IGN1cnNvcjogcG9pbnRlcjsgfSBtZC1uYXYtbGlzdCAubWQtbGlzdC1pdGVtOmhvdmVyLCBtZC1uYXYtbGlzdCAubWQtbGlzdC1pdGVtLm1kLWxpc3QtaXRlbS1mb2N1cyB7IG91dGxpbmU6IG5vbmU7IH0gLyojIHNvdXJjZU1hcHBpbmdVUkw9bGlzdC5jc3MubWFwICovIFwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRMaXN0KTtcbiAgICByZXR1cm4gTWRMaXN0O1xufSgpKTtcbi8qIE5lZWQgZGlyZWN0aXZlIGZvciBhIENvbnRlbnRDaGlsZCBxdWVyeSBpbiBsaXN0LWl0ZW0gKi9cbnZhciBNZExpc3RBdmF0YXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGlzdEF2YXRhcigpIHtcbiAgICB9XG4gICAgTWRMaXN0QXZhdGFyID0gX19kZWNvcmF0ZSQyNShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbWQtbGlzdC1hdmF0YXJdJyB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRMaXN0QXZhdGFyKTtcbiAgICByZXR1cm4gTWRMaXN0QXZhdGFyO1xufSgpKTtcbnZhciBNZExpc3RJdGVtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZExpc3RJdGVtKF9yZW5kZXJlciwgX2VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgdGhpcy5faGFzRm9jdXMgPSBmYWxzZTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTGlzdEl0ZW0ucHJvdG90eXBlLCBcIl9oYXNBdmF0YXJcIiwge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChhdmF0YXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdtZC1saXN0LWF2YXRhcicsIGF2YXRhciAhPSBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIFRPRE86IGludGVybmFsICovXG4gICAgTWRMaXN0SXRlbS5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9saW5lU2V0dGVyID0gbmV3IE1kTGluZVNldHRlcih0aGlzLl9saW5lcywgdGhpcy5fcmVuZGVyZXIsIHRoaXMuX2VsZW1lbnQpO1xuICAgIH07XG4gICAgTWRMaXN0SXRlbS5wcm90b3R5cGUuX2hhbmRsZUZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9oYXNGb2N1cyA9IHRydWU7XG4gICAgfTtcbiAgICBNZExpc3RJdGVtLnByb3RvdHlwZS5faGFuZGxlQmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faGFzRm9jdXMgPSBmYWxzZTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMjUoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZHJlbihNZExpbmUpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNSgnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLlF1ZXJ5TGlzdClcbiAgICBdLCBNZExpc3RJdGVtLnByb3RvdHlwZSwgXCJfbGluZXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDI1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db250ZW50Q2hpbGQoTWRMaXN0QXZhdGFyKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjUoJ2Rlc2lnbjp0eXBlJywgTWRMaXN0QXZhdGFyKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW01kTGlzdEF2YXRhcl0pXG4gICAgXSwgTWRMaXN0SXRlbS5wcm90b3R5cGUsIFwiX2hhc0F2YXRhclwiLCBudWxsKTtcbiAgICBNZExpc3RJdGVtID0gX19kZWNvcmF0ZSQyNShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLWxpc3QtaXRlbSwgYVttZC1saXN0LWl0ZW1dJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAncm9sZSc6ICdsaXN0aXRlbScsXG4gICAgICAgICAgICAgICAgJyhmb2N1cyknOiAnX2hhbmRsZUZvY3VzKCknLFxuICAgICAgICAgICAgICAgICcoYmx1ciknOiAnX2hhbmRsZUJsdXIoKScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdiBjbGFzcz1cXFwibWQtbGlzdC1pdGVtXFxcIiBbY2xhc3MubWQtbGlzdC1pdGVtLWZvY3VzXT1cXFwiX2hhc0ZvY3VzXFxcIj4gPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJbbWQtbGlzdC1hdmF0YXJdLFttZC1saXN0LWljb25dXFxcIj48L25nLWNvbnRlbnQ+IDxkaXYgY2xhc3M9XFxcIm1kLWxpc3QtdGV4dFxcXCI+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJbbWQtbGluZV1cXFwiPjwvbmctY29udGVudD48L2Rpdj4gPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PiA8L2Rpdj4gXCIsXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDI1KCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLlJlbmRlcmVyLCBfYW5ndWxhcl9jb3JlLkVsZW1lbnRSZWZdKVxuICAgIF0sIE1kTGlzdEl0ZW0pO1xuICAgIHJldHVybiBNZExpc3RJdGVtO1xufSgpKTtcbnZhciBNZExpc3RNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTGlzdE1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWRMaXN0TW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRMaXN0TW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRMaXN0TW9kdWxlID0gX19kZWNvcmF0ZSQyNShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW01kTGluZU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRMaXN0LCBNZExpc3RJdGVtLCBNZExpc3REaXZpZGVyLCBNZExpc3RBdmF0YXIsIE1kTGluZU1vZHVsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZExpc3QsIE1kTGlzdEl0ZW0sIE1kTGlzdERpdmlkZXIsIE1kTGlzdEF2YXRhcl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZExpc3RNb2R1bGUpO1xuICAgIHJldHVybiBNZExpc3RNb2R1bGU7XG59KCkpO1xuXG4vKipcbiAqIENvbnZlcnRzIHZhbHVlcyBpbnRvIHN0cmluZ3MuIEZhbHN5IHZhbHVlcyBiZWNvbWUgZW1wdHkgc3RyaW5ncy5cbiAqIFRPRE86IGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIFwiXCIgKyAodmFsdWUgfHwgJycpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHZhbHVlIHRoYXQgbWlnaHQgYmUgYSBzdHJpbmcgaW50byBhIG51bWJlci5cbiAqIFRPRE86IGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZVRvTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBwYXJzZUludCh2YWx1ZSwgMTApIDogdmFsdWU7XG59XG5cbnZhciBfX2RlY29yYXRlJDI3ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDI3ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTWRHcmlkVGlsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRHcmlkVGlsZShfcmVuZGVyZXIsIF9lbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3Jvd3NwYW4gPSAxO1xuICAgICAgICB0aGlzLl9jb2xzcGFuID0gMTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kR3JpZFRpbGUucHJvdG90eXBlLCBcInJvd3NwYW5cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb3dzcGFuO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcm93c3BhbiA9IGNvZXJjZVRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kR3JpZFRpbGUucHJvdG90eXBlLCBcImNvbHNwYW5cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xzcGFuO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY29sc3BhbiA9IGNvZXJjZVRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3R5bGUgb2YgdGhlIGdyaWQtdGlsZSBlbGVtZW50LiAgTmVlZHMgdG8gYmUgc2V0IG1hbnVhbGx5IHRvIGF2b2lkXG4gICAgICogXCJDaGFuZ2VkIGFmdGVyIGNoZWNrZWRcIiBlcnJvcnMgdGhhdCB3b3VsZCBvY2N1ciB3aXRoIEhvc3RCaW5kaW5nLlxuICAgICAqL1xuICAgIE1kR3JpZFRpbGUucHJvdG90eXBlLl9zZXRTdHlsZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMjcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDI3KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZEdyaWRUaWxlLnByb3RvdHlwZSwgXCJyb3dzcGFuXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMjcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDI3KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZEdyaWRUaWxlLnByb3RvdHlwZSwgXCJjb2xzcGFuXCIsIG51bGwpO1xuICAgIE1kR3JpZFRpbGUgPSBfX2RlY29yYXRlJDI3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtZ3JpZC10aWxlJyxcbiAgICAgICAgICAgIGhvc3Q6IHsgJ3JvbGUnOiAnbGlzdGl0ZW0nIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8IS0tIFRPRE8oa2FyYSk6IFJldmlzaXQgd2h5IHRoaXMgaXMgYSBmaWd1cmUuLS0+IDxmaWd1cmU+IDxuZy1jb250ZW50PjwvbmctY29udGVudD4gPC9maWd1cmU+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIm1kLWdyaWQtbGlzdCB7IGRpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogcmVsYXRpdmU7IH0gbWQtZ3JpZC10aWxlIHsgZGlzcGxheTogYmxvY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgb3ZlcmZsb3c6IGhpZGRlbjsgfSBtZC1ncmlkLXRpbGUgZmlndXJlIHsgZGlzcGxheTogZmxleDsgcG9zaXRpb246IGFic29sdXRlOyBhbGlnbi1pdGVtczogY2VudGVyOyBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsgaGVpZ2h0OiAxMDAlOyB0b3A6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IGxlZnQ6IDA7IHBhZGRpbmc6IDA7IG1hcmdpbjogMDsgfSBtZC1ncmlkLXRpbGUgbWQtZ3JpZC10aWxlLWhlYWRlciwgbWQtZ3JpZC10aWxlIG1kLWdyaWQtdGlsZS1mb290ZXIgeyBkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyBoZWlnaHQ6IDQ4cHg7IGNvbG9yOiAjZmZmOyBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuMzgpOyBvdmVyZmxvdzogaGlkZGVuOyBwYWRkaW5nOiAwIDE2cHg7IGZvbnQtc2l6ZTogMTZweDsgcG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyByaWdodDogMDsgfSBtZC1ncmlkLXRpbGUgbWQtZ3JpZC10aWxlLWhlYWRlciBbbWQtbGluZV0sIG1kLWdyaWQtdGlsZSBtZC1ncmlkLXRpbGUtZm9vdGVyIFttZC1saW5lXSB7IHdoaXRlLXNwYWNlOiBub3dyYXA7IG92ZXJmbG93LXg6IGhpZGRlbjsgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7IGRpc3BsYXk6IGJsb2NrOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9IG1kLWdyaWQtdGlsZSBtZC1ncmlkLXRpbGUtaGVhZGVyIFttZC1saW5lXTpudGgtY2hpbGQobisyKSwgbWQtZ3JpZC10aWxlIG1kLWdyaWQtdGlsZS1mb290ZXIgW21kLWxpbmVdOm50aC1jaGlsZChuKzIpIHsgZm9udC1zaXplOiAxMnB4OyB9IG1kLWdyaWQtdGlsZSBtZC1ncmlkLXRpbGUtaGVhZGVyID4gKiwgbWQtZ3JpZC10aWxlIG1kLWdyaWQtdGlsZS1mb290ZXIgPiAqIHsgbWFyZ2luOiAwOyBwYWRkaW5nOiAwOyBmb250LXdlaWdodDogbm9ybWFsOyBmb250LXNpemU6IGluaGVyaXQ7IH0gbWQtZ3JpZC10aWxlIG1kLWdyaWQtdGlsZS1oZWFkZXIubWQtMi1saW5lLCBtZC1ncmlkLXRpbGUgbWQtZ3JpZC10aWxlLWZvb3Rlci5tZC0yLWxpbmUgeyBoZWlnaHQ6IDY4cHg7IH0gbWQtZ3JpZC10aWxlIC5tZC1ncmlkLWxpc3QtdGV4dCB7IGRpc3BsYXk6IGZsZXg7IGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IHdpZHRoOiAxMDAlOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyBvdmVyZmxvdzogaGlkZGVuOyB9IG1kLWdyaWQtdGlsZSAubWQtZ3JpZC1saXN0LXRleHQgPiAqIHsgbWFyZ2luOiAwOyBwYWRkaW5nOiAwOyBmb250LXdlaWdodDogbm9ybWFsOyBmb250LXNpemU6IGluaGVyaXQ7IH0gbWQtZ3JpZC10aWxlIC5tZC1ncmlkLWxpc3QtdGV4dDplbXB0eSB7IGRpc3BsYXk6IG5vbmU7IH0gbWQtZ3JpZC10aWxlIG1kLWdyaWQtdGlsZS1oZWFkZXIgeyB0b3A6IDA7IH0gbWQtZ3JpZC10aWxlIG1kLWdyaWQtdGlsZS1mb290ZXIgeyBib3R0b206IDA7IH0gbWQtZ3JpZC10aWxlIFttZC1ncmlkLWF2YXRhcl0geyBwYWRkaW5nLXJpZ2h0OiAxNnB4OyB9IFtkaXI9J3J0bCddIG1kLWdyaWQtdGlsZSBbbWQtZ3JpZC1hdmF0YXJdIHsgcGFkZGluZy1yaWdodDogMDsgcGFkZGluZy1sZWZ0OiAxNnB4OyB9IG1kLWdyaWQtdGlsZSBbbWQtZ3JpZC1hdmF0YXJdOmVtcHR5IHsgZGlzcGxheTogbm9uZTsgfSAvKiMgc291cmNlTWFwcGluZ1VSTD1ncmlkLWxpc3QuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNygnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmXSlcbiAgICBdLCBNZEdyaWRUaWxlKTtcbiAgICByZXR1cm4gTWRHcmlkVGlsZTtcbn0oKSk7XG52YXIgTWRHcmlkVGlsZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kR3JpZFRpbGVUZXh0KF9yZW5kZXJlciwgX2VsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICB9XG4gICAgTWRHcmlkVGlsZVRleHQucHJvdG90eXBlLm5nQWZ0ZXJDb250ZW50SW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbGluZVNldHRlciA9IG5ldyBNZExpbmVTZXR0ZXIodGhpcy5fbGluZXMsIHRoaXMuX3JlbmRlcmVyLCB0aGlzLl9lbGVtZW50KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMjcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZHJlbihNZExpbmUpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNygnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLlF1ZXJ5TGlzdClcbiAgICBdLCBNZEdyaWRUaWxlVGV4dC5wcm90b3R5cGUsIFwiX2xpbmVzXCIsIHZvaWQgMCk7XG4gICAgTWRHcmlkVGlsZVRleHQgPSBfX2RlY29yYXRlJDI3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtZ3JpZC10aWxlLWhlYWRlciwgbWQtZ3JpZC10aWxlLWZvb3RlcicsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bmctY29udGVudCBzZWxlY3Q9XFxcIlttZC1ncmlkLWF2YXRhcl1cXFwiPjwvbmctY29udGVudD4gPGRpdiBjbGFzcz1cXFwibWQtZ3JpZC1saXN0LXRleHRcXFwiPjxuZy1jb250ZW50IHNlbGVjdD1cXFwiW21kLWxpbmVdXFxcIj48L25nLWNvbnRlbnQ+PC9kaXY+IDxuZy1jb250ZW50PjwvbmctY29udGVudD5cIlxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZl0pXG4gICAgXSwgTWRHcmlkVGlsZVRleHQpO1xuICAgIHJldHVybiBNZEdyaWRUaWxlVGV4dDtcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMkOCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBjb2xzIHByb3BlcnR5IGlzIG1pc3NpbmcgZnJvbSBncmlkLWxpc3RcbiAqL1xudmFyIE1kR3JpZExpc3RDb2xzRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQ4KE1kR3JpZExpc3RDb2xzRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRHcmlkTGlzdENvbHNFcnJvcigpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJtZC1ncmlkLWxpc3Q6IG11c3QgcGFzcyBpbiBudW1iZXIgb2YgY29sdW1ucy4gRXhhbXBsZTogPG1kLWdyaWQtbGlzdCBjb2xzPVxcXCIzXFxcIj5cIik7XG4gICAgfVxuICAgIHJldHVybiBNZEdyaWRMaXN0Q29sc0Vycm9yO1xufShNZEVycm9yKSk7XG4vKipcbiAqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBhIHRpbGUncyBjb2xzcGFuIGlzIGxvbmdlciB0aGFuIHRoZSBudW1iZXIgb2YgY29scyBpbiBsaXN0XG4gKi9cbnZhciBNZEdyaWRUaWxlVG9vV2lkZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkOChNZEdyaWRUaWxlVG9vV2lkZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kR3JpZFRpbGVUb29XaWRlRXJyb3IoY29scywgbGlzdExlbmd0aCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIm1kLWdyaWQtbGlzdDogdGlsZSB3aXRoIGNvbHNwYW4gXCIgKyBjb2xzICsgXCIgaXMgd2lkZXIgdGhhbiBncmlkIHdpdGggY29scz1cXFwiXCIgKyBsaXN0TGVuZ3RoICsgXCJcXFwiLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE1kR3JpZFRpbGVUb29XaWRlRXJyb3I7XG59KE1kRXJyb3IpKTtcbi8qKlxuICogRXhjZXB0aW9uIHRocm93biB3aGVuIGFuIGludmFsaWQgcmF0aW8gaXMgcGFzc2VkIGluIGFzIGEgcm93SGVpZ2h0XG4gKi9cbnZhciBNZEdyaWRMaXN0QmFkUmF0aW9FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDgoTWRHcmlkTGlzdEJhZFJhdGlvRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRHcmlkTGlzdEJhZFJhdGlvRXJyb3IodmFsdWUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJtZC1ncmlkLWxpc3Q6IGludmFsaWQgcmF0aW8gZ2l2ZW4gZm9yIHJvdy1oZWlnaHQ6IFxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTWRHcmlkTGlzdEJhZFJhdGlvRXJyb3I7XG59KE1kRXJyb3IpKTtcblxuLyoqXG4gKiBDbGFzcyBmb3IgZGV0ZXJtaW5pbmcsIGZyb20gYSBsaXN0IG9mIHRpbGVzLCB0aGUgKHJvdywgY29sKSBwb3NpdGlvbiBvZiBlYWNoIG9mIHRob3NlIHRpbGVzXG4gKiBpbiB0aGUgZ3JpZC4gVGhpcyBpcyBuZWNlc3NhcnkgKHJhdGhlciB0aGFuIGp1c3QgcmVuZGVyaW5nIHRoZSB0aWxlcyBpbiBub3JtYWwgZG9jdW1lbnQgZmxvdylcbiAqIGJlY2F1c2UgdGhlIHRpbGVzIGNhbiBoYXZlIGEgcm93c3Bhbi5cbiAqXG4gKiBUaGUgcG9zaXRpb25pbmcgYWxnb3JpdGhtIGdyZWVkaWx5IHBsYWNlcyBlYWNoIHRpbGUgYXMgc29vbiBhcyBpdCBlbmNvdW50ZXJzIGEgZ2FwIGluIHRoZSBncmlkXG4gKiBsYXJnZSBlbm91Z2ggdG8gYWNjb21tb2RhdGUgaXQgc28gdGhhdCB0aGUgdGlsZXMgc3RpbGwgcmVuZGVyIGluIHRoZSBzYW1lIG9yZGVyIGluIHdoaWNoIHRoZXlcbiAqIGFyZSBnaXZlbi5cbiAqXG4gKiBUaGUgYmFzaXMgb2YgdGhlIGFsZ29yaXRobSBpcyB0aGUgdXNlIG9mIGFuIGFycmF5IHRvIHRyYWNrIHRoZSBhbHJlYWR5IHBsYWNlZCB0aWxlcy4gRWFjaFxuICogZWxlbWVudCBvZiB0aGUgYXJyYXkgY29ycmVzcG9uZHMgdG8gYSBjb2x1bW4sIGFuZCB0aGUgdmFsdWUgaW5kaWNhdGVzIGhvdyBtYW55IGNlbGxzIGluIHRoYXRcbiAqIGNvbHVtbiBhcmUgYWxyZWFkeSBvY2N1cGllZDsgemVybyBpbmRpY2F0ZXMgYW4gZW1wdHkgY2VsbC4gTW92aW5nIFwiZG93blwiIHRvIHRoZSBuZXh0IHJvd1xuICogZGVjcmVtZW50cyBlYWNoIHZhbHVlIGluIHRoZSB0cmFja2luZyBhcnJheSAoaW5kaWNhdGluZyB0aGF0IHRoZSBjb2x1bW4gaXMgb25lIGNlbGwgY2xvc2VyIHRvXG4gKiBiZWluZyBmcmVlKS5cbiAqL1xudmFyIFRpbGVDb29yZGluYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGlsZUNvb3JkaW5hdG9yKG51bUNvbHVtbnMsIHRpbGVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKiBJbmRleCBhdCB3aGljaCB0aGUgc2VhcmNoIGZvciB0aGUgbmV4dCBnYXAgd2lsbCBzdGFydC4gKi9cbiAgICAgICAgdGhpcy5jb2x1bW5JbmRleCA9IDA7XG4gICAgICAgIC8qKiBUaGUgY3VycmVudCByb3cgaW5kZXguICovXG4gICAgICAgIHRoaXMucm93SW5kZXggPSAwO1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSBuZXcgQXJyYXkobnVtQ29sdW1ucyk7XG4gICAgICAgIHRoaXMudHJhY2tlci5maWxsKDAsIDAsIHRoaXMudHJhY2tlci5sZW5ndGgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9ucyA9IHRpbGVzLm1hcChmdW5jdGlvbiAodGlsZSkgeyByZXR1cm4gX3RoaXMuX3RyYWNrVGlsZSh0aWxlKTsgfSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaWxlQ29vcmRpbmF0b3IucHJvdG90eXBlLCBcInJvd0NvdW50XCIsIHtcbiAgICAgICAgLyoqIEdldHMgdGhlIHRvdGFsIG51bWJlciBvZiByb3dzIG9jY3VwaWVkIGJ5IHRpbGVzICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5yb3dJbmRleCArIDE7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUaWxlQ29vcmRpbmF0b3IucHJvdG90eXBlLCBcInJvd3NwYW5cIiwge1xuICAgICAgICAvKiogR2V0cyB0aGUgdG90YWwgc3BhbiBvZiByb3dzIG9jY3VwaWVkIGJ5IHRpbGVzLlxuICAgICAgICAgKiBFeDogQSBsaXN0IHdpdGggMSByb3cgdGhhdCBjb250YWlucyBhIHRpbGUgd2l0aCByb3dzcGFuIDIgd2lsbCBoYXZlIGEgdG90YWwgcm93c3BhbiBvZiAyLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsYXN0Um93TWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgdGhpcy50cmFja2VyKTtcbiAgICAgICAgICAgIC8vIGlmIGFueSBvZiB0aGUgdGlsZXMgaGFzIGEgcm93c3BhbiB0aGF0IHB1c2hlcyBpdCBiZXlvbmQgdGhlIHRvdGFsIHJvdyBjb3VudCxcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgZGlmZmVyZW5jZSB0byB0aGUgcm93Y291bnRcbiAgICAgICAgICAgIHJldHVybiBsYXN0Um93TWF4ID4gMSA/IHRoaXMucm93Q291bnQgKyBsYXN0Um93TWF4IC0gMSA6IHRoaXMucm93Q291bnQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBDYWxjdWxhdGVzIHRoZSByb3cgYW5kIGNvbCBwb3NpdGlvbiBvZiBhIHRpbGUuICovXG4gICAgVGlsZUNvb3JkaW5hdG9yLnByb3RvdHlwZS5fdHJhY2tUaWxlID0gZnVuY3Rpb24gKHRpbGUpIHtcbiAgICAgICAgLy8gRmluZCBhIGdhcCBsYXJnZSBlbm91Z2ggZm9yIHRoaXMgdGlsZS5cbiAgICAgICAgdmFyIGdhcFN0YXJ0SW5kZXggPSB0aGlzLl9maW5kTWF0Y2hpbmdHYXAodGlsZS5jb2xzcGFuKTtcbiAgICAgICAgLy8gUGxhY2UgdGlsZSBpbiB0aGUgcmVzdWx0aW5nIGdhcC5cbiAgICAgICAgdGhpcy5fbWFya1RpbGVQb3NpdGlvbihnYXBTdGFydEluZGV4LCB0aWxlKTtcbiAgICAgICAgLy8gVGhlIG5leHQgdGltZSB3ZSBsb29rIGZvciBhIGdhcCwgdGhlIHNlYXJjaCB3aWxsIHN0YXJ0IGF0IGNvbHVtbkluZGV4LCB3aGljaCBzaG91bGQgYmVcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHRpbGUgdGhhdCBoYXMganVzdCBiZWVuIHBsYWNlZC5cbiAgICAgICAgdGhpcy5jb2x1bW5JbmRleCA9IGdhcFN0YXJ0SW5kZXggKyB0aWxlLmNvbHNwYW47XG4gICAgICAgIHJldHVybiBuZXcgVGlsZVBvc2l0aW9uKHRoaXMucm93SW5kZXgsIGdhcFN0YXJ0SW5kZXgpO1xuICAgIH07XG4gICAgLyoqIEZpbmRzIHRoZSBuZXh0IGF2YWlsYWJsZSBzcGFjZSBsYXJnZSBlbm91Z2ggdG8gZml0IHRoZSB0aWxlLiAqL1xuICAgIFRpbGVDb29yZGluYXRvci5wcm90b3R5cGUuX2ZpbmRNYXRjaGluZ0dhcCA9IGZ1bmN0aW9uICh0aWxlQ29scykge1xuICAgICAgICBpZiAodGlsZUNvbHMgPiB0aGlzLnRyYWNrZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWRHcmlkVGlsZVRvb1dpZGVFcnJvcih0aWxlQ29scywgdGhpcy50cmFja2VyLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQgaW5kZXggaXMgaW5jbHVzaXZlLCBlbmQgaW5kZXggaXMgZXhjbHVzaXZlLlxuICAgICAgICB2YXIgZ2FwU3RhcnRJbmRleCA9IC0xO1xuICAgICAgICB2YXIgZ2FwRW5kSW5kZXggPSAtMTtcbiAgICAgICAgLy8gTG9vayBmb3IgYSBnYXAgbGFyZ2UgZW5vdWdoIHRvIGZpdCB0aGUgZ2l2ZW4gdGlsZS4gRW1wdHkgc3BhY2VzIGFyZSBtYXJrZWQgd2l0aCBhIHplcm8uXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgcm93LCBnbyB0byB0aGUgbmV4dCByb3cuXG4gICAgICAgICAgICBpZiAodGhpcy5jb2x1bW5JbmRleCArIHRpbGVDb2xzID4gdGhpcy50cmFja2VyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25leHRSb3coKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdhcFN0YXJ0SW5kZXggPSB0aGlzLnRyYWNrZXIuaW5kZXhPZigwLCB0aGlzLmNvbHVtbkluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBtb3JlIGVtcHR5IHNwYWNlcyBpbiB0aGlzIHJvdyBhdCBhbGwsIG1vdmUgb24gdG8gdGhlIG5leHQgcm93LlxuICAgICAgICAgICAgaWYgKGdhcFN0YXJ0SW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXh0Um93KCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnYXBFbmRJbmRleCA9IHRoaXMuX2ZpbmRHYXBFbmRJbmRleChnYXBTdGFydEluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIGEgZ2FwIGxhcmdlIGVub3VnaCBpc24ndCBmb3VuZCwgd2Ugd2FudCB0byBzdGFydCBsb29raW5nIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjdXJyZW50XG4gICAgICAgICAgICAvLyBnYXAgb24gdGhlIG5leHQgaXRlcmF0aW9uLlxuICAgICAgICAgICAgdGhpcy5jb2x1bW5JbmRleCA9IGdhcFN0YXJ0SW5kZXggKyAxO1xuICAgICAgICB9IHdoaWxlIChnYXBFbmRJbmRleCAtIGdhcFN0YXJ0SW5kZXggPCB0aWxlQ29scyk7XG4gICAgICAgIHJldHVybiBnYXBTdGFydEluZGV4O1xuICAgIH07XG4gICAgLyoqIE1vdmUgXCJkb3duXCIgdG8gdGhlIG5leHQgcm93LiAqL1xuICAgIFRpbGVDb29yZGluYXRvci5wcm90b3R5cGUuX25leHRSb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29sdW1uSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnJvd0luZGV4Kys7XG4gICAgICAgIC8vIERlY3JlbWVudCBhbGwgc3BhY2VzIGJ5IG9uZSB0byByZWZsZWN0IG1vdmluZyBkb3duIG9uZSByb3cuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50cmFja2VyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrZXJbaV0gPSBNYXRoLm1heCgwLCB0aGlzLnRyYWNrZXJbaV0gLSAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGVuZCBpbmRleCAoZXhjbHVzaXZlKSBvZiBhIGdhcCBnaXZlbiB0aGUgaW5kZXggZnJvbSB3aGljaCB0byBzdGFydCBsb29raW5nLlxuICAgICAqIFRoZSBnYXAgZW5kcyB3aGVuIGEgbm9uLXplcm8gdmFsdWUgaXMgZm91bmQuXG4gICAgICovXG4gICAgVGlsZUNvb3JkaW5hdG9yLnByb3RvdHlwZS5fZmluZEdhcEVuZEluZGV4ID0gZnVuY3Rpb24gKGdhcFN0YXJ0SW5kZXgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGdhcFN0YXJ0SW5kZXggKyAxOyBpIDwgdGhpcy50cmFja2VyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFja2VyW2ldICE9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgZ2FwIGVuZHMgd2l0aCB0aGUgZW5kIG9mIHRoZSByb3cuXG4gICAgICAgIHJldHVybiB0aGlzLnRyYWNrZXIubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqIFVwZGF0ZSB0aGUgdGlsZSB0cmFja2VyIHRvIGFjY291bnQgZm9yIHRoZSBnaXZlbiB0aWxlIGluIHRoZSBnaXZlbiBzcGFjZS4gKi9cbiAgICBUaWxlQ29vcmRpbmF0b3IucHJvdG90eXBlLl9tYXJrVGlsZVBvc2l0aW9uID0gZnVuY3Rpb24gKHN0YXJ0LCB0aWxlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGlsZS5jb2xzcGFuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2tlcltzdGFydCArIGldID0gdGlsZS5yb3dzcGFuO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGlsZUNvb3JkaW5hdG9yO1xufSgpKTtcbi8qKiBTaW1wbGUgZGF0YSBzdHJ1Y3R1cmUgZm9yIHRpbGUgcG9zaXRpb24gKHJvdywgY29sKS4gKi9cbnZhciBUaWxlUG9zaXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbGVQb3NpdGlvbihyb3csIGNvbCkge1xuICAgICAgICB0aGlzLnJvdyA9IHJvdztcbiAgICAgICAgdGhpcy5jb2wgPSBjb2w7XG4gICAgfVxuICAgIHJldHVybiBUaWxlUG9zaXRpb247XG59KCkpO1xuXG52YXIgX19leHRlbmRzJDkgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBTZXRzIHRoZSBzdHlsZSBwcm9wZXJ0aWVzIGZvciBhbiBpbmRpdmlkdWFsIHRpbGUsIGdpdmVuIHRoZSBwb3NpdGlvbiBjYWxjdWxhdGVkIGJ5IHRoZVxuICogVGlsZSBDb29yZGluYXRvci5cbiAqIFRPRE86IGludGVybmFsXG4gKi9cbnZhciBUaWxlU3R5bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaWxlU3R5bGVyKCkge1xuICAgICAgICB0aGlzLl9yb3dzID0gMDtcbiAgICAgICAgdGhpcy5fcm93c3BhbiA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgZ3JpZC1saXN0IGxheW91dCBpbmZvIG9uY2UgaXQgaXMgYXZhaWxhYmxlLiBDYW5ub3QgYmUgcHJvY2Vzc2VkIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAqIGJlY2F1c2UgdGhlc2UgcHJvcGVydGllcyBoYXZlbid0IGJlZW4gY2FsY3VsYXRlZCBieSB0aGF0IHBvaW50LlxuICAgICAqL1xuICAgIFRpbGVTdHlsZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoX2d1dHRlclNpemUsIHRyYWNrZXIsIGNvbHMsIGRpcmVjdGlvbikge1xuICAgICAgICB0aGlzLl9ndXR0ZXJTaXplID0gbm9ybWFsaXplVW5pdHMoX2d1dHRlclNpemUpO1xuICAgICAgICB0aGlzLl9yb3dzID0gdHJhY2tlci5yb3dDb3VudDtcbiAgICAgICAgdGhpcy5fcm93c3BhbiA9IHRyYWNrZXIucm93c3BhbjtcbiAgICAgICAgdGhpcy5fY29scyA9IGNvbHM7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBhbW91bnQgb2Ygc3BhY2UgYSBzaW5nbGUgMXgxIHRpbGUgd291bGQgdGFrZSB1cCAod2lkdGggb3IgaGVpZ2h0KS5cbiAgICAgKiBVc2VkIGFzIGEgYmFzaXMgZm9yIG90aGVyIGNhbGN1bGF0aW9ucy5cbiAgICAgKiBAcGFyYW0gc2l6ZVBlcmNlbnQgUGVyY2VudCBvZiB0aGUgdG90YWwgZ3JpZC1saXN0IHNwYWNlIHRoYXQgb25lIDF4MSB0aWxlIHdvdWxkIHRha2UgdXAuXG4gICAgICogQHBhcmFtIGd1dHRlckZyYWN0aW9uIEZyYWN0aW9uIG9mIHRoZSBndXR0ZXIgc2l6ZSB0YWtlbiB1cCBieSBvbmUgMXgxIHRpbGUuXG4gICAgICogQHJldHVybiBUaGUgc2l6ZSBvZiBhIDF4MSB0aWxlIGFzIGFuIGV4cHJlc3Npb24gdGhhdCBjYW4gYmUgZXZhbHVhdGVkIHZpYSBDU1MgY2FsYygpLlxuICAgICAqL1xuICAgIFRpbGVTdHlsZXIucHJvdG90eXBlLmdldEJhc2VUaWxlU2l6ZSA9IGZ1bmN0aW9uIChzaXplUGVyY2VudCwgZ3V0dGVyRnJhY3Rpb24pIHtcbiAgICAgICAgLy8gVGFrZSB0aGUgYmFzZSBzaXplIHBlcmNlbnQgKGFzIHdvdWxkIGJlIGlmIGV2ZW5seSBkaXZpZGluZyB0aGUgc2l6ZSBiZXR3ZWVuIGNlbGxzKSxcbiAgICAgICAgLy8gYW5kIHRoZW4gc3VidHJhY3RpbmcgdGhlIHNpemUgb2Ygb25lIGd1dHRlci4gSG93ZXZlciwgc2luY2UgdGhlcmUgYXJlIG5vIGd1dHRlcnMgb24gdGhlXG4gICAgICAgIC8vIGVkZ2VzLCBlYWNoIHRpbGUgb25seSB1c2VzIGEgZnJhY3Rpb24gKGd1dHRlclNoYXJlID0gbnVtR3V0dGVycyAvIG51bUNlbGxzKSBvZiB0aGUgZ3V0dGVyXG4gICAgICAgIC8vIHNpemUuIChJbWFnaW5lIGhhdmluZyBvbmUgZ3V0dGVyIHBlciB0aWxlLCBhbmQgdGhlbiBicmVha2luZyB1cCB0aGUgZXh0cmEgZ3V0dGVyIG9uIHRoZVxuICAgICAgICAvLyBlZGdlIGV2ZW5seSBhbW9uZyB0aGUgY2VsbHMpLlxuICAgICAgICByZXR1cm4gXCIoXCIgKyBzaXplUGVyY2VudCArIFwiJSAtICggXCIgKyB0aGlzLl9ndXR0ZXJTaXplICsgXCIgKiBcIiArIGd1dHRlckZyYWN0aW9uICsgXCIgKSlcIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgVGhlIGhvcml6b250YWwgb3IgdmVydGljYWwgcG9zaXRpb24gb2YgYSB0aWxlLCBlLmcuLCB0aGUgJ3RvcCcgb3IgJ2xlZnQnIHByb3BlcnR5IHZhbHVlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQgTnVtYmVyIG9mIHRpbGVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVuZGVyZWQgaW4gdGhlIHJvdy9jb2x1bW4uXG4gICAgICogQHBhcmFtIGJhc2VTaXplIEJhc2Ugc2l6ZSBvZiBhIDF4MSB0aWxlIChhcyBjb21wdXRlZCBpbiBnZXRCYXNlVGlsZVNpemUpLlxuICAgICAqIEByZXR1cm4gUG9zaXRpb24gb2YgdGhlIHRpbGUgYXMgYSBDU1MgY2FsYygpIGV4cHJlc3Npb24uXG4gICAgICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0VGlsZVBvc2l0aW9uID0gZnVuY3Rpb24gKGJhc2VTaXplLCBvZmZzZXQpIHtcbiAgICAgICAgLy8gVGhlIHBvc2l0aW9uIGNvbWVzIHRoZSBzaXplIG9mIGEgMXgxIHRpbGUgcGx1cyBndXR0ZXIgZm9yIGVhY2ggcHJldmlvdXMgdGlsZSBpbiB0aGVcbiAgICAgICAgLy8gcm93L2NvbHVtbiAob2Zmc2V0KS5cbiAgICAgICAgcmV0dXJuIGNhbGMoXCIoXCIgKyBiYXNlU2l6ZSArIFwiICsgXCIgKyB0aGlzLl9ndXR0ZXJTaXplICsgXCIpICogXCIgKyBvZmZzZXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYWN0dWFsIHNpemUgb2YgYSB0aWxlLCBlLmcuLCB3aWR0aCBvciBoZWlnaHQsIHRha2luZyByb3dzcGFuIG9yIGNvbHNwYW4gaW50byBhY2NvdW50LlxuICAgICAqIEBwYXJhbSBiYXNlU2l6ZSBCYXNlIHNpemUgb2YgYSAxeDEgdGlsZSAoYXMgY29tcHV0ZWQgaW4gZ2V0QmFzZVRpbGVTaXplKS5cbiAgICAgKiBAcGFyYW0gc3BhbiBUaGUgdGlsZSdzIHJvd3NwYW4gb3IgY29sc3Bhbi5cbiAgICAgKiBAcmV0dXJuIFNpemUgb2YgdGhlIHRpbGUgYXMgYSBDU1MgY2FsYygpIGV4cHJlc3Npb24uXG4gICAgICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0VGlsZVNpemUgPSBmdW5jdGlvbiAoYmFzZVNpemUsIHNwYW4pIHtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgYmFzZVNpemUgKyBcIiAqIFwiICsgc3BhbiArIFwiKSArIChcIiArIChzcGFuIC0gMSkgKyBcIiAqIFwiICsgdGhpcy5fZ3V0dGVyU2l6ZSArIFwiKVwiO1xuICAgIH07XG4gICAgLyoqIEdldHMgdGhlIHN0eWxlIHByb3BlcnRpZXMgdG8gYmUgYXBwbGllZCB0byBhIHRpbGUgZm9yIHRoZSBnaXZlbiByb3cgYW5kIGNvbHVtbiBpbmRleC4gKi9cbiAgICBUaWxlU3R5bGVyLnByb3RvdHlwZS5zZXRTdHlsZSA9IGZ1bmN0aW9uICh0aWxlLCByb3dJbmRleCwgY29sSW5kZXgpIHtcbiAgICAgICAgLy8gUGVyY2VudCBvZiB0aGUgYXZhaWxhYmxlIGhvcml6b250YWwgc3BhY2UgdGhhdCBvbmUgY29sdW1uIHRha2VzIHVwLlxuICAgICAgICB2YXIgcGVyY2VudFdpZHRoUGVyVGlsZSA9IDEwMCAvIHRoaXMuX2NvbHM7XG4gICAgICAgIC8vIEZyYWN0aW9uIG9mIHRoZSB2ZXJ0aWNhbCBndXR0ZXIgc2l6ZSB0aGF0IGVhY2ggY29sdW1uIHRha2VzIHVwLlxuICAgICAgICAvLyBGb3IgZXhhbXBsZSwgaWYgdGhlcmUgYXJlIDUgY29sdW1ucywgZWFjaCBjb2x1bW4gdXNlcyA0LzUgPSAwLjggdGltZXMgdGhlIGd1dHRlciB3aWR0aC5cbiAgICAgICAgdmFyIGd1dHRlcldpZHRoRnJhY3Rpb25QZXJUaWxlID0gKHRoaXMuX2NvbHMgLSAxKSAvIHRoaXMuX2NvbHM7XG4gICAgICAgIHRoaXMuc2V0Q29sU3R5bGVzKHRpbGUsIGNvbEluZGV4LCBwZXJjZW50V2lkdGhQZXJUaWxlLCBndXR0ZXJXaWR0aEZyYWN0aW9uUGVyVGlsZSk7XG4gICAgICAgIHRoaXMuc2V0Um93U3R5bGVzKHRpbGUsIHJvd0luZGV4LCBwZXJjZW50V2lkdGhQZXJUaWxlLCBndXR0ZXJXaWR0aEZyYWN0aW9uUGVyVGlsZSk7XG4gICAgfTtcbiAgICAvKiogU2V0cyB0aGUgaG9yaXpvbnRhbCBwbGFjZW1lbnQgb2YgdGhlIHRpbGUgaW4gdGhlIGxpc3QuICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuc2V0Q29sU3R5bGVzID0gZnVuY3Rpb24gKHRpbGUsIGNvbEluZGV4LCBwZXJjZW50V2lkdGgsIGd1dHRlcldpZHRoKSB7XG4gICAgICAgIC8vIEJhc2UgaG9yaXpvbnRhbCBzaXplIG9mIGEgY29sdW1uLlxuICAgICAgICB2YXIgYmFzZVRpbGVXaWR0aCA9IHRoaXMuZ2V0QmFzZVRpbGVTaXplKHBlcmNlbnRXaWR0aCwgZ3V0dGVyV2lkdGgpO1xuICAgICAgICAvLyBUaGUgd2lkdGggYW5kIGhvcml6b250YWwgcG9zaXRpb24gb2YgZWFjaCB0aWxlIGlzIGFsd2F5cyBjYWxjdWxhdGVkIHRoZSBzYW1lIHdheSwgYnV0IHRoZVxuICAgICAgICAvLyBoZWlnaHQgYW5kIHZlcnRpY2FsIHBvc2l0aW9uIGRlcGVuZHMgb24gdGhlIHJvd01vZGUuXG4gICAgICAgIHZhciBzaWRlID0gdGhpcy5fZGlyZWN0aW9uID09PSAnbHRyJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgIHRpbGUuX3NldFN0eWxlKHNpZGUsIHRoaXMuZ2V0VGlsZVBvc2l0aW9uKGJhc2VUaWxlV2lkdGgsIGNvbEluZGV4KSk7XG4gICAgICAgIHRpbGUuX3NldFN0eWxlKCd3aWR0aCcsIGNhbGModGhpcy5nZXRUaWxlU2l6ZShiYXNlVGlsZVdpZHRoLCB0aWxlLmNvbHNwYW4pKSk7XG4gICAgfTtcbiAgICAvKiogQ2FsY3VsYXRlcyB0aGUgdG90YWwgc2l6ZSB0YWtlbiB1cCBieSBndXR0ZXJzIGFjcm9zcyBvbmUgYXhpcyBvZiBhIGxpc3QuICovXG4gICAgVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0R3V0dGVyU3BhbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2d1dHRlclNpemUgKyBcIiAqIChcIiArIHRoaXMuX3Jvd3NwYW4gKyBcIiAtIDEpXCI7XG4gICAgfTtcbiAgICAvKiogQ2FsY3VsYXRlcyB0aGUgdG90YWwgc2l6ZSB0YWtlbiB1cCBieSB0aWxlcyBhY3Jvc3Mgb25lIGF4aXMgb2YgYSBsaXN0LiAqL1xuICAgIFRpbGVTdHlsZXIucHJvdG90eXBlLmdldFRpbGVTcGFuID0gZnVuY3Rpb24gKHRpbGVIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvd3NwYW4gKyBcIiAqIFwiICsgdGhpcy5nZXRUaWxlU2l6ZSh0aWxlSGVpZ2h0LCAxKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZlcnRpY2FsIHBsYWNlbWVudCBvZiB0aGUgdGlsZSBpbiB0aGUgbGlzdC5cbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggdHlwZSBvZiBUaWxlU3R5bGVyLlxuICAgICAqL1xuICAgIFRpbGVTdHlsZXIucHJvdG90eXBlLnNldFJvd1N0eWxlcyA9IGZ1bmN0aW9uICh0aWxlLCByb3dJbmRleCwgcGVyY2VudFdpZHRoLCBndXR0ZXJXaWR0aCkgeyB9O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGNvbXB1dGVkIGhlaWdodCBhbmQgcmV0dXJucyB0aGUgY29ycmVjdCBzdHlsZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBiZSBpbXBsZW1lbnRlZCBieSBlYWNoIHR5cGUgb2YgVGlsZVN0eWxlci5cbiAgICAgKi9cbiAgICBUaWxlU3R5bGVyLnByb3RvdHlwZS5nZXRDb21wdXRlZEhlaWdodCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH07XG4gICAgcmV0dXJuIFRpbGVTdHlsZXI7XG59KCkpO1xuLyoqXG4gKiBUaGlzIHR5cGUgb2Ygc3R5bGVyIGlzIGluc3RhbnRpYXRlZCB3aGVuIHRoZSB1c2VyIHBhc3NlcyBpbiBhIGZpeGVkIHJvdyBoZWlnaHQuXG4gKiBFeGFtcGxlIDxtZC1ncmlkLWxpc3QgY29scz1cIjNcIiByb3dIZWlnaHQ9XCIxMDBweFwiPlxuICogVE9ETzogaW50ZXJuYWxcbiAqL1xudmFyIEZpeGVkVGlsZVN0eWxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDkoRml4ZWRUaWxlU3R5bGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpeGVkVGlsZVN0eWxlcihmaXhlZFJvd0hlaWdodCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5maXhlZFJvd0hlaWdodCA9IGZpeGVkUm93SGVpZ2h0O1xuICAgIH1cbiAgICBGaXhlZFRpbGVTdHlsZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZ3V0dGVyU2l6ZSwgdHJhY2tlciwgY29scywgZGlyZWN0aW9uKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGd1dHRlclNpemUsIHRyYWNrZXIsIGNvbHMsIGRpcmVjdGlvbik7XG4gICAgICAgIHRoaXMuZml4ZWRSb3dIZWlnaHQgPSBub3JtYWxpemVVbml0cyh0aGlzLmZpeGVkUm93SGVpZ2h0KTtcbiAgICB9O1xuICAgIEZpeGVkVGlsZVN0eWxlci5wcm90b3R5cGUuc2V0Um93U3R5bGVzID0gZnVuY3Rpb24gKHRpbGUsIHJvd0luZGV4LCBwZXJjZW50V2lkdGgsIGd1dHRlcldpZHRoKSB7XG4gICAgICAgIHRpbGUuX3NldFN0eWxlKCd0b3AnLCB0aGlzLmdldFRpbGVQb3NpdGlvbih0aGlzLmZpeGVkUm93SGVpZ2h0LCByb3dJbmRleCkpO1xuICAgICAgICB0aWxlLl9zZXRTdHlsZSgnaGVpZ2h0JywgY2FsYyh0aGlzLmdldFRpbGVTaXplKHRoaXMuZml4ZWRSb3dIZWlnaHQsIHRpbGUucm93c3BhbikpKTtcbiAgICB9O1xuICAgIEZpeGVkVGlsZVN0eWxlci5wcm90b3R5cGUuZ2V0Q29tcHV0ZWRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnaGVpZ2h0JywgY2FsYyh0aGlzLmdldFRpbGVTcGFuKHRoaXMuZml4ZWRSb3dIZWlnaHQpICsgXCIgKyBcIiArIHRoaXMuZ2V0R3V0dGVyU3BhbigpKVxuICAgICAgICBdO1xuICAgIH07XG4gICAgcmV0dXJuIEZpeGVkVGlsZVN0eWxlcjtcbn0oVGlsZVN0eWxlcikpO1xuLyoqXG4gKiBUaGlzIHR5cGUgb2Ygc3R5bGVyIGlzIGluc3RhbnRpYXRlZCB3aGVuIHRoZSB1c2VyIHBhc3NlcyBpbiBhIHdpZHRoOmhlaWdodCByYXRpb1xuICogZm9yIHRoZSByb3cgaGVpZ2h0LiAgRXhhbXBsZSA8bWQtZ3JpZC1saXN0IGNvbHM9XCIzXCIgcm93SGVpZ2h0PVwiMzoxXCI+XG4gKiBUT0RPOiBpbnRlcm5hbFxuICovXG52YXIgUmF0aW9UaWxlU3R5bGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkOShSYXRpb1RpbGVTdHlsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmF0aW9UaWxlU3R5bGVyKHZhbHVlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9wYXJzZVJhdGlvKHZhbHVlKTtcbiAgICB9XG4gICAgUmF0aW9UaWxlU3R5bGVyLnByb3RvdHlwZS5zZXRSb3dTdHlsZXMgPSBmdW5jdGlvbiAodGlsZSwgcm93SW5kZXgsIHBlcmNlbnRXaWR0aCwgZ3V0dGVyV2lkdGgpIHtcbiAgICAgICAgdmFyIHBlcmNlbnRIZWlnaHRQZXJUaWxlID0gcGVyY2VudFdpZHRoIC8gdGhpcy5yb3dIZWlnaHRSYXRpbztcbiAgICAgICAgdGhpcy5iYXNlVGlsZUhlaWdodCA9IHRoaXMuZ2V0QmFzZVRpbGVTaXplKHBlcmNlbnRIZWlnaHRQZXJUaWxlLCBndXR0ZXJXaWR0aCk7XG4gICAgICAgIC8vIFVzZSBwYWRkaW5nVG9wIGFuZCBtYXJnaW5Ub3AgdG8gbWFpbnRhaW4gdGhlIGdpdmVuIGFzcGVjdCByYXRpbywgYXNcbiAgICAgICAgLy8gYSBwZXJjZW50YWdlLWJhc2VkIHZhbHVlIGZvciB0aGVzZSBwcm9wZXJ0aWVzIGlzIGFwcGxpZWQgdmVyc3VzIHRoZSAqd2lkdGgqIG9mIHRoZVxuICAgICAgICAvLyBjb250YWluaW5nIGJsb2NrLiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvQ1NTMi9ib3guaHRtbCNtYXJnaW4tcHJvcGVydGllc1xuICAgICAgICB0aWxlLl9zZXRTdHlsZSgnbWFyZ2luVG9wJywgdGhpcy5nZXRUaWxlUG9zaXRpb24odGhpcy5iYXNlVGlsZUhlaWdodCwgcm93SW5kZXgpKTtcbiAgICAgICAgdGlsZS5fc2V0U3R5bGUoJ3BhZGRpbmdUb3AnLCBjYWxjKHRoaXMuZ2V0VGlsZVNpemUodGhpcy5iYXNlVGlsZUhlaWdodCwgdGlsZS5yb3dzcGFuKSkpO1xuICAgIH07XG4gICAgUmF0aW9UaWxlU3R5bGVyLnByb3RvdHlwZS5nZXRDb21wdXRlZEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdwYWRkaW5nQm90dG9tJywgY2FsYyh0aGlzLmdldFRpbGVTcGFuKHRoaXMuYmFzZVRpbGVIZWlnaHQpICsgXCIgKyBcIiArIHRoaXMuZ2V0R3V0dGVyU3BhbigpKVxuICAgICAgICBdO1xuICAgIH07XG4gICAgUmF0aW9UaWxlU3R5bGVyLnByb3RvdHlwZS5fcGFyc2VSYXRpbyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmF0aW9QYXJ0cyA9IHZhbHVlLnNwbGl0KCc6Jyk7XG4gICAgICAgIGlmIChyYXRpb1BhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1kR3JpZExpc3RCYWRSYXRpb0Vycm9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvd0hlaWdodFJhdGlvID0gcGFyc2VGbG9hdChyYXRpb1BhcnRzWzBdKSAvIHBhcnNlRmxvYXQocmF0aW9QYXJ0c1sxXSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmF0aW9UaWxlU3R5bGVyO1xufShUaWxlU3R5bGVyKSk7XG4vKiAgVGhpcyB0eXBlIG9mIHN0eWxlciBpcyBpbnN0YW50aWF0ZWQgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgXCJmaXRcIiByb3cgaGVpZ2h0IG1vZGUuXG4gKiAgSW4gb3RoZXIgd29yZHMsIHRoZSByb3cgaGVpZ2h0IHdpbGwgcmVmbGVjdCB0aGUgdG90YWwgaGVpZ2h0IG9mIHRoZSBjb250YWluZXIgZGl2aWRlZFxuICogIGJ5IHRoZSBudW1iZXIgb2Ygcm93cy4gIEV4YW1wbGUgPG1kLWdyaWQtbGlzdCBjb2xzPVwiM1wiIHJvd0hlaWdodD1cImZpdFwiPiAqL1xudmFyIEZpdFRpbGVTdHlsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQ5KEZpdFRpbGVTdHlsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRml0VGlsZVN0eWxlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEZpdFRpbGVTdHlsZXIucHJvdG90eXBlLnNldFJvd1N0eWxlcyA9IGZ1bmN0aW9uICh0aWxlLCByb3dJbmRleCwgcGVyY2VudFdpZHRoLCBndXR0ZXJXaWR0aCkge1xuICAgICAgICAvLyBQZXJjZW50IG9mIHRoZSBhdmFpbGFibGUgdmVydGljYWwgc3BhY2UgdGhhdCBvbmUgcm93IHRha2VzIHVwLlxuICAgICAgICB2YXIgcGVyY2VudEhlaWdodFBlclRpbGUgPSAxMDAgLyB0aGlzLl9yb3dzcGFuO1xuICAgICAgICAvLyBGcmFjdGlvbiBvZiB0aGUgaG9yaXpvbnRhbCBndXR0ZXIgc2l6ZSB0aGF0IGVhY2ggY29sdW1uIHRha2VzIHVwLlxuICAgICAgICB2YXIgZ3V0dGVySGVpZ2h0UGVyVGlsZSA9ICh0aGlzLl9yb3dzIC0gMSkgLyB0aGlzLl9yb3dzO1xuICAgICAgICAvLyBCYXNlIHZlcnRpY2FsIHNpemUgb2YgYSBjb2x1bW4uXG4gICAgICAgIHZhciBiYXNlVGlsZUhlaWdodCA9IHRoaXMuZ2V0QmFzZVRpbGVTaXplKHBlcmNlbnRIZWlnaHRQZXJUaWxlLCBndXR0ZXJIZWlnaHRQZXJUaWxlKTtcbiAgICAgICAgdGlsZS5fc2V0U3R5bGUoJ3RvcCcsIHRoaXMuZ2V0VGlsZVBvc2l0aW9uKGJhc2VUaWxlSGVpZ2h0LCByb3dJbmRleCkpO1xuICAgICAgICB0aWxlLl9zZXRTdHlsZSgnaGVpZ2h0JywgY2FsYyh0aGlzLmdldFRpbGVTaXplKGJhc2VUaWxlSGVpZ2h0LCB0aWxlLnJvd3NwYW4pKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRml0VGlsZVN0eWxlcjtcbn0oVGlsZVN0eWxlcikpO1xuLyoqIFdyYXBzIGEgQ1NTIHN0cmluZyBpbiBhIGNhbGMgZnVuY3Rpb24gKi9cbmZ1bmN0aW9uIGNhbGMoZXhwKSB7IHJldHVybiBcImNhbGMoXCIgKyBleHAgKyBcIilcIjsgfVxuLyoqIEFwcGVuZHMgcGl4ZWxzIHRvIGEgQ1NTIHN0cmluZyBpZiBubyB1bml0cyBhcmUgZ2l2ZW4uICovXG5mdW5jdGlvbiBub3JtYWxpemVVbml0cyh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUubWF0Y2goL3B4fGVtfHJlbS8pKSA/IHZhbHVlIDogdmFsdWUgKyAncHgnO1xufVxuXG52YXIgX19kZWNvcmF0ZSQyNiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQyNiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kNCA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8vIFRPRE8oa2FyYSk6IENvbmRpdGlvbmFsIChyZXNwb25zaXZlKSBjb2x1bW4gY291bnQgLyByb3cgc2l6ZS5cbi8vIFRPRE8oa2FyYSk6IFJlLWxheW91dCBvbiB3aW5kb3cgcmVzaXplIC8gbWVkaWEgY2hhbmdlIChkZWJvdW5jZWQpLlxuLy8gVE9ETyhrYXJhKTogZ3JpZFRpbGVIZWFkZXIgYW5kIGdyaWRUaWxlRm9vdGVyLlxudmFyIE1EX0ZJVF9NT0RFID0gJ2ZpdCc7XG52YXIgTWRHcmlkTGlzdCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRHcmlkTGlzdChfcmVuZGVyZXIsIF9lbGVtZW50LCBfZGlyKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX2RpciA9IF9kaXI7XG4gICAgICAgIC8qKiBUaGUgYW1vdW50IG9mIHNwYWNlIGJldHdlZW4gdGlsZXMuIFRoaXMgd2lsbCBiZSBzb21ldGhpbmcgbGlrZSAnNXB4JyBvciAnMmVtJy4gKi9cbiAgICAgICAgdGhpcy5fZ3V0dGVyID0gJzFweCc7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEdyaWRMaXN0LnByb3RvdHlwZSwgXCJjb2xzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29scztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbHMgPSBjb2VyY2VUb051bWJlcih2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZEdyaWRMaXN0LnByb3RvdHlwZSwgXCJndXR0ZXJTaXplXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ3V0dGVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZ3V0dGVyID0gY29lcmNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRHcmlkTGlzdC5wcm90b3R5cGUsIFwicm93SGVpZ2h0XCIsIHtcbiAgICAgICAgLyoqIFNldCBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiByb3cgaGVpZ2h0IGZyb20gdGhlIHVzZXItcHJvdmlkZWQgdmFsdWUuICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3dIZWlnaHQgPSBjb2VyY2VUb1N0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9zZXRUaWxlU3R5bGVyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBUT0RPOiBpbnRlcm5hbCAqL1xuICAgIE1kR3JpZExpc3QucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jaGVja0NvbHMoKTtcbiAgICAgICAgdGhpcy5fY2hlY2tSb3dIZWlnaHQoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSBsYXlvdXQgY2FsY3VsYXRpb24gaXMgZmFpcmx5IGNoZWFwIGlmIG5vdGhpbmcgY2hhbmdlcywgc28gdGhlcmUncyBsaXR0bGUgY29zdFxuICAgICAqIHRvIHJ1biBpdCBmcmVxdWVudGx5LlxuICAgICAqIFRPRE86IGludGVybmFsXG4gICAgICovXG4gICAgTWRHcmlkTGlzdC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sYXlvdXRUaWxlcygpO1xuICAgIH07XG4gICAgLyoqIFRocm93IGEgZnJpZW5kbHkgZXJyb3IgaWYgY29scyBwcm9wZXJ0eSBpcyBtaXNzaW5nICovXG4gICAgTWRHcmlkTGlzdC5wcm90b3R5cGUuX2NoZWNrQ29scyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZEdyaWRMaXN0Q29sc0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBEZWZhdWx0IHRvIGVxdWFsIHdpZHRoOmhlaWdodCBpZiByb3dIZWlnaHQgcHJvcGVydHkgaXMgbWlzc2luZyAqL1xuICAgIE1kR3JpZExpc3QucHJvdG90eXBlLl9jaGVja1Jvd0hlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb3dIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVTdHlsZXIgPSBuZXcgUmF0aW9UaWxlU3R5bGVyKCcxOjEnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIENyZWF0ZXMgY29ycmVjdCBUaWxlIFN0eWxlciBzdWJ0eXBlIGJhc2VkIG9uIHJvd0hlaWdodCBwYXNzZWQgaW4gYnkgdXNlciAqL1xuICAgIE1kR3JpZExpc3QucHJvdG90eXBlLl9zZXRUaWxlU3R5bGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcm93SGVpZ2h0ID09PSBNRF9GSVRfTU9ERSkge1xuICAgICAgICAgICAgdGhpcy5fdGlsZVN0eWxlciA9IG5ldyBGaXRUaWxlU3R5bGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fcm93SGVpZ2h0ICYmIHRoaXMuX3Jvd0hlaWdodC5tYXRjaCgvOi9nKSkge1xuICAgICAgICAgICAgdGhpcy5fdGlsZVN0eWxlciA9IG5ldyBSYXRpb1RpbGVTdHlsZXIodGhpcy5fcm93SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVTdHlsZXIgPSBuZXcgRml4ZWRUaWxlU3R5bGVyKHRoaXMuX3Jvd0hlaWdodCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBDb21wdXRlcyBhbmQgYXBwbGllcyB0aGUgc2l6ZSBhbmQgcG9zaXRpb24gZm9yIGFsbCBjaGlsZHJlbiBncmlkIHRpbGVzLiAqL1xuICAgIE1kR3JpZExpc3QucHJvdG90eXBlLl9sYXlvdXRUaWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRpbGVzID0gdGhpcy5fdGlsZXMudG9BcnJheSgpO1xuICAgICAgICB2YXIgdHJhY2tlciA9IG5ldyBUaWxlQ29vcmRpbmF0b3IodGhpcy5jb2xzLCB0aWxlcyk7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLl9kaXIgPyB0aGlzLl9kaXIudmFsdWUgOiAnbHRyJztcbiAgICAgICAgdGhpcy5fdGlsZVN0eWxlci5pbml0KHRoaXMuZ3V0dGVyU2l6ZSwgdHJhY2tlciwgdGhpcy5jb2xzLCBkaXJlY3Rpb24pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gdHJhY2tlci5wb3NpdGlvbnNbaV07XG4gICAgICAgICAgICB2YXIgdGlsZSA9IHRpbGVzW2ldO1xuICAgICAgICAgICAgdGhpcy5fdGlsZVN0eWxlci5zZXRTdHlsZSh0aWxlLCBwb3Mucm93LCBwb3MuY29sKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRMaXN0U3R5bGUodGhpcy5fdGlsZVN0eWxlci5nZXRDb21wdXRlZEhlaWdodCgpKTtcbiAgICB9O1xuICAgIC8qKiBTZXRzIHN0eWxlIG9uIHRoZSBtYWluIGdyaWQtbGlzdCBlbGVtZW50LCBnaXZlbiB0aGUgc3R5bGUgbmFtZSBhbmQgdmFsdWUuICovXG4gICAgTWRHcmlkTGlzdC5wcm90b3R5cGUuX3NldExpc3RTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsIHN0eWxlWzBdLCBzdHlsZVsxXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMjYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZHJlbihNZEdyaWRUaWxlKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjYoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5RdWVyeUxpc3QpXG4gICAgXSwgTWRHcmlkTGlzdC5wcm90b3R5cGUsIFwiX3RpbGVzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQyNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kR3JpZExpc3QucHJvdG90eXBlLCBcImNvbHNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQyNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2d1dHRlclNpemUnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kR3JpZExpc3QucHJvdG90eXBlLCBcImd1dHRlclNpemVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQyNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjYoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjYoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW09iamVjdF0pXG4gICAgXSwgTWRHcmlkTGlzdC5wcm90b3R5cGUsIFwicm93SGVpZ2h0XCIsIG51bGwpO1xuICAgIE1kR3JpZExpc3QgPSBfX2RlY29yYXRlJDI2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtZ3JpZC1saXN0JyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1kLWdyaWQtbGlzdFxcXCI+IDxuZy1jb250ZW50PjwvbmctY29udGVudD4gPC9kaXY+XCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIm1kLWdyaWQtbGlzdCB7IGRpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogcmVsYXRpdmU7IH0gbWQtZ3JpZC10aWxlIHsgZGlzcGxheTogYmxvY2s7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgb3ZlcmZsb3c6IGhpZGRlbjsgfSBtZC1ncmlkLXRpbGUgZmlndXJlIHsgZGlzcGxheTogZmxleDsgcG9zaXRpb246IGFic29sdXRlOyBhbGlnbi1pdGVtczogY2VudGVyOyBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsgaGVpZ2h0OiAxMDAlOyB0b3A6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IGxlZnQ6IDA7IHBhZGRpbmc6IDA7IG1hcmdpbjogMDsgfSBtZC1ncmlkLXRpbGUgbWQtZ3JpZC10aWxlLWhlYWRlciwgbWQtZ3JpZC10aWxlIG1kLWdyaWQtdGlsZS1mb290ZXIgeyBkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyBoZWlnaHQ6IDQ4cHg7IGNvbG9yOiAjZmZmOyBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuMzgpOyBvdmVyZmxvdzogaGlkZGVuOyBwYWRkaW5nOiAwIDE2cHg7IGZvbnQtc2l6ZTogMTZweDsgcG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyByaWdodDogMDsgfSBtZC1ncmlkLXRpbGUgbWQtZ3JpZC10aWxlLWhlYWRlciBbbWQtbGluZV0sIG1kLWdyaWQtdGlsZSBtZC1ncmlkLXRpbGUtZm9vdGVyIFttZC1saW5lXSB7IHdoaXRlLXNwYWNlOiBub3dyYXA7IG92ZXJmbG93LXg6IGhpZGRlbjsgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7IGRpc3BsYXk6IGJsb2NrOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyB9IG1kLWdyaWQtdGlsZSBtZC1ncmlkLXRpbGUtaGVhZGVyIFttZC1saW5lXTpudGgtY2hpbGQobisyKSwgbWQtZ3JpZC10aWxlIG1kLWdyaWQtdGlsZS1mb290ZXIgW21kLWxpbmVdOm50aC1jaGlsZChuKzIpIHsgZm9udC1zaXplOiAxMnB4OyB9IG1kLWdyaWQtdGlsZSBtZC1ncmlkLXRpbGUtaGVhZGVyID4gKiwgbWQtZ3JpZC10aWxlIG1kLWdyaWQtdGlsZS1mb290ZXIgPiAqIHsgbWFyZ2luOiAwOyBwYWRkaW5nOiAwOyBmb250LXdlaWdodDogbm9ybWFsOyBmb250LXNpemU6IGluaGVyaXQ7IH0gbWQtZ3JpZC10aWxlIG1kLWdyaWQtdGlsZS1oZWFkZXIubWQtMi1saW5lLCBtZC1ncmlkLXRpbGUgbWQtZ3JpZC10aWxlLWZvb3Rlci5tZC0yLWxpbmUgeyBoZWlnaHQ6IDY4cHg7IH0gbWQtZ3JpZC10aWxlIC5tZC1ncmlkLWxpc3QtdGV4dCB7IGRpc3BsYXk6IGZsZXg7IGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IHdpZHRoOiAxMDAlOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyBvdmVyZmxvdzogaGlkZGVuOyB9IG1kLWdyaWQtdGlsZSAubWQtZ3JpZC1saXN0LXRleHQgPiAqIHsgbWFyZ2luOiAwOyBwYWRkaW5nOiAwOyBmb250LXdlaWdodDogbm9ybWFsOyBmb250LXNpemU6IGluaGVyaXQ7IH0gbWQtZ3JpZC10aWxlIC5tZC1ncmlkLWxpc3QtdGV4dDplbXB0eSB7IGRpc3BsYXk6IG5vbmU7IH0gbWQtZ3JpZC10aWxlIG1kLWdyaWQtdGlsZS1oZWFkZXIgeyB0b3A6IDA7IH0gbWQtZ3JpZC10aWxlIG1kLWdyaWQtdGlsZS1mb290ZXIgeyBib3R0b206IDA7IH0gbWQtZ3JpZC10aWxlIFttZC1ncmlkLWF2YXRhcl0geyBwYWRkaW5nLXJpZ2h0OiAxNnB4OyB9IFtkaXI9J3J0bCddIG1kLWdyaWQtdGlsZSBbbWQtZ3JpZC1hdmF0YXJdIHsgcGFkZGluZy1yaWdodDogMDsgcGFkZGluZy1sZWZ0OiAxNnB4OyB9IG1kLWdyaWQtdGlsZSBbbWQtZ3JpZC1hdmF0YXJdOmVtcHR5IHsgZGlzcGxheTogbm9uZTsgfSAvKiMgc291cmNlTWFwcGluZ1VSTD1ncmlkLWxpc3QuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgIH0pLFxuICAgICAgICBfX3BhcmFtJDQoMiwgX2FuZ3VsYXJfY29yZS5PcHRpb25hbCgpKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjYoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgRGlyXSlcbiAgICBdLCBNZEdyaWRMaXN0KTtcbiAgICByZXR1cm4gTWRHcmlkTGlzdDtcbn0oKSk7XG52YXIgTWRHcmlkTGlzdE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRHcmlkTGlzdE1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWRHcmlkTGlzdE1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kR3JpZExpc3RNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZEdyaWRMaXN0TW9kdWxlID0gX19kZWNvcmF0ZSQyNihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW01kTGluZU1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRHcmlkTGlzdCwgTWRHcmlkVGlsZSwgTWRHcmlkVGlsZVRleHQsIE1kTGluZU1vZHVsZV0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZEdyaWRMaXN0LCBNZEdyaWRUaWxlLCBNZEdyaWRUaWxlVGV4dF0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQyNignZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZEdyaWRMaXN0TW9kdWxlKTtcbiAgICByZXR1cm4gTWRHcmlkTGlzdE1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDI4ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDI4ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIENvbnRlbnQgb2YgYSBjYXJkLCBuZWVkZWQgYXMgaXQncyB1c2VkIGFzIGEgc2VsZWN0b3IgaW4gdGhlIEFQSS5cbiAqL1xudmFyIE1kQ2FyZENvbnRlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZENvbnRlbnQoKSB7XG4gICAgfVxuICAgIE1kQ2FyZENvbnRlbnQgPSBfX2RlY29yYXRlJDI4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1jYXJkLWNvbnRlbnQnXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQyOCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZENhcmRDb250ZW50KTtcbiAgICByZXR1cm4gTWRDYXJkQ29udGVudDtcbn0oKSk7XG4vKipcbiAqIFRpdGxlIG9mIGEgY2FyZCwgbmVlZGVkIGFzIGl0J3MgdXNlZCBhcyBhIHNlbGVjdG9yIGluIHRoZSBBUEkuXG4gKi9cbnZhciBNZENhcmRUaXRsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkVGl0bGUoKSB7XG4gICAgfVxuICAgIE1kQ2FyZFRpdGxlID0gX19kZWNvcmF0ZSQyOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtY2FyZC10aXRsZSdcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDI4KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2FyZFRpdGxlKTtcbiAgICByZXR1cm4gTWRDYXJkVGl0bGU7XG59KCkpO1xuLyoqXG4gKiBTdWItdGl0bGUgb2YgYSBjYXJkLCBuZWVkZWQgYXMgaXQncyB1c2VkIGFzIGEgc2VsZWN0b3IgaW4gdGhlIEFQSS5cbiAqL1xudmFyIE1kQ2FyZFN1YnRpdGxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRTdWJ0aXRsZSgpIHtcbiAgICB9XG4gICAgTWRDYXJkU3VidGl0bGUgPSBfX2RlY29yYXRlJDI4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1jYXJkLXN1YnRpdGxlJ1xuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjgoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRDYXJkU3VidGl0bGUpO1xuICAgIHJldHVybiBNZENhcmRTdWJ0aXRsZTtcbn0oKSk7XG4vKipcbiAqIEFjdGlvbiBzZWN0aW9uIG9mIGEgY2FyZCwgbmVlZGVkIGFzIGl0J3MgdXNlZCBhcyBhIHNlbGVjdG9yIGluIHRoZSBBUEkuXG4gKi9cbnZhciBNZENhcmRBY3Rpb25zID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRBY3Rpb25zKCkge1xuICAgIH1cbiAgICBNZENhcmRBY3Rpb25zID0gX19kZWNvcmF0ZSQyOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWQtY2FyZC1hY3Rpb25zJ1xuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjgoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRDYXJkQWN0aW9ucyk7XG4gICAgcmV0dXJuIE1kQ2FyZEFjdGlvbnM7XG59KCkpO1xuLyoqXG4gKiBGb290ZXIgb2YgYSBjYXJkLCBuZWVkZWQgYXMgaXQncyB1c2VkIGFzIGEgc2VsZWN0b3IgaW4gdGhlIEFQSS5cbiAqL1xudmFyIE1kQ2FyZEZvb3RlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkRm9vdGVyKCkge1xuICAgIH1cbiAgICBNZENhcmRGb290ZXIgPSBfX2RlY29yYXRlJDI4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1jYXJkLWZvb3RlcidcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDI4KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2FyZEZvb3Rlcik7XG4gICAgcmV0dXJuIE1kQ2FyZEZvb3Rlcjtcbn0oKSk7XG4vKlxuXG48bWQtY2FyZD4gaXMgYSBiYXNpYyBjb250ZW50IGNvbnRhaW5lciBjb21wb25lbnQgdGhhdCBhZGRzIHRoZSBzdHlsZXMgb2YgYSBtYXRlcmlhbCBkZXNpZ24gY2FyZC5cblxuV2hpbGUgeW91IGNhbiB1c2UgdGhpcyBjb21wb25lbnQgYWxvbmUsXG5pdCBhbHNvIHByb3ZpZGVzIGEgbnVtYmVyIG9mIHByZXNldCBzdHlsZXMgZm9yIGNvbW1vbiBjYXJkIHNlY3Rpb25zLCBpbmNsdWRpbmc6XG4gLSBtZC1jYXJkLXRpdGxlXG4gLSBtZC1jYXJkLXN1YnRpdGxlXG4gLSBtZC1jYXJkLWNvbnRlbnRcbiAtIG1kLWNhcmQtYWN0aW9uc1xuIC0gbWQtY2FyZC1mb290ZXJcblxuIFlvdSBjYW4gc2VlIHNvbWUgZXhhbXBsZXMgb2YgY2FyZHMgaGVyZTpcbiBodHRwOi8vZW1iZWQucGxua3IuY28vczVPNFljeXZiTGhJQXBTcklodGovXG5cbiBUT0RPKGthcmEpOiB1cGRhdGUgbGluayB0byBkZW1vIHNpdGUgd2hlbiBpdCBleGlzdHNcblxuKi9cbnZhciBNZENhcmQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZCgpIHtcbiAgICB9XG4gICAgTWRDYXJkID0gX19kZWNvcmF0ZSQyOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLWNhcmQnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PiBcIixcbiAgICAgICAgICAgIHN0eWxlczogW1wibWQtY2FyZCB7IGJveC1zaGFkb3c6IDBweCAycHggMXB4IC0xcHggcmdiYSgwLCAwLCAwLCAwLjIpLCAwcHggMXB4IDFweCAwcHggcmdiYSgwLCAwLCAwLCAwLjE0KSwgMHB4IDFweCAzcHggMHB4IHJnYmEoMCwgMCwgMCwgMC4xMik7IHRyYW5zaXRpb246IGJveC1zaGFkb3cgMjgwbXMgY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTsgd2lsbC1jaGFuZ2U6IGJveC1zaGFkb3c7IGRpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogcmVsYXRpdmU7IHBhZGRpbmc6IDI0cHg7IGJvcmRlci1yYWRpdXM6IDJweDsgZm9udC1mYW1pbHk6IFJvYm90bywgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgc2Fucy1zZXJpZjsgfSBtZC1jYXJkOmhvdmVyIHsgYm94LXNoYWRvdzogMHB4IDNweCAxcHggLTJweCByZ2JhKDAsIDAsIDAsIDAuMiksIDBweCAycHggMnB4IDBweCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwcHggMXB4IDVweCAwcHggcmdiYSgwLCAwLCAwLCAwLjEyKTsgfSAubWQtY2FyZC1mbGF0IHsgYm94LXNoYWRvdzogbm9uZTsgfSBtZC1jYXJkLXRpdGxlLCBtZC1jYXJkLXN1YnRpdGxlLCBtZC1jYXJkLWNvbnRlbnQsIG1kLWNhcmQtYWN0aW9ucyB7IGRpc3BsYXk6IGJsb2NrOyBtYXJnaW4tYm90dG9tOiAxNnB4OyB9IG1kLWNhcmQtdGl0bGUgeyBmb250LXNpemU6IDI0cHg7IGZvbnQtd2VpZ2h0OiA0MDA7IH0gbWQtY2FyZC1zdWJ0aXRsZSB7IGZvbnQtc2l6ZTogMTRweDsgfSBtZC1jYXJkLWNvbnRlbnQgeyBmb250LXNpemU6IDE0cHg7IH0gbWQtY2FyZC1hY3Rpb25zIHsgbWFyZ2luLWxlZnQ6IC0xNnB4OyBtYXJnaW4tcmlnaHQ6IC0xNnB4OyBwYWRkaW5nOiA4cHggMDsgfSBtZC1jYXJkLWFjdGlvbnNbYWxpZ249J2VuZCddIHsgZGlzcGxheTogZmxleDsganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDsgfSBbbWQtY2FyZC1pbWFnZV0geyB3aWR0aDogY2FsYygxMDAlICsgNDhweCk7IG1hcmdpbjogMCAtMjRweCAxNnB4IC0yNHB4OyB9IFttZC1jYXJkLXhsLWltYWdlXSB7IHdpZHRoOiAyNDBweDsgaGVpZ2h0OiAyNDBweDsgbWFyZ2luOiAtOHB4OyB9IG1kLWNhcmQtZm9vdGVyIHsgcG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgbWluLWhlaWdodDogNXB4OyBib3R0b206IDA7IGxlZnQ6IDA7IH0gbWQtY2FyZC1hY3Rpb25zIFttZC1idXR0b25dLCBtZC1jYXJkLWFjdGlvbnMgW21kLXJhaXNlZC1idXR0b25dIHsgbWFyZ2luOiAwIDRweDsgfSBtZC1jYXJkLWhlYWRlciB7IGRpc3BsYXk6IGZsZXg7IGZsZXgtZGlyZWN0aW9uOiByb3c7IGhlaWdodDogNDBweDsgbWFyZ2luOiAtOHB4IDAgMTZweCAwOyB9IC5tZC1jYXJkLWhlYWRlci10ZXh0IHsgaGVpZ2h0OiA0MHB4OyBtYXJnaW46IDAgOHB4OyB9IFttZC1jYXJkLWF2YXRhcl0geyBoZWlnaHQ6IDQwcHg7IHdpZHRoOiA0MHB4OyBib3JkZXItcmFkaXVzOiA1MCU7IH0gbWQtY2FyZC1oZWFkZXIgbWQtY2FyZC10aXRsZSB7IGZvbnQtc2l6ZTogMTRweDsgfSBbbWQtY2FyZC1zbS1pbWFnZV0sIFttZC1jYXJkLW1kLWltYWdlXSwgW21kLWNhcmQtbGctaW1hZ2VdIHsgbWFyZ2luOiAtOHB4IDA7IH0gbWQtY2FyZC10aXRsZS1ncm91cCB7IGRpc3BsYXk6IGZsZXg7IGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjsgbWFyZ2luOiAwIC04cHg7IH0gW21kLWNhcmQtc20taW1hZ2VdIHsgd2lkdGg6IDgwcHg7IGhlaWdodDogODBweDsgfSBbbWQtY2FyZC1tZC1pbWFnZV0geyB3aWR0aDogMTEycHg7IGhlaWdodDogMTEycHg7IH0gW21kLWNhcmQtbGctaW1hZ2VdIHsgd2lkdGg6IDE1MnB4OyBoZWlnaHQ6IDE1MnB4OyB9IEBtZWRpYSAobWF4LXdpZHRoOiA2MDBweCkgeyBtZC1jYXJkIHsgcGFkZGluZzogMjRweCAxNnB4OyB9IFttZC1jYXJkLWltYWdlXSB7IHdpZHRoOiBjYWxjKDEwMCUgKyAzMnB4KTsgbWFyZ2luOiAxNnB4IC0xNnB4OyB9IG1kLWNhcmQtdGl0bGUtZ3JvdXAgeyBtYXJnaW46IDA7IH0gW21kLWNhcmQteGwtaW1hZ2VdIHsgbWFyZ2luLWxlZnQ6IDA7IG1hcmdpbi1yaWdodDogMDsgfSBtZC1jYXJkLWhlYWRlciB7IG1hcmdpbjogLThweCAwIDAgMDsgfSB9IG1kLWNhcmQgPiA6Zmlyc3QtY2hpbGQsIG1kLWNhcmQtY29udGVudCA+IDpmaXJzdC1jaGlsZCB7IG1hcmdpbi10b3A6IDA7IH0gbWQtY2FyZCA+IDpsYXN0LWNoaWxkLCBtZC1jYXJkLWNvbnRlbnQgPiA6bGFzdC1jaGlsZCB7IG1hcmdpbi1ib3R0b206IDA7IH0gW21kLWNhcmQtaW1hZ2VdOmZpcnN0LWNoaWxkIHsgbWFyZ2luLXRvcDogLTI0cHg7IH0gbWQtY2FyZCA+IG1kLWNhcmQtYWN0aW9uczpsYXN0LWNoaWxkIHsgbWFyZ2luLWJvdHRvbTogLTE2cHg7IHBhZGRpbmctYm90dG9tOiAwOyB9IG1kLWNhcmQtYWN0aW9ucyBbbWQtYnV0dG9uXTpmaXJzdC1jaGlsZCwgbWQtY2FyZC1hY3Rpb25zIFttZC1yYWlzZWQtYnV0dG9uXTpmaXJzdC1jaGlsZCB7IG1hcmdpbi1sZWZ0OiAwOyBtYXJnaW4tcmlnaHQ6IDA7IH0gbWQtY2FyZC10aXRsZTpub3QoOmZpcnN0LWNoaWxkKSwgbWQtY2FyZC1zdWJ0aXRsZTpub3QoOmZpcnN0LWNoaWxkKSB7IG1hcmdpbi10b3A6IC00cHg7IH0gbWQtY2FyZC1oZWFkZXIgbWQtY2FyZC1zdWJ0aXRsZTpub3QoOmZpcnN0LWNoaWxkKSB7IG1hcmdpbi10b3A6IC04cHg7IH0gbWQtY2FyZCA+IFttZC1jYXJkLXhsLWltYWdlXTpmaXJzdC1jaGlsZCB7IG1hcmdpbi10b3A6IC04cHg7IH0gbWQtY2FyZCA+IFttZC1jYXJkLXhsLWltYWdlXTpsYXN0LWNoaWxkIHsgbWFyZ2luLWJvdHRvbTogLThweDsgfSAvKiMgc291cmNlTWFwcGluZ1VSTD1jYXJkLmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDI4KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2FyZCk7XG4gICAgcmV0dXJuIE1kQ2FyZDtcbn0oKSk7XG4vKiAgVGhlIGZvbGxvd2luZyBjb21wb25lbnRzIGRvbid0IGhhdmUgYW55IGJlaGF2aW9yLlxuIFRoZXkgc2ltcGx5IHVzZSBjb250ZW50IHByb2plY3Rpb24gdG8gd3JhcCB1c2VyIGNvbnRlbnRcbiBmb3IgZmxleCBsYXlvdXQgcHVycG9zZXMgaW4gPG1kLWNhcmQ+IChhbmQgdGh1cyBhbGxvdyBhIGNsZWFuZXIsIGJvaWxlcnBsYXRlLWZyZWUgQVBJKS5cblxuXG48bWQtY2FyZC1oZWFkZXI+IGlzIGEgY29tcG9uZW50IGludGVuZGVkIHRvIGJlIHVzZWQgd2l0aGluIHRoZSA8bWQtY2FyZD4gY29tcG9uZW50LlxuSXQgYWRkcyBzdHlsZXMgZm9yIGEgcHJlc2V0IGhlYWRlciBzZWN0aW9uIChpLmUuIGEgdGl0bGUsIHN1YnRpdGxlLCBhbmQgYXZhdGFyIGxheW91dCkuXG5cbllvdSBjYW4gc2VlIGFuIGV4YW1wbGUgb2YgYSBjYXJkIHdpdGggYSBoZWFkZXIgaGVyZTpcbmh0dHA6Ly9lbWJlZC5wbG5rci5jby90dkpsMTl6M2daVFFkNldtd2tJYS9cblxuVE9ETyhrYXJhKTogdXBkYXRlIGxpbmsgdG8gZGVtbyBzaXRlIHdoZW4gaXQgZXhpc3RzXG4qL1xudmFyIE1kQ2FyZEhlYWRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRDYXJkSGVhZGVyKCkge1xuICAgIH1cbiAgICBNZENhcmRIZWFkZXIgPSBfX2RlY29yYXRlJDI4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtY2FyZC1oZWFkZXInLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJbbWQtY2FyZC1hdmF0YXJdXFxcIj48L25nLWNvbnRlbnQ+IDxkaXYgY2xhc3M9XFxcIm1kLWNhcmQtaGVhZGVyLXRleHRcXFwiPiA8bmctY29udGVudCBzZWxlY3Q9XFxcIm1kLWNhcmQtdGl0bGUsIG1kLWNhcmQtc3VidGl0bGVcXFwiPjwvbmctY29udGVudD4gPC9kaXY+IDxuZy1jb250ZW50PjwvbmctY29udGVudD4gXCIsXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjgoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRDYXJkSGVhZGVyKTtcbiAgICByZXR1cm4gTWRDYXJkSGVhZGVyO1xufSgpKTtcbi8qXG5cbjxtZC1jYXJkLXRpdGxlLWdyb3VwPiBpcyBhIGNvbXBvbmVudCBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGhpbiB0aGUgPG1kLWNhcmQ+IGNvbXBvbmVudC5cbkl0IGFkZHMgc3R5bGVzIGZvciBhIHByZXNldCBsYXlvdXQgdGhhdCBncm91cHMgYW4gaW1hZ2Ugd2l0aCBhIHRpdGxlIHNlY3Rpb24uXG5cbllvdSBjYW4gc2VlIGFuIGV4YW1wbGUgb2YgYSBjYXJkIHdpdGggYSB0aXRsZS1ncm91cCBzZWN0aW9uIGhlcmU6XG5odHRwOi8vZW1iZWQucGxua3IuY28vRURmZ0NGOWVLY1hqaW5pMVdPRG0vXG5cblRPRE8oa2FyYSk6IHVwZGF0ZSBsaW5rIHRvIGRlbW8gc2l0ZSB3aGVuIGl0IGV4aXN0c1xuKi9cbnZhciBNZENhcmRUaXRsZUdyb3VwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZENhcmRUaXRsZUdyb3VwKCkge1xuICAgIH1cbiAgICBNZENhcmRUaXRsZUdyb3VwID0gX19kZWNvcmF0ZSQyOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLWNhcmQtdGl0bGUtZ3JvdXAnLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPGRpdj4gPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJtZC1jYXJkLXRpdGxlLCBtZC1jYXJkLXN1YnRpdGxlXFxcIj48L25nLWNvbnRlbnQ+IDwvZGl2PiA8bmctY29udGVudCBzZWxlY3Q9XFxcImltZ1xcXCI+PC9uZy1jb250ZW50PiA8bmctY29udGVudD48L25nLWNvbnRlbnQ+IFwiLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDI4KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kQ2FyZFRpdGxlR3JvdXApO1xuICAgIHJldHVybiBNZENhcmRUaXRsZUdyb3VwO1xufSgpKTtcbnZhciBNZENhcmRNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kQ2FyZE1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWRDYXJkTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRDYXJkTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRDYXJkTW9kdWxlID0gX19kZWNvcmF0ZSQyOChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgIE1kQ2FyZCwgTWRDYXJkSGVhZGVyLCBNZENhcmRUaXRsZUdyb3VwLCBNZENhcmRDb250ZW50LCBNZENhcmRUaXRsZSwgTWRDYXJkU3VidGl0bGUsXG4gICAgICAgICAgICAgICAgTWRDYXJkQWN0aW9ucywgTWRDYXJkRm9vdGVyXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgTWRDYXJkLCBNZENhcmRIZWFkZXIsIE1kQ2FyZFRpdGxlR3JvdXAsIE1kQ2FyZENvbnRlbnQsIE1kQ2FyZFRpdGxlLCBNZENhcmRTdWJ0aXRsZSxcbiAgICAgICAgICAgICAgICBNZENhcmRBY3Rpb25zLCBNZENhcmRGb290ZXJcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQyOCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZENhcmRNb2R1bGUpO1xuICAgIHJldHVybiBNZENhcmRNb2R1bGU7XG59KCkpO1xuXG52YXIgX19leHRlbmRzJDExID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBfX2RlY29yYXRlJDMwID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDMwID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKiogRXhjZXB0aW9uIHRocm93biB3aGVuIGF0dGVtcHRpbmcgdG8gbG9hZCBhbiBpY29uIHdpdGggYSBuYW1lIHRoYXQgY2Fubm90IGJlIGZvdW5kLiAqL1xudmFyIE1kSWNvbk5hbWVOb3RGb3VuZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTEoTWRJY29uTmFtZU5vdEZvdW5kRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRJY29uTmFtZU5vdEZvdW5kRXJyb3IoaWNvbk5hbWUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgXCJVbmFibGUgdG8gZmluZCBpY29uIHdpdGggdGhlIG5hbWUgXFxcIlwiICsgaWNvbk5hbWUgKyBcIlxcXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBNZEljb25OYW1lTm90Rm91bmRFcnJvcjtcbn0oTWRFcnJvcikpO1xuLyoqXG4gKiBFeGNlcHRpb24gdGhyb3duIHdoZW4gYXR0ZW1wdGluZyB0byBsb2FkIFNWRyBjb250ZW50IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgZXhwZWN0ZWRcbiAqIDxzdmc+IHRhZy5cbiAqL1xudmFyIE1kSWNvblN2Z1RhZ05vdEZvdW5kRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxMShNZEljb25TdmdUYWdOb3RGb3VuZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kSWNvblN2Z1RhZ05vdEZvdW5kRXJyb3IoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICc8c3ZnPiB0YWcgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiBNZEljb25TdmdUYWdOb3RGb3VuZEVycm9yO1xufShNZEVycm9yKSk7XG4vKiogQ29uZmlndXJhdGlvbiBmb3IgYW4gaWNvbiwgaW5jbHVkaW5nIHRoZSBVUkwgYW5kIHBvc3NpYmx5IHRoZSBjYWNoZWQgU1ZHIGVsZW1lbnQuICovXG52YXIgU3ZnSWNvbkNvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3ZnSWNvbkNvbmZpZyh1cmwpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBTdmdJY29uQ29uZmlnO1xufSgpKTtcbi8qKiBSZXR1cm5zIHRoZSBjYWNoZSBrZXkgdG8gdXNlIGZvciBhbiBpY29uIG5hbWVzcGFjZSBhbmQgbmFtZS4gKi9cbnZhciBpY29uS2V5ID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbmFtZSkgeyByZXR1cm4gbmFtZXNwYWNlICsgJzonICsgbmFtZTsgfTtcbi8qKlxuICogU2VydmljZSB0byByZWdpc3RlciBhbmQgZGlzcGxheSBpY29ucyB1c2VkIGJ5IHRoZSA8bWQtaWNvbj4gY29tcG9uZW50LlxuICogLSBSZWdpc3RlcnMgaWNvbiBVUkxzIGJ5IG5hbWVzcGFjZSBhbmQgbmFtZS5cbiAqIC0gUmVnaXN0ZXJzIGljb24gc2V0IFVSTHMgYnkgbmFtZXNwYWNlLlxuICogLSBSZWdpc3RlcnMgYWxpYXNlcyBmb3IgQ1NTIGNsYXNzZXMsIGZvciB1c2Ugd2l0aCBpY29uIGZvbnRzLlxuICogLSBMb2FkcyBpY29ucyBmcm9tIFVSTHMgYW5kIGV4dHJhY3RzIGluZGl2aWR1YWwgaWNvbnMgZnJvbSBpY29uIHNldHMuXG4gKi9cbnZhciBNZEljb25SZWdpc3RyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRJY29uUmVnaXN0cnkoX2h0dHApIHtcbiAgICAgICAgdGhpcy5faHR0cCA9IF9odHRwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVVJMcyBhbmQgY2FjaGVkIFNWRyBlbGVtZW50cyBmb3IgaW5kaXZpZHVhbCBpY29ucy4gS2V5cyBhcmUgb2YgdGhlIGZvcm1hdCBcIltuYW1lc3BhY2VdOltpY29uXVwiLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3ZnSWNvbkNvbmZpZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdmdJY29uQ29uZmlnIG9iamVjdHMgYW5kIGNhY2hlZCBTVkcgZWxlbWVudHMgZm9yIGljb24gc2V0cywga2V5ZWQgYnkgbmFtZXNwYWNlLlxuICAgICAgICAgKiBNdWx0aXBsZSBpY29uIHNldHMgY2FuIGJlIHJlZ2lzdGVyZWQgdW5kZXIgdGhlIHNhbWUgbmFtZXNwYWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faWNvblNldENvbmZpZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKiBDYWNoZSBmb3IgaWNvbnMgbG9hZGVkIGJ5IGRpcmVjdCBVUkxzLiAqL1xuICAgICAgICB0aGlzLl9jYWNoZWRJY29uc0J5VXJsID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiogSW4tcHJvZ3Jlc3MgaWNvbiBmZXRjaGVzLiBVc2VkIHRvIGNvYWxlc2NlIG11bHRpcGxlIHJlcXVlc3RzIHRvIHRoZSBzYW1lIFVSTC4gKi9cbiAgICAgICAgdGhpcy5faW5Qcm9ncmVzc1VybEZldGNoZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKiBNYXAgZnJvbSBmb250IGlkZW50aWZpZXJzIHRvIHRoZWlyIENTUyBjbGFzcyBuYW1lcy4gVXNlZCBmb3IgaWNvbiBmb250cy4gKi9cbiAgICAgICAgdGhpcy5fZm9udENzc0NsYXNzZXNCeUFsaWFzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIENTUyBjbGFzcyB0byBhcHBseSB3aGVuIGFuIDxtZC1pY29uPiBjb21wb25lbnQgaGFzIG5vIGljb24gbmFtZSwgdXJsLCBvciBmb250IHNwZWNpZmllZC5cbiAgICAgICAgICogVGhlIGRlZmF1bHQgJ21hdGVyaWFsLWljb25zJyB2YWx1ZSBhc3N1bWVzIHRoYXQgdGhlIG1hdGVyaWFsIGljb24gZm9udCBoYXMgYmVlbiBsb2FkZWQgYXNcbiAgICAgICAgICogZGVzY3JpYmVkIGF0IGh0dHA6Ly9nb29nbGUuZ2l0aHViLmlvL21hdGVyaWFsLWRlc2lnbi1pY29ucy8jaWNvbi1mb250LWZvci10aGUtd2ViXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kZWZhdWx0Rm9udFNldENsYXNzID0gJ21hdGVyaWFsLWljb25zJztcbiAgICB9XG4gICAgLyoqIFJlZ2lzdGVycyBhbiBpY29uIGJ5IFVSTCBpbiB0aGUgZGVmYXVsdCBuYW1lc3BhY2UuICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLmFkZFN2Z0ljb24gPSBmdW5jdGlvbiAoaWNvbk5hbWUsIHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRTdmdJY29uSW5OYW1lc3BhY2UoJycsIGljb25OYW1lLCB1cmwpO1xuICAgIH07XG4gICAgLyoqIFJlZ2lzdGVycyBhbiBpY29uIGJ5IFVSTCBpbiB0aGUgc3BlY2lmaWVkIG5hbWVzcGFjZS4gKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuYWRkU3ZnSWNvbkluTmFtZXNwYWNlID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgaWNvbk5hbWUsIHVybCkge1xuICAgICAgICB2YXIga2V5ID0gaWNvbktleShuYW1lc3BhY2UsIGljb25OYW1lKTtcbiAgICAgICAgdGhpcy5fc3ZnSWNvbkNvbmZpZ3Muc2V0KGtleSwgbmV3IFN2Z0ljb25Db25maWcodXJsKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIFJlZ2lzdGVycyBhbiBpY29uIHNldCBieSBVUkwgaW4gdGhlIGRlZmF1bHQgbmFtZXNwYWNlLiAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5hZGRTdmdJY29uU2V0ID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRTdmdJY29uU2V0SW5OYW1lc3BhY2UoJycsIHVybCk7XG4gICAgfTtcbiAgICAvKiogUmVnaXN0ZXJzIGFuIGljb24gc2V0IGJ5IFVSTCBpbiB0aGUgc3BlY2lmaWVkIG5hbWVzcGFjZS4gKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuYWRkU3ZnSWNvblNldEluTmFtZXNwYWNlID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgdXJsKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBuZXcgU3ZnSWNvbkNvbmZpZyh1cmwpO1xuICAgICAgICBpZiAodGhpcy5faWNvblNldENvbmZpZ3MuaGFzKG5hbWVzcGFjZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ljb25TZXRDb25maWdzLmdldChuYW1lc3BhY2UpLnB1c2goY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ljb25TZXRDb25maWdzLnNldChuYW1lc3BhY2UsIFtjb25maWddKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgYW4gYWxpYXMgZm9yIGEgQ1NTIGNsYXNzIG5hbWUgdG8gYmUgdXNlZCBmb3IgaWNvbiBmb250cy4gQ3JlYXRpbmcgYW4gbWRJY29uXG4gICAgICogY29tcG9uZW50IHdpdGggdGhlIGFsaWFzIGFzIHRoZSBmb250U2V0IGlucHV0IHdpbGwgY2F1c2UgdGhlIGNsYXNzIG5hbWUgdG8gYmUgYXBwbGllZFxuICAgICAqIHRvIHRoZSA8bWQtaWNvbj4gZWxlbWVudC5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUucmVnaXN0ZXJGb250Q2xhc3NBbGlhcyA9IGZ1bmN0aW9uIChhbGlhcywgY2xhc3NOYW1lKSB7XG4gICAgICAgIGlmIChjbGFzc05hbWUgPT09IHZvaWQgMCkgeyBjbGFzc05hbWUgPSBhbGlhczsgfVxuICAgICAgICB0aGlzLl9mb250Q3NzQ2xhc3Nlc0J5QWxpYXMuc2V0KGFsaWFzLCBjbGFzc05hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIENTUyBjbGFzcyBuYW1lIGFzc29jaWF0ZWQgd2l0aCB0aGUgYWxpYXMgYnkgYSBwcmV2aW91cyBjYWxsIHRvXG4gICAgICogcmVnaXN0ZXJGb250Q2xhc3NBbGlhcy4gSWYgbm8gQ1NTIGNsYXNzIGhhcyBiZWVuIGFzc29jaWF0ZWQsIHJldHVybnMgdGhlIGFsaWFzIHVubW9kaWZpZWQuXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLmNsYXNzTmFtZUZvckZvbnRBbGlhcyA9IGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9udENzc0NsYXNzZXNCeUFsaWFzLmdldChhbGlhcykgfHwgYWxpYXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBDU1MgY2xhc3MgbmFtZSB0byBiZSB1c2VkIGZvciBpY29uIGZvbnRzIHdoZW4gYW4gPG1kLWljb24+IGNvbXBvbmVudCBkb2VzIG5vdFxuICAgICAqIGhhdmUgYSBmb250U2V0IGlucHV0IHZhbHVlLCBhbmQgaXMgbm90IGxvYWRpbmcgYW4gaWNvbiBieSBuYW1lIG9yIFVSTC5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuc2V0RGVmYXVsdEZvbnRTZXRDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEZvbnRTZXRDbGFzcyA9IGNsYXNzTmFtZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBDU1MgY2xhc3MgbmFtZSB0byBiZSB1c2VkIGZvciBpY29uIGZvbnRzIHdoZW4gYW4gPG1kLWljb24+IGNvbXBvbmVudCBkb2VzIG5vdFxuICAgICAqIGhhdmUgYSBmb250U2V0IGlucHV0IHZhbHVlLCBhbmQgaXMgbm90IGxvYWRpbmcgYW4gaWNvbiBieSBuYW1lIG9yIFVSTC5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuZ2V0RGVmYXVsdEZvbnRTZXRDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRGb250U2V0Q2xhc3M7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBwcm9kdWNlcyB0aGUgaWNvbiAoYXMgYW4gPHN2Zz4gRE9NIGVsZW1lbnQpIGZyb20gdGhlIGdpdmVuIFVSTC5cbiAgICAgKiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgVVJMIG1heSBiZSBjYWNoZWQgc28gdGhpcyB3aWxsIG5vdCBhbHdheXMgY2F1c2UgYW4gSFRUUCByZXF1ZXN0LCBidXRcbiAgICAgKiB0aGUgcHJvZHVjZWQgZWxlbWVudCB3aWxsIGFsd2F5cyBiZSBhIG5ldyBjb3B5IG9mIHRoZSBvcmlnaW5hbGx5IGZldGNoZWQgaWNvbi4gKFRoYXQgaXMsXG4gICAgICogaXQgd2lsbCBub3QgY29udGFpbiBhbnkgbW9kaWZpY2F0aW9ucyBtYWRlIHRvIGVsZW1lbnRzIHByZXZpb3VzbHkgcmV0dXJuZWQpLlxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5nZXRTdmdJY29uRnJvbVVybCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZEljb25zQnlVcmwuaGFzKHVybCkpIHtcbiAgICAgICAgICAgIHJldHVybiByeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZS5vZihjbG9uZVN2Zyh0aGlzLl9jYWNoZWRJY29uc0J5VXJsLmdldCh1cmwpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRTdmdJY29uRnJvbUNvbmZpZyhuZXcgU3ZnSWNvbkNvbmZpZyh1cmwpKVxuICAgICAgICAgICAgLmRvKGZ1bmN0aW9uIChzdmcpIHsgcmV0dXJuIF90aGlzLl9jYWNoZWRJY29uc0J5VXJsLnNldCh1cmwsIHN2Zyk7IH0pXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzdmcpIHsgcmV0dXJuIGNsb25lU3ZnKHN2Zyk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgcHJvZHVjZXMgdGhlIGljb24gKGFzIGFuIDxzdmc+IERPTSBlbGVtZW50KSB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAgICogYW5kIG5hbWVzcGFjZS4gVGhlIGljb24gbXVzdCBoYXZlIGJlZW4gcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYWRkSWNvbiBvciBhZGRJY29uU2V0O1xuICAgICAqIGlmIG5vdCwgdGhlIE9ic2VydmFibGUgd2lsbCB0aHJvdyBhbiBNZEljb25OYW1lTm90Rm91bmRFcnJvci5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuZ2V0TmFtZWRTdmdJY29uID0gZnVuY3Rpb24gKG5hbWUsIG5hbWVzcGFjZSkge1xuICAgICAgICBpZiAobmFtZXNwYWNlID09PSB2b2lkIDApIHsgbmFtZXNwYWNlID0gJyc7IH1cbiAgICAgICAgLy8gUmV0dXJuIChjb3B5IG9mKSBjYWNoZWQgaWNvbiBpZiBwb3NzaWJsZS5cbiAgICAgICAgdmFyIGtleSA9IGljb25LZXkobmFtZXNwYWNlLCBuYW1lKTtcbiAgICAgICAgaWYgKHRoaXMuX3N2Z0ljb25Db25maWdzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3ZnRnJvbUNvbmZpZyh0aGlzLl9zdmdJY29uQ29uZmlncy5nZXQoa2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlIGlmIHdlIGhhdmUgYW55IGljb24gc2V0cyByZWdpc3RlcmVkIGZvciB0aGUgbmFtZXNwYWNlLlxuICAgICAgICB2YXIgaWNvblNldENvbmZpZ3MgPSB0aGlzLl9pY29uU2V0Q29uZmlncy5nZXQobmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKGljb25TZXRDb25maWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3ZnRnJvbUljb25TZXRDb25maWdzKG5hbWUsIGljb25TZXRDb25maWdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUudGhyb3cobmV3IE1kSWNvbk5hbWVOb3RGb3VuZEVycm9yKGtleSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2FjaGVkIGljb24gZm9yIGEgU3ZnSWNvbkNvbmZpZyBpZiBhdmFpbGFibGUsIG9yIGZldGNoZXMgaXQgZnJvbSBpdHMgVVJMIGlmIG5vdC5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuX2dldFN2Z0Zyb21Db25maWcgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuc3ZnRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIHRoZSBTVkcgZWxlbWVudCBmb3IgdGhpcyBpY29uLCByZXR1cm4gYSBjb3B5LlxuICAgICAgICAgICAgcmV0dXJuIHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlLm9mKGNsb25lU3ZnKGNvbmZpZy5zdmdFbGVtZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgaWNvbiBmcm9tIHRoZSBjb25maWcncyBVUkwsIGNhY2hlIGl0LCBhbmQgcmV0dXJuIGEgY29weS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2FkU3ZnSWNvbkZyb21Db25maWcoY29uZmlnKVxuICAgICAgICAgICAgICAgIC5kbyhmdW5jdGlvbiAoc3ZnKSB7IHJldHVybiBjb25maWcuc3ZnRWxlbWVudCA9IHN2ZzsgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzdmcpIHsgcmV0dXJuIGNsb25lU3ZnKHN2Zyk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBmaW5kIGFuIGljb24gd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUgaW4gYW55IG9mIHRoZSBTVkcgaWNvbiBzZXRzLlxuICAgICAqIEZpcnN0IHNlYXJjaGVzIHRoZSBhdmFpbGFibGUgY2FjaGVkIGljb25zIGZvciBhIG5lc3RlZCBlbGVtZW50IHdpdGggYSBtYXRjaGluZyBuYW1lLCBhbmRcbiAgICAgKiBpZiBmb3VuZCBjb3BpZXMgdGhlIGVsZW1lbnQgdG8gYSBuZXcgPHN2Zz4gZWxlbWVudC4gSWYgbm90IGZvdW5kLCBmZXRjaGVzIGFsbCBpY29uIHNldHNcbiAgICAgKiB0aGF0IGhhdmUgbm90IGJlZW4gY2FjaGVkLCBhbmQgc2VhcmNoZXMgYWdhaW4gYWZ0ZXIgYWxsIGZldGNoZXMgYXJlIGNvbXBsZXRlZC5cbiAgICAgKiBUaGUgcmV0dXJuZWQgT2JzZXJ2YWJsZSBwcm9kdWNlcyB0aGUgU1ZHIGVsZW1lbnQgaWYgcG9zc2libGUsIGFuZCB0aHJvd3NcbiAgICAgKiBNZEljb25OYW1lTm90Rm91bmRFcnJvciBpZiBubyBpY29uIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lIGNhbiBiZSBmb3VuZC5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuX2dldFN2Z0Zyb21JY29uU2V0Q29uZmlncyA9IGZ1bmN0aW9uIChuYW1lLCBpY29uU2V0Q29uZmlncykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBGb3IgYWxsIHRoZSBpY29uIHNldCBTVkcgZWxlbWVudHMgd2UndmUgZmV0Y2hlZCwgc2VlIGlmIGFueSBjb250YWluIGFuIGljb24gd2l0aCB0aGVcbiAgICAgICAgLy8gcmVxdWVzdGVkIG5hbWUuXG4gICAgICAgIHZhciBuYW1lZEljb24gPSB0aGlzLl9leHRyYWN0SWNvbldpdGhOYW1lRnJvbUFueVNldChuYW1lLCBpY29uU2V0Q29uZmlncyk7XG4gICAgICAgIGlmIChuYW1lZEljb24pIHtcbiAgICAgICAgICAgIC8vIFdlIGNvdWxkIGNhY2hlIG5hbWVkSWNvbiBpbiBfc3ZnSWNvbkNvbmZpZ3MsIGJ1dCBzaW5jZSB3ZSBoYXZlIHRvIG1ha2UgYSBjb3B5IGV2ZXJ5XG4gICAgICAgICAgICAvLyB0aW1lIGFueXdheSwgdGhlcmUncyBwcm9iYWJseSBub3QgbXVjaCBhZHZhbnRhZ2UgY29tcGFyZWQgdG8ganVzdCBhbHdheXMgZXh0cmFjdGluZ1xuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgaWNvbiBzZXQuXG4gICAgICAgICAgICByZXR1cm4gcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUub2YobmFtZWRJY29uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgZm91bmQgaW4gYW55IGNhY2hlZCBpY29uIHNldHMuIElmIHRoZXJlIGFyZSBpY29uIHNldHMgd2l0aCBVUkxzIHRoYXQgd2UgaGF2ZW4ndFxuICAgICAgICAvLyBmZXRjaGVkLCBmZXRjaCB0aGVtIG5vdyBhbmQgbG9vayBmb3IgaWNvbk5hbWUgaW4gdGhlIHJlc3VsdHMuXG4gICAgICAgIHZhciBpY29uU2V0RmV0Y2hSZXF1ZXN0cyA9IGljb25TZXRDb25maWdzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChpY29uU2V0Q29uZmlnKSB7IHJldHVybiAhaWNvblNldENvbmZpZy5zdmdFbGVtZW50OyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaWNvblNldENvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9sb2FkU3ZnSWNvblNldEZyb21Db25maWcoaWNvblNldENvbmZpZylcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVyciwgY2F1Z2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gU3dhbGxvdyBlcnJvcnMgZmV0Y2hpbmcgaW5kaXZpZHVhbCBVUkxzIHNvIHRoZSBjb21iaW5lZCBPYnNlcnZhYmxlIHdvbid0XG4gICAgICAgICAgICAgICAgLy8gbmVjZXNzYXJpbHkgZmFpbC5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxvYWRpbmcgaWNvbiBzZXQgVVJMOiBcIiArIGljb25TZXRDb25maWcudXJsICsgXCIgZmFpbGVkOiBcIiArIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlLm9mKG51bGwpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZG8oZnVuY3Rpb24gKHN2Zykge1xuICAgICAgICAgICAgICAgIC8vIENhY2hlIFNWRyBlbGVtZW50LlxuICAgICAgICAgICAgICAgIGlmIChzdmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWNvblNldENvbmZpZy5zdmdFbGVtZW50ID0gc3ZnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRmV0Y2ggYWxsIHRoZSBpY29uIHNldCBVUkxzLiBXaGVuIHRoZSByZXF1ZXN0cyBjb21wbGV0ZSwgZXZlcnkgSWNvblNldCBzaG91bGQgaGF2ZSBhXG4gICAgICAgIC8vIGNhY2hlZCBTVkcgZWxlbWVudCAodW5sZXNzIHRoZSByZXF1ZXN0IGZhaWxlZCksIGFuZCB3ZSBjYW4gY2hlY2sgYWdhaW4gZm9yIHRoZSBpY29uLlxuICAgICAgICByZXR1cm4gcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUuZm9ya0pvaW4oaWNvblNldEZldGNoUmVxdWVzdHMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpZ25vcmVkUmVzdWx0cykge1xuICAgICAgICAgICAgdmFyIGZvdW5kSWNvbiA9IF90aGlzLl9leHRyYWN0SWNvbldpdGhOYW1lRnJvbUFueVNldChuYW1lLCBpY29uU2V0Q29uZmlncyk7XG4gICAgICAgICAgICBpZiAoIWZvdW5kSWNvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBNZEljb25OYW1lTm90Rm91bmRFcnJvcihuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmb3VuZEljb247XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhlIGNhY2hlZCBTVkcgZWxlbWVudHMgZm9yIHRoZSBnaXZlbiBpY29uIHNldHMgZm9yIGEgbmVzdGVkIGljb24gZWxlbWVudCB3aG9zZSBcImlkXCJcbiAgICAgKiB0YWcgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIG5hbWUuIElmIGZvdW5kLCBjb3BpZXMgdGhlIG5lc3RlZCBlbGVtZW50IHRvIGEgbmV3IFNWRyBlbGVtZW50IGFuZFxuICAgICAqIHJldHVybnMgaXQuIFJldHVybnMgbnVsbCBpZiBubyBtYXRjaGluZyBlbGVtZW50IGlzIGZvdW5kLlxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5fZXh0cmFjdEljb25XaXRoTmFtZUZyb21BbnlTZXQgPSBmdW5jdGlvbiAoaWNvbk5hbWUsIGljb25TZXRDb25maWdzKSB7XG4gICAgICAgIC8vIEl0ZXJhdGUgYmFja3dhcmRzLCBzbyBpY29uIHNldHMgYWRkZWQgbGF0ZXIgaGF2ZSBwcmVjZWRlbmNlLlxuICAgICAgICBmb3IgKHZhciBpID0gaWNvblNldENvbmZpZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBjb25maWcgPSBpY29uU2V0Q29uZmlnc1tpXTtcbiAgICAgICAgICAgIGlmIChjb25maWcuc3ZnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBmb3VuZEljb24gPSB0aGlzLl9leHRyYWN0U3ZnSWNvbkZyb21TZXQoY29uZmlnLnN2Z0VsZW1lbnQsIGljb25OYW1lLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZEljb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kSWNvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgY29udGVudCBvZiB0aGUgaWNvbiBVUkwgc3BlY2lmaWVkIGluIHRoZSBTdmdJY29uQ29uZmlnIGFuZCBjcmVhdGVzIGFuIFNWRyBlbGVtZW50XG4gICAgICogZnJvbSBpdC5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuX2xvYWRTdmdJY29uRnJvbUNvbmZpZyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoVXJsKGNvbmZpZy51cmwpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzdmdUZXh0KSB7IHJldHVybiBfdGhpcy5fY3JlYXRlU3ZnRWxlbWVudEZvclNpbmdsZUljb24oc3ZnVGV4dCwgY29uZmlnKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgY29udGVudCBvZiB0aGUgaWNvbiBzZXQgVVJMIHNwZWNpZmllZCBpbiB0aGUgU3ZnSWNvbkNvbmZpZyBhbmQgY3JlYXRlcyBhbiBTVkcgZWxlbWVudFxuICAgICAqIGZyb20gaXQuXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9sb2FkU3ZnSWNvblNldEZyb21Db25maWcgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFRPRE86IERvY3VtZW50IHRoYXQgaWNvbnMgc2hvdWxkIG9ubHkgYmUgbG9hZGVkIGZyb20gdHJ1c3RlZCBzb3VyY2VzLlxuICAgICAgICByZXR1cm4gdGhpcy5fZmV0Y2hVcmwoY29uZmlnLnVybClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHN2Z1RleHQpIHsgcmV0dXJuIF90aGlzLl9zdmdFbGVtZW50RnJvbVN0cmluZyhzdmdUZXh0KTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgRE9NIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gU1ZHIHN0cmluZywgYW5kIGFkZHMgZGVmYXVsdCBhdHRyaWJ1dGVzLlxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5fY3JlYXRlU3ZnRWxlbWVudEZvclNpbmdsZUljb24gPSBmdW5jdGlvbiAocmVzcG9uc2VUZXh0LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHN2ZyA9IHRoaXMuX3N2Z0VsZW1lbnRGcm9tU3RyaW5nKHJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHRoaXMuX3NldFN2Z0F0dHJpYnV0ZXMoc3ZnLCBjb25maWcpO1xuICAgICAgICByZXR1cm4gc3ZnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VhcmNoZXMgdGhlIGNhY2hlZCBlbGVtZW50IG9mIHRoZSBnaXZlbiBTdmdJY29uQ29uZmlnIGZvciBhIG5lc3RlZCBpY29uIGVsZW1lbnQgd2hvc2UgXCJpZFwiXG4gICAgICogdGFnIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBuYW1lLiBJZiBmb3VuZCwgY29waWVzIHRoZSBuZXN0ZWQgZWxlbWVudCB0byBhIG5ldyBTVkcgZWxlbWVudCBhbmRcbiAgICAgKiByZXR1cm5zIGl0LiBSZXR1cm5zIG51bGwgaWYgbm8gbWF0Y2hpbmcgZWxlbWVudCBpcyBmb3VuZC5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuX2V4dHJhY3RTdmdJY29uRnJvbVNldCA9IGZ1bmN0aW9uIChpY29uU2V0LCBpY29uTmFtZSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBpY29uTm9kZSA9IGljb25TZXQucXVlcnlTZWxlY3RvcignIycgKyBpY29uTmFtZSk7XG4gICAgICAgIGlmICghaWNvbk5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBpY29uIG5vZGUgaXMgaXRzZWxmIGFuIDxzdmc+IG5vZGUsIGNsb25lIGFuZCByZXR1cm4gaXQgZGlyZWN0bHkuIElmIG5vdCwgc2V0IGl0IGFzXG4gICAgICAgIC8vIHRoZSBjb250ZW50IG9mIGEgbmV3IDxzdmc+IG5vZGUuXG4gICAgICAgIGlmIChpY29uTm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT0gJ3N2ZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRTdmdBdHRyaWJ1dGVzKGljb25Ob2RlLmNsb25lTm9kZSh0cnVlKSwgY29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGVFbGVtZW50KCdTVkcnKSBkb2Vzbid0IHdvcmsgYXMgZXhwZWN0ZWQ7IHRoZSBET00gZW5kcyB1cCB3aXRoXG4gICAgICAgIC8vIHRoZSBjb3JyZWN0IG5vZGVzLCBidXQgdGhlIFNWRyBjb250ZW50IGRvZXNuJ3QgcmVuZGVyLiBJbnN0ZWFkIHdlXG4gICAgICAgIC8vIGhhdmUgdG8gY3JlYXRlIGFuIGVtcHR5IFNWRyBub2RlIHVzaW5nIGlubmVySFRNTCBhbmQgYXBwZW5kIGl0cyBjb250ZW50LlxuICAgICAgICAvLyBFbGVtZW50cyBjcmVhdGVkIHVzaW5nIERPTVBhcnNlci5wYXJzZUZyb21TdHJpbmcgaGF2ZSB0aGUgc2FtZSBwcm9ibGVtLlxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIzMDAzMjc4L3N2Zy1pbm5lcmh0bWwtaW4tZmlyZWZveC1jYW4tbm90LWRpc3BsYXlcbiAgICAgICAgdmFyIHN2ZyA9IHRoaXMuX3N2Z0VsZW1lbnRGcm9tU3RyaW5nKCc8c3ZnPjwvc3ZnPicpO1xuICAgICAgICAvLyBDbG9uZSB0aGUgbm9kZSBzbyB3ZSBkb24ndCByZW1vdmUgaXQgZnJvbSB0aGUgcGFyZW50IGljb24gc2V0IGVsZW1lbnQuXG4gICAgICAgIHN2Zy5hcHBlbmRDaGlsZChpY29uTm9kZS5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0U3ZnQXR0cmlidXRlcyhzdmcsIGNvbmZpZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgRE9NIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gU1ZHIHN0cmluZy5cbiAgICAgKi9cbiAgICBNZEljb25SZWdpc3RyeS5wcm90b3R5cGUuX3N2Z0VsZW1lbnRGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAvLyBUT0RPOiBJcyB0aGVyZSBhIGJldHRlciB3YXkgdGhhbiBpbm5lckhUTUw/IFJlbmRlcmVyIGRvZXNuJ3QgYXBwZWFyIHRvIGhhdmUgYSBtZXRob2QgZm9yXG4gICAgICAgIC8vIGNyZWF0aW5nIGFuIGVsZW1lbnQgZnJvbSBhbiBIVE1MIHN0cmluZy5cbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgICAgICBkaXYuaW5uZXJIVE1MID0gc3RyO1xuICAgICAgICB2YXIgc3ZnID0gZGl2LnF1ZXJ5U2VsZWN0b3IoJ3N2ZycpO1xuICAgICAgICBpZiAoIXN2Zykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1kSWNvblN2Z1RhZ05vdEZvdW5kRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ZnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGVmYXVsdCBhdHRyaWJ1dGVzIGZvciBhbiBTVkcgZWxlbWVudCB0byBiZSB1c2VkIGFzIGFuIGljb24uXG4gICAgICovXG4gICAgTWRJY29uUmVnaXN0cnkucHJvdG90eXBlLl9zZXRTdmdBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHN2ZywgY29uZmlnKSB7XG4gICAgICAgIGlmICghc3ZnLmdldEF0dHJpYnV0ZSgneG1sbnMnKSkge1xuICAgICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKTtcbiAgICAgICAgfVxuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKCdmaXQnLCAnJyk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcxMDAlJyk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzEwMCUnKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsICd4TWlkWU1pZCBtZWV0Jyk7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScsICdmYWxzZScpOyAvLyBEaXNhYmxlIElFMTEgZGVmYXVsdCBiZWhhdmlvciB0byBtYWtlIFNWR3MgZm9jdXNhYmxlLlxuICAgICAgICByZXR1cm4gc3ZnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHdoaWNoIHByb2R1Y2VzIHRoZSBzdHJpbmcgY29udGVudHMgb2YgdGhlIGdpdmVuIFVSTC4gUmVzdWx0cyBtYXkgYmVcbiAgICAgKiBjYWNoZWQsIHNvIGZ1dHVyZSBjYWxscyB3aXRoIHRoZSBzYW1lIFVSTCBtYXkgbm90IGNhdXNlIGFub3RoZXIgSFRUUCByZXF1ZXN0LlxuICAgICAqL1xuICAgIE1kSWNvblJlZ2lzdHJ5LnByb3RvdHlwZS5fZmV0Y2hVcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFN0b3JlIGluLXByb2dyZXNzIGZldGNoZXMgdG8gYXZvaWQgc2VuZGluZyBhIGR1cGxpY2F0ZSByZXF1ZXN0IGZvciBhIFVSTCB3aGVuIHRoZXJlIGlzXG4gICAgICAgIC8vIGFscmVhZHkgYSByZXF1ZXN0IGluIHByb2dyZXNzIGZvciB0aGF0IFVSTC4gSXQncyBuZWNlc3NhcnkgdG8gY2FsbCBzaGFyZSgpIG9uIHRoZVxuICAgICAgICAvLyBPYnNlcnZhYmxlIHJldHVybmVkIGJ5IGh0dHAuZ2V0KCkgc28gdGhhdCBtdWx0aXBsZSBzdWJzY3JpYmVycyBkb24ndCBjYXVzZSBtdWx0aXBsZSBYSFJzLlxuICAgICAgICBpZiAodGhpcy5faW5Qcm9ncmVzc1VybEZldGNoZXMuaGFzKHVybCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pblByb2dyZXNzVXJsRmV0Y2hlcy5nZXQodXJsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPKGplbGJvdXJuKTogZm9yIHNvbWUgcmVhc29uLCB0aGUgYGZpbmFsbHlgIG9wZXJhdG9yIFwibG9zZXNcIiB0aGUgZ2VuZXJpYyB0eXBlIG9uIHRoZVxuICAgICAgICAvLyBPYnNlcnZhYmxlLiBGaWd1cmUgb3V0IHdoeSBhbmQgZml4IGl0LlxuICAgICAgICB2YXIgcmVxID0gdGhpcy5faHR0cC5nZXQodXJsKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTsgfSlcbiAgICAgICAgICAgIC5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9pblByb2dyZXNzVXJsRmV0Y2hlcy5kZWxldGUodXJsKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5zaGFyZSgpO1xuICAgICAgICB0aGlzLl9pblByb2dyZXNzVXJsRmV0Y2hlcy5zZXQodXJsLCByZXEpO1xuICAgICAgICByZXR1cm4gcmVxO1xuICAgIH07XG4gICAgTWRJY29uUmVnaXN0cnkgPSBfX2RlY29yYXRlJDMwKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDMwKCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9odHRwLkh0dHBdKVxuICAgIF0sIE1kSWNvblJlZ2lzdHJ5KTtcbiAgICByZXR1cm4gTWRJY29uUmVnaXN0cnk7XG59KCkpO1xuLyoqIENsb25lcyBhbiBTVkdFbGVtZW50IHdoaWxlIHByZXNlcnZpbmcgdHlwZSBpbmZvcm1hdGlvbi4gKi9cbmZ1bmN0aW9uIGNsb25lU3ZnKHN2Zykge1xuICAgIHJldHVybiBzdmcuY2xvbmVOb2RlKHRydWUpO1xufVxuXG52YXIgX19leHRlbmRzJDEwID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBfX2RlY29yYXRlJDI5ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDI5ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKiogRXhjZXB0aW9uIHRocm93biB3aGVuIGFuIGludmFsaWQgaWNvbiBuYW1lIGlzIHBhc3NlZCB0byBhbiBtZC1pY29uIGNvbXBvbmVudC4gKi9cbnZhciBNZEljb25JbnZhbGlkTmFtZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTAoTWRJY29uSW52YWxpZE5hbWVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZEljb25JbnZhbGlkTmFtZUVycm9yKGljb25OYW1lKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiSW52YWxpZCBpY29uIG5hbWU6IFxcXCJcIiArIGljb25OYW1lICsgXCJcXFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTWRJY29uSW52YWxpZE5hbWVFcnJvcjtcbn0oTWRFcnJvcikpO1xuLyoqXG4gKiBDb21wb25lbnQgdG8gZGlzcGxheSBhbiBpY29uLiBJdCBjYW4gYmUgdXNlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIFNwZWNpZnkgdGhlIHN2Z1NyYyBpbnB1dCB0byBsb2FkIGFuIFNWRyBpY29uIGZyb20gYSBVUkwuIFRoZSBTVkcgY29udGVudCBpcyBkaXJlY3RseSBpbmxpbmVkXG4gKiAgIGFzIGEgY2hpbGQgb2YgdGhlIDxtZC1pY29uPiBjb21wb25lbnQsIHNvIHRoYXQgQ1NTIHN0eWxlcyBjYW4gZWFzaWx5IGJlIGFwcGxpZWQgdG8gaXQuXG4gKiAgIFRoZSBVUkwgaXMgbG9hZGVkIHZpYSBhbiBYTUxIdHRwUmVxdWVzdCwgc28gaXQgbXVzdCBiZSBvbiB0aGUgc2FtZSBkb21haW4gYXMgdGhlIHBhZ2Ugb3IgaXRzXG4gKiAgIHNlcnZlciBtdXN0IGJlIGNvbmZpZ3VyZWQgdG8gYWxsb3cgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLlxuICogICBFeGFtcGxlOlxuICogICAgIDxtZC1pY29uIHN2Z1NyYz1cImFzc2V0cy9hcnJvdy5zdmdcIj48L21kLWljb24+XG4gKlxuICogLSBTcGVjaWZ5IHRoZSBzdmdJY29uIGlucHV0IHRvIGxvYWQgYW4gU1ZHIGljb24gZnJvbSBhIFVSTCBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCB0aGVcbiAqICAgYWRkU3ZnSWNvbiwgYWRkU3ZnSWNvbkluTmFtZXNwYWNlLCBhZGRTdmdJY29uU2V0LCBvciBhZGRTdmdJY29uU2V0SW5OYW1lc3BhY2UgbWV0aG9kcyBvZlxuICogICBNZEljb25SZWdpc3RyeS4gSWYgdGhlIHN2Z0ljb24gdmFsdWUgY29udGFpbnMgYSBjb2xvbiBpdCBpcyBhc3N1bWVkIHRvIGJlIGluIHRoZSBmb3JtYXRcbiAqICAgXCJbbmFtZXNwYWNlXTpbbmFtZV1cIiwgaWYgbm90IHRoZSB2YWx1ZSB3aWxsIGJlIHRoZSBuYW1lIG9mIGFuIGljb24gaW4gdGhlIGRlZmF1bHQgbmFtZXNwYWNlLlxuICogICBFeGFtcGxlczpcbiAqICAgICA8bWQtaWNvbiBzdmdJY29uPVwibGVmdC1hcnJvd1wiPjwvbWQtaWNvbj5cbiAqICAgICA8bWQtaWNvbiBzdmdJY29uPVwiYW5pbWFsczpjYXRcIj48L21kLWljb24+XG4gKlxuICogLSBVc2UgYSBmb250IGxpZ2F0dXJlIGFzIGFuIGljb24gYnkgcHV0dGluZyB0aGUgbGlnYXR1cmUgdGV4dCBpbiB0aGUgY29udGVudCBvZiB0aGUgPG1kLWljb24+XG4gKiAgIGNvbXBvbmVudC4gQnkgZGVmYXVsdCB0aGUgTWF0ZXJpYWwgaWNvbnMgZm9udCBpcyB1c2VkIGFzIGRlc2NyaWJlZCBhdFxuICogICBodHRwOi8vZ29vZ2xlLmdpdGh1Yi5pby9tYXRlcmlhbC1kZXNpZ24taWNvbnMvI2ljb24tZm9udC1mb3ItdGhlLXdlYi4gWW91IGNhbiBzcGVjaWZ5IGFuXG4gKiAgIGFsdGVybmF0ZSBmb250IGJ5IHNldHRpbmcgdGhlIGZvbnRTZXQgaW5wdXQgdG8gZWl0aGVyIHRoZSBDU1MgY2xhc3MgdG8gYXBwbHkgdG8gdXNlIHRoZVxuICogICBkZXNpcmVkIGZvbnQsIG9yIHRvIGFuIGFsaWFzIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIE1kSWNvblJlZ2lzdHJ5LnJlZ2lzdGVyRm9udENsYXNzQWxpYXMuXG4gKiAgIEV4YW1wbGVzOlxuICogICAgIDxtZC1pY29uPmhvbWU8L21kLWljb24+XG4gKiAgICAgPG1kLWljb24gZm9udFNldD1cIm15Zm9udFwiPnN1bjwvbWQtaWNvbj5cbiAqXG4gKiAtIFNwZWNpZnkgYSBmb250IGdseXBoIHRvIGJlIGluY2x1ZGVkIHZpYSBDU1MgcnVsZXMgYnkgc2V0dGluZyB0aGUgZm9udFNldCBpbnB1dCB0byBzcGVjaWZ5IHRoZVxuICogICBmb250LCBhbmQgdGhlIGZvbnRJY29uIGlucHV0IHRvIHNwZWNpZnkgdGhlIGljb24uIFR5cGljYWxseSB0aGUgZm9udEljb24gd2lsbCBzcGVjaWZ5IGFcbiAqICAgQ1NTIGNsYXNzIHdoaWNoIGNhdXNlcyB0aGUgZ2x5cGggdG8gYmUgZGlzcGxheWVkIHZpYSBhIDpiZWZvcmUgc2VsZWN0b3IsIGFzIGluXG4gKiAgIGh0dHBzOi8vZm9ydGF3ZXNvbWUuZ2l0aHViLmlvL0ZvbnQtQXdlc29tZS9leGFtcGxlcy9cbiAqICAgRXhhbXBsZTpcbiAqICAgICA8bWQtaWNvbiBmb250U2V0PVwiZmFcIiBmb250SWNvbj1cImFsYXJtXCI+PC9tZC1pY29uPlxuICovXG52YXIgTWRJY29uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEljb24oX2VsZW1lbnQsIF9yZW5kZXJlciwgX21kSWNvblJlZ2lzdHJ5KSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBfZWxlbWVudDtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX21kSWNvblJlZ2lzdHJ5ID0gX21kSWNvblJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLmhvc3RBcmlhTGFiZWwgPSAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3BsaXRzIGFuIHN2Z0ljb24gYmluZGluZyB2YWx1ZSBpbnRvIGl0cyBpY29uIHNldCBhbmQgaWNvbiBuYW1lIGNvbXBvbmVudHMuXG4gICAgICogUmV0dXJucyBhIDItZWxlbWVudCBhcnJheSBvZiBbKGljb24gc2V0KSwgKGljb24gbmFtZSldLlxuICAgICAqIFRoZSBzZXBhcmF0b3IgZm9yIHRoZSB0d28gZmllbGRzIGlzICc6Jy4gSWYgdGhlcmUgaXMgbm8gc2VwYXJhdG9yLCBhbiBlbXB0eVxuICAgICAqIHN0cmluZyBpcyByZXR1cm5lZCBmb3IgdGhlIGljb24gc2V0IGFuZCB0aGUgZW50aXJlIHZhbHVlIGlzIHJldHVybmVkIGZvclxuICAgICAqIHRoZSBpY29uIG5hbWUuIElmIHRoZSBhcmd1bWVudCBpcyBmYWxzeSwgcmV0dXJucyBhbiBhcnJheSBvZiB0d28gZW1wdHkgc3RyaW5ncy5cbiAgICAgKiBUaHJvd3MgYSBNZEljb25JbnZhbGlkTmFtZUVycm9yIGlmIHRoZSBuYW1lIGNvbnRhaW5zIHR3byBvciBtb3JlICc6JyBzZXBhcmF0b3JzLlxuICAgICAqIEV4YW1wbGVzOlxuICAgICAqICAgJ3NvY2lhbDpjYWtlJyAtPiBbJ3NvY2lhbCcsICdjYWtlJ11cbiAgICAgKiAgICdwZW5ndWluJyAtPiBbJycsICdwZW5ndWluJ11cbiAgICAgKiAgIG51bGwgLT4gWycnLCAnJ11cbiAgICAgKiAgICdhOmI6YycgLT4gKHRocm93cyBNZEljb25JbnZhbGlkTmFtZUVycm9yKVxuICAgICAqL1xuICAgIE1kSWNvbi5wcm90b3R5cGUuX3NwbGl0SWNvbk5hbWUgPSBmdW5jdGlvbiAoaWNvbk5hbWUpIHtcbiAgICAgICAgaWYgKCFpY29uTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIFsnJywgJyddO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJ0cyA9IGljb25OYW1lLnNwbGl0KCc6Jyk7XG4gICAgICAgIHN3aXRjaCAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgLy8gVXNlIGRlZmF1bHQgbmFtZXNwYWNlLlxuICAgICAgICAgICAgICAgIHJldHVybiBbJycsIHBhcnRzWzBdXTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBNZEljb25JbnZhbGlkTmFtZUVycm9yKGljb25OYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIFRPRE86IGludGVybmFsICovXG4gICAgTWRJY29uLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjaGFuZ2VkSW5wdXRzID0gT2JqZWN0LmtleXMoY2hhbmdlcyk7XG4gICAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSBpbmxpbmUgU1ZHIGljb24gaWYgdGhlIGlucHV0cyBjaGFuZ2VkLCB0byBhdm9pZCB1bm5lY2Vzc2FyeSBET00gb3BlcmF0aW9ucy5cbiAgICAgICAgaWYgKGNoYW5nZWRJbnB1dHMuaW5kZXhPZignc3ZnSWNvbicpICE9IC0xIHx8IGNoYW5nZWRJbnB1dHMuaW5kZXhPZignc3ZnU3JjJykgIT0gLTEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN2Z0ljb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSB0aGlzLl9zcGxpdEljb25OYW1lKHRoaXMuc3ZnSWNvbiksIG5hbWVzcGFjZSA9IF9hWzBdLCBpY29uTmFtZSA9IF9hWzFdO1xuICAgICAgICAgICAgICAgIHRoaXMuX21kSWNvblJlZ2lzdHJ5LmdldE5hbWVkU3ZnSWNvbihpY29uTmFtZSwgbmFtZXNwYWNlKS5zdWJzY3JpYmUoZnVuY3Rpb24gKHN2ZykgeyByZXR1cm4gX3RoaXMuX3NldFN2Z0VsZW1lbnQoc3ZnKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gY29uc29sZS5sb2coXCJFcnJvciByZXRyaWV2aW5nIGljb246IFwiICsgZXJyKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN2Z1NyYykge1xuICAgICAgICAgICAgICAgIHRoaXMuX21kSWNvblJlZ2lzdHJ5LmdldFN2Z0ljb25Gcm9tVXJsKHRoaXMuc3ZnU3JjKS5zdWJzY3JpYmUoZnVuY3Rpb24gKHN2ZykgeyByZXR1cm4gX3RoaXMuX3NldFN2Z0VsZW1lbnQoc3ZnKTsgfSwgZnVuY3Rpb24gKGVycikgeyByZXR1cm4gY29uc29sZS5sb2coXCJFcnJvciByZXRyaWV2aW5nIGljb246IFwiICsgZXJyKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3VzaW5nRm9udEljb24oKSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRm9udEljb25DbGFzc2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQXJpYUxhYmVsKCk7XG4gICAgfTtcbiAgICAvKiogVE9ETzogaW50ZXJuYWwgKi9cbiAgICBNZEljb24ucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBVcGRhdGUgZm9udCBjbGFzc2VzIGJlY2F1c2UgbmdPbkNoYW5nZXMgd29uJ3QgYmUgY2FsbGVkIGlmIG5vbmUgb2YgdGhlIGlucHV0cyBhcmUgcHJlc2VudCxcbiAgICAgICAgLy8gZS5nLiA8bWQtaWNvbj5hcnJvdzwvbWQtaWNvbj4uIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGFkZCBhIENTUyBjbGFzcyBmb3IgdGhlIGRlZmF1bHQgZm9udC5cbiAgICAgICAgaWYgKHRoaXMuX3VzaW5nRm9udEljb24oKSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRm9udEljb25DbGFzc2VzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBUT0RPOiBpbnRlcm5hbCAqL1xuICAgIE1kSWNvbi5wcm90b3R5cGUubmdBZnRlclZpZXdDaGVja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBVcGRhdGUgYXJpYSBsYWJlbCBoZXJlIGJlY2F1c2UgaXQgbWF5IGRlcGVuZCBvbiB0aGUgcHJvamVjdGVkIHRleHQgY29udGVudC5cbiAgICAgICAgLy8gKGUuZy4gPG1kLWljb24+aG9tZTwvbWQtaWNvbj4gc2hvdWxkIHVzZSAnaG9tZScpLlxuICAgICAgICB0aGlzLl91cGRhdGVBcmlhTGFiZWwoKTtcbiAgICB9O1xuICAgIE1kSWNvbi5wcm90b3R5cGUuX3VwZGF0ZUFyaWFMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyaWFMYWJlbCA9IHRoaXMuX2dldEFyaWFMYWJlbCgpO1xuICAgICAgICBpZiAoYXJpYUxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50QXR0cmlidXRlKHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2FyaWEtbGFiZWwnLCBhcmlhTGFiZWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZEljb24ucHJvdG90eXBlLl9nZXRBcmlhTGFiZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElmIHRoZSBwYXJlbnQgcHJvdmlkZWQgYW4gYXJpYS1sYWJlbCBhdHRyaWJ1dGUgdmFsdWUsIHVzZSBpdCBhcy1pcy4gT3RoZXJ3aXNlIGxvb2sgZm9yIGFcbiAgICAgICAgLy8gcmVhc29uYWJsZSB2YWx1ZSBmcm9tIHRoZSBhbHQgYXR0cmlidXRlLCBmb250IGljb24gbmFtZSwgU1ZHIGljb24gbmFtZSwgb3IgKGZvciBsaWdhdHVyZXMpXG4gICAgICAgIC8vIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIGRpcmVjdGl2ZS5cbiAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5ob3N0QXJpYUxhYmVsIHx8XG4gICAgICAgICAgICB0aGlzLmFsdCB8fFxuICAgICAgICAgICAgdGhpcy5mb250SWNvbiB8fFxuICAgICAgICAgICAgdGhpcy5fc3BsaXRJY29uTmFtZSh0aGlzLnN2Z0ljb24pWzFdO1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgXCJjb250ZW50XCIgb2YgYW4gU1ZHIGljb24gaXMgbm90IGEgdXNlZnVsIGxhYmVsLlxuICAgICAgICBpZiAodGhpcy5fdXNpbmdGb250SWNvbigpKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9IHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogV2FybiBoZXJlIGluIGRldiBtb2RlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIE1kSWNvbi5wcm90b3R5cGUuX3VzaW5nRm9udEljb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhKHRoaXMuc3ZnSWNvbiB8fCB0aGlzLnN2Z1NyYyk7XG4gICAgfTtcbiAgICBNZEljb24ucHJvdG90eXBlLl9zZXRTdmdFbGVtZW50ID0gZnVuY3Rpb24gKHN2Zykge1xuICAgICAgICB2YXIgbGF5b3V0RWxlbWVudCA9IHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIGNoaWxkIG5vZGVzIGFuZCBhZGQgdGhlIG5ldyBTVkcgZWxlbWVudC5cbiAgICAgICAgLy8gV2Ugd291bGQgdXNlIHJlbmRlcmVyLmRldGFjaFZpZXcoQXJyYXkuZnJvbShsYXlvdXRFbGVtZW50LmNoaWxkTm9kZXMpKSBoZXJlLFxuICAgICAgICAvLyBidXQgaXQgZmFpbHMgaW4gSUUxMTogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvNjMyN1xuICAgICAgICBsYXlvdXRFbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5wcm9qZWN0Tm9kZXMobGF5b3V0RWxlbWVudCwgW3N2Z10pO1xuICAgIH07XG4gICAgTWRJY29uLnByb3RvdHlwZS5fdXBkYXRlRm9udEljb25DbGFzc2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3VzaW5nRm9udEljb24oKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbGVtID0gdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB2YXIgZm9udFNldENsYXNzID0gdGhpcy5mb250U2V0ID9cbiAgICAgICAgICAgIHRoaXMuX21kSWNvblJlZ2lzdHJ5LmNsYXNzTmFtZUZvckZvbnRBbGlhcyh0aGlzLmZvbnRTZXQpIDpcbiAgICAgICAgICAgIHRoaXMuX21kSWNvblJlZ2lzdHJ5LmdldERlZmF1bHRGb250U2V0Q2xhc3MoKTtcbiAgICAgICAgaWYgKGZvbnRTZXRDbGFzcyAhPSB0aGlzLl9wcmV2aW91c0ZvbnRTZXRDbGFzcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXZpb3VzRm9udFNldENsYXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKGVsZW0sIHRoaXMuX3ByZXZpb3VzRm9udFNldENsYXNzLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9udFNldENsYXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKGVsZW0sIGZvbnRTZXRDbGFzcywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c0ZvbnRTZXRDbGFzcyA9IGZvbnRTZXRDbGFzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mb250SWNvbiAhPSB0aGlzLl9wcmV2aW91c0ZvbnRJY29uQ2xhc3MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmV2aW91c0ZvbnRJY29uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3MoZWxlbSwgdGhpcy5fcHJldmlvdXNGb250SWNvbkNsYXNzLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5mb250SWNvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyhlbGVtLCB0aGlzLmZvbnRJY29uLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzRm9udEljb25DbGFzcyA9IHRoaXMuZm9udEljb247XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMjkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDI5KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZEljb24ucHJvdG90eXBlLCBcInN2Z1NyY1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMjkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDI5KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZEljb24ucHJvdG90eXBlLCBcInN2Z0ljb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDI5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyOSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRJY29uLnByb3RvdHlwZSwgXCJmb250U2V0XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQyOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjkoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kSWNvbi5wcm90b3R5cGUsIFwiZm9udEljb25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDI5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyOSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRJY29uLnByb3RvdHlwZSwgXCJhbHRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDI5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnYXJpYS1sYWJlbCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQyOSgnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRJY29uLnByb3RvdHlwZSwgXCJob3N0QXJpYUxhYmVsXCIsIHZvaWQgMCk7XG4gICAgTWRJY29uID0gX19kZWNvcmF0ZSQyOShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHt0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1pY29uJyxcbiAgICAgICAgICAgIHN0eWxlczogW1wibWQtaWNvbiB7IGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgZmlsbDogY3VycmVudENvbG9yOyBoZWlnaHQ6IDI0cHg7IHdpZHRoOiAyNHB4OyB9IC8qIyBzb3VyY2VNYXBwaW5nVVJMPWljb24uY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ3JvbGUnOiAnaW1nJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmNhcHN1bGF0aW9uOiBfYW5ndWxhcl9jb3JlLlZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjkoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgX2FuZ3VsYXJfY29yZS5SZW5kZXJlciwgTWRJY29uUmVnaXN0cnldKVxuICAgIF0sIE1kSWNvbik7XG4gICAgcmV0dXJuIE1kSWNvbjtcbn0oKSk7XG52YXIgTWRJY29uTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZEljb25Nb2R1bGUoKSB7XG4gICAgfVxuICAgIE1kSWNvbk1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kSWNvbk1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW01kSWNvblJlZ2lzdHJ5XSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kSWNvbk1vZHVsZSA9IF9fZGVjb3JhdGUkMjkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtfYW5ndWxhcl9odHRwLkh0dHBNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW01kSWNvbl0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZEljb25dLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMjkoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRJY29uTW9kdWxlKTtcbiAgICByZXR1cm4gTWRJY29uTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZXh0ZW5kcyQxMiA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQzMSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQzMSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLy8gVE9ETyhqb3NlcGhwZXJyb3R0KTogQmVuY2hwcmVzcyB0ZXN0cy5cbi8qKiBBIHNpbmdsZSBkZWdyZWUgaW4gcmFkaWFucy4gKi9cbnZhciBERUdSRUVfSU5fUkFESUFOUyA9IE1hdGguUEkgLyAxODA7XG4vKiogRHVyYXRpb24gb2YgdGhlIGluZGV0ZXJtaW5hdGUgYW5pbWF0aW9uLiAqL1xudmFyIERVUkFUSU9OX0lOREVURVJNSU5BVEUgPSA2Njc7XG4vKiogRHVyYXRpb24gb2YgdGhlIGluZGV0ZXJtaW5hdGUgYW5pbWF0aW9uLiAqL1xudmFyIERVUkFUSU9OX0RFVEVSTUlOQVRFID0gMjI1O1xuLyoqIFN0YXJ0IGFuaW1hdGlvbiB2YWx1ZSBvZiB0aGUgaW5kZXRlcm1pbmF0ZSBhbmltYXRpb24gKi9cbnZhciBzdGFydEluZGV0ZXJtaW5hdGUgPSAzO1xuLyoqIEVuZCBhbmltYXRpb24gdmFsdWUgb2YgdGhlIGluZGV0ZXJtaW5hdGUgYW5pbWF0aW9uICovXG52YXIgZW5kSW5kZXRlcm1pbmF0ZSA9IDgwO1xuLyoqXG4gKiA8bWQtcHJvZ3Jlc3MtY2lyY2xlPiBjb21wb25lbnQuXG4gKi9cbnZhciBNZFByb2dyZXNzQ2lyY2xlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFByb2dyZXNzQ2lyY2xlKF9jaGFuZ2VEZXRlY3RvclJlZikge1xuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZiA9IF9jaGFuZ2VEZXRlY3RvclJlZjtcbiAgICAgICAgLyoqIFRoZSBpZCBvZiB0aGUgbGFzdCByZXF1ZXN0ZWQgYW5pbWF0aW9uLiAqL1xuICAgICAgICB0aGlzLl9sYXN0QW5pbWF0aW9uSWQgPSAwO1xuICAgICAgICB0aGlzLl9tb2RlID0gJ2RldGVybWluYXRlJztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUHJvZ3Jlc3NDaXJjbGUucHJvdG90eXBlLCBcIl9hcmlhVmFsdWVNaW5cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWVzIGZvciBhcmlhIG1heCBhbmQgbWluIGFyZSBvbmx5IGRlZmluZWQgYXMgbnVtYmVycyB3aGVuIGluIGEgZGV0ZXJtaW5hdGUgbW9kZS4gIFdlIGRvIHRoaXNcbiAgICAgICAgICogYmVjYXVzZSB2b2ljZW92ZXIgZG9lcyBub3QgcmVwb3J0IHRoZSBwcm9ncmVzcyBpbmRpY2F0b3IgYXMgaW5kZXRlcm1pbmF0ZSBpZiB0aGUgYXJpYSBtaW5cbiAgICAgICAgICogYW5kL29yIG1heCB2YWx1ZSBhcmUgbnVtYmVyIHZhbHVlcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PSAnZGV0ZXJtaW5hdGUnID8gMCA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFByb2dyZXNzQ2lyY2xlLnByb3RvdHlwZSwgXCJfYXJpYVZhbHVlTWF4XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlID09ICdkZXRlcm1pbmF0ZScgPyAxMDAgOiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc0NpcmNsZS5wcm90b3R5cGUsIFwiaW50ZXJkZXRlcm1pbmF0ZUludGVydmFsXCIsIHtcbiAgICAgICAgLyoqIFRPRE86IGludGVybmFsICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIFRPRE86IGludGVybmFsICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbCk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcmRldGVybWluYXRlSW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUHJvZ3Jlc3NDaXJjbGUucHJvdG90eXBlLCBcImN1cnJlbnRQYXRoXCIsIHtcbiAgICAgICAgLyoqIFRPRE86IGludGVybmFsICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRQYXRoO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UGF0aCA9IHBhdGg7XG4gICAgICAgICAgICAvLyBNYXJrIGZvciBjaGVjayBhcyBvdXIgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgaXMgT25QdXNoLCB3aGVuIGNoYW5nZXMgY29tZSBmcm9tIHdpdGhpbiB0aGVcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCwgY2hhbmdlIGRldGVjdGlvbiBtdXN0IGJlIGNhbGxlZCBmb3IuXG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIENsZWFuIHVwIGFueSBhbmltYXRpb25zIHRoYXQgd2VyZSBydW5uaW5nLiAqL1xuICAgIE1kUHJvZ3Jlc3NDaXJjbGUucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jbGVhbnVwSW5kZXRlcm1pbmF0ZUFuaW1hdGlvbigpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kUHJvZ3Jlc3NDaXJjbGUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlID09ICdkZXRlcm1pbmF0ZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGlmICh2ICYmIHRoaXMubW9kZSA9PSAnZGV0ZXJtaW5hdGUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY2xhbXAodik7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZUNpcmNsZSgodGhpcy52YWx1ZSB8fCAwKSwgbmV3VmFsdWUsIGxpbmVhckVhc2UsIERVUkFUSU9OX0RFVEVSTUlOQVRFLCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc0NpcmNsZS5wcm90b3R5cGUsIFwibW9kZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb2RlIG9mIHRoZSBwcm9ncmVzcyBjaXJjbGVcbiAgICAgICAgICpcbiAgICAgICAgICogSW5wdXQgbXVzdCBiZSBvbmUgb2YgdGhlIHZhbHVlcyBmcm9tIFByb2dyZXNzTW9kZSwgZGVmYXVsdHMgdG8gJ2RldGVybWluYXRlJy5cbiAgICAgICAgICogbW9kZSBpcyBib3VuZCB0byB0aGUgaG9zdCBhcyB0aGUgYXR0cmlidXRlIGhvc3QuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb2RlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICBpZiAobSA9PSAnaW5kZXRlcm1pbmF0ZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydEluZGV0ZXJtaW5hdGVBbmltYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBJbmRldGVybWluYXRlQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tb2RlID0gbTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQW5pbWF0ZXMgdGhlIGNpcmNsZSBmcm9tIG9uZSBwZXJjZW50YWdlIHZhbHVlIHRvIGFub3RoZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW5pbWF0ZUZyb20gVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGNpcmNsZSBmaWxsZWQgc3RhcnRpbmcgdGhlIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0gYW5pbWF0ZVRvIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBjaXJjbGUgZmlsbGVkIGVuZGluZyB0aGUgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSBlYXNlIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gbWFuYWdlIHRoZSBwYWNlIG9mIGNoYW5nZSBpbiB0aGUgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSBkdXJhdGlvbiBUaGUgbGVuZ3RoIG9mIHRpbWUgdG8gc2hvdyB0aGUgYW5pbWF0aW9uLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogQHBhcmFtIHJvdGF0aW9uIFRoZSBzdGFydGluZyBhbmdsZSBvZiB0aGUgY2lyY2xlIGZpbGwsIHdpdGggMMKwIHJlcHJlc2VudGVkIGF0IHRoZSB0b3AgY2VudGVyXG4gICAgICogICAgb2YgdGhlIGNpcmNsZS5cbiAgICAgKi9cbiAgICBNZFByb2dyZXNzQ2lyY2xlLnByb3RvdHlwZS5fYW5pbWF0ZUNpcmNsZSA9IGZ1bmN0aW9uIChhbmltYXRlRnJvbSwgYW5pbWF0ZVRvLCBlYXNlLCBkdXJhdGlvbiwgcm90YXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGlkID0gKyt0aGlzLl9sYXN0QW5pbWF0aW9uSWQ7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgY2hhbmdlSW5WYWx1ZSA9IGFuaW1hdGVUbyAtIGFuaW1hdGVGcm9tO1xuICAgICAgICAvLyBObyBuZWVkIHRvIGFuaW1hdGUgaXQgaWYgdGhlIHZhbHVlcyBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKGFuaW1hdGVUbyA9PT0gYW5pbWF0ZUZyb20pIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBnZXRTdmdBcmMoYW5pbWF0ZVRvLCByb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsYXBzZWRUaW1lID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSwgZHVyYXRpb24pKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50UGF0aCA9IGdldFN2Z0FyYyhlYXNlKGVsYXBzZWRUaW1lLCBhbmltYXRlRnJvbSwgY2hhbmdlSW5WYWx1ZSwgZHVyYXRpb24pLCByb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBvdmVybGFwcGluZyBhbmltYXRpb25zIGJ5IGNoZWNraW5nIGlmIGEgbmV3IGFuaW1hdGlvbiBoYXMgYmVlbiBjYWxsZWQgZm9yIGFuZFxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBhbmltYXRpb24gaGFzIGxhc3RlZCBsb25nIHRoYW4gdGhlIGFuaW1hdGlvbiBkdXJhdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoaWQgPT09IF90aGlzLl9sYXN0QW5pbWF0aW9uSWQgJiYgZWxhcHNlZFRpbWUgPCBkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uXzEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydHMgdGhlIGluZGV0ZXJtaW5hdGUgYW5pbWF0aW9uIGludGVydmFsLCBpZiBpdCBpcyBub3QgYWxyZWFkeSBydW5uaW5nLlxuICAgICAqL1xuICAgIE1kUHJvZ3Jlc3NDaXJjbGUucHJvdG90eXBlLl9zdGFydEluZGV0ZXJtaW5hdGVBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByb3RhdGlvblN0YXJ0UG9pbnQgPSAwO1xuICAgICAgICB2YXIgc3RhcnQgPSBzdGFydEluZGV0ZXJtaW5hdGU7XG4gICAgICAgIHZhciBlbmQgPSBlbmRJbmRldGVybWluYXRlO1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBEVVJBVElPTl9JTkRFVEVSTUlOQVRFO1xuICAgICAgICB2YXIgYW5pbWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9hbmltYXRlQ2lyY2xlKHN0YXJ0LCBlbmQsIG1hdGVyaWFsRWFzZSwgZHVyYXRpb24sIHJvdGF0aW9uU3RhcnRQb2ludCk7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IHJvdGF0aW9uIGZyb20gcmVhY2hpbmcgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIuXG4gICAgICAgICAgICByb3RhdGlvblN0YXJ0UG9pbnQgPSAocm90YXRpb25TdGFydFBvaW50ICsgZW5kKSAlIDEwMDtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gc3RhcnQ7XG4gICAgICAgICAgICBzdGFydCA9IC1lbmQ7XG4gICAgICAgICAgICBlbmQgPSAtdGVtcDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLmludGVyZGV0ZXJtaW5hdGVJbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcmRldGVybWluYXRlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChhbmltYXRlLCBkdXJhdGlvbiArIDUwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICBhbmltYXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgaW50ZXJ2YWwsIGVuZGluZyB0aGUgYW5pbWF0aW9uLlxuICAgICAqL1xuICAgIE1kUHJvZ3Jlc3NDaXJjbGUucHJvdG90eXBlLl9jbGVhbnVwSW5kZXRlcm1pbmF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbnRlcmRldGVybWluYXRlSW50ZXJ2YWwgPSBudWxsO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQzMShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSxcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnYXR0ci5hcmlhLXZhbHVlbm93JyksIFxuICAgICAgICBfX21ldGFkYXRhJDMxKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFByb2dyZXNzQ2lyY2xlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDMxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnYXR0ci5tb2RlJyksXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzEoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kUHJvZ3Jlc3NDaXJjbGUucHJvdG90eXBlLCBcIm1vZGVcIiwgbnVsbCk7XG4gICAgTWRQcm9ncmVzc0NpcmNsZSA9IF9fZGVjb3JhdGUkMzEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC1wcm9ncmVzcy1jaXJjbGUnLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdyb2xlJzogJ3Byb2dyZXNzYmFyJyxcbiAgICAgICAgICAgICAgICAnW2F0dHIuYXJpYS12YWx1ZW1pbl0nOiAnX2FyaWFWYWx1ZU1pbicsXG4gICAgICAgICAgICAgICAgJ1thdHRyLmFyaWEtdmFsdWVtYXhdJzogJ19hcmlhVmFsdWVNYXgnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjwhLS0gcHJlc2VydmVBc3BlY3RSYXRpbyBvZiB4TWlkWU1pZCBtZWV0IGFzIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0IGlzIHRoZSBjaXJjbGUncyBjZW50ZXIuICBUaGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgd2l0aCByZW1haW4gYXQgdGhlIGNlbnRlciBvZiB0aGUgbWQtcHJvZ3Jlc3MtY2lyY2xlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgU1ZHLiAtLT4gPHN2ZyB2aWV3Qm94PVxcXCIwIDAgMTAwIDEwMFxcXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pZFlNaWQgbWVldFxcXCI+IDxwYXRoIFthdHRyLmRdPVxcXCJjdXJyZW50UGF0aFxcXCI+PC9wYXRoPiA8L3N2Zz4gXCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0IHsgZGlzcGxheTogYmxvY2s7IGhlaWdodDogMTAwcHg7IHdpZHRoOiAxMDBweDsgfSA6aG9zdCBzdmcgeyBoZWlnaHQ6IDEwMCU7IHdpZHRoOiAxMDAlOyB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7IH0gOmhvc3QgcGF0aCB7IGZpbGw6IHRyYW5zcGFyZW50OyBzdHJva2Utd2lkdGg6IDEwcHg7IH0gOmhvc3RbbW9kZT0naW5kZXRlcm1pbmF0ZSddIHsgYW5pbWF0aW9uLWR1cmF0aW9uOiA1MjUwbXMsIDI4ODcuNW1zOyBhbmltYXRpb24tbmFtZTogbWQtcHJvZ3Jlc3MtY2lyY2xlLXNwb3JhZGljLXJvdGF0ZSwgbWQtcHJvZ3Jlc3MtY2lyY2xlLWxpbmVhci1yb3RhdGU7IGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjM1LCAwLCAwLjI1LCAxKSwgbGluZWFyOyBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiBpbmZpbml0ZTsgdHJhbnNpdGlvbjogbm9uZTsgfSBAa2V5ZnJhbWVzIG1kLXByb2dyZXNzLWNpcmNsZS1saW5lYXItcm90YXRlIHsgMCUgeyB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfSAxMDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfSB9IEBrZXlmcmFtZXMgbWQtcHJvZ3Jlc3MtY2lyY2xlLXNwb3JhZGljLXJvdGF0ZSB7IDEyLjUlIHsgdHJhbnNmb3JtOiByb3RhdGUoMTM1ZGVnKTsgfSAyNSUgeyB0cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpOyB9IDM3LjUlIHsgdHJhbnNmb3JtOiByb3RhdGUoNDA1ZGVnKTsgfSA1MCUgeyB0cmFuc2Zvcm06IHJvdGF0ZSg1NDBkZWcpOyB9IDYyLjUlIHsgdHJhbnNmb3JtOiByb3RhdGUoNjc1ZGVnKTsgfSA3NSUgeyB0cmFuc2Zvcm06IHJvdGF0ZSg4MTBkZWcpOyB9IDg3LjUlIHsgdHJhbnNmb3JtOiByb3RhdGUoOTQ1ZGVnKTsgfSAxMDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMTA4MGRlZyk7IH0gfSAvKiMgc291cmNlTWFwcGluZ1VSTD1wcm9ncmVzcy1jaXJjbGUuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuICAgIF0sIE1kUHJvZ3Jlc3NDaXJjbGUpO1xuICAgIHJldHVybiBNZFByb2dyZXNzQ2lyY2xlO1xufSgpKTtcbi8qKlxuICogPG1kLXNwaW5uZXI+IGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGlzIGEgY29tcG9uZW50IGRlZmluaXRpb24gdG8gYmUgdXNlZCBhcyBhIGNvbnZlbmllbmNlIHJlZmVyZW5jZSB0byBjcmVhdGUgYW5cbiAqIGluZGV0ZXJtaW5hdGUgPG1kLXByb2dyZXNzLWNpcmNsZT4gaW5zdGFuY2UuXG4gKi9cbnZhciBNZFNwaW5uZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxMihNZFNwaW5uZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRTcGlubmVyKGNoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGNoYW5nZURldGVjdG9yUmVmKTtcbiAgICAgICAgdGhpcy5tb2RlID0gJ2luZGV0ZXJtaW5hdGUnO1xuICAgIH1cbiAgICBNZFNwaW5uZXIgPSBfX2RlY29yYXRlJDMxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtc3Bpbm5lcicsXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ3JvbGUnOiAncHJvZ3Jlc3NiYXInLFxuICAgICAgICAgICAgICAgICdtb2RlJzogJ2luZGV0ZXJtaW5hdGUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjwhLS0gcHJlc2VydmVBc3BlY3RSYXRpbyBvZiB4TWlkWU1pZCBtZWV0IGFzIHRoZSBjZW50ZXIgb2YgdGhlIHZpZXdwb3J0IGlzIHRoZSBjaXJjbGUncyBjZW50ZXIuICBUaGUgY2VudGVyIG9mIHRoZSBjaXJjbGUgd2l0aCByZW1haW4gYXQgdGhlIGNlbnRlciBvZiB0aGUgbWQtcHJvZ3Jlc3MtY2lyY2xlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgU1ZHLiAtLT4gPHN2ZyB2aWV3Qm94PVxcXCIwIDAgMTAwIDEwMFxcXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pZFlNaWQgbWVldFxcXCI+IDxwYXRoIFthdHRyLmRdPVxcXCJjdXJyZW50UGF0aFxcXCI+PC9wYXRoPiA8L3N2Zz4gXCIsXG4gICAgICAgICAgICBzdHlsZXM6IFtcIjpob3N0IHsgZGlzcGxheTogYmxvY2s7IGhlaWdodDogMTAwcHg7IHdpZHRoOiAxMDBweDsgfSA6aG9zdCBzdmcgeyBoZWlnaHQ6IDEwMCU7IHdpZHRoOiAxMDAlOyB0cmFuc2Zvcm0tb3JpZ2luOiBjZW50ZXI7IH0gOmhvc3QgcGF0aCB7IGZpbGw6IHRyYW5zcGFyZW50OyBzdHJva2Utd2lkdGg6IDEwcHg7IH0gOmhvc3RbbW9kZT0naW5kZXRlcm1pbmF0ZSddIHsgYW5pbWF0aW9uLWR1cmF0aW9uOiA1MjUwbXMsIDI4ODcuNW1zOyBhbmltYXRpb24tbmFtZTogbWQtcHJvZ3Jlc3MtY2lyY2xlLXNwb3JhZGljLXJvdGF0ZSwgbWQtcHJvZ3Jlc3MtY2lyY2xlLWxpbmVhci1yb3RhdGU7IGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjM1LCAwLCAwLjI1LCAxKSwgbGluZWFyOyBhbmltYXRpb24taXRlcmF0aW9uLWNvdW50OiBpbmZpbml0ZTsgdHJhbnNpdGlvbjogbm9uZTsgfSBAa2V5ZnJhbWVzIG1kLXByb2dyZXNzLWNpcmNsZS1saW5lYXItcm90YXRlIHsgMCUgeyB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfSAxMDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTsgfSB9IEBrZXlmcmFtZXMgbWQtcHJvZ3Jlc3MtY2lyY2xlLXNwb3JhZGljLXJvdGF0ZSB7IDEyLjUlIHsgdHJhbnNmb3JtOiByb3RhdGUoMTM1ZGVnKTsgfSAyNSUgeyB0cmFuc2Zvcm06IHJvdGF0ZSgyNzBkZWcpOyB9IDM3LjUlIHsgdHJhbnNmb3JtOiByb3RhdGUoNDA1ZGVnKTsgfSA1MCUgeyB0cmFuc2Zvcm06IHJvdGF0ZSg1NDBkZWcpOyB9IDYyLjUlIHsgdHJhbnNmb3JtOiByb3RhdGUoNjc1ZGVnKTsgfSA3NSUgeyB0cmFuc2Zvcm06IHJvdGF0ZSg4MTBkZWcpOyB9IDg3LjUlIHsgdHJhbnNmb3JtOiByb3RhdGUoOTQ1ZGVnKTsgfSAxMDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMTA4MGRlZyk7IH0gfSAvKiMgc291cmNlTWFwcGluZ1VSTD1wcm9ncmVzcy1jaXJjbGUuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5DaGFuZ2VEZXRlY3RvclJlZl0pXG4gICAgXSwgTWRTcGlubmVyKTtcbiAgICByZXR1cm4gTWRTcGlubmVyO1xufShNZFByb2dyZXNzQ2lyY2xlKSk7XG4vKipcbiAqIE1vZHVsZSBmdW5jdGlvbnMuXG4gKi9cbi8qKiBDbGFtcHMgYSB2YWx1ZSB0byBiZSBiZXR3ZWVuIDAgYW5kIDEwMC4gKi9cbmZ1bmN0aW9uIGNsYW1wKHYpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMTAwLCB2KSk7XG59XG4vKipcbiAqIENvbnZlcnRzIFBvbGFyIGNvb3JkaW5hdGVzIHRvIENhcnRlc2lhbi5cbiAqL1xuZnVuY3Rpb24gcG9sYXJUb0NhcnRlc2lhbihyYWRpdXMsIHBhdGhSYWRpdXMsIGFuZ2xlSW5EZWdyZWVzKSB7XG4gICAgdmFyIGFuZ2xlSW5SYWRpYW5zID0gKGFuZ2xlSW5EZWdyZWVzIC0gOTApICogREVHUkVFX0lOX1JBRElBTlM7XG4gICAgcmV0dXJuIChyYWRpdXMgKyAocGF0aFJhZGl1cyAqIE1hdGguY29zKGFuZ2xlSW5SYWRpYW5zKSkpICtcbiAgICAgICAgJywnICsgKHJhZGl1cyArIChwYXRoUmFkaXVzICogTWF0aC5zaW4oYW5nbGVJblJhZGlhbnMpKSk7XG59XG4vKipcbiAqIEVhc2luZyBmdW5jdGlvbiBmb3IgbGluZWFyIGFuaW1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gbGluZWFyRWFzZShjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgY2hhbmdlSW5WYWx1ZSwgZHVyYXRpb24pIHtcbiAgICByZXR1cm4gY2hhbmdlSW5WYWx1ZSAqIGN1cnJlbnRUaW1lIC8gZHVyYXRpb24gKyBzdGFydFZhbHVlO1xufVxuLyoqXG4gKiBFYXNpbmcgZnVuY3Rpb24gdG8gbWF0Y2ggbWF0ZXJpYWwgZGVzaWduIGluZGV0ZXJtaW5hdGUgYW5pbWF0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRlcmlhbEVhc2UoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGNoYW5nZUluVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgdmFyIHRpbWUgPSBjdXJyZW50VGltZSAvIGR1cmF0aW9uO1xuICAgIHZhciB0aW1lQ3ViZWQgPSBNYXRoLnBvdyh0aW1lLCAzKTtcbiAgICB2YXIgdGltZVF1YWQgPSBNYXRoLnBvdyh0aW1lLCA0KTtcbiAgICB2YXIgdGltZVF1aW50ID0gTWF0aC5wb3codGltZSwgNSk7XG4gICAgcmV0dXJuIHN0YXJ0VmFsdWUgKyBjaGFuZ2VJblZhbHVlICogKCg2ICogdGltZVF1aW50KSArICgtMTUgKiB0aW1lUXVhZCkgKyAoMTAgKiB0aW1lQ3ViZWQpKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgcGF0aCB2YWx1ZSB0byBkZWZpbmUgdGhlIGFyYy4gIENvbnZlcnRpbmcgcGVyY2VudGFnZSB2YWx1ZXMgdG8gdG8gcG9sYXJcbiAqIGNvb3JkaW5hdGVzIG9uIHRoZSBjaXJjbGUsIGFuZCB0aGVuIHRvIGNhcnRlc2lhbiBjb29yZGluYXRlcyBpbiB0aGUgdmlld3BvcnQuXG4gKlxuICogQHBhcmFtIGN1cnJlbnRWYWx1ZSBUaGUgY3VycmVudCBwZXJjZW50YWdlIHZhbHVlIG9mIHRoZSBwcm9ncmVzcyBjaXJjbGUsIHRoZSBwZXJjZW50YWdlIG9mIHRoZVxuICogICAgY2lyY2xlIHRvIGZpbGwuXG4gKiBAcGFyYW0gcm90YXRpb24gVGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBjaXJjbGUgd2l0aCAwIGJlaW5nIHRoZSAwIGRlZ3JlZSBwb2ludC5cbiAqIEByZXR1cm4gQSBzdHJpbmcgZm9yIGFuIFNWRyBwYXRoIHJlcHJlc2VudGluZyBhIGNpcmNsZSBmaWxsZWQgZnJvbSB0aGUgc3RhcnRpbmcgcG9pbnQgdG8gdGhlXG4gKiAgICBwZXJjZW50YWdlIHZhbHVlIHByb3ZpZGVkLlxuICovXG5mdW5jdGlvbiBnZXRTdmdBcmMoY3VycmVudFZhbHVlLCByb3RhdGlvbikge1xuICAgIC8vIFRoZSBhbmdsZSBjYW4ndCBiZSBleGFjdGx5IDM2MCwgYmVjYXVzZSB0aGUgYXJjIGJlY29tZXMgaGlkZGVuLlxuICAgIHZhciBtYXhpbXVtQW5nbGUgPSAzNTkuOTkgLyAxMDA7XG4gICAgdmFyIHN0YXJ0UG9pbnQgPSByb3RhdGlvbiB8fCAwO1xuICAgIHZhciByYWRpdXMgPSA1MDtcbiAgICB2YXIgcGF0aFJhZGl1cyA9IDQwO1xuICAgIHZhciBzdGFydEFuZ2xlID0gc3RhcnRQb2ludCAqIG1heGltdW1BbmdsZTtcbiAgICB2YXIgZW5kQW5nbGUgPSBjdXJyZW50VmFsdWUgKiBtYXhpbXVtQW5nbGU7XG4gICAgdmFyIHN0YXJ0ID0gcG9sYXJUb0NhcnRlc2lhbihyYWRpdXMsIHBhdGhSYWRpdXMsIHN0YXJ0QW5nbGUpO1xuICAgIHZhciBlbmQgPSBwb2xhclRvQ2FydGVzaWFuKHJhZGl1cywgcGF0aFJhZGl1cywgZW5kQW5nbGUgKyBzdGFydEFuZ2xlKTtcbiAgICB2YXIgYXJjU3dlZXAgPSBlbmRBbmdsZSA8IDAgPyAwIDogMTtcbiAgICB2YXIgbGFyZ2VBcmNGbGFnO1xuICAgIGlmIChlbmRBbmdsZSA8IDApIHtcbiAgICAgICAgbGFyZ2VBcmNGbGFnID0gZW5kQW5nbGUgPj0gLTE4MCA/IDAgOiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGFyZ2VBcmNGbGFnID0gZW5kQW5nbGUgPD0gMTgwID8gMCA6IDE7XG4gICAgfVxuICAgIHJldHVybiBcIk1cIiArIHN0YXJ0ICsgXCJBXCIgKyBwYXRoUmFkaXVzICsgXCIsXCIgKyBwYXRoUmFkaXVzICsgXCIgMCBcIiArIGxhcmdlQXJjRmxhZyArIFwiLFwiICsgYXJjU3dlZXAgKyBcIiBcIiArIGVuZDtcbn1cbnZhciBNZFByb2dyZXNzQ2lyY2xlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFByb2dyZXNzQ2lyY2xlTW9kdWxlKCkge1xuICAgIH1cbiAgICBNZFByb2dyZXNzQ2lyY2xlTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRQcm9ncmVzc0NpcmNsZU1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kUHJvZ3Jlc3NDaXJjbGVNb2R1bGUgPSBfX2RlY29yYXRlJDMxKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBleHBvcnRzOiBbTWRQcm9ncmVzc0NpcmNsZSwgTWRTcGlubmVyXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kUHJvZ3Jlc3NDaXJjbGUsIE1kU3Bpbm5lcl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFByb2dyZXNzQ2lyY2xlTW9kdWxlKTtcbiAgICByZXR1cm4gTWRQcm9ncmVzc0NpcmNsZU1vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDMyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDMyID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vLyBUT0RPKGpvc2VwaHBlcnJvdHQpOiBCZW5jaHByZXNzIHRlc3RzLlxuLy8gVE9ETyhqb3NlcGhwZXJyb3R0KTogQWRkIEFSSUEgYXR0cmlidXRlcyBmb3IgcHJvZ3Jlc3NiYXIgXCJmb3JcIi5cbi8qKlxuICogPG1kLXByb2dyZXNzLWJhcj4gY29tcG9uZW50LlxuICovXG52YXIgTWRQcm9ncmVzc0JhciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRQcm9ncmVzc0JhcigpIHtcbiAgICAgICAgLyoqIFZhbHVlIG9mIHRoZSBwcm9ncmVzc2Jhci4gRGVmYXVsdHMgdG8gemVyby4gTWlycm9yZWQgdG8gYXJpYS12YWx1ZW5vdy4gKi9cbiAgICAgICAgdGhpcy5fdmFsdWUgPSAwO1xuICAgICAgICAvKiogQnVmZmVyIHZhbHVlIG9mIHRoZSBwcm9ncmVzcyBiYXIuIERlZmF1bHRzIHRvIHplcm8uICovXG4gICAgICAgIHRoaXMuX2J1ZmZlclZhbHVlID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vZGUgb2YgdGhlIHByb2dyZXNzIGJhci5cbiAgICAgICAgICpcbiAgICAgICAgICogSW5wdXQgbXVzdCBiZSBvbmUgb2YgdGhlc2UgdmFsdWVzOiBkZXRlcm1pbmF0ZSwgaW5kZXRlcm1pbmF0ZSwgYnVmZmVyLCBxdWVyeSwgZGVmYXVsdHMgdG9cbiAgICAgICAgICogJ2RldGVybWluYXRlJy5cbiAgICAgICAgICogTWlycm9yZWQgdG8gbW9kZSBhdHRyaWJ1dGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vZGUgPSAnZGV0ZXJtaW5hdGUnO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRQcm9ncmVzc0Jhci5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBjbGFtcCQxKHYgfHwgMCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFByb2dyZXNzQmFyLnByb3RvdHlwZSwgXCJidWZmZXJWYWx1ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlclZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJWYWx1ZSA9IGNsYW1wJDEodiB8fCAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEdldHMgdGhlIGN1cnJlbnQgdHJhbnNmb3JtIHZhbHVlIGZvciB0aGUgcHJvZ3Jlc3MgYmFyJ3MgcHJpbWFyeSBpbmRpY2F0b3IuICovXG4gICAgTWRQcm9ncmVzc0Jhci5wcm90b3R5cGUuX3ByaW1hcnlUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMudmFsdWUgLyAxMDA7XG4gICAgICAgIHJldHVybiB7IHRyYW5zZm9ybTogXCJzY2FsZVgoXCIgKyBzY2FsZSArIFwiKVwiIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHRyYW5zZm9ybSB2YWx1ZSBmb3IgdGhlIHByb2dyZXNzIGJhcidzIGJ1ZmZlciBpbmRpY2F0b3IuICBPbmx5IHVzZWQgaWYgdGhlXG4gICAgICogcHJvZ3Jlc3MgbW9kZSBpcyBzZXQgdG8gYnVmZmVyLCBvdGhlcndpc2UgcmV0dXJucyBhbiB1bmRlZmluZWQsIGNhdXNpbmcgbm8gdHJhbnNmb3JtYXRpb24uXG4gICAgICovXG4gICAgTWRQcm9ncmVzc0Jhci5wcm90b3R5cGUuX2J1ZmZlclRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PSAnYnVmZmVyJykge1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5idWZmZXJWYWx1ZSAvIDEwMDtcbiAgICAgICAgICAgIHJldHVybiB7IHRyYW5zZm9ybTogXCJzY2FsZVgoXCIgKyBzY2FsZSArIFwiKVwiIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkMzIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS12YWx1ZW5vdycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMignZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRQcm9ncmVzc0Jhci5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzMihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzIoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kUHJvZ3Jlc3NCYXIucHJvdG90eXBlLCBcImJ1ZmZlclZhbHVlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSG9zdEJpbmRpbmcoJ2F0dHIubW9kZScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMignZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRQcm9ncmVzc0Jhci5wcm90b3R5cGUsIFwibW9kZVwiLCB2b2lkIDApO1xuICAgIE1kUHJvZ3Jlc3NCYXIgPSBfX2RlY29yYXRlJDMyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtcHJvZ3Jlc3MtYmFyJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAncm9sZSc6ICdwcm9ncmVzc2JhcicsXG4gICAgICAgICAgICAgICAgJ2FyaWEtdmFsdWVtaW4nOiAnMCcsXG4gICAgICAgICAgICAgICAgJ2FyaWEtdmFsdWVtYXgnOiAnMTAwJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8IS0tIFRoZSBiYWNrZ3JvdW5kIGRpdiBpcyBuYW1lZCBhcyBzdWNoIGJlY2F1c2UgaXQgYXBwZWFycyBiZWxvdyB0aGUgb3RoZXIgZGl2cyBhbmQgaXMgbm90IHNpemVkIGJhc2VkIG9uIHZhbHVlcy4gLS0+IDxkaXYgY2xhc3M9XFxcIm1kLXByb2dyZXNzLWJhci1iYWNrZ3JvdW5kXFxcIj48L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWQtcHJvZ3Jlc3MtYmFyLWJ1ZmZlclxcXCIgW25nU3R5bGVdPVxcXCJfYnVmZmVyVHJhbnNmb3JtKClcXFwiPjwvZGl2PiA8ZGl2IGNsYXNzPVxcXCJtZC1wcm9ncmVzcy1iYXItcHJpbWFyeSBtZC1wcm9ncmVzcy1iYXItZmlsbFxcXCIgW25nU3R5bGVdPVxcXCJfcHJpbWFyeVRyYW5zZm9ybSgpXFxcIj48L2Rpdj4gPGRpdiBjbGFzcz1cXFwibWQtcHJvZ3Jlc3MtYmFyLXNlY29uZGFyeSBtZC1wcm9ncmVzcy1iYXItZmlsbFxcXCI+PC9kaXY+IFwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdCB7IGRpc3BsYXk6IGJsb2NrOyBoZWlnaHQ6IDVweDsgb3ZlcmZsb3c6IGhpZGRlbjsgcG9zaXRpb246IHJlbGF0aXZlOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7IHRyYW5zaXRpb246IG9wYWNpdHkgMjUwbXMgbGluZWFyOyB3aWR0aDogMTAwJTsgfSA6aG9zdCAubWQtcHJvZ3Jlc3MtYmFyLWJhY2tncm91bmQgeyBiYWNrZ3JvdW5kLXJlcGVhdDogcmVwZWF0LXg7IGJhY2tncm91bmQtc2l6ZTogMTBweCA0cHg7IGhlaWdodDogMTAwJTsgcG9zaXRpb246IGFic29sdXRlOyB2aXNpYmlsaXR5OiBoaWRkZW47IHdpZHRoOiAxMDAlOyB9IDpob3N0IC5tZC1wcm9ncmVzcy1iYXItYnVmZmVyIHsgaGVpZ2h0OiAxMDAlOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRyYW5zZm9ybS1vcmlnaW46IHRvcCBsZWZ0OyB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMjUwbXMgZWFzZTsgd2lkdGg6IDEwMCU7IH0gOmhvc3QgLm1kLXByb2dyZXNzLWJhci1zZWNvbmRhcnkgeyB2aXNpYmlsaXR5OiBoaWRkZW47IH0gOmhvc3QgLm1kLXByb2dyZXNzLWJhci1maWxsIHsgYW5pbWF0aW9uOiBub25lOyBoZWlnaHQ6IDEwMCU7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdHJhbnNmb3JtLW9yaWdpbjogdG9wIGxlZnQ7IHRyYW5zaXRpb246IHRyYW5zZm9ybSAyNTBtcyBlYXNlOyB3aWR0aDogMTAwJTsgfSA6aG9zdCAubWQtcHJvZ3Jlc3MtYmFyLWZpbGw6OmFmdGVyIHsgYW5pbWF0aW9uOiBub25lOyBjb250ZW50OiAnJzsgZGlzcGxheTogaW5saW5lLWJsb2NrOyBoZWlnaHQ6IDEwMCU7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDEwMCU7IH0gOmhvc3RbbW9kZT0ncXVlcnknXSB7IHRyYW5zZm9ybTogcm90YXRlWigxODBkZWcpOyB9IDpob3N0W21vZGU9J2luZGV0ZXJtaW5hdGUnXSAubWQtcHJvZ3Jlc3MtYmFyLWZpbGwsIDpob3N0W21vZGU9J3F1ZXJ5J10gLm1kLXByb2dyZXNzLWJhci1maWxsIHsgdHJhbnNpdGlvbjogbm9uZTsgfSA6aG9zdFttb2RlPSdpbmRldGVybWluYXRlJ10gLm1kLXByb2dyZXNzLWJhci1wcmltYXJ5LCA6aG9zdFttb2RlPSdxdWVyeSddIC5tZC1wcm9ncmVzcy1iYXItcHJpbWFyeSB7IGFuaW1hdGlvbjogbWQtcHJvZ3Jlc3MtYmFyLXByaW1hcnktaW5kZXRlcm1pbmF0ZS10cmFuc2xhdGUgMjAwMG1zIGluZmluaXRlIGxpbmVhcjsgbGVmdDogLTE0NS4xNjY2MTElOyB9IDpob3N0W21vZGU9J2luZGV0ZXJtaW5hdGUnXSAubWQtcHJvZ3Jlc3MtYmFyLXByaW1hcnkubWQtcHJvZ3Jlc3MtYmFyLWZpbGw6OmFmdGVyLCA6aG9zdFttb2RlPSdxdWVyeSddIC5tZC1wcm9ncmVzcy1iYXItcHJpbWFyeS5tZC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXIgeyBhbmltYXRpb246IG1kLXByb2dyZXNzLWJhci1wcmltYXJ5LWluZGV0ZXJtaW5hdGUtc2NhbGUgMjAwMG1zIGluZmluaXRlIGxpbmVhcjsgfSA6aG9zdFttb2RlPSdpbmRldGVybWluYXRlJ10gLm1kLXByb2dyZXNzLWJhci1zZWNvbmRhcnksIDpob3N0W21vZGU9J3F1ZXJ5J10gLm1kLXByb2dyZXNzLWJhci1zZWNvbmRhcnkgeyBhbmltYXRpb246IG1kLXByb2dyZXNzLWJhci1zZWNvbmRhcnktaW5kZXRlcm1pbmF0ZS10cmFuc2xhdGUgMjAwMG1zIGluZmluaXRlIGxpbmVhcjsgbGVmdDogLTU0Ljg4ODg5MSU7IHZpc2liaWxpdHk6IHZpc2libGU7IH0gOmhvc3RbbW9kZT0naW5kZXRlcm1pbmF0ZSddIC5tZC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5Lm1kLXByb2dyZXNzLWJhci1maWxsOjphZnRlciwgOmhvc3RbbW9kZT0ncXVlcnknXSAubWQtcHJvZ3Jlc3MtYmFyLXNlY29uZGFyeS5tZC1wcm9ncmVzcy1iYXItZmlsbDo6YWZ0ZXIgeyBhbmltYXRpb246IG1kLXByb2dyZXNzLWJhci1zZWNvbmRhcnktaW5kZXRlcm1pbmF0ZS1zY2FsZSAyMDAwbXMgaW5maW5pdGUgbGluZWFyOyB9IDpob3N0W21vZGU9J2J1ZmZlciddIC5tZC1wcm9ncmVzcy1iYXItYmFja2dyb3VuZCB7IGFuaW1hdGlvbjogbWQtcHJvZ3Jlc3MtYmFyLWJhY2tncm91bmQtc2Nyb2xsIDI1MG1zIGluZmluaXRlIGxpbmVhcjsgdmlzaWJpbGl0eTogdmlzaWJsZTsgfSA6aG9zdC1jb250ZXh0KFtkaXI9J3J0bCddKSB7IHRyYW5zZm9ybTogcm90YXRlWSgxODBkZWcpOyB9IEBrZXlmcmFtZXMgbWQtcHJvZ3Jlc3MtYmFyLXByaW1hcnktaW5kZXRlcm1pbmF0ZS10cmFuc2xhdGUgeyAwJSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTsgfSAyMCUgeyBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC41LCAwLCAwLjcwMTczLCAwLjQ5NTgyKTsgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApOyB9IDU5LjE1JSB7IGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjMwMjQ0LCAwLjM4MTM1LCAwLjU1LCAwLjk1NjM1KTsgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDgzLjY3MTQyJSk7IH0gMTAwJSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlWCgyMDAuNjExMDYlKTsgfSB9IEBrZXlmcmFtZXMgbWQtcHJvZ3Jlc3MtYmFyLXByaW1hcnktaW5kZXRlcm1pbmF0ZS1zY2FsZSB7IDAlIHsgdHJhbnNmb3JtOiBzY2FsZVgoMC4wOCk7IH0gMzYuNjUlIHsgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuMzM0NzMsIDAuMTI0ODIsIDAuNzg1ODQsIDEpOyB0cmFuc2Zvcm06IHNjYWxlWCgwLjA4KTsgfSA2OS4xNSUgeyBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4wNiwgMC4xMSwgMC42LCAxKTsgdHJhbnNmb3JtOiBzY2FsZVgoMC42NjE0OCk7IH0gMTAwJSB7IHRyYW5zZm9ybTogc2NhbGVYKDAuMDgpOyB9IH0gQGtleWZyYW1lcyBtZC1wcm9ncmVzcy1iYXItc2Vjb25kYXJ5LWluZGV0ZXJtaW5hdGUtdHJhbnNsYXRlIHsgMCUgeyBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4xNSwgMCwgMC41MTUwNiwgMC40MDk2OSk7IHRyYW5zZm9ybTogdHJhbnNsYXRlWCgwKTsgfSAyNSUgeyBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4zMTAzMywgMC4yODQwNiwgMC44LCAwLjczMzcxKTsgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDM3LjY1MTkxJSk7IH0gNDguMzUlIHsgYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNCwgMC42MjcwNCwgMC42LCAwLjkwMjAzKTsgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDg0LjM4NjE3JSk7IH0gMTAwJSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxNjAuMjc3NzglKTsgfSB9IEBrZXlmcmFtZXMgbWQtcHJvZ3Jlc3MtYmFyLXNlY29uZGFyeS1pbmRldGVybWluYXRlLXNjYWxlIHsgMCUgeyBhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC4xNSwgMCwgMC41MTUwNiwgMC40MDk2OSk7IHRyYW5zZm9ybTogc2NhbGVYKDAuMDgpOyB9IDE5LjE1JSB7IGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjMxMDMzLCAwLjI4NDA2LCAwLjgsIDAuNzMzNzEpOyB0cmFuc2Zvcm06IHNjYWxlWCgwLjQ1NzEpOyB9IDQ0LjE1JSB7IGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAuNjI3MDQsIDAuNiwgMC45MDIwMyk7IHRyYW5zZm9ybTogc2NhbGVYKDAuNzI3OTYpOyB9IDEwMCUgeyB0cmFuc2Zvcm06IHNjYWxlWCgwLjA4KTsgfSB9IEBrZXlmcmFtZXMgbWQtcHJvZ3Jlc3MtYmFyLWJhY2tncm91bmQtc2Nyb2xsIHsgdG8geyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTEwcHgpOyB9IH0gLyojIHNvdXJjZU1hcHBpbmdVUkw9cHJvZ3Jlc3MtYmFyLmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBfYW5ndWxhcl9jb3JlLkNoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDMyKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kUHJvZ3Jlc3NCYXIpO1xuICAgIHJldHVybiBNZFByb2dyZXNzQmFyO1xufSgpKTtcbi8qKiBDbGFtcHMgYSB2YWx1ZSB0byBiZSBiZXR3ZWVuIHR3byBudW1iZXJzLCBieSBkZWZhdWx0IDAgYW5kIDEwMC4gKi9cbmZ1bmN0aW9uIGNsYW1wJDEodiwgbWluLCBtYXgpIHtcbiAgICBpZiAobWluID09PSB2b2lkIDApIHsgbWluID0gMDsgfVxuICAgIGlmIChtYXggPT09IHZvaWQgMCkgeyBtYXggPSAxMDA7IH1cbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHYpKTtcbn1cbnZhciBNZFByb2dyZXNzQmFyTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFByb2dyZXNzQmFyTW9kdWxlKCkge1xuICAgIH1cbiAgICBNZFByb2dyZXNzQmFyTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRQcm9ncmVzc0Jhck1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kUHJvZ3Jlc3NCYXJNb2R1bGUgPSBfX2RlY29yYXRlJDMyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbX2FuZ3VsYXJfY29tbW9uLkNvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRQcm9ncmVzc0Jhcl0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFByb2dyZXNzQmFyXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDMyKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kUHJvZ3Jlc3NCYXJNb2R1bGUpO1xuICAgIHJldHVybiBNZFByb2dyZXNzQmFyTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZXh0ZW5kcyQxMyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQzMyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQzMyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG52YXIgTURfSU5QVVRfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBfYW5ndWxhcl9mb3Jtcy5OR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogX2FuZ3VsYXJfY29yZS5mb3J3YXJkUmVmKGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1kSW5wdXQ7IH0pLFxuICAgIG11bHRpOiB0cnVlXG59O1xuLy8gSW52YWxpZCBpbnB1dCB0eXBlLiBVc2luZyBvbmUgb2YgdGhlc2Ugd2lsbCB0aHJvdyBhbiBNZElucHV0VW5zdXBwb3J0ZWRUeXBlRXJyb3IuXG52YXIgTURfSU5QVVRfSU5WQUxJRF9JTlBVVF9UWVBFID0gW1xuICAgICdmaWxlJyxcbiAgICAncmFkaW8nLFxuICAgICdjaGVja2JveCcsXG5dO1xudmFyIG5leHRVbmlxdWVJZCQxID0gMDtcbnZhciBNZElucHV0UGxhY2Vob2xkZXJDb25mbGljdEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTMoTWRJbnB1dFBsYWNlaG9sZGVyQ29uZmxpY3RFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZElucHV0UGxhY2Vob2xkZXJDb25mbGljdEVycm9yKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnUGxhY2Vob2xkZXIgYXR0cmlidXRlIGFuZCBjaGlsZCBlbGVtZW50IHdlcmUgYm90aCBzcGVjaWZpZWQuJyk7XG4gICAgfVxuICAgIHJldHVybiBNZElucHV0UGxhY2Vob2xkZXJDb25mbGljdEVycm9yO1xufShNZEVycm9yKSk7XG52YXIgTWRJbnB1dFVuc3VwcG9ydGVkVHlwZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTMoTWRJbnB1dFVuc3VwcG9ydGVkVHlwZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kSW5wdXRVbnN1cHBvcnRlZFR5cGVFcnJvcih0eXBlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiSW5wdXQgdHlwZSBcXFwiXCIgKyB0eXBlICsgXCJcXFwiIGlzbid0IHN1cHBvcnRlZCBieSBtZC1pbnB1dC5cIik7XG4gICAgfVxuICAgIHJldHVybiBNZElucHV0VW5zdXBwb3J0ZWRUeXBlRXJyb3I7XG59KE1kRXJyb3IpKTtcbnZhciBNZElucHV0RHVwbGljYXRlZEhpbnRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDEzKE1kSW5wdXREdXBsaWNhdGVkSGludEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kSW5wdXREdXBsaWNhdGVkSGludEVycm9yKGFsaWduKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwiQSBoaW50IHdhcyBhbHJlYWR5IGRlY2xhcmVkIGZvciAnYWxpZ249XFxcIlwiICsgYWxpZ24gKyBcIlxcXCInLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIE1kSW5wdXREdXBsaWNhdGVkSGludEVycm9yO1xufShNZEVycm9yKSk7XG4vKipcbiAqIFRoZSBwbGFjZWhvbGRlciBkaXJlY3RpdmUuIFRoZSBjb250ZW50IGNhbiBkZWNsYXJlIHRoaXMgdG8gaW1wbGVtZW50IG1vcmVcbiAqIGNvbXBsZXggcGxhY2Vob2xkZXJzLlxuICovXG52YXIgTWRQbGFjZWhvbGRlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRQbGFjZWhvbGRlcigpIHtcbiAgICB9XG4gICAgTWRQbGFjZWhvbGRlciA9IF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLXBsYWNlaG9sZGVyJ1xuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRQbGFjZWhvbGRlcik7XG4gICAgcmV0dXJuIE1kUGxhY2Vob2xkZXI7XG59KCkpO1xuLyoqIFRoZSBoaW50IGRpcmVjdGl2ZSwgdXNlZCB0byB0YWcgY29udGVudCBhcyBoaW50IGxhYmVscyAoZ29pbmcgdW5kZXIgdGhlIGlucHV0KS4gKi9cbnZhciBNZEhpbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kSGludCgpIHtcbiAgICAgICAgLy8gV2hldGhlciB0byBhbGlnbiB0aGUgaGludCBsYWJlbCBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBsaW5lLlxuICAgICAgICB0aGlzLmFsaWduID0gJ3N0YXJ0JztcbiAgICB9XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kSGludC5wcm90b3R5cGUsIFwiYWxpZ25cIiwgdm9pZCAwKTtcbiAgICBNZEhpbnQgPSBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC1oaW50JyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1kLXJpZ2h0XSc6ICdhbGlnbiA9PSBcImVuZFwiJyxcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1kLWhpbnRdJzogJ3RydWUnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZEhpbnQpO1xuICAgIHJldHVybiBNZEhpbnQ7XG59KCkpO1xuLyoqXG4gKiBDb21wb25lbnQgdGhhdCByZXByZXNlbnRzIGEgdGV4dCBpbnB1dC4gSXQgZW5jYXBzdWxhdGVzIHRoZSA8aW5wdXQ+IEhUTUxFbGVtZW50IGFuZFxuICogaW1wcm92ZSBvbiBpdHMgYmVoYXZpb3VyLCBhbG9uZyB3aXRoIHN0eWxpbmcgaXQgYWNjb3JkaW5nIHRvIHRoZSBNYXRlcmlhbCBEZXNpZ24uXG4gKi9cbnZhciBNZElucHV0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZElucHV0KCkge1xuICAgICAgICB0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gJyc7XG4gICAgICAgIC8qKiBDYWxsYmFjayByZWdpc3RlcmVkIHZpYSByZWdpc3Rlck9uVG91Y2hlZCAoQ29udHJvbFZhbHVlQWNjZXNzb3IpICovXG4gICAgICAgIHRoaXMuX29uVG91Y2hlZENhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgLyoqIENhbGxiYWNrIHJlZ2lzdGVyZWQgdmlhIHJlZ2lzdGVyT25DaGFuZ2UgKENvbnRyb2xWYWx1ZUFjY2Vzc29yKSAqL1xuICAgICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJpbmRpbmdzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbGlnbiA9ICdzdGFydCc7XG4gICAgICAgIHRoaXMuZGl2aWRlckNvbG9yID0gJ3ByaW1hcnknO1xuICAgICAgICB0aGlzLmZsb2F0aW5nUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLmhpbnRMYWJlbCA9ICcnO1xuICAgICAgICB0aGlzLmF1dG9mb2N1cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaWQgPSBcIm1kLWlucHV0LVwiICsgbmV4dFVuaXF1ZUlkJDErKztcbiAgICAgICAgdGhpcy5saXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYXggPSBudWxsO1xuICAgICAgICB0aGlzLm1heGxlbmd0aCA9IG51bGw7XG4gICAgICAgIHRoaXMubWluID0gbnVsbDtcbiAgICAgICAgdGhpcy5taW5sZW5ndGggPSBudWxsO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlcXVpcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3BlbGxjaGVjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0ZXAgPSBudWxsO1xuICAgICAgICB0aGlzLnRhYmluZGV4ID0gbnVsbDtcbiAgICAgICAgdGhpcy50eXBlID0gJ3RleHQnO1xuICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9ibHVyRW1pdHRlciA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9mb2N1c0VtaXR0ZXIgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kSW5wdXQucHJvdG90eXBlLCBcImZvY3VzZWRcIiwge1xuICAgICAgICAvKiogUmVhZG9ubHkgcHJvcGVydGllcy4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9mb2N1c2VkOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dC5wcm90b3R5cGUsIFwiZW1wdHlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh0aGlzLl92YWx1ZSA9PSBudWxsIHx8IHRoaXMuX3ZhbHVlID09PSAnJykgJiYgdGhpcy50eXBlICE9PSAnZGF0ZSc7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0LnByb3RvdHlwZSwgXCJjaGFyYWN0ZXJDb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHkgPyAwIDogKCcnICsgdGhpcy5fdmFsdWUpLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kSW5wdXQucHJvdG90eXBlLCBcImlucHV0SWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaWQgKyBcIi1pbnB1dFwiOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dC5wcm90b3R5cGUsIFwib25CbHVyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmx1ckVtaXR0ZXIuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZElucHV0LnByb3RvdHlwZSwgXCJvbkZvY3VzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm9jdXNFbWl0dGVyLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2ID0gdGhpcy5fY29udmVydFZhbHVlRm9ySW5wdXRUeXBlKHYpO1xuICAgICAgICAgICAgaWYgKHYgIT09IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xuICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sodik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRJbnB1dC5wcm90b3R5cGUsIFwiX2FsaWduXCIsIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0byByZW1vdmUgdGhlIGBhbGlnbmAgcHJvcGVydHkgb2YgdGhlIGBtZC1pbnB1dGAgaXRzZWxmLiBPdGhlcndpc2UgSFRNTDVcbiAgICAgICAgLy8gbWlnaHQgcGxhY2UgaXQgYXMgUlRMIHdoZW4gd2UgZG9uJ3Qgd2FudCB0by4gV2Ugc3RpbGwgd2FudCB0byB1c2UgYGFsaWduYCBhcyBhblxuICAgICAgICAvLyBJbnB1dCB0aG91Z2gsIHNvIHdlIHVzZSBIb3N0QmluZGluZy5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogU2V0IGZvY3VzIG9uIGlucHV0ICovXG4gICAgTWRJbnB1dC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2lucHV0RWxlbWVudC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfTtcbiAgICBNZElucHV0LnByb3RvdHlwZS5faGFuZGxlRm9jdXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2ZvY3VzRW1pdHRlci5lbWl0KGV2ZW50KTtcbiAgICB9O1xuICAgIE1kSW5wdXQucHJvdG90eXBlLl9oYW5kbGVCbHVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb25Ub3VjaGVkQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy5fYmx1ckVtaXR0ZXIuZW1pdChldmVudCk7XG4gICAgfTtcbiAgICBNZElucHV0LnByb3RvdHlwZS5faGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBldmVudC50YXJnZXQudmFsdWU7XG4gICAgICAgIHRoaXMuX29uVG91Y2hlZENhbGxiYWNrKCk7XG4gICAgfTtcbiAgICBNZElucHV0LnByb3RvdHlwZS5faGFzUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucGxhY2Vob2xkZXIgfHwgdGhpcy5fcGxhY2Vob2xkZXJDaGlsZCAhPSBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50ZWQgYXMgcGFydCBvZiBDb250cm9sVmFsdWVBY2Nlc3Nvci5cbiAgICAgKiBUT0RPOiBpbnRlcm5hbFxuICAgICAqL1xuICAgIE1kSW5wdXQucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogVE9ETzogaW50ZXJuYWxcbiAgICAgKi9cbiAgICBNZElucHV0LnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSBmbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGVkIGFzIHBhcnQgb2YgQ29udHJvbFZhbHVlQWNjZXNzb3IuXG4gICAgICogVE9ETzogaW50ZXJuYWxcbiAgICAgKi9cbiAgICBNZElucHV0LnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0aGlzLl9vblRvdWNoZWRDYWxsYmFjayA9IGZuO1xuICAgIH07XG4gICAgLyoqIFRPRE86IGludGVybmFsICovXG4gICAgTWRJbnB1dC5wcm90b3R5cGUubmdBZnRlckNvbnRlbnRJbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZUNvbnN0cmFpbnRzKCk7XG4gICAgICAgIC8vIFRyaWdnZXIgdmFsaWRhdGlvbiB3aGVuIHRoZSBoaW50IGNoaWxkcmVuIGNoYW5nZS5cbiAgICAgICAgdGhpcy5faGludENoaWxkcmVuLmNoYW5nZXMuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl92YWxpZGF0ZUNvbnN0cmFpbnRzKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIFRPRE86IGludGVybmFsICovXG4gICAgTWRJbnB1dC5wcm90b3R5cGUubmdPbkNoYW5nZXMgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xuICAgICAgICB0aGlzLl92YWxpZGF0ZUNvbnN0cmFpbnRzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSB2YWx1ZSBwYXNzZWQgaW4gdG8gYSB2YWx1ZSB0aGF0IGlzIGV4cGVjdGVkIGZyb20gdGhlIHR5cGUgb2YgdGhlIG1kLWlucHV0LlxuICAgICAqIFRoaXMgaXMgbm9ybWFsbHkgcGVyZm9ybWVkIGJ5IHRoZSAqX1ZBTFVFX0FDQ0VTU09SIGluIGZvcm1zLCBidXQgc2luY2UgdGhlIHR5cGUgaXMgYm91bmRcbiAgICAgKiBvbiBvdXIgaW50ZXJuYWwgaW5wdXQgaXQgd29uJ3Qgd29yayBsb2NhbGx5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTWRJbnB1dC5wcm90b3R5cGUuX2NvbnZlcnRWYWx1ZUZvcklucHV0VHlwZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOiByZXR1cm4gcGFyc2VGbG9hdCh2KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiB2O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCBhbGwgY29uc3RyYWludHMgZGVmaW5lZCBieSB0aGUgQVBJIGFyZSB2YWxpZGF0ZWQsIG9yIHRocm93IGVycm9ycyBvdGhlcndpc2UuXG4gICAgICogQ29uc3RyYWludHMgZm9yIG5vdzpcbiAgICAgKiAgIC0gcGxhY2Vob2xkZXIgYXR0cmlidXRlIGFuZCA8bWQtcGxhY2Vob2xkZXI+IGFyZSBtdXR1YWxseSBleGNsdXNpdmUuXG4gICAgICogICAtIHR5cGUgYXR0cmlidXRlIGlzIG5vdCBvbmUgb2YgdGhlIGZvcmJpZGRlbiB0eXBlcyAoc2VlIGNvbnN0YW50IGF0IHRoZSB0b3ApLlxuICAgICAqICAgLSBNYXhpbXVtIG9uZSBvZiBlYWNoIGA8bWQtaGludD5gIGFsaWdubWVudCBzcGVjaWZpZWQsIHdpdGggdGhlIGF0dHJpYnV0ZSBiZWluZ1xuICAgICAqICAgICBjb25zaWRlcmVkIGFzIGFsaWduPVwic3RhcnRcIi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIE1kSW5wdXQucHJvdG90eXBlLl92YWxpZGF0ZUNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5wbGFjZWhvbGRlciAhPSAnJyAmJiB0aGlzLnBsYWNlaG9sZGVyICE9IG51bGwgJiYgdGhpcy5fcGxhY2Vob2xkZXJDaGlsZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWRJbnB1dFBsYWNlaG9sZGVyQ29uZmxpY3RFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNRF9JTlBVVF9JTlZBTElEX0lOUFVUX1RZUEUuaW5kZXhPZih0aGlzLnR5cGUpICE9IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWRJbnB1dFVuc3VwcG9ydGVkVHlwZUVycm9yKHRoaXMudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2hpbnRDaGlsZHJlbikge1xuICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGhpbnQgbGFiZWxzLlxuICAgICAgICAgICAgdmFyIHN0YXJ0SGludF8xID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBlbmRIaW50XzEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faGludENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGhpbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGludC5hbGlnbiA9PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydEhpbnRfMSB8fCBfdGhpcy5oaW50TGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNZElucHV0RHVwbGljYXRlZEhpbnRFcnJvcignc3RhcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGFydEhpbnRfMSA9IGhpbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhpbnQuYWxpZ24gPT0gJ2VuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEhpbnRfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1kSW5wdXREdXBsaWNhdGVkSGludEVycm9yKCdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbmRIaW50XzEgPSBoaW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnYXJpYS1sYWJlbCcpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRJbnB1dC5wcm90b3R5cGUsIFwiYXJpYUxhYmVsXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2FyaWEtbGFiZWxsZWRieScpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRJbnB1dC5wcm90b3R5cGUsIFwiYXJpYUxhYmVsbGVkQnlcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnYXJpYS1kaXNhYmxlZCcpLFxuICAgICAgICBCb29sZWFuRmllbGRWYWx1ZSgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kSW5wdXQucHJvdG90eXBlLCBcImFyaWFEaXNhYmxlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdhcmlhLXJlcXVpcmVkJyksXG4gICAgICAgIEJvb2xlYW5GaWVsZFZhbHVlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRJbnB1dC5wcm90b3R5cGUsIFwiYXJpYVJlcXVpcmVkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoJ2FyaWEtaW52YWxpZCcpLFxuICAgICAgICBCb29sZWFuRmllbGRWYWx1ZSgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kSW5wdXQucHJvdG90eXBlLCBcImFyaWFJbnZhbGlkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29udGVudENoaWxkKE1kUGxhY2Vob2xkZXIpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBNZFBsYWNlaG9sZGVyKVxuICAgIF0sIE1kSW5wdXQucHJvdG90eXBlLCBcIl9wbGFjZWhvbGRlckNoaWxkXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29udGVudENoaWxkcmVuKE1kSGludCksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuUXVlcnlMaXN0KVxuICAgIF0sIE1kSW5wdXQucHJvdG90eXBlLCBcIl9oaW50Q2hpbGRyZW5cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRJbnB1dC5wcm90b3R5cGUsIFwiYWxpZ25cIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRJbnB1dC5wcm90b3R5cGUsIFwiZGl2aWRlckNvbG9yXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSxcbiAgICAgICAgQm9vbGVhbkZpZWxkVmFsdWUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZElucHV0LnByb3RvdHlwZSwgXCJmbG9hdGluZ1BsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kSW5wdXQucHJvdG90eXBlLCBcImhpbnRMYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZElucHV0LnByb3RvdHlwZSwgXCJhdXRvY29tcGxldGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRJbnB1dC5wcm90b3R5cGUsIFwiYXV0b2NvcnJlY3RcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRJbnB1dC5wcm90b3R5cGUsIFwiYXV0b2NhcGl0YWxpemVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLFxuICAgICAgICBCb29sZWFuRmllbGRWYWx1ZSgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kSW5wdXQucHJvdG90eXBlLCBcImF1dG9mb2N1c1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksXG4gICAgICAgIEJvb2xlYW5GaWVsZFZhbHVlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRJbnB1dC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRJbnB1dC5wcm90b3R5cGUsIFwiaWRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRJbnB1dC5wcm90b3R5cGUsIFwibGlzdFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZElucHV0LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBOdW1iZXIpXG4gICAgXSwgTWRJbnB1dC5wcm90b3R5cGUsIFwibWF4bGVuZ3RoXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgT2JqZWN0KVxuICAgIF0sIE1kSW5wdXQucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246dHlwZScsIE51bWJlcilcbiAgICBdLCBNZElucHV0LnByb3RvdHlwZSwgXCJtaW5sZW5ndGhcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRJbnB1dC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLFxuICAgICAgICBCb29sZWFuRmllbGRWYWx1ZSgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBCb29sZWFuKVxuICAgIF0sIE1kSW5wdXQucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSxcbiAgICAgICAgQm9vbGVhbkZpZWxkVmFsdWUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZElucHV0LnByb3RvdHlwZSwgXCJyZXF1aXJlZFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksXG4gICAgICAgIEJvb2xlYW5GaWVsZFZhbHVlKCksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246dHlwZScsIEJvb2xlYW4pXG4gICAgXSwgTWRJbnB1dC5wcm90b3R5cGUsIFwic3BlbGxjaGVja1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246dHlwZScsIE51bWJlcilcbiAgICBdLCBNZElucHV0LnByb3RvdHlwZSwgXCJzdGVwXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgTnVtYmVyKVxuICAgIF0sIE1kSW5wdXQucHJvdG90eXBlLCBcInRhYmluZGV4XCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKVxuICAgIF0sIE1kSW5wdXQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRJbnB1dC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgnYmx1cicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCByeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZSlcbiAgICBdLCBNZElucHV0LnByb3RvdHlwZSwgXCJvbkJsdXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCdmb2N1cycpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCByeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZSlcbiAgICBdLCBNZElucHV0LnByb3RvdHlwZSwgXCJvbkZvY3VzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZElucHV0LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnYXR0ci5hbGlnbicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzMygnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRJbnB1dC5wcm90b3R5cGUsIFwiX2FsaWduXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZCgnaW5wdXQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmKVxuICAgIF0sIE1kSW5wdXQucHJvdG90eXBlLCBcIl9pbnB1dEVsZW1lbnRcIiwgdm9pZCAwKTtcbiAgICBNZElucHV0ID0gX19kZWNvcmF0ZSQzMyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLWlucHV0JyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1kLWlucHV0LXdyYXBwZXJcXFwiPiA8ZGl2IGNsYXNzPVxcXCJtZC1pbnB1dC10YWJsZVxcXCI+IDxkaXYgY2xhc3M9XFxcIm1kLWlucHV0LXByZWZpeFxcXCI+PG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJbbWQtcHJlZml4XVxcXCI+PC9uZy1jb250ZW50PjwvZGl2PiA8ZGl2IGNsYXNzPVxcXCJtZC1pbnB1dC1pbmZpeFxcXCI+IDxpbnB1dCAjaW5wdXQgYXJpYS10YXJnZXQgY2xhc3M9XFxcIm1kLWlucHV0LWVsZW1lbnRcXFwiIFtjbGFzcy5tZC1lbmRdPVxcXCJhbGlnbiA9PSAnZW5kJ1xcXCIgW2F0dHIuYXJpYS1sYWJlbF09XFxcImFyaWFMYWJlbFxcXCIgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cXFwiYXJpYUxhYmVsbGVkQnlcXFwiIFthdHRyLmFyaWEtZGlzYWJsZWRdPVxcXCJhcmlhRGlzYWJsZWRcXFwiIFthdHRyLmFyaWEtcmVxdWlyZWRdPVxcXCJhcmlhUmVxdWlyZWRcXFwiIFthdHRyLmFyaWEtaW52YWxpZF09XFxcImFyaWFJbnZhbGlkXFxcIiBbYXR0ci5hdXRvY29tcGxldGVdPVxcXCJhdXRvY29tcGxldGVcXFwiIFthdHRyLmF1dG9jb3JyZWN0XT1cXFwiYXV0b2NvcnJlY3RcXFwiIFthdHRyLmF1dG9jYXBpdGFsaXplXT1cXFwiYXV0b2NhcGl0YWxpemVcXFwiIFthdXRvZm9jdXNdPVxcXCJhdXRvZm9jdXNcXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiBbaWRdPVxcXCJpbnB1dElkXFxcIiBbYXR0ci5saXN0XT1cXFwibGlzdFxcXCIgW2F0dHIubWF4XT1cXFwibWF4XFxcIiBbYXR0ci5tYXhsZW5ndGhdPVxcXCJtYXhsZW5ndGhcXFwiIFthdHRyLm1pbl09XFxcIm1pblxcXCIgW2F0dHIubWlubGVuZ3RoXT1cXFwibWlubGVuZ3RoXFxcIiBbcmVhZG9ubHldPVxcXCJyZWFkb25seVxcXCIgW3JlcXVpcmVkXT1cXFwicmVxdWlyZWRcXFwiIFtzcGVsbGNoZWNrXT1cXFwic3BlbGxjaGVja1xcXCIgW2F0dHIuc3RlcF09XFxcInN0ZXBcXFwiIFthdHRyLnRhYmluZGV4XT1cXFwidGFiaW5kZXhcXFwiIFt0eXBlXT1cXFwidHlwZVxcXCIgW2F0dHIubmFtZV09XFxcIm5hbWVcXFwiIChmb2N1cyk9XFxcIl9oYW5kbGVGb2N1cygkZXZlbnQpXFxcIiAoYmx1cik9XFxcIl9oYW5kbGVCbHVyKCRldmVudClcXFwiIFsobmdNb2RlbCldPVxcXCJ2YWx1ZVxcXCIgKGNoYW5nZSk9XFxcIl9oYW5kbGVDaGFuZ2UoJGV2ZW50KVxcXCI+IDxsYWJlbCBjbGFzcz1cXFwibWQtaW5wdXQtcGxhY2Vob2xkZXJcXFwiIFthdHRyLmZvcl09XFxcImlucHV0SWRcXFwiIFtjbGFzcy5tZC1lbXB0eV09XFxcImVtcHR5XFxcIiBbY2xhc3MubWQtZm9jdXNlZF09XFxcImZvY3VzZWRcXFwiIFtjbGFzcy5tZC1mbG9hdF09XFxcImZsb2F0aW5nUGxhY2Vob2xkZXJcXFwiIFtjbGFzcy5tZC1hY2NlbnRdPVxcXCJkaXZpZGVyQ29sb3IgPT0gJ2FjY2VudCdcXFwiIFtjbGFzcy5tZC13YXJuXT1cXFwiZGl2aWRlckNvbG9yID09ICd3YXJuJ1xcXCIgKm5nSWY9XFxcIl9oYXNQbGFjZWhvbGRlcigpXFxcIj4gPG5nLWNvbnRlbnQgc2VsZWN0PVxcXCJtZC1wbGFjZWhvbGRlclxcXCI+PC9uZy1jb250ZW50PiB7e3BsYWNlaG9sZGVyfX0gPHNwYW4gY2xhc3M9XFxcIm1kLXBsYWNlaG9sZGVyLXJlcXVpcmVkXFxcIiAqbmdJZj1cXFwicmVxdWlyZWRcXFwiPio8L3NwYW4+IDwvbGFiZWw+IDwvZGl2PiA8ZGl2IGNsYXNzPVxcXCJtZC1pbnB1dC1zdWZmaXhcXFwiPjxuZy1jb250ZW50IHNlbGVjdD1cXFwiW21kLXN1ZmZpeF1cXFwiPjwvbmctY29udGVudD48L2Rpdj4gPC9kaXY+IDxkaXYgY2xhc3M9XFxcIm1kLWlucHV0LXVuZGVybGluZVxcXCIgW2NsYXNzLm1kLWRpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiPiA8c3BhbiBjbGFzcz1cXFwibWQtaW5wdXQtcmlwcGxlXFxcIiBbY2xhc3MubWQtZm9jdXNlZF09XFxcImZvY3VzZWRcXFwiIFtjbGFzcy5tZC1hY2NlbnRdPVxcXCJkaXZpZGVyQ29sb3IgPT0gJ2FjY2VudCdcXFwiIFtjbGFzcy5tZC13YXJuXT1cXFwiZGl2aWRlckNvbG9yID09ICd3YXJuJ1xcXCI+PC9zcGFuPiA8L2Rpdj4gPGRpdiAqbmdJZj1cXFwiaGludExhYmVsICE9ICcnXFxcIiBjbGFzcz1cXFwibWQtaGludFxcXCI+e3toaW50TGFiZWx9fTwvZGl2PiA8bmctY29udGVudCBzZWxlY3Q9XFxcIm1kLWhpbnRcXFwiPjwvbmctY29udGVudD4gPC9kaXY+IFwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCJtZC1pbnB1dCB7IGRpc3BsYXk6IGlubGluZS1ibG9jazsgcG9zaXRpb246IHJlbGF0aXZlOyBmb250LWZhbWlseTogUm9ib3RvLCBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBzYW5zLXNlcmlmOyB0ZXh0LWFsaWduOiBsZWZ0OyB9IFtkaXI9J3J0bCddIG1kLWlucHV0IHsgdGV4dC1hbGlnbjogcmlnaHQ7IH0gLm1kLWlucHV0LXdyYXBwZXIgeyBtYXJnaW46IDE2cHggMDsgfSAubWQtaW5wdXQtdGFibGUgeyBkaXNwbGF5OiBpbmxpbmUtdGFibGU7IGZsZXgtZmxvdzogY29sdW1uOyB2ZXJ0aWNhbC1hbGlnbjogYm90dG9tOyB3aWR0aDogMTAwJTsgfSAubWQtaW5wdXQtdGFibGUgPiAqIHsgZGlzcGxheTogdGFibGUtY2VsbDsgfSAubWQtaW5wdXQtaW5maXggeyBwb3NpdGlvbjogcmVsYXRpdmU7IH0gLm1kLWlucHV0LWVsZW1lbnQgeyBmb250OiBpbmhlcml0OyBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsgY29sb3I6IGN1cnJlbnRDb2xvcjsgYm9yZGVyOiBub25lOyBvdXRsaW5lOiBub25lOyBwYWRkaW5nOiAwOyB3aWR0aDogMTAwJTsgfSAubWQtaW5wdXQtZWxlbWVudC5tZC1lbmQgeyB0ZXh0LWFsaWduOiByaWdodDsgfSBbZGlyPSdydGwnXSAubWQtaW5wdXQtZWxlbWVudC5tZC1lbmQgeyB0ZXh0LWFsaWduOiBsZWZ0OyB9IC5tZC1pbnB1dC1lbGVtZW50Oi1tb3otdWktaW52YWxpZCB7IGJveC1zaGFkb3c6IG5vbmU7IH0gLm1kLWlucHV0LWVsZW1lbnQ6LXdlYmtpdC1hdXRvZmlsbCArIC5tZC1pbnB1dC1wbGFjZWhvbGRlciB7IGRpc3BsYXk6IGJsb2NrOyBwYWRkaW5nLWJvdHRvbTogNXB4OyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTEwMCUpIHNjYWxlKDAuNzUpOyB3aWR0aDogMTMzLjMzMzMzJTsgfSAubWQtaW5wdXQtcGxhY2Vob2xkZXIgeyBwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDA7IHRvcDogMDsgZm9udC1zaXplOiAxMDAlOyBwb2ludGVyLWV2ZW50czogbm9uZTsgei1pbmRleDogMTsgd2lkdGg6IDEwMCU7IGRpc3BsYXk6IG5vbmU7IHdoaXRlLXNwYWNlOiBub3dyYXA7IHRleHQtb3ZlcmZsb3c6IGVsbGlwc2lzOyBvdmVyZmxvdy14OiBoaWRkZW47IHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTsgdHJhbnNmb3JtLW9yaWdpbjogYm90dG9tIGxlZnQ7IHRyYW5zaXRpb246IHRyYW5zZm9ybSA0MDBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKSwgc2NhbGUgNDAwbXMgY3ViaWMtYmV6aWVyKDAuMjUsIDAuOCwgMC4yNSwgMSksIGNvbG9yIDQwMG1zIGN1YmljLWJlemllcigwLjI1LCAwLjgsIDAuMjUsIDEpLCB3aWR0aCA0MDBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKTsgfSAubWQtaW5wdXQtcGxhY2Vob2xkZXIubWQtZW1wdHkgeyBkaXNwbGF5OiBibG9jazsgY3Vyc29yOiB0ZXh0OyB9IC5tZC1pbnB1dC1wbGFjZWhvbGRlci5tZC1mbG9hdDpub3QoLm1kLWVtcHR5KSwgLm1kLWlucHV0LXBsYWNlaG9sZGVyLm1kLWZsb2F0Lm1kLWZvY3VzZWQgeyBkaXNwbGF5OiBibG9jazsgcGFkZGluZy1ib3R0b206IDVweDsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMDAlKSBzY2FsZSgwLjc1KTsgd2lkdGg6IDEzMy4zMzMzMyU7IH0gW2Rpcj0ncnRsJ10gLm1kLWlucHV0LXBsYWNlaG9sZGVyIHsgdHJhbnNmb3JtLW9yaWdpbjogYm90dG9tIHJpZ2h0OyB9IC5tZC1pbnB1dC11bmRlcmxpbmUgeyBwb3NpdGlvbjogYWJzb2x1dGU7IGhlaWdodDogMXB4OyB3aWR0aDogMTAwJTsgbWFyZ2luLXRvcDogNHB4OyBib3JkZXItdG9wLXdpZHRoOiAxcHg7IGJvcmRlci10b3Atc3R5bGU6IHNvbGlkOyB9IC5tZC1pbnB1dC11bmRlcmxpbmUubWQtZGlzYWJsZWQgeyBib3JkZXItdG9wOiAwOyBiYWNrZ3JvdW5kLWltYWdlOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsIHJnYmEoMCwgMCwgMCwgMC4yNikgMCUsIHJnYmEoMCwgMCwgMCwgMC4yNikgMzMlLCB0cmFuc3BhcmVudCAwJSk7IGJhY2tncm91bmQtcG9zaXRpb246IDA7IGJhY2tncm91bmQtc2l6ZTogNHB4IDFweDsgYmFja2dyb3VuZC1yZXBlYXQ6IHJlcGVhdC14OyB9IC5tZC1pbnB1dC11bmRlcmxpbmUgLm1kLWlucHV0LXJpcHBsZSB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgaGVpZ2h0OiAycHg7IHotaW5kZXg6IDE7IHRvcDogLTFweDsgd2lkdGg6IDEwMCU7IHRyYW5zZm9ybS1vcmlnaW46IHRvcDsgb3BhY2l0eTogMDsgdHJhbnNmb3JtOiBzY2FsZVkoMCk7IHRyYW5zaXRpb246IHRyYW5zZm9ybSA0MDBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKSwgb3BhY2l0eSA0MDBtcyBjdWJpYy1iZXppZXIoMC4yNSwgMC44LCAwLjI1LCAxKTsgfSAubWQtaW5wdXQtdW5kZXJsaW5lIC5tZC1pbnB1dC1yaXBwbGUubWQtZm9jdXNlZCB7IG9wYWNpdHk6IDE7IHRyYW5zZm9ybTogc2NhbGVZKDEpOyB9IC5tZC1oaW50IHsgcG9zaXRpb246IGFic29sdXRlOyBmb250LXNpemU6IDc1JTsgYm90dG9tOiAtMC41ZW07IH0gLm1kLWhpbnQubWQtcmlnaHQgeyByaWdodDogMDsgfSBbZGlyPSdydGwnXSAubWQtaGludCB7IHJpZ2h0OiAwOyBsZWZ0OiBhdXRvOyB9IFtkaXI9J3J0bCddIC5tZC1oaW50Lm1kLXJpZ2h0IHsgcmlnaHQ6IGF1dG87IGxlZnQ6IDA7IH0gLyojIHNvdXJjZU1hcHBpbmdVUkw9aW5wdXQuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtNRF9JTlBVVF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICAgICAgICAgIGhvc3Q6IHsgJyhjbGljayknOiAnZm9jdXMoKScgfSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDMzKCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kSW5wdXQpO1xuICAgIHJldHVybiBNZElucHV0O1xufSgpKTtcbnZhciBNZElucHV0TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZElucHV0TW9kdWxlKCkge1xuICAgIH1cbiAgICBNZElucHV0TW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTWRJbnB1dE1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kSW5wdXRNb2R1bGUgPSBfX2RlY29yYXRlJDMzKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFBsYWNlaG9sZGVyLCBNZElucHV0LCBNZEhpbnRdLFxuICAgICAgICAgICAgaW1wb3J0czogW19hbmd1bGFyX2NvbW1vbi5Db21tb25Nb2R1bGUsIF9hbmd1bGFyX2Zvcm1zLkZvcm1zTW9kdWxlXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNZFBsYWNlaG9sZGVyLCBNZElucHV0LCBNZEhpbnRdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRJbnB1dE1vZHVsZSk7XG4gICAgcmV0dXJuIE1kSW5wdXRNb2R1bGU7XG59KCkpO1xuXG4vLyBUT0RPKGpvc2VwaHBlcnJvdHQpOiBJbXBsZW1lbnQgb25BY3Rpb24gb2JzZXJ2YWJsZS5cbi8qKlxuICogUmVmZXJlbmNlIHRvIGEgc25hY2sgYmFyIGRpc3BhdGNoZWQgZnJvbSB0aGUgc25hY2sgYmFyIHNlcnZpY2UuXG4gKi9cbnZhciBNZFNuYWNrQmFyUmVmID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNuYWNrQmFyUmVmKGluc3RhbmNlLCBfb3ZlcmxheVJlZikge1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gX292ZXJsYXlSZWY7XG4gICAgICAgIC8qKiBTdWJqZWN0IGZvciBub3RpZnlpbmcgdGhlIHVzZXIgdGhhdCB0aGUgc25hY2sgYmFyIGhhcyBjbG9zZWQuICovXG4gICAgICAgIHRoaXMuX2FmdGVyQ2xvc2VkID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XG4gICAgICAgIC8vIFNldHMgdGhlIHJlYWRvbmx5IGluc3RhbmNlIG9mIHRoZSBzbmFjayBiYXIgY29udGVudCBjb21wb25lbnQuXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqIERpc21pc3NlcyB0aGUgc25hY2sgYmFyLiAqL1xuICAgIE1kU25hY2tCYXJSZWYucHJvdG90eXBlLmRpc21pc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fYWZ0ZXJDbG9zZWQuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2FmdGVyQ2xvc2VkLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBHZXRzIGFuIG9ic2VydmFibGUgdGhhdCBpcyBub3RpZmllZCB3aGVuIHRoZSBzbmFjayBiYXIgaXMgZmluaXNoZWQgY2xvc2luZy4gKi9cbiAgICBNZFNuYWNrQmFyUmVmLnByb3RvdHlwZS5hZnRlckRpc21pc3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FmdGVyQ2xvc2VkLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIE1kU25hY2tCYXJSZWY7XG59KCkpO1xuXG52YXIgX19leHRlbmRzJDE1ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBNZFNuYWNrQmFyQ29udGVudEFscmVhZHlBdHRhY2hlZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDE1KE1kU25hY2tCYXJDb250ZW50QWxyZWFkeUF0dGFjaGVkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kU25hY2tCYXJDb250ZW50QWxyZWFkeUF0dGFjaGVkKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnQXR0ZW1wdGluZyB0byBhdHRhY2ggc25hY2sgYmFyIGNvbnRlbnQgYWZ0ZXIgY29udGVudCBpcyBhbHJlYWR5IGF0dGFjaGVkJyk7XG4gICAgfVxuICAgIHJldHVybiBNZFNuYWNrQmFyQ29udGVudEFscmVhZHlBdHRhY2hlZDtcbn0oTWRFcnJvcikpO1xuXG52YXIgX19leHRlbmRzJDE0ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBfX2RlY29yYXRlJDM1ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDM1ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIEludGVybmFsIGNvbXBvbmVudCB0aGF0IHdyYXBzIHVzZXItcHJvdmlkZWQgc25hY2sgYmFyIGNvbnRlbnQuXG4gKi9cbnZhciBNZFNuYWNrQmFyQ29udGFpbmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTQoTWRTbmFja0JhckNvbnRhaW5lciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZFNuYWNrQmFyQ29udGFpbmVyKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLyoqIEF0dGFjaCBhIHBvcnRhbCBhcyBjb250ZW50IHRvIHRoaXMgc25hY2sgYmFyIGNvbnRhaW5lci4gKi9cbiAgICBNZFNuYWNrQmFyQ29udGFpbmVyLnByb3RvdHlwZS5hdHRhY2hDb21wb25lbnRQb3J0YWwgPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIGlmICh0aGlzLl9wb3J0YWxIb3N0Lmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZFNuYWNrQmFyQ29udGVudEFscmVhZHlBdHRhY2hlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3J0YWxIb3N0LmF0dGFjaENvbXBvbmVudFBvcnRhbChwb3J0YWwpO1xuICAgIH07XG4gICAgTWRTbmFja0JhckNvbnRhaW5lci5wcm90b3R5cGUuYXR0YWNoVGVtcGxhdGVQb3J0YWwgPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdOb3QgeWV0IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDM1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5WaWV3Q2hpbGQoUG9ydGFsSG9zdERpcmVjdGl2ZSksIFxuICAgICAgICBfX21ldGFkYXRhJDM1KCdkZXNpZ246dHlwZScsIFBvcnRhbEhvc3REaXJlY3RpdmUpXG4gICAgXSwgTWRTbmFja0JhckNvbnRhaW5lci5wcm90b3R5cGUsIFwiX3BvcnRhbEhvc3RcIiwgdm9pZCAwKTtcbiAgICBNZFNuYWNrQmFyQ29udGFpbmVyID0gX19kZWNvcmF0ZSQzNShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ3NuYWNrLWJhci1jb250YWluZXInLFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHRlbXBsYXRlIHBvcnRhbEhvc3Q+PC90ZW1wbGF0ZT5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wiOmhvc3QgeyBib3gtc2hhZG93OiAwcHggMTFweCAxNXB4IC03cHggcmdiYSgwLCAwLCAwLCAwLjIpLCAwcHggMjRweCAzOHB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMTQpLCAwcHggOXB4IDQ2cHggOHB4IHJnYmEoMCwgMCwgMCwgMC4xMik7IGJhY2tncm91bmQ6ICMzMjMyMzI7IGJvcmRlci1yYWRpdXM6IDJweDsgZGlzcGxheTogYmxvY2s7IGhlaWdodDogMjBweDsgbWF4LXdpZHRoOiA1NjhweDsgbWluLXdpZHRoOiAyODhweDsgb3ZlcmZsb3c6IGhpZGRlbjsgcGFkZGluZzogMTRweCAyNHB4OyB9IC8qIyBzb3VyY2VNYXBwaW5nVVJMPXNuYWNrLWJhci1jb250YWluZXIuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAgICAgJ3JvbGUnOiAnYWxlcnQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFNuYWNrQmFyQ29udGFpbmVyKTtcbiAgICByZXR1cm4gTWRTbmFja0JhckNvbnRhaW5lcjtcbn0oQmFzZVBvcnRhbEhvc3QpKTtcblxudmFyIF9fZGVjb3JhdGUkMzYgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMzYgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogQSBjb21wb25lbnQgdXNlZCB0byBvcGVuIGFzIHRoZSBkZWZhdWx0IHNuYWNrIGJhciwgbWF0Y2hpbmcgbWF0ZXJpYWwgc3BlYy5cbiAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBzbmFjayBiYXIgc2VydmljZS5cbiAqL1xudmFyIFNpbXBsZVNuYWNrQmFyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTaW1wbGVTbmFja0JhcigpIHtcbiAgICB9XG4gICAgLyoqIERpc21pc3NlcyB0aGUgc25hY2sgYmFyLiAqL1xuICAgIFNpbXBsZVNuYWNrQmFyLnByb3RvdHlwZS5kaXNtaXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNuYWNrQmFyUmVmLmRpc21pc3MoKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTaW1wbGVTbmFja0Jhci5wcm90b3R5cGUsIFwiaGFzQWN0aW9uXCIsIHtcbiAgICAgICAgLyoqIElmIHRoZSBhY3Rpb24gYnV0dG9uIHNob3VsZCBiZSBzaG93bi4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiAhIXRoaXMuYWN0aW9uOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTaW1wbGVTbmFja0JhciA9IF9fZGVjb3JhdGUkMzYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdzaW1wbGUtc25hY2stYmFyJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxzcGFuIGNsYXNzPVxcXCJtZC1zaW1wbGUtc25hY2tiYXItbWVzc2FnZVxcXCI+e3ttZXNzYWdlfX08L3NwYW4+IDxidXR0b24gbWQtYnV0dG9uIGNsYXNzPVxcXCJtZC1zaW1wbGUtc25hY2tiYXItYWN0aW9uXFxcIiAqbmdJZj1cXFwiaGFzQWN0aW9uXFxcIiAoY2xpY2spPVxcXCJkaXNtaXNzKClcXFwiPnt7YWN0aW9ufX08L2J1dHRvbj5cIixcbiAgICAgICAgICAgIHN0eWxlczogW1wibWQtc2ltcGxlLXNuYWNrYmFyIHsgZGlzcGxheTogZmxleDsganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOyB9IC5tZC1zaW1wbGUtc25hY2tiYXItbWVzc2FnZSB7IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IGJvcmRlcjogbm9uZTsgY29sb3I6IHdoaXRlOyBmb250LWZhbWlseTogUm9ib3RvLCAnSGVsdmV0aWNhIE5ldWUnLCBzYW5zLXNlcmlmOyBmb250LXNpemU6IDE0cHg7IGxpbmUtaGVpZ2h0OiAyMHB4OyBvdXRsaW5lOiBub25lOyB0ZXh0LWRlY29yYXRpb246IG5vbmU7IHdvcmQtYnJlYWs6IGJyZWFrLWFsbDsgfSAubWQtc2ltcGxlLXNuYWNrYmFyLWFjdGlvbiB7IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IGNvbG9yOiB3aGl0ZTsgZmxvYXQ6IHJpZ2h0OyBmb250LXdlaWdodDogNjAwOyBsaW5lLWhlaWdodDogMjBweDsgbWFyZ2luOiAtNXB4IDAgMCA0OHB4OyBtaW4td2lkdGg6IGluaXRpYWw7IHBhZGRpbmc6IDVweDsgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTsgfSAvKiMgc291cmNlTWFwcGluZ1VSTD1zaW1wbGUtc25hY2stYmFyLmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzYoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgU2ltcGxlU25hY2tCYXIpO1xuICAgIHJldHVybiBTaW1wbGVTbmFja0Jhcjtcbn0oKSk7XG5cbnZhciBNZFNuYWNrQmFyQ29uZmlnID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFNuYWNrQmFyQ29uZmlnKHZpZXdDb250YWluZXJSZWYpIHtcbiAgICAgICAgLyoqIFRoZSBwb2xpdGVuZXNzIGxldmVsIGZvciB0aGUgTWRBcmlhTGl2ZUFubm91bmNlciBhbm5vdW5jZW1lbnQuICovXG4gICAgICAgIHRoaXMucG9saXRlbmVzcyA9ICdhc3NlcnRpdmUnO1xuICAgICAgICB0aGlzLnZpZXdDb250YWluZXJSZWYgPSB2aWV3Q29udGFpbmVyUmVmO1xuICAgIH1cbiAgICByZXR1cm4gTWRTbmFja0JhckNvbmZpZztcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDM0ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDM0ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vLyBUT0RPKGpvc2VwaHBlcnJvdHQpOiBBbmltYXRlIGVudHJhbmNlIGFuZCBleGl0IG9mIHNuYWNrIGJhcnMuXG4vLyBUT0RPKGpvc2VwaHBlcnJvdHQpOiBBdXRvbWF0ZSBkaXNtaXNzIGFmdGVyIHRpbWVvdXQuXG4vKipcbiAqIFNlcnZpY2UgdG8gZGlzcGF0Y2ggTWF0ZXJpYWwgRGVzaWduIHNuYWNrIGJhciBtZXNzYWdlcy5cbiAqL1xudmFyIE1kU25hY2tCYXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kU25hY2tCYXIoX292ZXJsYXksIF9saXZlKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXkgPSBfb3ZlcmxheTtcbiAgICAgICAgdGhpcy5fbGl2ZSA9IF9saXZlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuZCBkaXNwYXRjaGVzIGEgc25hY2sgYmFyIHdpdGggYSBjdXN0b20gY29tcG9uZW50IGZvciB0aGUgY29udGVudCwgcmVtb3ZpbmcgYW55XG4gICAgICogY3VycmVudGx5IG9wZW5lZCBzbmFjayBiYXJzLlxuICAgICAqL1xuICAgIE1kU25hY2tCYXIucHJvdG90eXBlLm9wZW5Gcm9tQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgY29uZmlnKSB7XG4gICAgICAgIGlmICh0aGlzLl9zbmFja0JhclJlZikge1xuICAgICAgICAgICAgdGhpcy5fc25hY2tCYXJSZWYuZGlzbWlzcygpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdmVybGF5UmVmID0gdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgICB2YXIgc25hY2tCYXJDb250YWluZXIgPSB0aGlzLl9hdHRhY2hTbmFja0JhckNvbnRhaW5lcihvdmVybGF5UmVmLCBjb25maWcpO1xuICAgICAgICB2YXIgbWRTbmFja0JhclJlZiA9IHRoaXMuX2F0dGFjaFNuYWNrYmFyQ29udGVudChjb21wb25lbnQsIHNuYWNrQmFyQ29udGFpbmVyLCBvdmVybGF5UmVmKTtcbiAgICAgICAgdGhpcy5fbGl2ZS5hbm5vdW5jZShjb25maWcuYW5ub3VuY2VtZW50TWVzc2FnZSwgY29uZmlnLnBvbGl0ZW5lc3MpO1xuICAgICAgICByZXR1cm4gbWRTbmFja0JhclJlZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIGRpc3BhdGNoZXMgYSBzbmFjayBiYXIuXG4gICAgICovXG4gICAgTWRTbmFja0Jhci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChtZXNzYWdlLCBhY3Rpb25MYWJlbCwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5hbm5vdW5jZW1lbnRNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdmFyIHNpbXBsZVNuYWNrQmFyUmVmID0gdGhpcy5vcGVuRnJvbUNvbXBvbmVudChTaW1wbGVTbmFja0JhciwgY29uZmlnKTtcbiAgICAgICAgc2ltcGxlU25hY2tCYXJSZWYuaW5zdGFuY2Uuc25hY2tCYXJSZWYgPSBzaW1wbGVTbmFja0JhclJlZjtcbiAgICAgICAgc2ltcGxlU25hY2tCYXJSZWYuaW5zdGFuY2UubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHNpbXBsZVNuYWNrQmFyUmVmLmluc3RhbmNlLmFjdGlvbiA9IGFjdGlvbkxhYmVsO1xuICAgICAgICByZXR1cm4gc2ltcGxlU25hY2tCYXJSZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyB0aGUgc25hY2sgYmFyIGNvbnRhaW5lciBjb21wb25lbnQgdG8gdGhlIG92ZXJsYXkuXG4gICAgICovXG4gICAgTWRTbmFja0Jhci5wcm90b3R5cGUuX2F0dGFjaFNuYWNrQmFyQ29udGFpbmVyID0gZnVuY3Rpb24gKG92ZXJsYXlSZWYsIGNvbmZpZykge1xuICAgICAgICB2YXIgY29udGFpbmVyUG9ydGFsID0gbmV3IENvbXBvbmVudFBvcnRhbChNZFNuYWNrQmFyQ29udGFpbmVyLCBjb25maWcudmlld0NvbnRhaW5lclJlZik7XG4gICAgICAgIHZhciBjb250YWluZXJSZWYgPSBvdmVybGF5UmVmLmF0dGFjaChjb250YWluZXJQb3J0YWwpO1xuICAgICAgICBjb250YWluZXJSZWYuaW5zdGFuY2Uuc25hY2tCYXJDb25maWcgPSBjb25maWc7XG4gICAgICAgIHJldHVybiBjb250YWluZXJSZWYuaW5zdGFuY2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQbGFjZXMgYSBuZXcgY29tcG9uZW50IGFzIHRoZSBjb250ZW50IG9mIHRoZSBzbmFjayBiYXIgY29udGFpbmVyLlxuICAgICAqL1xuICAgIE1kU25hY2tCYXIucHJvdG90eXBlLl9hdHRhY2hTbmFja2JhckNvbnRlbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50LCBjb250YWluZXIsIG92ZXJsYXlSZWYpIHtcbiAgICAgICAgdmFyIHBvcnRhbCA9IG5ldyBDb21wb25lbnRQb3J0YWwoY29tcG9uZW50KTtcbiAgICAgICAgdmFyIGNvbnRlbnRSZWYgPSBjb250YWluZXIuYXR0YWNoQ29tcG9uZW50UG9ydGFsKHBvcnRhbCk7XG4gICAgICAgIHZhciBzbmFja0JhclJlZiA9IG5ldyBNZFNuYWNrQmFyUmVmKGNvbnRlbnRSZWYuaW5zdGFuY2UsIG92ZXJsYXlSZWYpO1xuICAgICAgICB0aGlzLl9zbmFja0JhclJlZiA9IHNuYWNrQmFyUmVmO1xuICAgICAgICByZXR1cm4gc25hY2tCYXJSZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG92ZXJsYXkgYW5kIHBsYWNlcyBpdCBpbiB0aGUgY29ycmVjdCBsb2NhdGlvbi5cbiAgICAgKi9cbiAgICBNZFNuYWNrQmFyLnByb3RvdHlwZS5fY3JlYXRlT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpLmdsb2JhbCgpXG4gICAgICAgICAgICAuZml4ZWQoKVxuICAgICAgICAgICAgLmNlbnRlckhvcml6b250YWxseSgpXG4gICAgICAgICAgICAuYm90dG9tKCcwJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LmNyZWF0ZShzdGF0ZSk7XG4gICAgfTtcbiAgICBNZFNuYWNrQmFyID0gX19kZWNvcmF0ZSQzNChbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbT3ZlcmxheSwgTWRMaXZlQW5ub3VuY2VyXSlcbiAgICBdLCBNZFNuYWNrQmFyKTtcbiAgICByZXR1cm4gTWRTbmFja0Jhcjtcbn0oKSk7XG52YXIgTWRTbmFja0Jhck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRTbmFja0Jhck1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWRTbmFja0Jhck1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kU25hY2tCYXJNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtNZFNuYWNrQmFyLCBPVkVSTEFZX1BST1ZJREVSUywgTWRMaXZlQW5ub3VuY2VyXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRTbmFja0Jhck1vZHVsZSA9IF9fZGVjb3JhdGUkMzQoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtPdmVybGF5TW9kdWxlLCBQb3J0YWxNb2R1bGUsIF9hbmd1bGFyX2NvbW1vbi5Db21tb25Nb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW01kU25hY2tCYXJDb250YWluZXJdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRTbmFja0JhckNvbnRhaW5lciwgU2ltcGxlU25hY2tCYXJdLFxuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBbTWRTbmFja0JhckNvbnRhaW5lciwgU2ltcGxlU25hY2tCYXJdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzQoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRTbmFja0Jhck1vZHVsZSk7XG4gICAgcmV0dXJuIE1kU25hY2tCYXJNb2R1bGU7XG59KCkpO1xuXG52YXIgX19leHRlbmRzJDE2ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBfX2RlY29yYXRlJDM4ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDM4ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKiogVXNlZCB0byBmbGFnIHRhYiBsYWJlbHMgZm9yIHVzZSB3aXRoIHRoZSBwb3J0YWwgZGlyZWN0aXZlICovXG52YXIgTWRUYWJMYWJlbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzJDE2KE1kVGFiTGFiZWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRUYWJMYWJlbCh0ZW1wbGF0ZVJlZiwgdmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0ZW1wbGF0ZVJlZiwgdmlld0NvbnRhaW5lclJlZik7XG4gICAgfVxuICAgIE1kVGFiTGFiZWwgPSBfX2RlY29yYXRlJDM4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWQtdGFiLWxhYmVsXScsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiwgX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmXSlcbiAgICBdLCBNZFRhYkxhYmVsKTtcbiAgICByZXR1cm4gTWRUYWJMYWJlbDtcbn0oVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmUpKTtcblxudmFyIF9fZXh0ZW5kcyQxNyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQzOSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQzOSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqIFVzZWQgdG8gZmxhZyB0YWIgY29udGVudHMgZm9yIHVzZSB3aXRoIHRoZSBwb3J0YWwgZGlyZWN0aXZlICovXG52YXIgTWRUYWJDb250ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTcoTWRUYWJDb250ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kVGFiQ29udGVudCh0ZW1wbGF0ZVJlZiwgdmlld0NvbnRhaW5lclJlZikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB0ZW1wbGF0ZVJlZiwgdmlld0NvbnRhaW5lclJlZik7XG4gICAgfVxuICAgIE1kVGFiQ29udGVudCA9IF9fZGVjb3JhdGUkMzkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC10YWItY29udGVudF0nXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzOSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5UZW1wbGF0ZVJlZiwgX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmXSlcbiAgICBdLCBNZFRhYkNvbnRlbnQpO1xuICAgIHJldHVybiBNZFRhYkNvbnRlbnQ7XG59KFRlbXBsYXRlUG9ydGFsRGlyZWN0aXZlKSk7XG5cbnZhciBfX2RlY29yYXRlJDQwID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQwID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKiogVXNlZCBpbiB0aGUgYG1kLXRhYi1ncm91cGAgdmlldyB0byBkaXNwbGF5IHRhYiBsYWJlbHMgKi9cbnZhciBNZFRhYkxhYmVsV3JhcHBlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUYWJMYWJlbFdyYXBwZXIoZWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGZvY3VzIG9uIHRoZSB3cmFwcGVyIGVsZW1lbnRcbiAgICAgKi9cbiAgICBNZFRhYkxhYmVsV3JhcHBlci5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfTtcbiAgICBNZFRhYkxhYmVsV3JhcHBlciA9IF9fZGVjb3JhdGUkNDAoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttZC10YWItbGFiZWwtd3JhcHBlcl0nXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmXSlcbiAgICBdLCBNZFRhYkxhYmVsV3JhcHBlcik7XG4gICAgcmV0dXJuIE1kVGFiTGFiZWxXcmFwcGVyO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkNDEgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNDEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKiBUaGUgaW5rLWJhciBpcyB1c2VkIHRvIGRpc3BsYXkgYW5kIGFuaW1hdGUgdGhlIGxpbmUgdW5kZXJuZWF0aCB0aGUgY3VycmVudCBhY3RpdmUgdGFiIGxhYmVsLiAqL1xudmFyIE1kSW5rQmFyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZElua0JhcihfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHN0eWxlcyBmcm9tIHRoZSBwcm92aWRlZCBlbGVtZW50IGluIG9yZGVyIHRvIGFsaWduIHRoZSBpbmstYmFyIHRvIHRoYXQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqL1xuICAgIE1kSW5rQmFyLnByb3RvdHlwZS5hbGlnblRvRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdsZWZ0JywgdGhpcy5fZ2V0TGVmdFBvc2l0aW9uKGVsZW1lbnQpKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3dpZHRoJywgdGhpcy5fZ2V0RWxlbWVudFdpZHRoKGVsZW1lbnQpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgcGl4ZWwgZGlzdGFuY2UgZnJvbSB0aGUgbGVmdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZWxlbWVudCBpbiBzdHJpbmcgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBNZElua0Jhci5wcm90b3R5cGUuX2dldExlZnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC5vZmZzZXRMZWZ0ICsgJ3B4JyA6ICcwJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgcGl4ZWwgd2lkdGggZnJvbSB0aGUgcHJvdmlkZWQgZWxlbWVudCBpbiBzdHJpbmcgZm9ybWF0LlxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBNZElua0Jhci5wcm90b3R5cGUuX2dldEVsZW1lbnRXaWR0aCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC5vZmZzZXRXaWR0aCArICdweCcgOiAnMCc7XG4gICAgfTtcbiAgICBNZElua0JhciA9IF9fZGVjb3JhdGUkNDEoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLWluay1iYXInLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDEoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZl0pXG4gICAgXSwgTWRJbmtCYXIpO1xuICAgIHJldHVybiBNZElua0Jhcjtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDM3ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDM3ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSUQncyBmb3IgZWFjaCB0YWIgY29tcG9uZW50ICovXG52YXIgbmV4dElkJDIgPSAwO1xuLyoqIEEgc2ltcGxlIGNoYW5nZSBldmVudCBlbWl0dGVkIG9uIGZvY3VzIG9yIHNlbGVjdGlvbiBjaGFuZ2VzLiAqL1xudmFyIE1kVGFiQ2hhbmdlRXZlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVGFiQ2hhbmdlRXZlbnQoKSB7XG4gICAgfVxuICAgIHJldHVybiBNZFRhYkNoYW5nZUV2ZW50O1xufSgpKTtcbnZhciBNZFRhYiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUYWIoKSB7XG4gICAgICAgIC8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aGVuIEJvb2xlYW5GaWVsZFZhbHVlIGlzIHJlbW92ZWQuXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRhYi5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gKHZhbHVlICE9IG51bGwgJiYgXCJcIiArIHZhbHVlICE9PSAnZmFsc2UnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgX19kZWNvcmF0ZSQzNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29udGVudENoaWxkKE1kVGFiTGFiZWwpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNygnZGVzaWduOnR5cGUnLCBNZFRhYkxhYmVsKVxuICAgIF0sIE1kVGFiLnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbnRlbnRDaGlsZChNZFRhYkNvbnRlbnQpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNygnZGVzaWduOnR5cGUnLCBNZFRhYkNvbnRlbnQpXG4gICAgXSwgTWRUYWIucHJvdG90eXBlLCBcImNvbnRlbnRcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDM3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnZGlzYWJsZWQnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzcoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbiksIFxuICAgICAgICBfX21ldGFkYXRhJDM3KCdkZXNpZ246cGFyYW10eXBlcycsIFtCb29sZWFuXSlcbiAgICBdLCBNZFRhYi5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG4gICAgTWRUYWIgPSBfX2RlY29yYXRlJDM3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5EaXJlY3RpdmUoe1xuICAgICAgICAgICAgc2VsZWN0b3I6ICdtZC10YWInXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFRhYik7XG4gICAgcmV0dXJuIE1kVGFiO1xufSgpKTtcbi8qKlxuICogTWF0ZXJpYWwgZGVzaWduIHRhYi1ncm91cCBjb21wb25lbnQuICBTdXBwb3J0cyBiYXNpYyB0YWIgcGFpcnMgKGxhYmVsICsgY29udGVudCkgYW5kIGluY2x1ZGVzXG4gKiBhbmltYXRlZCBpbmstYmFyLCBrZXlib2FyZCBuYXZpZ2F0aW9uLCBhbmQgc2NyZWVuIHJlYWRlci5cbiAqIFNlZTogaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9jb21wb25lbnRzL3RhYnMuaHRtbFxuICovXG52YXIgTWRUYWJHcm91cCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUYWJHcm91cChfem9uZSkge1xuICAgICAgICB0aGlzLl96b25lID0gX3pvbmU7XG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX29uRm9jdXNDaGFuZ2UgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fb25TZWxlY3RDaGFuZ2UgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fZm9jdXNJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX2dyb3VwSWQgPSBuZXh0SWQkMisrO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJHcm91cC5wcm90b3R5cGUsIFwic2VsZWN0ZWRJbmRleFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkSW5kZXg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gdGhpcy5fc2VsZWN0ZWRJbmRleCAmJiB0aGlzLmlzVmFsaWRJbmRleCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25TZWxlY3RDaGFuZ2UuZW1pdCh0aGlzLl9jcmVhdGVDaGFuZ2VFdmVudCh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhbiBpbmRleCBpcyB2YWxpZC4gIElmIHRoZSB0YWJzIGFyZSBub3QgcmVhZHkgeWV0LCB3ZSBhc3N1bWUgdGhhdCB0aGUgdXNlciBpc1xuICAgICAqIHByb3ZpZGluZyBhIHZhbGlkIGluZGV4IGFuZCByZXR1cm4gdHJ1ZS5cbiAgICAgKi9cbiAgICBNZFRhYkdyb3VwLnByb3RvdHlwZS5pc1ZhbGlkSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhYnMpIHtcbiAgICAgICAgICAgIHZhciB0YWIgPSB0aGlzLl90YWJzLnRvQXJyYXkoKVtpbmRleF07XG4gICAgICAgICAgICByZXR1cm4gdGFiICYmICF0YWIuZGlzYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiR3JvdXAucHJvdG90eXBlLCBcIl9zZWxlY3RlZEluZGV4Q2hhbmdlXCIsIHtcbiAgICAgICAgLyoqIE91dHB1dCB0byBlbmFibGUgc3VwcG9ydCBmb3IgdHdvLXdheSBiaW5kaW5nIG9uIGBzZWxlY3RlZEluZGV4YC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RDaGFuZ2UubWFwKGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQuaW5kZXg7IH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJHcm91cC5wcm90b3R5cGUsIFwiZm9jdXNDaGFuZ2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbkZvY3VzQ2hhbmdlLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUYWJHcm91cC5wcm90b3R5cGUsIFwic2VsZWN0Q2hhbmdlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25TZWxlY3RDaGFuZ2UuYXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFdhaXRzIG9uZSBmcmFtZSBmb3IgdGhlIHZpZXcgdG8gdXBkYXRlLCB0aGVuIHVwYXRlcyB0aGUgaW5rIGJhclxuICAgICAqIE5vdGU6IFRoaXMgbXVzdCBiZSBydW4gb3V0c2lkZSBvZiB0aGUgem9uZSBvciBpdCB3aWxsIGNyZWF0ZSBhbiBpbmZpbml0ZSBjaGFuZ2UgZGV0ZWN0aW9uIGxvb3BcbiAgICAgKiBUT0RPOiBpbnRlcm5hbFxuICAgICAqL1xuICAgIE1kVGFiR3JvdXAucHJvdG90eXBlLm5nQWZ0ZXJWaWV3Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdXBkYXRlSW5rQmFyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH07XG4gICAgLyoqIFRlbGxzIHRoZSBpbmstYmFyIHRvIGFsaWduIGl0c2VsZiB0byB0aGUgY3VycmVudCBsYWJlbCB3cmFwcGVyICovXG4gICAgTWRUYWJHcm91cC5wcm90b3R5cGUuX3VwZGF0ZUlua0JhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faW5rQmFyLnRvQXJyYXkoKVswXS5hbGlnblRvRWxlbWVudCh0aGlzLl9jdXJyZW50TGFiZWxXcmFwcGVyKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRhYkdyb3VwLnByb3RvdHlwZSwgXCJfY3VycmVudExhYmVsV3JhcHBlclwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgbGFiZWwgd3JhcHBlcjsgZGVmYXVsdHMgdG8gbnVsbCBmb3IgaW5pdGlhbCByZW5kZXIgYmVmb3JlIHRoZVxuICAgICAgICAgKiBWaWV3Q2hpbGRyZW4gcmVmZXJlbmNlcyBhcmUgcmVhZHkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYWJlbFdyYXBwZXJzICYmIHRoaXMuX2xhYmVsV3JhcHBlcnMubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9sYWJlbFdyYXBwZXJzLnRvQXJyYXkoKVt0aGlzLnNlbGVjdGVkSW5kZXhdLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudFxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVGFiR3JvdXAucHJvdG90eXBlLCBcImZvY3VzSW5kZXhcIiwge1xuICAgICAgICAvKiogVHJhY2tzIHdoaWNoIGVsZW1lbnQgaGFzIGZvY3VzOyB1c2VkIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvY3VzSW5kZXg7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBXaGVuIHRoZSBmb2N1cyBpbmRleCBpcyBzZXQsIHdlIG11c3QgbWFudWFsbHkgc2VuZCBmb2N1cyB0byB0aGUgY29ycmVjdCBsYWJlbCAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZEluZGV4KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzSW5kZXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkZvY3VzQ2hhbmdlLmVtaXQodGhpcy5fY3JlYXRlQ2hhbmdlRXZlbnQodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xhYmVsV3JhcHBlcnMgJiYgdGhpcy5fbGFiZWxXcmFwcGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFiZWxXcmFwcGVycy50b0FycmF5KClbdmFsdWVdLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBNZFRhYkdyb3VwLnByb3RvdHlwZS5fY3JlYXRlQ2hhbmdlRXZlbnQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IE1kVGFiQ2hhbmdlRXZlbnQ7XG4gICAgICAgIGV2ZW50LmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGlmICh0aGlzLl90YWJzICYmIHRoaXMuX3RhYnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBldmVudC50YWIgPSB0aGlzLl90YWJzLnRvQXJyYXkoKVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSB1bmlxdWUgaWQgZm9yIGVhY2ggdGFiIGxhYmVsIGVsZW1lbnQgKi9cbiAgICBNZFRhYkdyb3VwLnByb3RvdHlwZS5fZ2V0VGFiTGFiZWxJZCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBcIm1kLXRhYi1sYWJlbC1cIiArIHRoaXMuX2dyb3VwSWQgKyBcIi1cIiArIGk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhIHVuaXF1ZSBpZCBmb3IgZWFjaCB0YWIgY29udGVudCBlbGVtZW50ICovXG4gICAgTWRUYWJHcm91cC5wcm90b3R5cGUuX2dldFRhYkNvbnRlbnRJZCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBcIm1kLXRhYi1jb250ZW50LVwiICsgdGhpcy5fZ3JvdXBJZCArIFwiLVwiICsgaTtcbiAgICB9O1xuICAgIE1kVGFiR3JvdXAucHJvdG90eXBlLmhhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFJJR0hUX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNOZXh0VGFiKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIExFRlRfQVJST1c6XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c1ByZXZpb3VzVGFiKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEVOVEVSOlxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRoaXMuZm9jdXNJbmRleDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIGZvY3VzIGxlZnQgb3IgcmlnaHQgZGVwZW5kaW5nIG9uIHRoZSBvZmZzZXQgcHJvdmlkZWQuICBWYWxpZCBvZmZzZXRzIGFyZSAxIGFuZCAtMS5cbiAgICAgKi9cbiAgICBNZFRhYkdyb3VwLnByb3RvdHlwZS5tb3ZlRm9jdXMgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9sYWJlbFdyYXBwZXJzKSB7XG4gICAgICAgICAgICB2YXIgdGFicyA9IHRoaXMuX3RhYnMudG9BcnJheSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuZm9jdXNJbmRleCArIG9mZnNldDsgaSA8IHRhYnMubGVuZ3RoICYmIGkgPj0gMDsgaSArPSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkSW5kZXgoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb2N1c0luZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEluY3JlbWVudCB0aGUgZm9jdXMgaW5kZXggYnkgMSB1bnRpbCBhIHZhbGlkIHRhYiBpcyBmb3VuZC4gKi9cbiAgICBNZFRhYkdyb3VwLnByb3RvdHlwZS5mb2N1c05leHRUYWIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubW92ZUZvY3VzKDEpO1xuICAgIH07XG4gICAgLyoqIERlY3JlbWVudCB0aGUgZm9jdXMgaW5kZXggYnkgMSB1bnRpbCBhIHZhbGlkIHRhYiBpcyBmb3VuZC4gKi9cbiAgICBNZFRhYkdyb3VwLnByb3RvdHlwZS5mb2N1c1ByZXZpb3VzVGFiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm1vdmVGb2N1cygtMSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDM3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db250ZW50Q2hpbGRyZW4oTWRUYWIpLCBcbiAgICAgICAgX19tZXRhZGF0YSQzNygnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLlF1ZXJ5TGlzdClcbiAgICBdLCBNZFRhYkdyb3VwLnByb3RvdHlwZSwgXCJfdGFic1wiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZHJlbihNZFRhYkxhYmVsV3JhcHBlciksIFxuICAgICAgICBfX21ldGFkYXRhJDM3KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuUXVlcnlMaXN0KVxuICAgIF0sIE1kVGFiR3JvdXAucHJvdG90eXBlLCBcIl9sYWJlbFdyYXBwZXJzXCIsIHZvaWQgMCk7XG4gICAgX19kZWNvcmF0ZSQzNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuVmlld0NoaWxkcmVuKE1kSW5rQmFyKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzcoJ2Rlc2lnbjp0eXBlJywgX2FuZ3VsYXJfY29yZS5RdWVyeUxpc3QpXG4gICAgXSwgTWRUYWJHcm91cC5wcm90b3R5cGUsIFwiX2lua0JhclwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkMzcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDM3KCdkZXNpZ246dHlwZScsIE51bWJlciksIFxuICAgICAgICBfX21ldGFkYXRhJDM3KCdkZXNpZ246cGFyYW10eXBlcycsIFtOdW1iZXJdKVxuICAgIF0sIE1kVGFiR3JvdXAucHJvdG90eXBlLCBcInNlbGVjdGVkSW5kZXhcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCdzZWxlY3RlZEluZGV4Q2hhbmdlJyksIFxuICAgICAgICBfX21ldGFkYXRhJDM3KCdkZXNpZ246dHlwZScsIHJ4anNfT2JzZXJ2YWJsZS5PYnNlcnZhYmxlKVxuICAgIF0sIE1kVGFiR3JvdXAucHJvdG90eXBlLCBcIl9zZWxlY3RlZEluZGV4Q2hhbmdlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkMzcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgnZm9jdXNDaGFuZ2UnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzcoJ2Rlc2lnbjp0eXBlJywgcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUpXG4gICAgXSwgTWRUYWJHcm91cC5wcm90b3R5cGUsIFwiZm9jdXNDaGFuZ2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQzNyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCdzZWxlY3RDaGFuZ2UnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzcoJ2Rlc2lnbjp0eXBlJywgcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUpXG4gICAgXSwgTWRUYWJHcm91cC5wcm90b3R5cGUsIFwic2VsZWN0Q2hhbmdlXCIsIG51bGwpO1xuICAgIE1kVGFiR3JvdXAgPSBfX2RlY29yYXRlJDM3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtdGFiLWdyb3VwJyxcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxkaXYgY2xhc3M9XFxcIm1kLXRhYi1oZWFkZXJcXFwiIHJvbGU9XFxcInRhYmxpc3RcXFwiIChrZXlkb3duKT1cXFwiaGFuZGxlS2V5ZG93bigkZXZlbnQpXFxcIj4gPGRpdiBjbGFzcz1cXFwibWQtdGFiLWxhYmVsXFxcIiByb2xlPVxcXCJ0YWJcXFwiIG1kLXRhYi1sYWJlbC13cmFwcGVyICpuZ0Zvcj1cXFwibGV0IHRhYiBvZiBfdGFiczsgbGV0IGkgPSBpbmRleFxcXCIgW2lkXT1cXFwiX2dldFRhYkxhYmVsSWQoaSlcXFwiIFt0YWJJbmRleF09XFxcInNlbGVjdGVkSW5kZXggPT0gaSA/IDAgOiAtMVxcXCIgW2F0dHIuYXJpYS1jb250cm9sc109XFxcIl9nZXRUYWJDb250ZW50SWQoaSlcXFwiIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVxcXCJzZWxlY3RlZEluZGV4ID09IGlcXFwiIFtjbGFzcy5tZC10YWItYWN0aXZlXT1cXFwic2VsZWN0ZWRJbmRleCA9PSBpXFxcIiBbY2xhc3MubWQtdGFiLWRpc2FibGVkXT1cXFwidGFiLmRpc2FibGVkXFxcIiAoY2xpY2spPVxcXCJmb2N1c0luZGV4ID0gc2VsZWN0ZWRJbmRleCA9IGlcXFwiPiA8dGVtcGxhdGUgW3BvcnRhbEhvc3RdPVxcXCJ0YWIubGFiZWxcXFwiPjwvdGVtcGxhdGU+IDwvZGl2PiA8bWQtaW5rLWJhcj48L21kLWluay1iYXI+IDwvZGl2PiA8ZGl2IGNsYXNzPVxcXCJtZC10YWItYm9keS13cmFwcGVyXFxcIj4gPGRpdiBjbGFzcz1cXFwibWQtdGFiLWJvZHlcXFwiIHJvbGU9XFxcInRhYnBhbmVsXFxcIiAqbmdGb3I9XFxcImxldCB0YWIgb2YgX3RhYnM7IGxldCBpID0gaW5kZXhcXFwiIFtpZF09XFxcIl9nZXRUYWJDb250ZW50SWQoaSlcXFwiIFtjbGFzcy5tZC10YWItYWN0aXZlXT1cXFwic2VsZWN0ZWRJbmRleCA9PSBpXFxcIiBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVxcXCJfZ2V0VGFiTGFiZWxJZChpKVxcXCI+IDx0ZW1wbGF0ZSBbbmdJZl09XFxcInNlbGVjdGVkSW5kZXggPT0gaVxcXCI+IDx0ZW1wbGF0ZSBbcG9ydGFsSG9zdF09XFxcInRhYi5jb250ZW50XFxcIj48L3RlbXBsYXRlPiA8L3RlbXBsYXRlPiA8L2Rpdj4gPC9kaXY+IFwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdCB7IGRpc3BsYXk6IGZsZXg7IGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47IGZvbnQtZmFtaWx5OiBSb2JvdG8sIFxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsIHNhbnMtc2VyaWY7IH0gLm1kLXRhYi1oZWFkZXIgeyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7IGRpc3BsYXk6IGZsZXg7IGZsZXgtZGlyZWN0aW9uOiByb3c7IGZsZXgtc2hyaW5rOiAwOyB9IC5tZC10YWItbGFiZWwgeyBsaW5lLWhlaWdodDogNDhweDsgaGVpZ2h0OiA0OHB4OyBwYWRkaW5nOiAwIDEycHg7IGZvbnQtc2l6ZTogMTRweDsgZm9udC1mYW1pbHk6IFJvYm90bywgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgc2Fucy1zZXJpZjsgZm9udC13ZWlnaHQ6IDUwMDsgY3Vyc29yOiBwb2ludGVyOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyBjb2xvcjogY3VycmVudENvbG9yOyBvcGFjaXR5OiAwLjY7IG1pbi13aWR0aDogMTYwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsgfSAubWQtdGFiLWxhYmVsOmZvY3VzIHsgb3V0bGluZTogbm9uZTsgb3BhY2l0eTogMTsgfSAubWQtdGFiLWRpc2FibGVkIHsgY3Vyc29yOiBkZWZhdWx0OyBwb2ludGVyLWV2ZW50czogbm9uZTsgfSAubWQtdGFiLWJvZHktd3JhcHBlciB7IHBvc2l0aW9uOiByZWxhdGl2ZTsgb3ZlcmZsb3c6IGhpZGRlbjsgZmxleC1ncm93OiAxOyBkaXNwbGF5OiBmbGV4OyB9IC5tZC10YWItYm9keSB7IGRpc3BsYXk6IG5vbmU7IG92ZXJmbG93OiBhdXRvOyBib3gtc2l6aW5nOiBib3JkZXItYm94OyBmbGV4LWdyb3c6IDE7IGZsZXgtc2hyaW5rOiAxOyB9IC5tZC10YWItYm9keS5tZC10YWItYWN0aXZlIHsgZGlzcGxheTogYmxvY2s7IH0gbWQtaW5rLWJhciB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgYm90dG9tOiAwOyBoZWlnaHQ6IDJweDsgdHJhbnNpdGlvbjogMzUwbXMgZWFzZS1vdXQ7IH0gLyojIHNvdXJjZU1hcHBpbmdVUkw9dGFiLWdyb3VwLmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMzcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuTmdab25lXSlcbiAgICBdLCBNZFRhYkdyb3VwKTtcbiAgICByZXR1cm4gTWRUYWJHcm91cDtcbn0oKSk7XG52YXIgTWRUYWJzTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFRhYnNNb2R1bGUoKSB7XG4gICAgfVxuICAgIE1kVGFic01vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kVGFic01vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW11cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1kVGFic01vZHVsZSA9IF9fZGVjb3JhdGUkMzcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlKHtcbiAgICAgICAgICAgIGltcG9ydHM6IFtfYW5ndWxhcl9jb21tb24uQ29tbW9uTW9kdWxlLCBQb3J0YWxNb2R1bGVdLFxuICAgICAgICAgICAgLy8gRG9uJ3QgZXhwb3J0IE1kSW5rQmFyIG9yIE1kVGFiTGFiZWxXcmFwcGVyLCBhcyB0aGV5IGFyZSBpbnRlcm5hbCBpbXBsZW1lbnRhdGlubyBkZXRhaWxzLlxuICAgICAgICAgICAgZXhwb3J0czogW01kVGFiR3JvdXAsIE1kVGFiTGFiZWwsIE1kVGFiQ29udGVudCwgTWRUYWJdLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRUYWJHcm91cCwgTWRUYWJMYWJlbCwgTWRUYWJDb250ZW50LCBNZFRhYiwgTWRJbmtCYXIsIE1kVGFiTGFiZWxXcmFwcGVyXSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDM3KCdkZXNpZ246cGFyYW10eXBlcycsIFtdKVxuICAgIF0sIE1kVGFic01vZHVsZSk7XG4gICAgcmV0dXJuIE1kVGFic01vZHVsZTtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDQyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQyID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTWRUb29sYmFyUm93ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZFRvb2xiYXJSb3coKSB7XG4gICAgfVxuICAgIE1kVG9vbGJhclJvdyA9IF9fZGVjb3JhdGUkNDIoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkRpcmVjdGl2ZSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogJ21kLXRvb2xiYXItcm93J1xuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRUb29sYmFyUm93KTtcbiAgICByZXR1cm4gTWRUb29sYmFyUm93O1xufSgpKTtcbnZhciBNZFRvb2xiYXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVG9vbGJhcihlbGVtZW50UmVmLCByZW5kZXJlcikge1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZFRvb2xiYXIucHJvdG90eXBlLCBcImNvbG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE1kVG9vbGJhci5wcm90b3R5cGUuX3VwZGF0ZUNvbG9yID0gZnVuY3Rpb24gKG5ld0NvbG9yKSB7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRDb2xvcih0aGlzLl9jb2xvciwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9zZXRFbGVtZW50Q29sb3IobmV3Q29sb3IsIHRydWUpO1xuICAgICAgICB0aGlzLl9jb2xvciA9IG5ld0NvbG9yO1xuICAgIH07XG4gICAgTWRUb29sYmFyLnByb3RvdHlwZS5fc2V0RWxlbWVudENvbG9yID0gZnVuY3Rpb24gKGNvbG9yLCBpc0FkZCkge1xuICAgICAgICBpZiAoY29sb3IgIT0gbnVsbCAmJiBjb2xvciAhPSAnJykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIFwibWQtXCIgKyBjb2xvciwgaXNBZGQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDQyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MignZGVzaWduOnR5cGUnLCBTdHJpbmcpXG4gICAgXSwgTWRUb29sYmFyLnByb3RvdHlwZSwgXCJjb2xvclwiLCBudWxsKTtcbiAgICBNZFRvb2xiYXIgPSBfX2RlY29yYXRlJDQyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtdG9vbGJhcicsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtZC10b29sYmFyLWxheW91dFxcXCI+IDxtZC10b29sYmFyLXJvdz4gPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PiA8L21kLXRvb2xiYXItcm93PiA8bmctY29udGVudCBzZWxlY3Q9XFxcIm1kLXRvb2xiYXItcm93XFxcIj48L25nLWNvbnRlbnQ+IDwvZGl2PlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCJtZC10b29sYmFyIHsgZGlzcGxheTogZmxleDsgYm94LXNpemluZzogYm9yZGVyLWJveDsgd2lkdGg6IDEwMCU7IG1pbi1oZWlnaHQ6IDY0cHg7IGZvbnQtc2l6ZTogMjBweDsgZm9udC13ZWlnaHQ6IDQwMDsgZm9udC1mYW1pbHk6IFJvYm90bywgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgc2Fucy1zZXJpZjsgcGFkZGluZzogMCAxNnB4OyBmbGV4LWRpcmVjdGlvbjogY29sdW1uOyB9IG1kLXRvb2xiYXIgbWQtdG9vbGJhci1yb3cgeyBkaXNwbGF5OiBmbGV4OyBib3gtc2l6aW5nOiBib3JkZXItYm94OyB3aWR0aDogMTAwJTsgaGVpZ2h0OiA2NHB4OyBmbGV4LWRpcmVjdGlvbjogcm93OyBhbGlnbi1pdGVtczogY2VudGVyOyB9IC8qIyBzb3VyY2VNYXBwaW5nVVJMPXRvb2xiYXIuY3NzLm1hcCAqLyBcIl0sXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICAgICAgZW5jYXBzdWxhdGlvbjogX2FuZ3VsYXJfY29yZS5WaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MignZGVzaWduOnBhcmFtdHlwZXMnLCBbX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBNZFRvb2xiYXIpO1xuICAgIHJldHVybiBNZFRvb2xiYXI7XG59KCkpO1xudmFyIE1kVG9vbGJhck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUb29sYmFyTW9kdWxlKCkge1xuICAgIH1cbiAgICBNZFRvb2xiYXJNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZFRvb2xiYXJNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZFRvb2xiYXJNb2R1bGUgPSBfX2RlY29yYXRlJDQyKFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBleHBvcnRzOiBbTWRUb29sYmFyLCBNZFRvb2xiYXJSb3ddLFxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWRUb29sYmFyLCBNZFRvb2xiYXJSb3ddLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDIoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWRUb29sYmFyTW9kdWxlKTtcbiAgICByZXR1cm4gTWRUb29sYmFyTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkNDMgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNDMgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBNZFRvb2x0aXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kVG9vbHRpcChfb3ZlcmxheSwgX2VsZW1lbnRSZWYsIF92aWV3Q29udGFpbmVyUmVmLCBfY2hhbmdlRGV0ZWN0aW9uUmVmKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXkgPSBfb3ZlcmxheTtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZiA9IF9lbGVtZW50UmVmO1xuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gX3ZpZXdDb250YWluZXJSZWY7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdGlvblJlZiA9IF9jaGFuZ2VEZXRlY3Rpb25SZWY7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAvKiogQWxsb3dzIHRoZSB1c2VyIHRvIGRlZmluZSB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXAgcmVsYXRpdmUgdG8gdGhlIHBhcmVudCBlbGVtZW50ICovXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gJ2JlbG93JztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kVG9vbHRpcC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU92ZXJsYXkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRUb29sdGlwLnByb3RvdHlwZSwgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2UgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBvdmVybGF5IG9uIGluaXRcbiAgICAgKiBUT0RPOiBpbnRlcm5hbFxuICAgICAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZU92ZXJsYXkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgb3ZlcmxheSBjb25maWcgYW5kIHBvc2l0aW9uIHN0cmF0ZWd5XG4gICAgICovXG4gICAgTWRUb29sdGlwLnByb3RvdHlwZS5fY3JlYXRlT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB2aXNpYmxlLCBoaWRlIGJlZm9yZSBkZXN0cm95aW5nXG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm90IHZpc2libGUsIGRpc3Bvc2UgYW5kIHJlY3JlYXRlXG4gICAgICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMuX2dldE9yaWdpbigpO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fZ2V0T3ZlcmxheVBvc2l0aW9uKCk7XG4gICAgICAgICAgICB2YXIgc3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKCkuY29ubmVjdGVkVG8odGhpcy5fZWxlbWVudFJlZiwgb3JpZ2luLCBwb3NpdGlvbik7XG4gICAgICAgICAgICB2YXIgY29uZmlnID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuICAgICAgICAgICAgY29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZShjb25maWcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvcmlnaW4gcG9zaXRpb24gYmFzZWQgb24gdGhlIHVzZXIncyBwb3NpdGlvbiBwcmVmZXJlbmNlXG4gICAgICovXG4gICAgTWRUb29sdGlwLnByb3RvdHlwZS5fZ2V0T3JpZ2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2JlZm9yZSc6IHJldHVybiB7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdjZW50ZXInIH07XG4gICAgICAgICAgICBjYXNlICdhZnRlcic6IHJldHVybiB7IG9yaWdpblg6ICdlbmQnLCBvcmlnaW5ZOiAnY2VudGVyJyB9O1xuICAgICAgICAgICAgY2FzZSAnYWJvdmUnOiByZXR1cm4geyBvcmlnaW5YOiAnY2VudGVyJywgb3JpZ2luWTogJ3RvcCcgfTtcbiAgICAgICAgICAgIGNhc2UgJ2JlbG93JzogcmV0dXJuIHsgb3JpZ2luWDogJ2NlbnRlcicsIG9yaWdpblk6ICdib3R0b20nIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG92ZXJsYXkgcG9zaXRpb24gYmFzZWQgb24gdGhlIHVzZXIncyBwcmVmZXJlbmNlXG4gICAgICovXG4gICAgTWRUb29sdGlwLnByb3RvdHlwZS5fZ2V0T3ZlcmxheVBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2JlZm9yZSc6IHJldHVybiB7IG92ZXJsYXlYOiAnZW5kJywgb3ZlcmxheVk6ICdjZW50ZXInIH07XG4gICAgICAgICAgICBjYXNlICdhZnRlcic6IHJldHVybiB7IG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ2NlbnRlcicgfTtcbiAgICAgICAgICAgIGNhc2UgJ2Fib3ZlJzogcmV0dXJuIHsgb3ZlcmxheVg6ICdjZW50ZXInLCBvdmVybGF5WTogJ2JvdHRvbScgfTtcbiAgICAgICAgICAgIGNhc2UgJ2JlbG93JzogcmV0dXJuIHsgb3ZlcmxheVg6ICdjZW50ZXInLCBvdmVybGF5WTogJ3RvcCcgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIHRvb2x0aXAgb24gbW91c2UgZW50ZXJcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLl9oYW5kbGVNb3VzZUVudGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIHRvb2x0aXAgb24gbW91c2UgbGVhdmVcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLl9oYW5kbGVNb3VzZUxlYXZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIHRvb2x0aXAgYW5kIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gdGhlIHRvb2x0aXAgaXMgdmlzaWJsZVxuICAgICAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpc2libGUgJiYgdGhpcy5fb3ZlcmxheVJlZiAmJiAhdGhpcy5fb3ZlcmxheVJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHBvcnRhbCA9IG5ldyBDb21wb25lbnRQb3J0YWwoVG9vbHRpcENvbXBvbmVudCwgdGhpcy5fdmlld0NvbnRhaW5lclJlZik7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcFJlZiA9IHRoaXMuX292ZXJsYXlSZWYuYXR0YWNoKHBvcnRhbCk7XG4gICAgICAgICAgICB0b29sdGlwUmVmLmluc3RhbmNlLm1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2U7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgdG9vbHRpcCBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2hlbiB0aGUgdG9vbHRpcCBpcyBoaWRkZW5cbiAgICAgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGUgJiYgdGhpcy5fb3ZlcmxheVJlZiAmJiB0aGlzLl9vdmVybGF5UmVmLmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogU2hvd3MvaGlkZXMgdGhlIHRvb2x0aXAgYW5kIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIHdoZW4gaXQgaXMgZG9uZVxuICAgICAqL1xuICAgIE1kVG9vbHRpcC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0b29sdGlwJ3MgcG9zaXRpb25cbiAgICAgKi9cbiAgICBNZFRvb2x0aXAucHJvdG90eXBlLl91cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdGlvblJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkNDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCd0b29sdGlwLXBvc2l0aW9uJyksIFxuICAgICAgICBfX21ldGFkYXRhJDQzKCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZFRvb2x0aXAucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUkNDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLklucHV0KCdtZC10b29sdGlwJyksIFxuICAgICAgICBfX21ldGFkYXRhJDQzKCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZFRvb2x0aXAucHJvdG90eXBlLCBcIm1lc3NhZ2VcIiwgbnVsbCk7XG4gICAgTWRUb29sdGlwID0gX19kZWNvcmF0ZSQ0MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLXRvb2x0aXBdJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnKG1vdXNlZW50ZXIpJzogJ19oYW5kbGVNb3VzZUVudGVyKCRldmVudCknLFxuICAgICAgICAgICAgICAgICcobW91c2VsZWF2ZSknOiAnX2hhbmRsZU1vdXNlTGVhdmUoJGV2ZW50KScsXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MygnZGVzaWduOnBhcmFtdHlwZXMnLCBbT3ZlcmxheSwgX2FuZ3VsYXJfY29yZS5FbGVtZW50UmVmLCBfYW5ndWxhcl9jb3JlLlZpZXdDb250YWluZXJSZWYsIF9hbmd1bGFyX2NvcmUuQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuICAgIF0sIE1kVG9vbHRpcCk7XG4gICAgcmV0dXJuIE1kVG9vbHRpcDtcbn0oKSk7XG52YXIgVG9vbHRpcENvbXBvbmVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9vbHRpcENvbXBvbmVudCgpIHtcbiAgICB9XG4gICAgVG9vbHRpcENvbXBvbmVudCA9IF9fZGVjb3JhdGUkNDMoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkNvbXBvbmVudCh7c2VsZWN0b3I6ICdtZC10b29sdGlwLWNvbXBvbmVudCcsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtZC10b29sdGlwXFxcIj57e21lc3NhZ2V9fTwvZGl2PlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCI6aG9zdCB7IHBvaW50ZXItZXZlbnRzOiBub25lOyB9IC5tZC10b29sdGlwIHsgY29sb3I6IHdoaXRlOyBwYWRkaW5nOiAwIDhweDsgYm9yZGVyLXJhZGl1czogMnB4OyBmb250LWZhbWlseTogUm9ib3RvLCBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBzYW5zLXNlcmlmOyBmb250LXNpemU6IDEwcHg7IG1hcmdpbjogMTRweDsgaGVpZ2h0OiAyMnB4OyBsaW5lLWhlaWdodDogMjJweDsgfSAvKiMgc291cmNlTWFwcGluZ1VSTD10b29sdGlwLmNzcy5tYXAgKi8gXCJdLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDMoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgVG9vbHRpcENvbXBvbmVudCk7XG4gICAgcmV0dXJuIFRvb2x0aXBDb21wb25lbnQ7XG59KCkpO1xudmFyIE1kVG9vbHRpcE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRUb29sdGlwTW9kdWxlKCkge1xuICAgIH1cbiAgICBNZFRvb2x0aXBNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZFRvb2x0aXBNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IE9WRVJMQVlfUFJPVklERVJTLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWRUb29sdGlwTW9kdWxlID0gX19kZWNvcmF0ZSQ0MyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW092ZXJsYXlNb2R1bGVdLFxuICAgICAgICAgICAgZXhwb3J0czogW01kVG9vbHRpcCwgVG9vbHRpcENvbXBvbmVudF0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZFRvb2x0aXAsIFRvb2x0aXBDb21wb25lbnRdLFxuICAgICAgICAgICAgZW50cnlDb21wb25lbnRzOiBbVG9vbHRpcENvbXBvbmVudF0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0MygnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZFRvb2x0aXBNb2R1bGUpO1xuICAgIHJldHVybiBNZFRvb2x0aXBNb2R1bGU7XG59KCkpO1xuXG52YXIgX19leHRlbmRzJDE4ID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogRXhjZXB0aW9uIHRocm93biB3aGVuIG1lbnUgdHJpZ2dlciBkb2Vzbid0IGhhdmUgYSB2YWxpZCBtZC1tZW51IGluc3RhbmNlXG4gKi9cbnZhciBNZE1lbnVNaXNzaW5nRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxOChNZE1lbnVNaXNzaW5nRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWRNZW51TWlzc2luZ0Vycm9yKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIm1kLW1lbnUtdHJpZ2dlcjogbXVzdCBwYXNzIGluIGFuIG1kLW1lbnUgaW5zdGFuY2UuXFxuXFxuICAgIEV4YW1wbGU6XFxuICAgICAgPG1kLW1lbnUgI21lbnU9XFxcIm1kTWVudVxcXCI+PC9tZC1tZW51PlxcbiAgICAgIDxidXR0b24gW21kLW1lbnUtdHJpZ2dlci1mb3JdPVxcXCJtZW51XFxcIj48L2J1dHRvbj5cXG4gICAgXCIpO1xuICAgIH1cbiAgICByZXR1cm4gTWRNZW51TWlzc2luZ0Vycm9yO1xufShNZEVycm9yKSk7XG4vKipcbiAqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBtZW51J3MgeC1wb3NpdGlvbiB2YWx1ZSBpc24ndCB2YWxpZC5cbiAqIEluIG90aGVyIHdvcmRzLCBpdCBkb2Vzbid0IG1hdGNoICdiZWZvcmUnIG9yICdhZnRlcicuXG4gKi9cbnZhciBNZE1lbnVJbnZhbGlkUG9zaXRpb25YID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMkMTgoTWRNZW51SW52YWxpZFBvc2l0aW9uWCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZE1lbnVJbnZhbGlkUG9zaXRpb25YKCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBcIngtcG9zaXRpb24gdmFsdWUgbXVzdCBiZSBlaXRoZXIgJ2JlZm9yZScgb3IgYWZ0ZXInLlxcbiAgICAgIEV4YW1wbGU6IDxtZC1tZW51IHgtcG9zaXRpb249XFxcImJlZm9yZVxcXCIgI21lbnU9XFxcIm1kTWVudVxcXCI+PC9tZC1tZW51PlxcbiAgICBcIik7XG4gICAgfVxuICAgIHJldHVybiBNZE1lbnVJbnZhbGlkUG9zaXRpb25YO1xufShNZEVycm9yKSk7XG4vKipcbiAqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBtZW51J3MgeS1wb3NpdGlvbiB2YWx1ZSBpc24ndCB2YWxpZC5cbiAqIEluIG90aGVyIHdvcmRzLCBpdCBkb2Vzbid0IG1hdGNoICdhYm92ZScgb3IgJ2JlbG93Jy5cbiAqL1xudmFyIE1kTWVudUludmFsaWRQb3NpdGlvblkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxOChNZE1lbnVJbnZhbGlkUG9zaXRpb25ZLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1kTWVudUludmFsaWRQb3NpdGlvblkoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIFwieS1wb3NpdGlvbiB2YWx1ZSBtdXN0IGJlIGVpdGhlciAnYWJvdmUnIG9yIGJlbG93Jy5cXG4gICAgICBFeGFtcGxlOiA8bWQtbWVudSB5LXBvc2l0aW9uPVxcXCJhYm92ZVxcXCIgI21lbnU9XFxcIm1kTWVudVxcXCI+PC9tZC1tZW51PlxcbiAgICBcIik7XG4gICAgfVxuICAgIHJldHVybiBNZE1lbnVJbnZhbGlkUG9zaXRpb25ZO1xufShNZEVycm9yKSk7XG5cbnZhciBfX2RlY29yYXRlJDQ2ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQ2ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgaW5zaWRlIGFuIG1kLW1lbnUgdGFnLlxuICogSXQgZXhpc3RzIG1vc3RseSB0byBzZXQgdGhlIHJvbGUgYXR0cmlidXRlLlxuICovXG52YXIgTWRNZW51SXRlbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRNZW51SXRlbShfcmVuZGVyZXIsIF9lbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmID0gX2VsZW1lbnRSZWY7XG4gICAgfVxuICAgIE1kTWVudUl0ZW0ucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5pbnZva2VFbGVtZW50TWV0aG9kKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2ZvY3VzJyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRNZW51SXRlbS5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwge1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSB0byBzdXBwb3J0IGFuY2hvcnNcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9ICh2YWx1ZSA9PT0gZmFsc2UgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBudWxsIDogdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTWVudUl0ZW0ucHJvdG90eXBlLCBcImlzQXJpYURpc2FibGVkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMuZGlzYWJsZWQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUT0RPOiBpbnRlcm5hbFxuICAgICAqL1xuICAgIE1kTWVudUl0ZW0ucHJvdG90eXBlLl9jaGVja0Rpc2FibGVkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkNDYoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkhvc3RCaW5kaW5nKCdhdHRyLmRpc2FibGVkJyksXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuSW5wdXQoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDYoJ2Rlc2lnbjp0eXBlJywgQm9vbGVhbilcbiAgICBdLCBNZE1lbnVJdGVtLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlJDQ2KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0QmluZGluZygnYXR0ci5hcmlhLWRpc2FibGVkJyksIFxuICAgICAgICBfX21ldGFkYXRhJDQ2KCdkZXNpZ246dHlwZScsIFN0cmluZylcbiAgICBdLCBNZE1lbnVJdGVtLnByb3RvdHlwZSwgXCJpc0FyaWFEaXNhYmxlZFwiLCBudWxsKTtcbiAgICBNZE1lbnVJdGVtID0gX19kZWNvcmF0ZSQ0NihbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLW1lbnUtaXRlbV0nLFxuICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICdyb2xlJzogJ21lbnVpdGVtJyxcbiAgICAgICAgICAgICAgICAnKGNsaWNrKSc6ICdfY2hlY2tEaXNhYmxlZCgkZXZlbnQpJyxcbiAgICAgICAgICAgICAgICAndGFiaW5kZXgnOiAnLTEnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtZE1lbnVJdGVtJ1xuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDYoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW19hbmd1bGFyX2NvcmUuUmVuZGVyZXIsIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZl0pXG4gICAgXSwgTWRNZW51SXRlbSk7XG4gICAgcmV0dXJuIE1kTWVudUl0ZW07XG59KCkpO1xuXG4vLyBUT0RPKGthcmEpOiBwcmV2ZW50LWNsb3NlIGZ1bmN0aW9uYWxpdHlcbnZhciBfX2RlY29yYXRlJDQ1ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQ1ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQ1ID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xudmFyIE1kTWVudSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWRNZW51KHBvc1gsIHBvc1kpIHtcbiAgICAgICAgdGhpcy5fc2hvd0NsaWNrQ2F0Y2hlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9mb2N1c2VkSXRlbUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wb3NpdGlvblggPSAnYWZ0ZXInO1xuICAgICAgICB0aGlzLnBvc2l0aW9uWSA9ICdiZWxvdyc7XG4gICAgICAgIHRoaXMuY2xvc2UgPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXI7XG4gICAgICAgIGlmIChwb3NYKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRQb3NpdGlvblgocG9zWCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc1kpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uWShwb3NZKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWRNZW51LnByb3RvdHlwZSwgXCJjbGFzc0xpc3RcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgdGFrZXMgY2xhc3NlcyBzZXQgb24gdGhlIGhvc3QgbWQtbWVudSBlbGVtZW50IGFuZCBhcHBsaWVzIHRoZW0gb24gdGhlXG4gICAgICAgICAqIG1lbnUgdGVtcGxhdGUgdGhhdCBkaXNwbGF5cyBpbiB0aGUgb3ZlcmxheSBjb250YWluZXIuICBPdGhlcndpc2UsIGl0J3MgZGlmZmljdWx0XG4gICAgICAgICAqIHRvIHN0eWxlIHRoZSBjb250YWluaW5nIG1lbnUgZnJvbSBvdXRzaWRlIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqIEBwYXJhbSBjbGFzc2VzIGxpc3Qgb2YgY2xhc3MgbmFtZXNcbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGNsYXNzZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsYXNzTGlzdCA9IGNsYXNzZXMuc3BsaXQoJyAnKS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgb2JqW2NsYXNzTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gdG9nZ2xlcyB0aGUgZGlzcGxheSBvZiB0aGUgbWVudSdzIGNsaWNrIGNhdGNoZXIgZWxlbWVudC5cbiAgICAgKiBUaGlzIGVsZW1lbnQgY292ZXJzIHRoZSB2aWV3cG9ydCB3aGVuIHRoZSBtZW51IGlzIG9wZW4gdG8gZGV0ZWN0IGNsaWNrcyBvdXRzaWRlIHRoZSBtZW51LlxuICAgICAqIFRPRE86IGludGVybmFsXG4gICAgICovXG4gICAgTWRNZW51LnByb3RvdHlwZS5fc2V0Q2xpY2tDYXRjaGVyID0gZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgdGhpcy5fc2hvd0NsaWNrQ2F0Y2hlciA9IGJvb2w7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb2N1cyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbWVudS4gVGhpcyBtZXRob2QgaXMgdXNlZCBieSB0aGUgbWVudSB0cmlnZ2VyXG4gICAgICogdG8gZm9jdXMgdGhlIGZpcnN0IGl0ZW0gd2hlbiB0aGUgbWVudSBpcyBvcGVuZWQgYnkgdGhlIEVOVEVSIGtleS5cbiAgICAgKiBUT0RPOiBpbnRlcm5hbFxuICAgICAqL1xuICAgIE1kTWVudS5wcm90b3R5cGUuX2ZvY3VzRmlyc3RJdGVtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLml0ZW1zLmZpcnN0LmZvY3VzKCk7XG4gICAgfTtcbiAgICAvLyBUT0RPKGthcmEpOiB1cGRhdGUgdGhpcyB3aGVuIChrZXlkb3duLmRvd25BcnJvdykgdGVzdGFiaWxpdHkgaXMgZml4ZWRcbiAgICAvLyBUT0RPOiBpbnRlcm5hbFxuICAgIE1kTWVudS5wcm90b3R5cGUuX2hhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IERPV05fQVJST1cpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzTmV4dEl0ZW0oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBVUF9BUlJPVykge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNQcmV2aW91c0l0ZW0oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBUQUIpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRDbG9zZUV2ZW50KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgZW1pdHMgYSBjbG9zZSBldmVudCB0byB3aGljaCB0aGUgdHJpZ2dlciBpcyBzdWJzY3JpYmVkLiBXaGVuIGVtaXR0ZWQsIHRoZVxuICAgICAqIHRyaWdnZXIgd2lsbCBjbG9zZSB0aGUgbWVudS5cbiAgICAgKi9cbiAgICBNZE1lbnUucHJvdG90eXBlLl9lbWl0Q2xvc2VFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNlZEl0ZW1JbmRleCA9IDA7XG4gICAgICAgIHRoaXMuY2xvc2UuZW1pdChudWxsKTtcbiAgICB9O1xuICAgIE1kTWVudS5wcm90b3R5cGUuX2ZvY3VzTmV4dEl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUZvY3VzZWRJdGVtSW5kZXgoMSk7XG4gICAgICAgIHRoaXMuaXRlbXMudG9BcnJheSgpW3RoaXMuX2ZvY3VzZWRJdGVtSW5kZXhdLmZvY3VzKCk7XG4gICAgfTtcbiAgICBNZE1lbnUucHJvdG90eXBlLl9mb2N1c1ByZXZpb3VzSXRlbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlRm9jdXNlZEl0ZW1JbmRleCgtMSk7XG4gICAgICAgIHRoaXMuaXRlbXMudG9BcnJheSgpW3RoaXMuX2ZvY3VzZWRJdGVtSW5kZXhdLmZvY3VzKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzZXRzIGZvY3VzIHRvIHRoZSBjb3JyZWN0IG1lbnUgaXRlbSwgZ2l2ZW4gYSBsaXN0IG9mIG1lbnUgaXRlbXMgYW5kIHRoZSBkZWx0YVxuICAgICAqIGJldHdlZW4gdGhlIGN1cnJlbnRseSBmb2N1c2VkIG1lbnUgaXRlbSBhbmQgdGhlIG5ldyBtZW51IGl0ZW0gdG8gYmUgZm9jdXNlZC4gSXQgd2lsbFxuICAgICAqIGNvbnRpbnVlIHRvIG1vdmUgZG93biB0aGUgbGlzdCB1bnRpbCBpdCBmaW5kcyBhbiBpdGVtIHRoYXQgaXMgbm90IGRpc2FibGVkLCBhbmQgaXQgd2lsbCB3cmFwXG4gICAgICogaWYgaXQgZW5jb3VudGVycyBlaXRoZXIgZW5kIG9mIHRoZSBtZW51LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRlbHRhIHRoZSBkZXNpcmVkIGNoYW5nZSBpbiBmb2N1cyBpbmRleFxuICAgICAqIEBwYXJhbSBtZW51SXRlbXMgdGhlIG1lbnUgaXRlbXMgdGhhdCBzaG91bGQgYmUgZm9jdXNlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICBNZE1lbnUucHJvdG90eXBlLl91cGRhdGVGb2N1c2VkSXRlbUluZGV4ID0gZnVuY3Rpb24gKGRlbHRhLCBtZW51SXRlbXMpIHtcbiAgICAgICAgaWYgKG1lbnVJdGVtcyA9PT0gdm9pZCAwKSB7IG1lbnVJdGVtcyA9IHRoaXMuaXRlbXMudG9BcnJheSgpOyB9XG4gICAgICAgIC8vIHdoZW4gZm9jdXMgd291bGQgbGVhdmUgbWVudSwgd3JhcCB0byBiZWdpbm5pbmcgb3IgZW5kXG4gICAgICAgIHRoaXMuX2ZvY3VzZWRJdGVtSW5kZXggPSAodGhpcy5fZm9jdXNlZEl0ZW1JbmRleCArIGRlbHRhICsgdGhpcy5pdGVtcy5sZW5ndGgpXG4gICAgICAgICAgICAlIHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICAvLyBza2lwIGFsbCBkaXNhYmxlZCBtZW51IGl0ZW1zIHJlY3Vyc2l2ZWx5IHVudGlsIGFuIGFjdGl2ZSBvbmVcbiAgICAgICAgLy8gaXMgcmVhY2hlZCBvciB0aGUgbWVudSBjbG9zZXMgZm9yIG92ZXJyZWFjaGluZyBib3VuZHNcbiAgICAgICAgd2hpbGUgKG1lbnVJdGVtc1t0aGlzLl9mb2N1c2VkSXRlbUluZGV4XS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRm9jdXNlZEl0ZW1JbmRleChkZWx0YSwgbWVudUl0ZW1zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRNZW51LnByb3RvdHlwZS5fc2V0UG9zaXRpb25YID0gZnVuY3Rpb24gKHBvcykge1xuICAgICAgICBpZiAocG9zICE9PSAnYmVmb3JlJyAmJiBwb3MgIT09ICdhZnRlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNZE1lbnVJbnZhbGlkUG9zaXRpb25YKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3NpdGlvblggPSBwb3M7XG4gICAgfTtcbiAgICBNZE1lbnUucHJvdG90eXBlLl9zZXRQb3NpdGlvblkgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmIChwb3MgIT09ICdhYm92ZScgJiYgcG9zICE9PSAnYmVsb3cnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWRNZW51SW52YWxpZFBvc2l0aW9uWSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9zaXRpb25ZID0gcG9zO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZSQ0NShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuVmlld0NoaWxkKF9hbmd1bGFyX2NvcmUuVGVtcGxhdGVSZWYpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NSgnZGVzaWduOnR5cGUnLCBfYW5ndWxhcl9jb3JlLlRlbXBsYXRlUmVmKVxuICAgIF0sIE1kTWVudS5wcm90b3R5cGUsIFwidGVtcGxhdGVSZWZcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDQ1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db250ZW50Q2hpbGRyZW4oTWRNZW51SXRlbSksIFxuICAgICAgICBfX21ldGFkYXRhJDQ1KCdkZXNpZ246dHlwZScsIF9hbmd1bGFyX2NvcmUuUXVlcnlMaXN0KVxuICAgIF0sIE1kTWVudS5wcm90b3R5cGUsIFwiaXRlbXNcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDQ1KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnY2xhc3MnKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDUoJ2Rlc2lnbjp0eXBlJywgU3RyaW5nKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW1N0cmluZ10pXG4gICAgXSwgTWRNZW51LnByb3RvdHlwZSwgXCJjbGFzc0xpc3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZSQ0NShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuT3V0cHV0KCksIFxuICAgICAgICBfX21ldGFkYXRhJDQ1KCdkZXNpZ246dHlwZScsIE9iamVjdClcbiAgICBdLCBNZE1lbnUucHJvdG90eXBlLCBcImNsb3NlXCIsIHZvaWQgMCk7XG4gICAgTWRNZW51ID0gX19kZWNvcmF0ZSQ0NShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuQ29tcG9uZW50KHtzZWxlY3RvcjogJ21kLW1lbnUnLFxuICAgICAgICAgICAgaG9zdDogeyAncm9sZSc6ICdtZW51JyB9LFxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPHRlbXBsYXRlPiA8ZGl2IGNsYXNzPVxcXCJtZC1tZW51XFxcIiBbbmdDbGFzc109XFxcIl9jbGFzc0xpc3RcXFwiIChjbGljayk9XFxcIl9lbWl0Q2xvc2VFdmVudCgpXFxcIiAoa2V5ZG93bik9XFxcIl9oYW5kbGVLZXlkb3duKCRldmVudClcXFwiPiA8bmctY29udGVudD48L25nLWNvbnRlbnQ+IDwvZGl2PiA8L3RlbXBsYXRlPiA8ZGl2IGNsYXNzPVxcXCJtZC1tZW51LWNsaWNrLWNhdGNoZXJcXFwiICpuZ0lmPVxcXCJfc2hvd0NsaWNrQ2F0Y2hlclxcXCIgKGNsaWNrKT1cXFwiX2VtaXRDbG9zZUV2ZW50KClcXFwiPjwvZGl2PlwiLFxuICAgICAgICAgICAgc3R5bGVzOiBbXCIubWQtbWVudSB7IGJveC1zaGFkb3c6IDBweCAzcHggMXB4IC0ycHggcmdiYSgwLCAwLCAwLCAwLjIpLCAwcHggMnB4IDJweCAwcHggcmdiYSgwLCAwLCAwLCAwLjE0KSwgMHB4IDFweCA1cHggMHB4IHJnYmEoMCwgMCwgMCwgMC4xMik7IG1pbi13aWR0aDogMTEycHg7IG1heC13aWR0aDogMjgwcHg7IG1heC1oZWlnaHQ6IGNhbGMoMTAwdmggKyA0OHB4KTsgb3ZlcmZsb3c6IGF1dG87IC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDsgcGFkZGluZy10b3A6IDhweDsgcGFkZGluZy1ib3R0b206IDhweDsgfSBbbWQtbWVudS1pdGVtXSB7IGN1cnNvcjogcG9pbnRlcjsgdXNlci1zZWxlY3Q6IG5vbmU7IG91dGxpbmU6IG5vbmU7IGJvcmRlcjogbm9uZTsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgb3ZlcmZsb3cteDogaGlkZGVuOyB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpczsgZGlzcGxheTogZmxleDsgZmxleC1kaXJlY3Rpb246IHJvdzsgYWxpZ24taXRlbXM6IGNlbnRlcjsgaGVpZ2h0OiA0OHB4OyBwYWRkaW5nOiAwIDE2cHg7IGZvbnQtc2l6ZTogMTZweDsgZm9udC1mYW1pbHk6IFJvYm90bywgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgc2Fucy1zZXJpZjsgdGV4dC1hbGlnbjogc3RhcnQ7IHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfSBbbWQtbWVudS1pdGVtXVtkaXNhYmxlZF0geyBjdXJzb3I6IGRlZmF1bHQ7IH0gYnV0dG9uW21kLW1lbnUtaXRlbV0geyB3aWR0aDogMTAwJTsgfSAubWQtbWVudS1jbGljay1jYXRjaGVyIHsgcG9zaXRpb246IGZpeGVkOyB0b3A6IDA7IGxlZnQ6IDA7IHJpZ2h0OiAwOyBib3R0b206IDA7IH0gLyojIHNvdXJjZU1hcHBpbmdVUkw9bWVudS5jc3MubWFwICovIFwiXSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbWRNZW51J1xuICAgICAgICB9KSxcbiAgICAgICAgX19wYXJhbSQ1KDAsIF9hbmd1bGFyX2NvcmUuQXR0cmlidXRlKCd4LXBvc2l0aW9uJykpLFxuICAgICAgICBfX3BhcmFtJDUoMSwgX2FuZ3VsYXJfY29yZS5BdHRyaWJ1dGUoJ3ktcG9zaXRpb24nKSksIFxuICAgICAgICBfX21ldGFkYXRhJDQ1KCdkZXNpZ246cGFyYW10eXBlcycsIFtTdHJpbmcsIFN0cmluZ10pXG4gICAgXSwgTWRNZW51KTtcbiAgICByZXR1cm4gTWRNZW51O1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkNDcgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNDcgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogVGhpcyBkaXJlY3RpdmUgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGFuIG1kLW1lbnUgdGFnLiAgSXQgaXNcbiAqIHJlc3BvbnNpYmxlIGZvciB0b2dnbGluZyB0aGUgZGlzcGxheSBvZiB0aGUgcHJvdmlkZWQgbWVudSBpbnN0YW5jZS5cbiAqL1xudmFyIE1kTWVudVRyaWdnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kTWVudVRyaWdnZXIoX292ZXJsYXksIF9lbGVtZW50LCBfdmlld0NvbnRhaW5lclJlZiwgX3JlbmRlcmVyKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXkgPSBfb3ZlcmxheTtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmID0gX3ZpZXdDb250YWluZXJSZWY7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9tZW51T3BlbiA9IGZhbHNlO1xuICAgICAgICAvLyB0cmFja2luZyBpbnB1dCB0eXBlIGlzIG5lY2Vzc2FyeSBzbyBpdCdzIHBvc3NpYmxlIHRvIG9ubHkgYXV0by1mb2N1c1xuICAgICAgICAvLyB0aGUgZmlyc3QgaXRlbSBvZiB0aGUgbGlzdCB3aGVuIHRoZSBtZW51IGlzIG9wZW5lZCB2aWEgdGhlIGtleWJvYXJkXG4gICAgICAgIHRoaXMuX29wZW5lZEZyb21LZXlib2FyZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uTWVudU9wZW4gPSBuZXcgX2FuZ3VsYXJfY29yZS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vbk1lbnVDbG9zZSA9IG5ldyBfYW5ndWxhcl9jb3JlLkV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2NoZWNrTWVudSgpO1xuICAgICAgICB0aGlzLm1lbnUuY2xvc2Uuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNsb3NlTWVudSgpOyB9KTtcbiAgICB9O1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkgeyB0aGlzLmRlc3Ryb3lNZW51KCk7IH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1kTWVudVRyaWdnZXIucHJvdG90eXBlLCBcIm1lbnVPcGVuXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tZW51T3BlbjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUudG9nZ2xlTWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lbnVPcGVuID8gdGhpcy5jbG9zZU1lbnUoKSA6IHRoaXMub3Blbk1lbnUoKTtcbiAgICB9O1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLm9wZW5NZW51ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVPdmVybGF5KCk7XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3BvcnRhbCk7XG4gICAgICAgIHRoaXMuX2luaXRNZW51KCk7XG4gICAgfTtcbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5jbG9zZU1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRNZW51KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLmRlc3Ryb3lNZW51ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmludm9rZUVsZW1lbnRNZXRob2QodGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnZm9jdXMnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIG1lbnUgc3RhdGUgdG8gb3BlbiBhbmQgZm9jdXNlcyB0aGUgZmlyc3QgaXRlbSBpZlxuICAgICAqIHRoZSBtZW51IHdhcyBvcGVuZWQgdmlhIHRoZSBrZXlib2FyZC5cbiAgICAgKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5faW5pdE1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NldElzTWVudU9wZW4odHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLl9vcGVuZWRGcm9tS2V5Ym9hcmQpIHtcbiAgICAgICAgICAgIHRoaXMubWVudS5fZm9jdXNGaXJzdEl0ZW0oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJlc2V0cyB0aGUgbWVudSB3aGVuIGl0J3MgY2xvc2VkLCBtb3N0IGltcG9ydGFudGx5IHJlc3RvcmluZ1xuICAgICAqIGZvY3VzIHRvIHRoZSBtZW51IHRyaWdnZXIgaWYgdGhlIG1lbnUgd2FzIG9wZW5lZCB2aWEgdGhlIGtleWJvYXJkLlxuICAgICAqL1xuICAgIE1kTWVudVRyaWdnZXIucHJvdG90eXBlLl9yZXNldE1lbnUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3NldElzTWVudU9wZW4oZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5fb3BlbmVkRnJvbUtleWJvYXJkKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgICAgICB0aGlzLl9vcGVuZWRGcm9tS2V5Ym9hcmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gc2V0IHN0YXRlIHJhdGhlciB0aGFuIHRvZ2dsZSB0byBzdXBwb3J0IHRyaWdnZXJzIHNoYXJpbmcgYSBtZW51XG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX3NldElzTWVudU9wZW4gPSBmdW5jdGlvbiAoaXNPcGVuKSB7XG4gICAgICAgIHRoaXMuX21lbnVPcGVuID0gaXNPcGVuO1xuICAgICAgICB0aGlzLm1lbnUuX3NldENsaWNrQ2F0Y2hlcihpc09wZW4pO1xuICAgICAgICB0aGlzLl9tZW51T3BlbiA/IHRoaXMub25NZW51T3Blbi5lbWl0KG51bGwpIDogdGhpcy5vbk1lbnVDbG9zZS5lbWl0KG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogIFRoaXMgbWV0aG9kIGNoZWNrcyB0aGF0IGEgdmFsaWQgaW5zdGFuY2Ugb2YgTWRNZW51IGhhcyBiZWVuIHBhc3NlZCBpbnRvXG4gICAgICogIG1kLW1lbnUtdHJpZ2dlci1mb3IuICBJZiBub3QsIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX2NoZWNrTWVudSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lbnUgfHwgISh0aGlzLm1lbnUgaW5zdGFuY2VvZiBNZE1lbnUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWRNZW51TWlzc2luZ0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqICBUaGlzIG1ldGhvZCBjcmVhdGVzIHRoZSBvdmVybGF5IGZyb20gdGhlIHByb3ZpZGVkIG1lbnUncyB0ZW1wbGF0ZSBhbmQgc2F2ZXMgaXRzXG4gICAgICogIE92ZXJsYXlSZWYgc28gdGhhdCBpdCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIERPTSB3aGVuIG9wZW5NZW51IGlzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBNZE1lbnVUcmlnZ2VyLnByb3RvdHlwZS5fY3JlYXRlT3ZlcmxheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0YWwgPSBuZXcgVGVtcGxhdGVQb3J0YWwodGhpcy5tZW51LnRlbXBsYXRlUmVmLCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZSh0aGlzLl9nZXRPdmVybGF5Q29uZmlnKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBidWlsZHMgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IG5lZWRlZCB0byBjcmVhdGUgdGhlIG92ZXJsYXksIHRoZSBPdmVybGF5U3RhdGUuXG4gICAgICogQHJldHVybnMgT3ZlcmxheVN0YXRlXG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX2dldE92ZXJsYXlDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdmVybGF5U3RhdGUgPSBuZXcgT3ZlcmxheVN0YXRlKCk7XG4gICAgICAgIG92ZXJsYXlTdGF0ZS5wb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5fZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgcmV0dXJuIG92ZXJsYXlTdGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGJ1aWxkcyB0aGUgcG9zaXRpb24gc3RyYXRlZ3kgZm9yIHRoZSBvdmVybGF5LCBzbyB0aGUgbWVudSBpcyBwcm9wZXJseSBjb25uZWN0ZWRcbiAgICAgKiB0byB0aGUgdHJpZ2dlci5cbiAgICAgKiBAcmV0dXJucyBDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5XG4gICAgICovXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX2dldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcG9zaXRpb25YID0gdGhpcy5tZW51LnBvc2l0aW9uWCA9PT0gJ2JlZm9yZScgPyAnZW5kJyA6ICdzdGFydCc7XG4gICAgICAgIHZhciBwb3NpdGlvblkgPSB0aGlzLm1lbnUucG9zaXRpb25ZID09PSAnYWJvdmUnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkucG9zaXRpb24oKS5jb25uZWN0ZWRUbyh0aGlzLl9lbGVtZW50LCB7IG9yaWdpblg6IHBvc2l0aW9uWCwgb3JpZ2luWTogcG9zaXRpb25ZIH0sIHsgb3ZlcmxheVg6IHBvc2l0aW9uWCwgb3ZlcmxheVk6IHBvc2l0aW9uWSB9KTtcbiAgICB9O1xuICAgIC8vIFRPRE86IGludGVybmFsXG4gICAgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUuX2hhbmRsZUtleWRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVOVEVSKSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVuZWRGcm9tS2V5Ym9hcmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlJDQ3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5JbnB1dCgnbWQtbWVudS10cmlnZ2VyLWZvcicpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NygnZGVzaWduOnR5cGUnLCBNZE1lbnUpXG4gICAgXSwgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUsIFwibWVudVwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNDcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NygnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUsIFwib25NZW51T3BlblwiLCB2b2lkIDApO1xuICAgIF9fZGVjb3JhdGUkNDcoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLk91dHB1dCgpLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NygnZGVzaWduOnR5cGUnLCBPYmplY3QpXG4gICAgXSwgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUsIFwib25NZW51Q2xvc2VcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDQ3KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Ib3N0TGlzdGVuZXIoJ2NsaWNrJyksIFxuICAgICAgICBfX21ldGFkYXRhJDQ3KCdkZXNpZ246dHlwZScsIEZ1bmN0aW9uKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NygnZGVzaWduOnJldHVybnR5cGUnLCB2b2lkIDApXG4gICAgXSwgTWRNZW51VHJpZ2dlci5wcm90b3R5cGUsIFwidG9nZ2xlTWVudVwiLCBudWxsKTtcbiAgICBNZE1lbnVUcmlnZ2VyID0gX19kZWNvcmF0ZSQ0NyhbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuRGlyZWN0aXZlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21kLW1lbnUtdHJpZ2dlci1mb3JdJyxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6ICd0cnVlJyxcbiAgICAgICAgICAgICAgICAnKGtleWRvd24pJzogJ19oYW5kbGVLZXlkb3duKCRldmVudCknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtZE1lbnVUcmlnZ2VyJ1xuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDcoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW092ZXJsYXksIF9hbmd1bGFyX2NvcmUuRWxlbWVudFJlZiwgX2FuZ3VsYXJfY29yZS5WaWV3Q29udGFpbmVyUmVmLCBfYW5ndWxhcl9jb3JlLlJlbmRlcmVyXSlcbiAgICBdLCBNZE1lbnVUcmlnZ2VyKTtcbiAgICByZXR1cm4gTWRNZW51VHJpZ2dlcjtcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDQ0ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQ0ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTWRNZW51TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZE1lbnVNb2R1bGUoKSB7XG4gICAgfVxuICAgIE1kTWVudU1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE1kTWVudU1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogT1ZFUkxBWV9QUk9WSURFUlMsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBNZE1lbnVNb2R1bGUgPSBfX2RlY29yYXRlJDQ0KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbT3ZlcmxheU1vZHVsZSwgX2FuZ3VsYXJfY29tbW9uLkNvbW1vbk1vZHVsZV0sXG4gICAgICAgICAgICBleHBvcnRzOiBbTWRNZW51LCBNZE1lbnVJdGVtLCBNZE1lbnVUcmlnZ2VyXSxcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01kTWVudSwgTWRNZW51SXRlbSwgTWRNZW51VHJpZ2dlcl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0NCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZE1lbnVNb2R1bGUpO1xuICAgIHJldHVybiBNZE1lbnVNb2R1bGU7XG59KCkpO1xuXG4vLyBUT0RPKGplbGJvdXJuKTogcmVzaXppbmdcbi8vIFRPRE8oamVsYm91cm4pOiBhZnRlck9wZW4gYW5kIGJlZm9yZUNsb3NlXG4vKipcbiAqIFJlZmVyZW5jZSB0byBhIGRpYWxvZyBvcGVuZWQgdmlhIHRoZSBNZERpYWxvZyBzZXJ2aWNlLlxuICovXG52YXIgTWREaWFsb2dSZWYgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1kRGlhbG9nUmVmKF9vdmVybGF5UmVmKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBfb3ZlcmxheVJlZjtcbiAgICAgICAgLyoqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGUgdXNlciB0aGF0IHRoZSBkaWFsb2cgaGFzIGZpbmlzaGVkIGNsb3NpbmcuICovXG4gICAgICAgIHRoaXMuX2FmdGVyQ2xvc2VkID0gbmV3IHJ4anNfU3ViamVjdC5TdWJqZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBkaWFsb2cuXG4gICAgICogQHBhcmFtIGRpYWxvZ1Jlc3VsdCBPcHRpb25hbCByZXN1bHQgdG8gcmV0dXJuIHRvIHRoZSBkaWFsb2cgb3BlbmVyLlxuICAgICAqL1xuICAgIE1kRGlhbG9nUmVmLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChkaWFsb2dSZXN1bHQpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX2FmdGVyQ2xvc2VkLm5leHQoZGlhbG9nUmVzdWx0KTtcbiAgICAgICAgdGhpcy5fYWZ0ZXJDbG9zZWQuY29tcGxldGUoKTtcbiAgICB9O1xuICAgIC8qKiBHZXRzIGFuIG9ic2VydmFibGUgdGhhdCBpcyBub3RpZmllZCB3aGVuIHRoZSBkaWFsb2cgaXMgZmluaXNoZWQgY2xvc2luZy4gKi9cbiAgICBNZERpYWxvZ1JlZi5wcm90b3R5cGUuYWZ0ZXJDbG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZnRlckNsb3NlZC5hc09ic2VydmFibGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBNZERpYWxvZ1JlZjtcbn0oKSk7XG5cbi8qKiBDdXN0b20gaW5qZWN0b3IgdHlwZSBzcGVjaWZpY2FsbHkgZm9yIGluc3RhbnRpYXRpbmcgY29tcG9uZW50cyB3aXRoIGEgZGlhbG9nLiAqL1xudmFyIERpYWxvZ0luamVjdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaWFsb2dJbmplY3RvcihfZGlhbG9nUmVmLCBfcGFyZW50SW5qZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fZGlhbG9nUmVmID0gX2RpYWxvZ1JlZjtcbiAgICAgICAgdGhpcy5fcGFyZW50SW5qZWN0b3IgPSBfcGFyZW50SW5qZWN0b3I7XG4gICAgfVxuICAgIERpYWxvZ0luamVjdG9yLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4sIG5vdEZvdW5kVmFsdWUpIHtcbiAgICAgICAgaWYgKHRva2VuID09PSBNZERpYWxvZ1JlZikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RpYWxvZ1JlZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50SW5qZWN0b3IuZ2V0KHRva2VuLCBub3RGb3VuZFZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBEaWFsb2dJbmplY3Rvcjtcbn0oKSk7XG5cbnZhciBfX2V4dGVuZHMkMjAgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqIEV4Y2VwdGlvbiB0aHJvd24gd2hlbiBhIENvbXBvbmVudFBvcnRhbCBpcyBhdHRhY2hlZCB0byBhIERvbVBvcnRhbEhvc3Qgd2l0aG91dCBhbiBvcmlnaW4uICovXG52YXIgTWREaWFsb2dDb250ZW50QWxyZWFkeUF0dGFjaGVkRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQyMChNZERpYWxvZ0NvbnRlbnRBbHJlYWR5QXR0YWNoZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZERpYWxvZ0NvbnRlbnRBbHJlYWR5QXR0YWNoZWRFcnJvcigpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ0F0dGVtcHRpbmcgdG8gYXR0YWNoIGRpYWxvZyBjb250ZW50IGFmdGVyIGNvbnRlbnQgaXMgYWxyZWFkeSBhdHRhY2hlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gTWREaWFsb2dDb250ZW50QWxyZWFkeUF0dGFjaGVkRXJyb3I7XG59KE1kRXJyb3IpKTtcblxudmFyIF9fZXh0ZW5kcyQxOSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgX19kZWNvcmF0ZSQ0OSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ0OSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBJbnRlcm5hbCBjb21wb25lbnQgdGhhdCB3cmFwcyB1c2VyLXByb3ZpZGVkIGRpYWxvZyBjb250ZW50LlxuICovXG52YXIgTWREaWFsb2dDb250YWluZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyQxOShNZERpYWxvZ0NvbnRhaW5lciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZERpYWxvZ0NvbnRhaW5lcihfbmdab25lKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9uZ1pvbmUgPSBfbmdab25lO1xuICAgICAgICAvKiogRWxlbWVudCB0aGF0IHdhcyBmb2N1c2VkIGJlZm9yZSB0aGUgZGlhbG9nIHdhcyBvcGVuZWQuIFNhdmUgdGhpcyB0byByZXN0b3JlIHVwb24gY2xvc2UuICovXG4gICAgICAgIHRoaXMuX2VsZW1lbnRGb2N1c2VkQmVmb3JlRGlhbG9nV2FzT3BlbmVkID0gbnVsbDtcbiAgICB9XG4gICAgLyoqIEF0dGFjaCBhIHBvcnRhbCBhcyBjb250ZW50IHRvIHRoaXMgZGlhbG9nIGNvbnRhaW5lci4gKi9cbiAgICBNZERpYWxvZ0NvbnRhaW5lci5wcm90b3R5cGUuYXR0YWNoQ29tcG9uZW50UG9ydGFsID0gZnVuY3Rpb24gKHBvcnRhbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fcG9ydGFsSG9zdC5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWREaWFsb2dDb250ZW50QWxyZWFkeUF0dGFjaGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXR0YWNoUmVzdWx0ID0gdGhpcy5fcG9ydGFsSG9zdC5hdHRhY2hDb21wb25lbnRQb3J0YWwocG9ydGFsKTtcbiAgICAgICAgLy8gSWYgd2VyZSB0byBhdHRlbXB0IHRvIGZvY3VzIGltbWVkaWF0ZWx5LCB0aGVuIHRoZSBjb250ZW50IG9mIHRoZSBkaWFsb2cgd291bGQgbm90IHlldCBiZVxuICAgICAgICAvLyByZWFkeSBpbiBpbnN0YW5jZXMgd2hlcmUgY2hhbmdlIGRldGVjdGlvbiBoYXMgdG8gcnVuIGZpcnN0LiBUbyBkZWFsIHdpdGggdGhpcywgd2Ugc2ltcGx5XG4gICAgICAgIC8vIHdhaXQgZm9yIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZW1wdHkuXG4gICAgICAgIHRoaXMuX25nWm9uZS5vbk1pY3JvdGFza0VtcHR5LmZpcnN0KCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9lbGVtZW50Rm9jdXNlZEJlZm9yZURpYWxvZ1dhc09wZW5lZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBfdGhpcy5fZm9jdXNUcmFwLmZvY3VzRmlyc3RUYWJiYWJsZUVsZW1lbnQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhdHRhY2hSZXN1bHQ7XG4gICAgfTtcbiAgICBNZERpYWxvZ0NvbnRhaW5lci5wcm90b3R5cGUuYXR0YWNoVGVtcGxhdGVQb3J0YWwgPSBmdW5jdGlvbiAocG9ydGFsKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdOb3QgeWV0IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICAvKiogSGFuZGxlcyB0aGUgdXNlciBwcmVzc2luZyB0aGUgRXNjYXBlIGtleS4gKi9cbiAgICBNZERpYWxvZ0NvbnRhaW5lci5wcm90b3R5cGUuaGFuZGxlRXNjYXBlS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPKGplbGJvdXJuKTogYWRkIE1kRGlhbG9nQ29uZmlnIG9wdGlvbiB0byBkaXNhYmxlIHRoaXMgYmVoYXZpb3IuXG4gICAgICAgIHRoaXMuZGlhbG9nUmVmLmNsb3NlKCk7XG4gICAgfTtcbiAgICBNZERpYWxvZ0NvbnRhaW5lci5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFdoZW4gdGhlIGRpYWxvZyBpcyBkZXN0cm95ZWQsIHJldHVybiBmb2N1cyB0byB0aGUgZWxlbWVudCB0aGF0IG9yaWdpbmFsbHkgaGFkIGl0IGJlZm9yZVxuICAgICAgICAvLyB0aGUgZGlhbG9nIHdhcyBvcGVuZWQuIFdhaXQgZm9yIHRoZSBET00gdG8gZmluaXNoIHNldHRsaW5nIGJlZm9yZSBjaGFuZ2luZyB0aGUgZm9jdXMgc29cbiAgICAgICAgLy8gdGhhdCBpdCBkb2Vzbid0IGVuZCB1cCBiYWNrIG9uIHRoZSA8Ym9keT4uXG4gICAgICAgIHRoaXMuX25nWm9uZS5vbk1pY3JvdGFza0VtcHR5LmZpcnN0KCkuc3Vic2NyaWJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9lbGVtZW50Rm9jdXNlZEJlZm9yZURpYWxvZ1dhc09wZW5lZC5mb2N1cygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUkNDkoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLlZpZXdDaGlsZChQb3J0YWxIb3N0RGlyZWN0aXZlKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDkoJ2Rlc2lnbjp0eXBlJywgUG9ydGFsSG9zdERpcmVjdGl2ZSlcbiAgICBdLCBNZERpYWxvZ0NvbnRhaW5lci5wcm90b3R5cGUsIFwiX3BvcnRhbEhvc3RcIiwgdm9pZCAwKTtcbiAgICBfX2RlY29yYXRlJDQ5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5WaWV3Q2hpbGQoRm9jdXNUcmFwKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDkoJ2Rlc2lnbjp0eXBlJywgRm9jdXNUcmFwKVxuICAgIF0sIE1kRGlhbG9nQ29udGFpbmVyLnByb3RvdHlwZSwgXCJfZm9jdXNUcmFwXCIsIHZvaWQgMCk7XG4gICAgTWREaWFsb2dDb250YWluZXIgPSBfX2RlY29yYXRlJDQ5KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5Db21wb25lbnQoe3NlbGVjdG9yOiAnbWQtZGlhbG9nLWNvbnRhaW5lcicsXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8Zm9jdXMtdHJhcD4gPHRlbXBsYXRlIHBvcnRhbEhvc3Q+PC90ZW1wbGF0ZT4gPC9mb2N1cy10cmFwPiBcIixcbiAgICAgICAgICAgIHN0eWxlczogW1wibWQtZGlhbG9nLWNvbnRhaW5lciB7IGJveC1zaGFkb3c6IDBweCAxMXB4IDE1cHggLTdweCByZ2JhKDAsIDAsIDAsIDAuMiksIDBweCAyNHB4IDM4cHggM3B4IHJnYmEoMCwgMCwgMCwgMC4xNCksIDBweCA5cHggNDZweCA4cHggcmdiYSgwLCAwLCAwLCAwLjEyKTsgZGlzcGxheTogYmxvY2s7IG92ZXJmbG93OiBoaWRkZW47IHBhZGRpbmc6IDI0cHg7IH0gLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGlhbG9nLWNvbnRhaW5lci5jc3MubWFwICovIFwiXSxcbiAgICAgICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWQtZGlhbG9nLWNvbnRhaW5lcicsXG4gICAgICAgICAgICAgICAgJ1thdHRyLnJvbGVdJzogJ2RpYWxvZ0NvbmZpZz8ucm9sZScsXG4gICAgICAgICAgICAgICAgJyhrZXlkb3duLmVzY2FwZSknOiAnaGFuZGxlRXNjYXBlS2V5KCknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuY2Fwc3VsYXRpb246IF9hbmd1bGFyX2NvcmUuVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICAgICAgfSksIFxuICAgICAgICBfX21ldGFkYXRhJDQ5KCdkZXNpZ246cGFyYW10eXBlcycsIFtfYW5ndWxhcl9jb3JlLk5nWm9uZV0pXG4gICAgXSwgTWREaWFsb2dDb250YWluZXIpO1xuICAgIHJldHVybiBNZERpYWxvZ0NvbnRhaW5lcjtcbn0oQmFzZVBvcnRhbEhvc3QpKTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBvcGVuaW5nIGEgbW9kYWwgZGlhbG9nIHdpdGggdGhlIE1kRGlhbG9nIHNlcnZpY2UuXG4gKi9cbnZhciBNZERpYWxvZ0NvbmZpZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWREaWFsb2dDb25maWcoKSB7XG4gICAgICAgIC8qKiBUaGUgQVJJQSByb2xlIG9mIHRoZSBkaWFsb2cgZWxlbWVudC4gKi9cbiAgICAgICAgdGhpcy5yb2xlID0gJ2RpYWxvZyc7XG4gICAgfVxuICAgIHJldHVybiBNZERpYWxvZ0NvbmZpZztcbn0oKSk7XG5cbnZhciBfX2RlY29yYXRlJDQ4ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQ4ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vLyBUT0RPKGplbGJvdXJuKTogYWRkIHN1cHBvcnQgZm9yIG9wZW5pbmcgd2l0aCBhIFRlbXBsYXRlUmVmXG4vLyBUT0RPKGplbGJvdXJuKTogYWRkIGBjbG9zZUFsbGAgbWV0aG9kXG4vLyBUT0RPKGplbGJvdXJuKTogZGVmYXVsdCBkaWFsb2cgY29uZmlnXG4vLyBUT0RPKGplbGJvdXJuKTogZXNjYXBlIGtleSBjbG9zZXMgZGlhbG9nXG4vLyBUT0RPKGplbGJvdXJuKTogZGlhbG9nIGNvbnRlbnQgZGlyZWN0aXZlcyAoZS5nLiwgbWQtZGlhbG9nLWhlYWRlcilcbi8vIFRPRE8oamVsYm91cm4pOiBhbmltYXRpb25zXG4vKipcbiAqIFNlcnZpY2UgdG8gb3BlbiBNYXRlcmlhbCBEZXNpZ24gbW9kYWwgZGlhbG9ncy5cbiAqL1xudmFyIE1kRGlhbG9nID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZERpYWxvZyhfb3ZlcmxheSwgX2luamVjdG9yKSB7XG4gICAgICAgIHRoaXMuX292ZXJsYXkgPSBfb3ZlcmxheTtcbiAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBfaW5qZWN0b3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIGEgbW9kYWwgZGlhbG9nIGNvbnRhaW5pbmcgdGhlIGdpdmVuIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IFR5cGUgb2YgdGhlIGNvbXBvbmVudCB0byBsb2FkIGludG8gdGhlIGxvYWQuXG4gICAgICogQHBhcmFtIGNvbmZpZ1xuICAgICAqL1xuICAgIE1kRGlhbG9nLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgY29uZmlnKSB7XG4gICAgICAgIHZhciBvdmVybGF5UmVmID0gdGhpcy5fY3JlYXRlT3ZlcmxheShjb25maWcpO1xuICAgICAgICB2YXIgZGlhbG9nQ29udGFpbmVyID0gdGhpcy5fYXR0YWNoRGlhbG9nQ29udGFpbmVyKG92ZXJsYXlSZWYsIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdHRhY2hEaWFsb2dDb250ZW50KGNvbXBvbmVudCwgZGlhbG9nQ29udGFpbmVyLCBvdmVybGF5UmVmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIG92ZXJsYXkgaW50byB3aGljaCB0aGUgZGlhbG9nIHdpbGwgYmUgbG9hZGVkLlxuICAgICAqIEBwYXJhbSBkaWFsb2dDb25maWcgVGhlIGRpYWxvZyBjb25maWd1cmF0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIE92ZXJsYXlSZWYgZm9yIHRoZSBjcmVhdGVkIG92ZXJsYXkuXG4gICAgICovXG4gICAgTWREaWFsb2cucHJvdG90eXBlLl9jcmVhdGVPdmVybGF5ID0gZnVuY3Rpb24gKGRpYWxvZ0NvbmZpZykge1xuICAgICAgICB2YXIgb3ZlcmxheVN0YXRlID0gdGhpcy5fZ2V0T3ZlcmxheVN0YXRlKGRpYWxvZ0NvbmZpZyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LmNyZWF0ZShvdmVybGF5U3RhdGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgYW4gTWREaWFsb2dDb250YWluZXIgdG8gYSBkaWFsb2cncyBhbHJlYWR5LWNyZWF0ZWQgb3ZlcmxheS5cbiAgICAgKiBAcGFyYW0gb3ZlcmxheSBSZWZlcmVuY2UgdG8gdGhlIGRpYWxvZydzIHVuZGVybHlpbmcgb3ZlcmxheS5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBkaWFsb2cgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIGEgQ29tcG9uZW50UmVmIGZvciB0aGUgYXR0YWNoZWQgY29udGFpbmVyLlxuICAgICAqL1xuICAgIE1kRGlhbG9nLnByb3RvdHlwZS5fYXR0YWNoRGlhbG9nQ29udGFpbmVyID0gZnVuY3Rpb24gKG92ZXJsYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgY29udGFpbmVyUG9ydGFsID0gbmV3IENvbXBvbmVudFBvcnRhbChNZERpYWxvZ0NvbnRhaW5lciwgY29uZmlnLnZpZXdDb250YWluZXJSZWYpO1xuICAgICAgICB2YXIgY29udGFpbmVyUmVmID0gb3ZlcmxheS5hdHRhY2goY29udGFpbmVyUG9ydGFsKTtcbiAgICAgICAgY29udGFpbmVyUmVmLmluc3RhbmNlLmRpYWxvZ0NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lclJlZi5pbnN0YW5jZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHRoZSB1c2VyLXByb3ZpZGVkIGNvbXBvbmVudCB0byB0aGUgYWxyZWFkeS1jcmVhdGVkIE1kRGlhbG9nQ29udGFpbmVyLlxuICAgICAqIEBwYXJhbSBjb21wb25lbnQgVGhlIHR5cGUgb2YgY29tcG9uZW50IGJlaW5nIGxvYWRlZCBpbnRvIHRoZSBkaWFsb2cuXG4gICAgICogQHBhcmFtIGRpYWxvZ0NvbnRhaW5lciBSZWZlcmVuY2UgdG8gdGhlIHdyYXBwaW5nIE1kRGlhbG9nQ29udGFpbmVyLlxuICAgICAqIEBwYXJhbSBvdmVybGF5UmVmIFJlZmVyZW5jZSB0byB0aGUgb3ZlcmxheSBpbiB3aGljaCB0aGUgZGlhbG9nIHJlc2lkZXMuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgTWREaWFsb2dSZWYgdGhhdCBzaG91bGQgYmUgcmV0dXJuZWQgdG8gdGhlIHVzZXIuXG4gICAgICovXG4gICAgTWREaWFsb2cucHJvdG90eXBlLl9hdHRhY2hEaWFsb2dDb250ZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgZGlhbG9nQ29udGFpbmVyLCBvdmVybGF5UmVmKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIHJlZmVyZW5jZSB0byB0aGUgZGlhbG9nIHdlJ3JlIGNyZWF0aW5nIGluIG9yZGVyIHRvIGdpdmUgdGhlIHVzZXIgYSBoYW5kbGVcbiAgICAgICAgLy8gdG8gbW9kaWZ5IGFuZCBjbG9zZSBpdC5cbiAgICAgICAgdmFyIGRpYWxvZ1JlZiA9IG5ldyBNZERpYWxvZ1JlZihvdmVybGF5UmVmKTtcbiAgICAgICAgLy8gV2hlbiB0aGUgZGlhbG9nIGJhY2tkcm9wIGlzIGNsaWNrZWQsIHdlIHdhbnQgdG8gY2xvc2UgaXQuXG4gICAgICAgIG92ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpLnN1YnNjcmliZShmdW5jdGlvbiAoKSB7IHJldHVybiBkaWFsb2dSZWYuY2xvc2UoKTsgfSk7XG4gICAgICAgIC8vIFNldCB0aGUgZGlhbG9nUmVmIHRvIHRoZSBjb250YWluZXIgc28gdGhhdCBpdCBjYW4gdXNlIHRoZSByZWYgdG8gY2xvc2UgdGhlIGRpYWxvZy5cbiAgICAgICAgZGlhbG9nQ29udGFpbmVyLmRpYWxvZ1JlZiA9IGRpYWxvZ1JlZjtcbiAgICAgICAgLy8gV2UgY3JlYXRlIGFuIGluamVjdG9yIHNwZWNpZmljYWxseSBmb3IgdGhlIGNvbXBvbmVudCB3ZSdyZSBpbnN0YW50aWF0aW5nIHNvIHRoYXQgaXQgY2FuXG4gICAgICAgIC8vIGluamVjdCB0aGUgTWREaWFsb2dSZWYuIFRoaXMgYWxsb3dzIGEgY29tcG9uZW50IGxvYWRlZCBpbnNpZGUgb2YgYSBkaWFsb2cgdG8gY2xvc2UgaXRzZWxmXG4gICAgICAgIC8vIGFuZCwgb3B0aW9uYWxseSwgdG8gcmV0dXJuIGEgdmFsdWUuXG4gICAgICAgIHZhciBkaWFsb2dJbmplY3RvciA9IG5ldyBEaWFsb2dJbmplY3RvcihkaWFsb2dSZWYsIHRoaXMuX2luamVjdG9yKTtcbiAgICAgICAgdmFyIGNvbnRlbnRQb3J0YWwgPSBuZXcgQ29tcG9uZW50UG9ydGFsKGNvbXBvbmVudCwgbnVsbCwgZGlhbG9nSW5qZWN0b3IpO1xuICAgICAgICB2YXIgY29udGVudFJlZiA9IGRpYWxvZ0NvbnRhaW5lci5hdHRhY2hDb21wb25lbnRQb3J0YWwoY29udGVudFBvcnRhbCk7XG4gICAgICAgIGRpYWxvZ1JlZi5jb21wb25lbnRJbnN0YW5jZSA9IGNvbnRlbnRSZWYuaW5zdGFuY2U7XG4gICAgICAgIHJldHVybiBkaWFsb2dSZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG92ZXJsYXkgc3RhdGUgZnJvbSBhIGRpYWxvZyBjb25maWcuXG4gICAgICogQHBhcmFtIGRpYWxvZ0NvbmZpZyBUaGUgZGlhbG9nIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHJldHVybnMgVGhlIG92ZXJsYXkgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBNZERpYWxvZy5wcm90b3R5cGUuX2dldE92ZXJsYXlTdGF0ZSA9IGZ1bmN0aW9uIChkaWFsb2dDb25maWcpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gbmV3IE92ZXJsYXlTdGF0ZSgpO1xuICAgICAgICBzdGF0ZS5oYXNCYWNrZHJvcCA9IHRydWU7XG4gICAgICAgIHN0YXRlLnBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcbiAgICAgICAgICAgIC5nbG9iYWwoKVxuICAgICAgICAgICAgLmNlbnRlckhvcml6b250YWxseSgpXG4gICAgICAgICAgICAuY2VudGVyVmVydGljYWxseSgpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcbiAgICBNZERpYWxvZyA9IF9fZGVjb3JhdGUkNDgoW1xuICAgICAgICBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUoKSwgXG4gICAgICAgIF9fbWV0YWRhdGEkNDgoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW092ZXJsYXksIF9hbmd1bGFyX2NvcmUuSW5qZWN0b3JdKVxuICAgIF0sIE1kRGlhbG9nKTtcbiAgICByZXR1cm4gTWREaWFsb2c7XG59KCkpO1xudmFyIE1kRGlhbG9nTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZERpYWxvZ01vZHVsZSgpIHtcbiAgICB9XG4gICAgTWREaWFsb2dNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNZERpYWxvZ01vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW01kRGlhbG9nLCBPVkVSTEFZX1BST1ZJREVSUywgSW50ZXJhY3Rpdml0eUNoZWNrZXJdLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWREaWFsb2dNb2R1bGUgPSBfX2RlY29yYXRlJDQ4KFtcbiAgICAgICAgX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSh7XG4gICAgICAgICAgICBpbXBvcnRzOiBbT3ZlcmxheU1vZHVsZSwgUG9ydGFsTW9kdWxlLCBBMTF5TW9kdWxlXSxcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNZERpYWxvZ0NvbnRhaW5lcl0sXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNZERpYWxvZ0NvbnRhaW5lcl0sXG4gICAgICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtNZERpYWxvZ0NvbnRhaW5lcl0sXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQ0OCgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNZERpYWxvZ01vZHVsZSk7XG4gICAgcmV0dXJuIE1kRGlhbG9nTW9kdWxlO1xufSgpKTtcblxudmFyIF9fZGVjb3JhdGUkMTUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTUgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBNQVRFUklBTF9NT0RVTEVTID0gW1xuICAgIE1kQnV0dG9uTW9kdWxlLFxuICAgIE1kQnV0dG9uVG9nZ2xlTW9kdWxlLFxuICAgIE1kQ2FyZE1vZHVsZSxcbiAgICBNZENoZWNrYm94TW9kdWxlLFxuICAgIE1kRGlhbG9nTW9kdWxlLFxuICAgIE1kR3JpZExpc3RNb2R1bGUsXG4gICAgTWRJY29uTW9kdWxlLFxuICAgIE1kSW5wdXRNb2R1bGUsXG4gICAgTWRMaXN0TW9kdWxlLFxuICAgIE1kTWVudU1vZHVsZSxcbiAgICBNZFByb2dyZXNzQmFyTW9kdWxlLFxuICAgIE1kUHJvZ3Jlc3NDaXJjbGVNb2R1bGUsXG4gICAgTWRSYWRpb01vZHVsZSxcbiAgICBNZFJpcHBsZU1vZHVsZSxcbiAgICBNZFNlbGVjdE1vZHVsZSxcbiAgICBNZFNpZGVuYXZNb2R1bGUsXG4gICAgTWRTbGlkZXJNb2R1bGUsXG4gICAgTWRTbGlkZVRvZ2dsZU1vZHVsZSxcbiAgICBNZFNuYWNrQmFyTW9kdWxlLFxuICAgIE1kVGFic01vZHVsZSxcbiAgICBNZFRvb2xiYXJNb2R1bGUsXG4gICAgTWRUb29sdGlwTW9kdWxlLFxuICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgUG9ydGFsTW9kdWxlLFxuICAgIFJ0bE1vZHVsZSxcbiAgICBBMTF5TW9kdWxlLFxuXTtcbnZhciBNYXRlcmlhbFJvb3RNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hdGVyaWFsUm9vdE1vZHVsZSgpIHtcbiAgICB9XG4gICAgTWF0ZXJpYWxSb290TW9kdWxlID0gX19kZWNvcmF0ZSQxNShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgICAgIE1kQnV0dG9uTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZENhcmRNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kQ2hlY2tib3hNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kR3JpZExpc3RNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kSW5wdXRNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kTGlzdE1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRQcm9ncmVzc0Jhck1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRQcm9ncmVzc0NpcmNsZU1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRSaXBwbGVNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kU2VsZWN0TW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZFNpZGVuYXZNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kVGFic01vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRUb29sYmFyTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBQb3J0YWxNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIFJ0bE1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgbW9kdWxlcyBpbmNsdWRlIHByb3ZpZGVycy5cbiAgICAgICAgICAgICAgICBBMTF5TW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZEJ1dHRvblRvZ2dsZU1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWREaWFsb2dNb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICAgICAgICAgIE1kSWNvbk1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRNZW51TW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZFJhZGlvTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBNZFNsaWRlck1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRTbGlkZVRvZ2dsZU1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRTbmFja0Jhck1vZHVsZS5mb3JSb290KCksXG4gICAgICAgICAgICAgICAgTWRUb29sdGlwTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgICAgICBPdmVybGF5TW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBleHBvcnRzOiBNQVRFUklBTF9NT0RVTEVTLFxuICAgICAgICB9KSwgXG4gICAgICAgIF9fbWV0YWRhdGEkMTUoJ2Rlc2lnbjpwYXJhbXR5cGVzJywgW10pXG4gICAgXSwgTWF0ZXJpYWxSb290TW9kdWxlKTtcbiAgICByZXR1cm4gTWF0ZXJpYWxSb290TW9kdWxlO1xufSgpKTtcbnZhciBNYXRlcmlhbE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWF0ZXJpYWxNb2R1bGUoKSB7XG4gICAgfVxuICAgIE1hdGVyaWFsTW9kdWxlLmZvclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IG5nTW9kdWxlOiBNYXRlcmlhbFJvb3RNb2R1bGUgfTtcbiAgICB9O1xuICAgIE1hdGVyaWFsTW9kdWxlID0gX19kZWNvcmF0ZSQxNShbXG4gICAgICAgIF9hbmd1bGFyX2NvcmUuTmdNb2R1bGUoe1xuICAgICAgICAgICAgaW1wb3J0czogTUFURVJJQUxfTU9EVUxFUyxcbiAgICAgICAgICAgIGV4cG9ydHM6IE1BVEVSSUFMX01PRFVMRVMsXG4gICAgICAgIH0pLCBcbiAgICAgICAgX19tZXRhZGF0YSQxNSgnZGVzaWduOnBhcmFtdHlwZXMnLCBbXSlcbiAgICBdLCBNYXRlcmlhbE1vZHVsZSk7XG4gICAgcmV0dXJuIE1hdGVyaWFsTW9kdWxlO1xufSgpKTtcblxuZXhwb3J0cy5NZENvcmVNb2R1bGUgPSBNZENvcmVNb2R1bGU7XG5leHBvcnRzLkRpciA9IERpcjtcbmV4cG9ydHMuUnRsTW9kdWxlID0gUnRsTW9kdWxlO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLkJhc2VQb3J0YWxIb3N0ID0gQmFzZVBvcnRhbEhvc3Q7XG5leHBvcnRzLkNvbXBvbmVudFBvcnRhbCA9IENvbXBvbmVudFBvcnRhbDtcbmV4cG9ydHMuVGVtcGxhdGVQb3J0YWwgPSBUZW1wbGF0ZVBvcnRhbDtcbmV4cG9ydHMuUG9ydGFsSG9zdERpcmVjdGl2ZSA9IFBvcnRhbEhvc3REaXJlY3RpdmU7XG5leHBvcnRzLlRlbXBsYXRlUG9ydGFsRGlyZWN0aXZlID0gVGVtcGxhdGVQb3J0YWxEaXJlY3RpdmU7XG5leHBvcnRzLlBvcnRhbE1vZHVsZSA9IFBvcnRhbE1vZHVsZTtcbmV4cG9ydHMuRG9tUG9ydGFsSG9zdCA9IERvbVBvcnRhbEhvc3Q7XG5leHBvcnRzLk92ZXJsYXkgPSBPdmVybGF5O1xuZXhwb3J0cy5PVkVSTEFZX1BST1ZJREVSUyA9IE9WRVJMQVlfUFJPVklERVJTO1xuZXhwb3J0cy5PdmVybGF5Q29udGFpbmVyID0gT3ZlcmxheUNvbnRhaW5lcjtcbmV4cG9ydHMuT3ZlcmxheVJlZiA9IE92ZXJsYXlSZWY7XG5leHBvcnRzLk92ZXJsYXlTdGF0ZSA9IE92ZXJsYXlTdGF0ZTtcbmV4cG9ydHMuQ29ubmVjdGVkT3ZlcmxheURpcmVjdGl2ZSA9IENvbm5lY3RlZE92ZXJsYXlEaXJlY3RpdmU7XG5leHBvcnRzLk92ZXJsYXlPcmlnaW4gPSBPdmVybGF5T3JpZ2luO1xuZXhwb3J0cy5PdmVybGF5TW9kdWxlID0gT3ZlcmxheU1vZHVsZTtcbmV4cG9ydHMuTWRHZXN0dXJlQ29uZmlnID0gTWRHZXN0dXJlQ29uZmlnO1xuZXhwb3J0cy5NZFJpcHBsZSA9IE1kUmlwcGxlO1xuZXhwb3J0cy5NZFJpcHBsZU1vZHVsZSA9IE1kUmlwcGxlTW9kdWxlO1xuZXhwb3J0cy5NZExpdmVBbm5vdW5jZXIgPSBNZExpdmVBbm5vdW5jZXI7XG5leHBvcnRzLkxJVkVfQU5OT1VOQ0VSX0VMRU1FTlRfVE9LRU4gPSBMSVZFX0FOTk9VTkNFUl9FTEVNRU5UX1RPS0VOO1xuZXhwb3J0cy5Gb2N1c1RyYXAgPSBGb2N1c1RyYXA7XG5leHBvcnRzLkludGVyYWN0aXZpdHlDaGVja2VyID0gSW50ZXJhY3Rpdml0eUNoZWNrZXI7XG5leHBvcnRzLkExMXlNb2R1bGUgPSBBMTF5TW9kdWxlO1xuZXhwb3J0cy5NZFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXIgPSBNZFVuaXF1ZVNlbGVjdGlvbkRpc3BhdGNoZXI7XG5leHBvcnRzLk1kTGluZU1vZHVsZSA9IE1kTGluZU1vZHVsZTtcbmV4cG9ydHMuTWRMaW5lID0gTWRMaW5lO1xuZXhwb3J0cy5NZExpbmVTZXR0ZXIgPSBNZExpbmVTZXR0ZXI7XG5leHBvcnRzLmFwcGx5Q3NzVHJhbnNmb3JtID0gYXBwbHlDc3NUcmFuc2Zvcm07XG5leHBvcnRzLk1kRXJyb3IgPSBNZEVycm9yO1xuZXhwb3J0cy5Cb29sZWFuRmllbGRWYWx1ZSA9IEJvb2xlYW5GaWVsZFZhbHVlO1xuZXhwb3J0cy5Db25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5ID0gQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneTtcbmV4cG9ydHMuQ29ubmVjdGlvblBvc2l0aW9uUGFpciA9IENvbm5lY3Rpb25Qb3NpdGlvblBhaXI7XG5leHBvcnRzLlVQX0FSUk9XID0gVVBfQVJST1c7XG5leHBvcnRzLkRPV05fQVJST1cgPSBET1dOX0FSUk9XO1xuZXhwb3J0cy5SSUdIVF9BUlJPVyA9IFJJR0hUX0FSUk9XO1xuZXhwb3J0cy5MRUZUX0FSUk9XID0gTEVGVF9BUlJPVztcbmV4cG9ydHMuRU5URVIgPSBFTlRFUjtcbmV4cG9ydHMuVEFCID0gVEFCO1xuZXhwb3J0cy5NYXRlcmlhbFJvb3RNb2R1bGUgPSBNYXRlcmlhbFJvb3RNb2R1bGU7XG5leHBvcnRzLk1hdGVyaWFsTW9kdWxlID0gTWF0ZXJpYWxNb2R1bGU7XG5leHBvcnRzLk1kQnV0dG9uID0gTWRCdXR0b247XG5leHBvcnRzLk1kQW5jaG9yID0gTWRBbmNob3I7XG5leHBvcnRzLk1kQnV0dG9uTW9kdWxlID0gTWRCdXR0b25Nb2R1bGU7XG5leHBvcnRzLk1EX0JVVFRPTl9UT0dHTEVfR1JPVVBfVkFMVUVfQUNDRVNTT1IgPSBNRF9CVVRUT05fVE9HR0xFX0dST1VQX1ZBTFVFX0FDQ0VTU09SO1xuZXhwb3J0cy5NZEJ1dHRvblRvZ2dsZUNoYW5nZSA9IE1kQnV0dG9uVG9nZ2xlQ2hhbmdlO1xuZXhwb3J0cy5NZEJ1dHRvblRvZ2dsZUdyb3VwID0gTWRCdXR0b25Ub2dnbGVHcm91cDtcbmV4cG9ydHMuTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlID0gTWRCdXR0b25Ub2dnbGVHcm91cE11bHRpcGxlO1xuZXhwb3J0cy5NZEJ1dHRvblRvZ2dsZSA9IE1kQnV0dG9uVG9nZ2xlO1xuZXhwb3J0cy5NZEJ1dHRvblRvZ2dsZU1vZHVsZSA9IE1kQnV0dG9uVG9nZ2xlTW9kdWxlO1xuZXhwb3J0cy5NZENhcmRDb250ZW50ID0gTWRDYXJkQ29udGVudDtcbmV4cG9ydHMuTWRDYXJkVGl0bGUgPSBNZENhcmRUaXRsZTtcbmV4cG9ydHMuTWRDYXJkU3VidGl0bGUgPSBNZENhcmRTdWJ0aXRsZTtcbmV4cG9ydHMuTWRDYXJkQWN0aW9ucyA9IE1kQ2FyZEFjdGlvbnM7XG5leHBvcnRzLk1kQ2FyZEZvb3RlciA9IE1kQ2FyZEZvb3RlcjtcbmV4cG9ydHMuTWRDYXJkID0gTWRDYXJkO1xuZXhwb3J0cy5NZENhcmRIZWFkZXIgPSBNZENhcmRIZWFkZXI7XG5leHBvcnRzLk1kQ2FyZFRpdGxlR3JvdXAgPSBNZENhcmRUaXRsZUdyb3VwO1xuZXhwb3J0cy5NZENhcmRNb2R1bGUgPSBNZENhcmRNb2R1bGU7XG5leHBvcnRzLk1EX0NIRUNLQk9YX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IgPSBNRF9DSEVDS0JPWF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SO1xuZXhwb3J0cy5NZENoZWNrYm94Q2hhbmdlID0gTWRDaGVja2JveENoYW5nZTtcbmV4cG9ydHMuTWRDaGVja2JveCA9IE1kQ2hlY2tib3g7XG5leHBvcnRzLk1kQ2hlY2tib3hNb2R1bGUgPSBNZENoZWNrYm94TW9kdWxlO1xuZXhwb3J0cy5NZERpYWxvZyA9IE1kRGlhbG9nO1xuZXhwb3J0cy5NZERpYWxvZ01vZHVsZSA9IE1kRGlhbG9nTW9kdWxlO1xuZXhwb3J0cy5NZERpYWxvZ0NvbmZpZyA9IE1kRGlhbG9nQ29uZmlnO1xuZXhwb3J0cy5NZERpYWxvZ1JlZiA9IE1kRGlhbG9nUmVmO1xuZXhwb3J0cy5NZERpYWxvZ0NvbnRhaW5lciA9IE1kRGlhbG9nQ29udGFpbmVyO1xuZXhwb3J0cy5NZEdyaWRMaXN0ID0gTWRHcmlkTGlzdDtcbmV4cG9ydHMuTWRHcmlkTGlzdE1vZHVsZSA9IE1kR3JpZExpc3RNb2R1bGU7XG5leHBvcnRzLk1kSWNvbkludmFsaWROYW1lRXJyb3IgPSBNZEljb25JbnZhbGlkTmFtZUVycm9yO1xuZXhwb3J0cy5NZEljb24gPSBNZEljb247XG5leHBvcnRzLk1kSWNvbk1vZHVsZSA9IE1kSWNvbk1vZHVsZTtcbmV4cG9ydHMuTWRJY29uUmVnaXN0cnkgPSBNZEljb25SZWdpc3RyeTtcbmV4cG9ydHMuTURfSU5QVVRfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUiA9IE1EX0lOUFVUX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I7XG5leHBvcnRzLk1kSW5wdXRQbGFjZWhvbGRlckNvbmZsaWN0RXJyb3IgPSBNZElucHV0UGxhY2Vob2xkZXJDb25mbGljdEVycm9yO1xuZXhwb3J0cy5NZElucHV0VW5zdXBwb3J0ZWRUeXBlRXJyb3IgPSBNZElucHV0VW5zdXBwb3J0ZWRUeXBlRXJyb3I7XG5leHBvcnRzLk1kSW5wdXREdXBsaWNhdGVkSGludEVycm9yID0gTWRJbnB1dER1cGxpY2F0ZWRIaW50RXJyb3I7XG5leHBvcnRzLk1kUGxhY2Vob2xkZXIgPSBNZFBsYWNlaG9sZGVyO1xuZXhwb3J0cy5NZEhpbnQgPSBNZEhpbnQ7XG5leHBvcnRzLk1kSW5wdXQgPSBNZElucHV0O1xuZXhwb3J0cy5NZElucHV0TW9kdWxlID0gTWRJbnB1dE1vZHVsZTtcbmV4cG9ydHMuTWRMaXN0RGl2aWRlciA9IE1kTGlzdERpdmlkZXI7XG5leHBvcnRzLk1kTGlzdCA9IE1kTGlzdDtcbmV4cG9ydHMuTWRMaXN0QXZhdGFyID0gTWRMaXN0QXZhdGFyO1xuZXhwb3J0cy5NZExpc3RJdGVtID0gTWRMaXN0SXRlbTtcbmV4cG9ydHMuTWRMaXN0TW9kdWxlID0gTWRMaXN0TW9kdWxlO1xuZXhwb3J0cy5NZE1lbnVNb2R1bGUgPSBNZE1lbnVNb2R1bGU7XG5leHBvcnRzLk1kTWVudSA9IE1kTWVudTtcbmV4cG9ydHMuTWRNZW51SXRlbSA9IE1kTWVudUl0ZW07XG5leHBvcnRzLk1kTWVudVRyaWdnZXIgPSBNZE1lbnVUcmlnZ2VyO1xuZXhwb3J0cy5NZFByb2dyZXNzQmFyID0gTWRQcm9ncmVzc0JhcjtcbmV4cG9ydHMuTWRQcm9ncmVzc0Jhck1vZHVsZSA9IE1kUHJvZ3Jlc3NCYXJNb2R1bGU7XG5leHBvcnRzLk1kUHJvZ3Jlc3NDaXJjbGUgPSBNZFByb2dyZXNzQ2lyY2xlO1xuZXhwb3J0cy5NZFNwaW5uZXIgPSBNZFNwaW5uZXI7XG5leHBvcnRzLk1kUHJvZ3Jlc3NDaXJjbGVNb2R1bGUgPSBNZFByb2dyZXNzQ2lyY2xlTW9kdWxlO1xuZXhwb3J0cy5NRF9SQURJT19HUk9VUF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SID0gTURfUkFESU9fR1JPVVBfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjtcbmV4cG9ydHMuTWRSYWRpb0NoYW5nZSA9IE1kUmFkaW9DaGFuZ2U7XG5leHBvcnRzLk1kUmFkaW9Hcm91cCA9IE1kUmFkaW9Hcm91cDtcbmV4cG9ydHMuTWRSYWRpb0J1dHRvbiA9IE1kUmFkaW9CdXR0b247XG5leHBvcnRzLk1kUmFkaW9Nb2R1bGUgPSBNZFJhZGlvTW9kdWxlO1xuZXhwb3J0cy5NZFNlbGVjdE1vZHVsZSA9IE1kU2VsZWN0TW9kdWxlO1xuZXhwb3J0cy5NZFNlbGVjdCA9IE1kU2VsZWN0O1xuZXhwb3J0cy5NZER1cGxpY2F0ZWRTaWRlbmF2RXJyb3IgPSBNZER1cGxpY2F0ZWRTaWRlbmF2RXJyb3I7XG5leHBvcnRzLk1kU2lkZW5hdiA9IE1kU2lkZW5hdjtcbmV4cG9ydHMuTWRTaWRlbmF2TGF5b3V0ID0gTWRTaWRlbmF2TGF5b3V0O1xuZXhwb3J0cy5NZFNpZGVuYXZNb2R1bGUgPSBNZFNpZGVuYXZNb2R1bGU7XG5leHBvcnRzLk1EX1NMSURFUl9WQUxVRV9BQ0NFU1NPUiA9IE1EX1NMSURFUl9WQUxVRV9BQ0NFU1NPUjtcbmV4cG9ydHMuTWRTbGlkZXIgPSBNZFNsaWRlcjtcbmV4cG9ydHMuU2xpZGVyUmVuZGVyZXIgPSBTbGlkZXJSZW5kZXJlcjtcbmV4cG9ydHMuTWRTbGlkZXJNb2R1bGUgPSBNZFNsaWRlck1vZHVsZTtcbmV4cG9ydHMuTURfU0xJREVfVE9HR0xFX1ZBTFVFX0FDQ0VTU09SID0gTURfU0xJREVfVE9HR0xFX1ZBTFVFX0FDQ0VTU09SO1xuZXhwb3J0cy5NZFNsaWRlVG9nZ2xlQ2hhbmdlID0gTWRTbGlkZVRvZ2dsZUNoYW5nZTtcbmV4cG9ydHMuTWRTbGlkZVRvZ2dsZSA9IE1kU2xpZGVUb2dnbGU7XG5leHBvcnRzLk1kU2xpZGVUb2dnbGVNb2R1bGUgPSBNZFNsaWRlVG9nZ2xlTW9kdWxlO1xuZXhwb3J0cy5NZFNuYWNrQmFyID0gTWRTbmFja0JhcjtcbmV4cG9ydHMuTWRTbmFja0Jhck1vZHVsZSA9IE1kU25hY2tCYXJNb2R1bGU7XG5leHBvcnRzLk1kU25hY2tCYXJSZWYgPSBNZFNuYWNrQmFyUmVmO1xuZXhwb3J0cy5NZFNuYWNrQmFyQ29uZmlnID0gTWRTbmFja0JhckNvbmZpZztcbmV4cG9ydHMuTWRTbmFja0JhckNvbnRhaW5lciA9IE1kU25hY2tCYXJDb250YWluZXI7XG5leHBvcnRzLk1kVGFiQ2hhbmdlRXZlbnQgPSBNZFRhYkNoYW5nZUV2ZW50O1xuZXhwb3J0cy5NZFRhYiA9IE1kVGFiO1xuZXhwb3J0cy5NZFRhYkdyb3VwID0gTWRUYWJHcm91cDtcbmV4cG9ydHMuTWRUYWJzTW9kdWxlID0gTWRUYWJzTW9kdWxlO1xuZXhwb3J0cy5NZFRvb2xiYXJSb3cgPSBNZFRvb2xiYXJSb3c7XG5leHBvcnRzLk1kVG9vbGJhciA9IE1kVG9vbGJhcjtcbmV4cG9ydHMuTWRUb29sYmFyTW9kdWxlID0gTWRUb29sYmFyTW9kdWxlO1xuZXhwb3J0cy5NZFRvb2x0aXAgPSBNZFRvb2x0aXA7XG5leHBvcnRzLlRvb2x0aXBDb21wb25lbnQgPSBUb29sdGlwQ29tcG9uZW50O1xuZXhwb3J0cy5NZFRvb2x0aXBNb2R1bGUgPSBNZFRvb2x0aXBNb2R1bGU7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPS4vbWF0ZXJpYWwudW1kLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L0Bhbmd1bGFyL21hdGVyaWFsL21hdGVyaWFsLnVtZC5qc1xuLy8gbW9kdWxlIGlkID0gNzMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }

});